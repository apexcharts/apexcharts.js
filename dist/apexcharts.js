/*!
 * ApexCharts v5.3.5
 * (c) 2018-2025 ApexCharts
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ApexCharts = factory());
})(this, (function () { 'use strict';

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }
  function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var n = 0,
          F = function () {};
        return {
          s: F,
          n: function () {
            return n >= r.length ? {
              done: !0
            } : {
              done: !1,
              value: r[n++]
            };
          },
          e: function (r) {
            throw r;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o,
      a = !0,
      u = !1;
    return {
      s: function () {
        t = t.call(r);
      },
      n: function () {
        var r = t.next();
        return a = r.done, r;
      },
      e: function (r) {
        u = !0, o = r;
      },
      f: function () {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _createSuper(t) {
    var r = _isNativeReflectConstruct();
    return function () {
      var e,
        o = _getPrototypeOf(t);
      if (r) {
        var s = _getPrototypeOf(this).constructor;
        e = Reflect.construct(o, arguments, s);
      } else e = o.apply(this, arguments);
      return _possibleConstructorReturn(this, e);
    };
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(t, "prototype", {
      writable: !1
    }), e && _setPrototypeOf(t, e);
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function () {
      return !!t;
    })();
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _possibleConstructorReturn(t, e) {
    if (e && ("object" == typeof e || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }

  /*
   ** Generic functions which are not dependent on ApexCharts
   */
  var Utils$1 = /*#__PURE__*/function () {
    function Utils() {
      _classCallCheck(this, Utils);
    }
    _createClass(Utils, [{
      key: "shadeRGBColor",
      value: function shadeRGBColor(percent, color) {
        var f = color.split(','),
          t = percent < 0 ? 0 : 255,
          p = percent < 0 ? percent * -1 : percent,
          R = parseInt(f[0].slice(4), 10),
          G = parseInt(f[1], 10),
          B = parseInt(f[2], 10);
        return 'rgb(' + (Math.round((t - R) * p) + R) + ',' + (Math.round((t - G) * p) + G) + ',' + (Math.round((t - B) * p) + B) + ')';
      }
    }, {
      key: "shadeHexColor",
      value: function shadeHexColor(percent, color) {
        var f = parseInt(color.slice(1), 16),
          t = percent < 0 ? 0 : 255,
          p = percent < 0 ? percent * -1 : percent,
          R = f >> 16,
          G = f >> 8 & 0x00ff,
          B = f & 0x0000ff;
        return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
      }

      // beautiful color shading blending code
      // http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
    }, {
      key: "shadeColor",
      value: function shadeColor(p, color) {
        if (Utils.isColorHex(color)) {
          return this.shadeHexColor(p, color);
        } else {
          return this.shadeRGBColor(p, color);
        }
      }
    }], [{
      key: "bind",
      value: function bind(fn, me) {
        return function () {
          return fn.apply(me, arguments);
        };
      }
    }, {
      key: "isObject",
      value: function isObject(item) {
        return item && _typeof(item) === 'object' && !Array.isArray(item) && item != null;
      }

      // Type checking that works across different window objects
    }, {
      key: "is",
      value: function is(type, val) {
        return Object.prototype.toString.call(val) === '[object ' + type + ']';
      }
    }, {
      key: "isSafari",
      value: function isSafari() {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      }
    }, {
      key: "listToArray",
      value: function listToArray(list) {
        var i,
          array = [];
        for (i = 0; i < list.length; i++) {
          array[i] = list[i];
        }
        return array;
      }

      // to extend defaults with user options
      // credit: http://stackoverflow.com/questions/27936772/deep-object-merging-in-es6-es7#answer-34749873
    }, {
      key: "extend",
      value: function extend(target, source) {
        var _this = this;
        if (typeof Object.assign !== 'function') {
          (function () {
            Object.assign = function (target) {

              // We must check against these specific cases.
              if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
              }
              var output = Object(target);
              for (var index = 1; index < arguments.length; index++) {
                var _source = arguments[index];
                if (_source !== undefined && _source !== null) {
                  for (var nextKey in _source) {
                    if (_source.hasOwnProperty(nextKey)) {
                      output[nextKey] = _source[nextKey];
                    }
                  }
                }
              }
              return output;
            };
          })();
        }
        var output = Object.assign({}, target);
        if (this.isObject(target) && this.isObject(source)) {
          Object.keys(source).forEach(function (key) {
            if (_this.isObject(source[key])) {
              if (!(key in target)) {
                Object.assign(output, _defineProperty({}, key, source[key]));
              } else {
                output[key] = _this.extend(target[key], source[key]);
              }
            } else {
              Object.assign(output, _defineProperty({}, key, source[key]));
            }
          });
        }
        return output;
      }
    }, {
      key: "extendArray",
      value: function extendArray(arrToExtend, resultArr) {
        var extendedArr = [];
        arrToExtend.map(function (item) {
          extendedArr.push(Utils.extend(resultArr, item));
        });
        arrToExtend = extendedArr;
        return arrToExtend;
      }

      // If month counter exceeds 12, it starts again from 1
    }, {
      key: "monthMod",
      value: function monthMod(month) {
        return month % 12;
      }
    }, {
      key: "clone",
      value: function clone(source) {
        var visited = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new WeakMap();
        if (source === null || _typeof(source) !== 'object') {
          return source;
        }
        if (visited.has(source)) {
          return visited.get(source);
        }
        var cloneResult;
        if (Array.isArray(source)) {
          cloneResult = [];
          visited.set(source, cloneResult);
          for (var i = 0; i < source.length; i++) {
            cloneResult[i] = this.clone(source[i], visited);
          }
        } else if (source instanceof Date) {
          cloneResult = new Date(source.getTime());
        } else {
          cloneResult = {};
          visited.set(source, cloneResult);
          for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
              cloneResult[prop] = this.clone(source[prop], visited);
            }
          }
        }
        return cloneResult;
      }
    }, {
      key: "log10",
      value: function log10(x) {
        return Math.log(x) / Math.LN10;
      }
    }, {
      key: "roundToBase10",
      value: function roundToBase10(x) {
        return Math.pow(10, Math.floor(Math.log10(x)));
      }
    }, {
      key: "roundToBase",
      value: function roundToBase(x, base) {
        return Math.pow(base, Math.floor(Math.log(x) / Math.log(base)));
      }
    }, {
      key: "parseNumber",
      value: function parseNumber(val) {
        if (typeof val === 'number' || val === null) return val;
        return parseFloat(val);
      }
    }, {
      key: "stripNumber",
      value: function stripNumber(num) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        return Number.isInteger(num) ? num : parseFloat(num.toPrecision(precision));
      }
    }, {
      key: "randomId",
      value: function randomId() {
        return (Math.random() + 1).toString(36).substring(4);
      }
    }, {
      key: "noExponents",
      value: function noExponents(num) {
        // Check if the number contains 'e' (exponential notation)
        if (num.toString().includes('e')) {
          return Math.round(num); // Round the number
        }
        return num; // Return as-is if no exponential notation
      }
    }, {
      key: "elementExists",
      value: function elementExists(element) {
        if (!element || !element.isConnected) {
          return false;
        }
        return true;
      }
    }, {
      key: "getDimensions",
      value: function getDimensions(el) {
        var computedStyle = getComputedStyle(el, null);
        var elementHeight = el.clientHeight;
        var elementWidth = el.clientWidth;
        elementHeight -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
        elementWidth -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
        return [elementWidth, elementHeight];
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect(element) {
        var rect = element.getBoundingClientRect();
        return {
          top: rect.top,
          right: rect.right,
          bottom: rect.bottom,
          left: rect.left,
          width: element.clientWidth,
          height: element.clientHeight,
          x: rect.left,
          y: rect.top
        };
      }
    }, {
      key: "getLargestStringFromArr",
      value: function getLargestStringFromArr(arr) {
        return arr.reduce(function (a, b) {
          if (Array.isArray(b)) {
            b = b.reduce(function (aa, bb) {
              return aa.length > bb.length ? aa : bb;
            });
          }
          return a.length > b.length ? a : b;
        }, 0);
      }

      // http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb#answer-12342275
    }, {
      key: "hexToRgba",
      value: function hexToRgba() {
        var hex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '#999999';
        var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.6;
        if (hex.substring(0, 1) !== '#') {
          hex = '#999999';
        }
        var h = hex.replace('#', '');
        h = h.match(new RegExp('(.{' + h.length / 3 + '})', 'g'));
        for (var i = 0; i < h.length; i++) {
          h[i] = parseInt(h[i].length === 1 ? h[i] + h[i] : h[i], 16);
        }
        if (typeof opacity !== 'undefined') h.push(opacity);
        return 'rgba(' + h.join(',') + ')';
      }
    }, {
      key: "getOpacityFromRGBA",
      value: function getOpacityFromRGBA(rgba) {
        return parseFloat(rgba.replace(/^.*,(.+)\)/, '$1'));
      }
    }, {
      key: "rgb2hex",
      value: function rgb2hex(rgb) {
        rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
        return rgb && rgb.length === 4 ? '#' + ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) + ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';
      }
    }, {
      key: "isColorHex",
      value: function isColorHex(color) {
        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(color);
      }
    }, {
      key: "getPolygonPos",
      value: function getPolygonPos(size, dataPointsLen) {
        var dotsArray = [];
        var angle = Math.PI * 2 / dataPointsLen;
        for (var i = 0; i < dataPointsLen; i++) {
          var curPos = {};
          curPos.x = size * Math.sin(i * angle);
          curPos.y = -size * Math.cos(i * angle);
          dotsArray.push(curPos);
        }
        return dotsArray;
      }
    }, {
      key: "polarToCartesian",
      value: function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
        return {
          x: centerX + radius * Math.cos(angleInRadians),
          y: centerY + radius * Math.sin(angleInRadians)
        };
      }
    }, {
      key: "escapeString",
      value: function escapeString(str) {
        var escapeWith = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
        var newStr = str.toString().slice();
        newStr = newStr.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, escapeWith);
        return newStr;
      }
    }, {
      key: "negToZero",
      value: function negToZero(val) {
        return val < 0 ? 0 : val;
      }
    }, {
      key: "moveIndexInArray",
      value: function moveIndexInArray(arr, old_index, new_index) {
        if (new_index >= arr.length) {
          var k = new_index - arr.length + 1;
          while (k--) {
            arr.push(undefined);
          }
        }
        arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
        return arr;
      }
    }, {
      key: "extractNumber",
      value: function extractNumber(s) {
        return parseFloat(s.replace(/[^\d.]*/g, ''));
      }
    }, {
      key: "findAncestor",
      value: function findAncestor(el, cls) {
        while ((el = el.parentElement) && !el.classList.contains(cls)) {
        }
        return el;
      }
    }, {
      key: "setELstyles",
      value: function setELstyles(el, styles) {
        for (var key in styles) {
          if (styles.hasOwnProperty(key)) {
            el.style.key = styles[key];
          }
        }
      }
      // prevents JS prevision errors when adding
    }, {
      key: "preciseAddition",
      value: function preciseAddition(a, b) {
        var aDecimals = (String(a).split('.')[1] || '').length;
        var bDecimals = (String(b).split('.')[1] || '').length;
        var factor = Math.pow(10, Math.max(aDecimals, bDecimals));
        return (Math.round(a * factor) + Math.round(b * factor)) / factor;
      }
    }, {
      key: "isNumber",
      value: function isNumber(value) {
        return !isNaN(value) && parseFloat(Number(value)) === value && !isNaN(parseInt(value, 10));
      }
    }, {
      key: "isFloat",
      value: function isFloat(n) {
        return Number(n) === n && n % 1 !== 0;
      }
    }, {
      key: "isMsEdge",
      value: function isMsEdge() {
        var ua = window.navigator.userAgent;
        var edge = ua.indexOf('Edge/');
        if (edge > 0) {
          // Edge (IE 12+) => return version number
          return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
        }

        // other browser
        return false;
      }
      //
      // Find the Greatest Common Divisor of two numbers
      //
    }, {
      key: "getGCD",
      value: function getGCD(a, b) {
        var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 7;
        var big = Math.pow(10, p - Math.floor(Math.log10(Math.max(a, b))));
        a = Math.round(Math.abs(a) * big);
        b = Math.round(Math.abs(b) * big);
        while (b) {
          var t = b;
          b = a % b;
          a = t;
        }
        return a / big;
      }
    }, {
      key: "getPrimeFactors",
      value: function getPrimeFactors(n) {
        var factors = [];
        var divisor = 2;
        while (n >= 2) {
          if (n % divisor == 0) {
            factors.push(divisor);
            n = n / divisor;
          } else {
            divisor++;
          }
        }
        return factors;
      }
    }, {
      key: "mod",
      value: function mod(a, b) {
        var p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 7;
        var big = Math.pow(10, p - Math.floor(Math.log10(Math.max(a, b))));
        a = Math.round(Math.abs(a) * big);
        b = Math.round(Math.abs(b) * big);
        return a % b / big;
      }
    }]);
    return Utils;
  }();

  /**
   * ApexCharts Animation Class.
   *
   * @module Animations
   **/
  var Animations = /*#__PURE__*/function () {
    function Animations(ctx) {
      _classCallCheck(this, Animations);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(Animations, [{
      key: "animateLine",
      value: function animateLine(el, from, to, speed) {
        el.attr(from).animate(speed).attr(to);
      }

      /*
       ** Animate radius of a circle element
       */
    }, {
      key: "animateMarker",
      value: function animateMarker(el, speed, easing, cb) {
        el.attr({
          opacity: 0
        }).animate(speed).attr({
          opacity: 1
        }).after(function () {
          cb();
        });
      }

      /*
       ** Animate rect properties
       */
    }, {
      key: "animateRect",
      value: function animateRect(el, from, to, speed, fn) {
        el.attr(from).animate(speed).attr(to).after(function () {
          return fn();
        });
      }
    }, {
      key: "animatePathsGradually",
      value: function animatePathsGradually(params) {
        var el = params.el,
          realIndex = params.realIndex,
          j = params.j,
          fill = params.fill,
          pathFrom = params.pathFrom,
          pathTo = params.pathTo,
          speed = params.speed,
          delay = params.delay;
        var me = this;
        var w = this.w;
        var delayFactor = 0;
        if (w.config.chart.animations.animateGradually.enabled) {
          delayFactor = w.config.chart.animations.animateGradually.delay;
        }
        if (w.config.chart.animations.dynamicAnimation.enabled && w.globals.dataChanged && w.config.chart.type !== 'bar') {
          // disabled due to this bug - https://github.com/apexcharts/vue-apexcharts/issues/75
          delayFactor = 0;
        }
        me.morphSVG(el, realIndex, j, w.config.chart.type === 'line' && !w.globals.comboCharts ? 'stroke' : fill, pathFrom, pathTo, speed, delay * delayFactor);
      }
    }, {
      key: "showDelayedElements",
      value: function showDelayedElements() {
        this.w.globals.delayedElements.forEach(function (d) {
          var ele = d.el;
          ele.classList.remove('apexcharts-element-hidden');
          ele.classList.add('apexcharts-hidden-element-shown');
        });
      }
    }, {
      key: "animationCompleted",
      value: function animationCompleted(el) {
        var w = this.w;
        if (w.globals.animationEnded) return;
        w.globals.animationEnded = true;
        this.showDelayedElements();
        if (typeof w.config.chart.events.animationEnd === 'function') {
          w.config.chart.events.animationEnd(this.ctx, {
            el: el,
            w: w
          });
        }
      }

      // SVG.js animation for morphing one path to another
    }, {
      key: "morphSVG",
      value: function morphSVG(el, realIndex, j, fill, pathFrom, pathTo, speed, delay) {
        var _this = this;
        var w = this.w;
        if (!pathFrom) {
          pathFrom = el.attr('pathFrom');
        }
        if (!pathTo) {
          pathTo = el.attr('pathTo');
        }
        var disableAnimationForCorrupPath = function disableAnimationForCorrupPath(path) {
          if (w.config.chart.type === 'radar') {
            // radar chart drops the path to bottom and hence a corrup path looks ugly
            // therefore, disable animation for such a case
            speed = 1;
          }
          return "M 0 ".concat(w.globals.gridHeight);
        };
        if (!pathFrom || pathFrom.indexOf('undefined') > -1 || pathFrom.indexOf('NaN') > -1) {
          pathFrom = disableAnimationForCorrupPath();
        }
        if (!pathTo.trim() || pathTo.indexOf('undefined') > -1 || pathTo.indexOf('NaN') > -1) {
          pathTo = disableAnimationForCorrupPath();
        }
        if (!w.globals.shouldAnimate) {
          speed = 1;
        }
        el.plot(pathFrom).animate(1, delay).plot(pathFrom).animate(speed, delay).plot(pathTo).after(function () {
          // a flag to indicate that the original mount function can return true now as animation finished here
          if (Utils$1.isNumber(j)) {
            if (j === w.globals.series[w.globals.maxValsInArrayIndex].length - 2 && w.globals.shouldAnimate) {
              _this.animationCompleted(el);
            }
          } else if (fill !== 'none' && w.globals.shouldAnimate) {
            if (!w.globals.comboCharts && realIndex === w.globals.series.length - 1 || w.globals.comboCharts) {
              _this.animationCompleted(el);
            }
          }
          _this.showDelayedElements();
        });
      }
    }]);
    return Animations;
  }();

  const methods$1 = {};
  const names = [];

  function registerMethods(name, m) {
    if (Array.isArray(name)) {
      for (const _name of name) {
        registerMethods(_name, m);
      }
      return
    }

    if (typeof name === 'object') {
      for (const _name in name) {
        registerMethods(_name, name[_name]);
      }
      return
    }

    addMethodNames(Object.getOwnPropertyNames(m));
    methods$1[name] = Object.assign(methods$1[name] || {}, m);
  }

  function getMethodsFor(name) {
    return methods$1[name] || {}
  }

  function getMethodNames() {
    return [...new Set(names)]
  }

  function addMethodNames(_names) {
    names.push(..._names);
  }

  // Map function
  function map(array, block) {
    let i;
    const il = array.length;
    const result = [];

    for (i = 0; i < il; i++) {
      result.push(block(array[i]));
    }

    return result
  }

  // Filter function
  function filter(array, block) {
    let i;
    const il = array.length;
    const result = [];

    for (i = 0; i < il; i++) {
      if (block(array[i])) {
        result.push(array[i]);
      }
    }

    return result
  }

  // Degrees to radians
  function radians(d) {
    return ((d % 360) * Math.PI) / 180
  }

  // Convert camel cased string to dash separated
  function unCamelCase(s) {
    return s.replace(/([A-Z])/g, function (m, g) {
      return '-' + g.toLowerCase()
    })
  }

  // Capitalize first letter of a string
  function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1)
  }

  // Calculate proportional width and height values when necessary
  function proportionalSize(element, width, height, box) {
    if (width == null || height == null) {
      box = box || element.bbox();

      if (width == null) {
        width = (box.width / box.height) * height;
      } else if (height == null) {
        height = (box.height / box.width) * width;
      }
    }

    return {
      width: width,
      height: height
    }
  }

  /**
   * This function adds support for string origins.
   * It searches for an origin in o.origin o.ox and o.originX.
   * This way, origin: {x: 'center', y: 50} can be passed as well as ox: 'center', oy: 50
   **/
  function getOrigin(o, element) {
    const origin = o.origin;
    // First check if origin is in ox or originX
    let ox = o.ox != null ? o.ox : o.originX != null ? o.originX : 'center';
    let oy = o.oy != null ? o.oy : o.originY != null ? o.originY : 'center';

    // Then check if origin was used and overwrite in that case
    if (origin != null) {
  [ox, oy] = Array.isArray(origin)
        ? origin
        : typeof origin === 'object'
          ? [origin.x, origin.y]
          : [origin, origin];
    }

    // Make sure to only call bbox when actually needed
    const condX = typeof ox === 'string';
    const condY = typeof oy === 'string';
    if (condX || condY) {
      const { height, width, x, y } = element.bbox();

      // And only overwrite if string was passed for this specific axis
      if (condX) {
        ox = ox.includes('left')
          ? x
          : ox.includes('right')
            ? x + width
            : x + width / 2;
      }

      if (condY) {
        oy = oy.includes('top')
          ? y
          : oy.includes('bottom')
            ? y + height
            : y + height / 2;
      }
    }

    // Return the origin as it is if it wasn't a string
    return [ox, oy]
  }

  const descriptiveElements = new Set(['desc', 'metadata', 'title']);
  const isDescriptive = (element) =>
    descriptiveElements.has(element.nodeName);

  const writeDataToDom = (element, data, defaults = {}) => {
    const cloned = { ...data };

    for (const key in cloned) {
      if (cloned[key].valueOf() === defaults[key]) {
        delete cloned[key];
      }
    }

    if (Object.keys(cloned).length) {
      element.node.setAttribute('data-svgjs', JSON.stringify(cloned)); // see #428
    } else {
      element.node.removeAttribute('data-svgjs');
      element.node.removeAttribute('svgjs:data');
    }
  };

  // Default namespaces
  const svg = 'http://www.w3.org/2000/svg';
  const html = 'http://www.w3.org/1999/xhtml';
  const xmlns = 'http://www.w3.org/2000/xmlns/';
  const xlink = 'http://www.w3.org/1999/xlink';

  const globals = {
    window: typeof window === 'undefined' ? null : window,
    document: typeof document === 'undefined' ? null : document
  };

  function getWindow() {
    return globals.window
  }

  let Base$1 = class Base {
    // constructor (node/*, {extensions = []} */) {
    //   // this.tags = []
    //   //
    //   // for (let extension of extensions) {
    //   //   extension.setup.call(this, node)
    //   //   this.tags.push(extension.name)
    //   // }
    // }
  };

  const elements = {};
  const root = '___SYMBOL___ROOT___';

  // Method for element creation
  function create(name, ns = svg) {
    // create element
    return globals.document.createElementNS(ns, name)
  }

  function makeInstance(element, isHTML = false) {
    if (element instanceof Base$1) return element

    if (typeof element === 'object') {
      return adopter(element)
    }

    if (element == null) {
      return new elements[root]()
    }

    if (typeof element === 'string' && element.charAt(0) !== '<') {
      return adopter(globals.document.querySelector(element))
    }

    // Make sure, that HTML elements are created with the correct namespace
    const wrapper = isHTML ? globals.document.createElement('div') : create('svg');
    wrapper.innerHTML = element;

    // We can use firstChild here because we know,
    // that the first char is < and thus an element
    element = adopter(wrapper.firstChild);

    // make sure, that element doesn't have its wrapper attached
    wrapper.removeChild(wrapper.firstChild);
    return element
  }

  function nodeOrNew(name, node) {
    return node &&
      (node instanceof globals.window.Node ||
        (node.ownerDocument &&
          node instanceof node.ownerDocument.defaultView.Node))
      ? node
      : create(name)
  }

  // Adopt existing svg elements
  function adopt(node) {
    // check for presence of node
    if (!node) return null

    // make sure a node isn't already adopted
    if (node.instance instanceof Base$1) return node.instance

    if (node.nodeName === '#document-fragment') {
      return new elements.Fragment(node)
    }

    // initialize variables
    let className = capitalize(node.nodeName || 'Dom');

    // Make sure that gradients are adopted correctly
    if (className === 'LinearGradient' || className === 'RadialGradient') {
      className = 'Gradient';

      // Fallback to Dom if element is not known
    } else if (!elements[className]) {
      className = 'Dom';
    }

    return new elements[className](node)
  }

  let adopter = adopt;

  function register(element, name = element.name, asRoot = false) {
    elements[name] = element;
    if (asRoot) elements[root] = element;

    addMethodNames(Object.getOwnPropertyNames(element.prototype));

    return element
  }

  function getClass(name) {
    return elements[name]
  }

  // Element id sequence
  let did = 1000;

  // Get next named element id
  function eid(name) {
    return 'Svgjs' + capitalize(name) + did++
  }

  // Deep new id assignment
  function assignNewId(node) {
    // do the same for SVG child nodes as well
    for (let i = node.children.length - 1; i >= 0; i--) {
      assignNewId(node.children[i]);
    }

    if (node.id) {
      node.id = eid(node.nodeName);
      return node
    }

    return node
  }

  // Method for extending objects
  function extend(modules, methods) {
    let key, i;

    modules = Array.isArray(modules) ? modules : [modules];

    for (i = modules.length - 1; i >= 0; i--) {
      for (key in methods) {
        modules[i].prototype[key] = methods[key];
      }
    }
  }

  function wrapWithAttrCheck(fn) {
    return function (...args) {
      const o = args[args.length - 1];

      if (o && o.constructor === Object && !(o instanceof Array)) {
        return fn.apply(this, args.slice(0, -1)).attr(o)
      } else {
        return fn.apply(this, args)
      }
    }
  }

  // Get all siblings, including myself
  function siblings() {
    return this.parent().children()
  }

  // Get the current position siblings
  function position() {
    return this.parent().index(this)
  }

  // Get the next element (will return null if there is none)
  function next() {
    return this.siblings()[this.position() + 1]
  }

  // Get the next element (will return null if there is none)
  function prev() {
    return this.siblings()[this.position() - 1]
  }

  // Send given element one step forward
  function forward() {
    const i = this.position();
    const p = this.parent();

    // move node one step forward
    p.add(this.remove(), i + 1);

    return this
  }

  // Send given element one step backward
  function backward() {
    const i = this.position();
    const p = this.parent();

    p.add(this.remove(), i ? i - 1 : 0);

    return this
  }

  // Send given element all the way to the front
  function front() {
    const p = this.parent();

    // Move node forward
    p.add(this.remove());

    return this
  }

  // Send given element all the way to the back
  function back() {
    const p = this.parent();

    // Move node back
    p.add(this.remove(), 0);

    return this
  }

  // Inserts a given element before the targeted element
  function before(element) {
    element = makeInstance(element);
    element.remove();

    const i = this.position();

    this.parent().add(element, i);

    return this
  }

  // Inserts a given element after the targeted element
  function after(element) {
    element = makeInstance(element);
    element.remove();

    const i = this.position();

    this.parent().add(element, i + 1);

    return this
  }

  function insertBefore(element) {
    element = makeInstance(element);
    element.before(this);
    return this
  }

  function insertAfter(element) {
    element = makeInstance(element);
    element.after(this);
    return this
  }

  registerMethods('Dom', {
    siblings,
    position,
    next,
    prev,
    forward,
    backward,
    front,
    back,
    before,
    after,
    insertBefore,
    insertAfter
  });

  // Parse unit value
  const numberAndUnit =
    /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i;

  // Parse hex value
  const hex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;

  // Parse rgb value
  const rgb = /rgb\((\d+),(\d+),(\d+)\)/;

  // Parse reference id
  const reference = /(#[a-z_][a-z0-9\-_]*)/i;

  // splits a transformation chain
  const transforms = /\)\s*,?\s*/;

  // Whitespace
  const whitespace = /\s/g;

  // Test hex value
  const isHex = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i;

  // Test rgb value
  const isRgb = /^rgb\(/;

  // Test for blank string
  const isBlank = /^(\s+)?$/;

  // Test for numeric string
  const isNumber = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;

  // Test for image url
  const isImage = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i;

  // split at whitespace and comma
  const delimiter = /[\s,]+/;

  // Test for path letter
  const isPathLetter = /[MLHVCSQTAZ]/i;

  // Return array of classes on the node
  function classes() {
    const attr = this.attr('class');
    return attr == null ? [] : attr.trim().split(delimiter)
  }

  // Return true if class exists on the node, false otherwise
  function hasClass(name) {
    return this.classes().indexOf(name) !== -1
  }

  // Add class to the node
  function addClass(name) {
    if (!this.hasClass(name)) {
      const array = this.classes();
      array.push(name);
      this.attr('class', array.join(' '));
    }

    return this
  }

  // Remove class from the node
  function removeClass(name) {
    if (this.hasClass(name)) {
      this.attr(
        'class',
        this.classes()
          .filter(function (c) {
            return c !== name
          })
          .join(' ')
      );
    }

    return this
  }

  // Toggle the presence of a class on the node
  function toggleClass(name) {
    return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)
  }

  registerMethods('Dom', {
    classes,
    hasClass,
    addClass,
    removeClass,
    toggleClass
  });

  // Dynamic style generator
  function css(style, val) {
    const ret = {};
    if (arguments.length === 0) {
      // get full style as object
      this.node.style.cssText
        .split(/\s*;\s*/)
        .filter(function (el) {
          return !!el.length
        })
        .forEach(function (el) {
          const t = el.split(/\s*:\s*/);
          ret[t[0]] = t[1];
        });
      return ret
    }

    if (arguments.length < 2) {
      // get style properties as array
      if (Array.isArray(style)) {
        for (const name of style) {
          const cased = name;
          ret[name] = this.node.style.getPropertyValue(cased);
        }
        return ret
      }

      // get style for property
      if (typeof style === 'string') {
        return this.node.style.getPropertyValue(style)
      }

      // set styles in object
      if (typeof style === 'object') {
        for (const name in style) {
          // set empty string if null/undefined/'' was given
          this.node.style.setProperty(
            name,
            style[name] == null || isBlank.test(style[name]) ? '' : style[name]
          );
        }
      }
    }

    // set style for property
    if (arguments.length === 2) {
      this.node.style.setProperty(
        style,
        val == null || isBlank.test(val) ? '' : val
      );
    }

    return this
  }

  // Show element
  function show() {
    return this.css('display', '')
  }

  // Hide element
  function hide() {
    return this.css('display', 'none')
  }

  // Is element visible?
  function visible() {
    return this.css('display') !== 'none'
  }

  registerMethods('Dom', {
    css,
    show,
    hide,
    visible
  });

  // Store data values on svg nodes
  function data(a, v, r) {
    if (a == null) {
      // get an object of attributes
      return this.data(
        map(
          filter(
            this.node.attributes,
            (el) => el.nodeName.indexOf('data-') === 0
          ),
          (el) => el.nodeName.slice(5)
        )
      )
    } else if (a instanceof Array) {
      const data = {};
      for (const key of a) {
        data[key] = this.data(key);
      }
      return data
    } else if (typeof a === 'object') {
      for (v in a) {
        this.data(v, a[v]);
      }
    } else if (arguments.length < 2) {
      try {
        return JSON.parse(this.attr('data-' + a))
      } catch (e) {
        return this.attr('data-' + a)
      }
    } else {
      this.attr(
        'data-' + a,
        v === null
          ? null
          : r === true || typeof v === 'string' || typeof v === 'number'
            ? v
            : JSON.stringify(v)
      );
    }

    return this
  }

  registerMethods('Dom', { data });

  // Remember arbitrary data
  function remember(k, v) {
    // remember every item in an object individually
    if (typeof arguments[0] === 'object') {
      for (const key in k) {
        this.remember(key, k[key]);
      }
    } else if (arguments.length === 1) {
      // retrieve memory
      return this.memory()[k]
    } else {
      // store memory
      this.memory()[k] = v;
    }

    return this
  }

  // Erase a given memory
  function forget() {
    if (arguments.length === 0) {
      this._memory = {};
    } else {
      for (let i = arguments.length - 1; i >= 0; i--) {
        delete this.memory()[arguments[i]];
      }
    }
    return this
  }

  // This triggers creation of a new hidden class which is not performant
  // However, this function is not rarely used so it will not happen frequently
  // Return local memory object
  function memory() {
    return (this._memory = this._memory || {})
  }

  registerMethods('Dom', { remember, forget, memory });

  function sixDigitHex(hex) {
    return hex.length === 4
      ? [
          '#',
          hex.substring(1, 2),
          hex.substring(1, 2),
          hex.substring(2, 3),
          hex.substring(2, 3),
          hex.substring(3, 4),
          hex.substring(3, 4)
        ].join('')
      : hex
  }

  function componentHex(component) {
    const integer = Math.round(component);
    const bounded = Math.max(0, Math.min(255, integer));
    const hex = bounded.toString(16);
    return hex.length === 1 ? '0' + hex : hex
  }

  function is(object, space) {
    for (let i = space.length; i--; ) {
      if (object[space[i]] == null) {
        return false
      }
    }
    return true
  }

  function getParameters(a, b) {
    const params = is(a, 'rgb')
      ? { _a: a.r, _b: a.g, _c: a.b, _d: 0, space: 'rgb' }
      : is(a, 'xyz')
        ? { _a: a.x, _b: a.y, _c: a.z, _d: 0, space: 'xyz' }
        : is(a, 'hsl')
          ? { _a: a.h, _b: a.s, _c: a.l, _d: 0, space: 'hsl' }
          : is(a, 'lab')
            ? { _a: a.l, _b: a.a, _c: a.b, _d: 0, space: 'lab' }
            : is(a, 'lch')
              ? { _a: a.l, _b: a.c, _c: a.h, _d: 0, space: 'lch' }
              : is(a, 'cmyk')
                ? { _a: a.c, _b: a.m, _c: a.y, _d: a.k, space: 'cmyk' }
                : { _a: 0, _b: 0, _c: 0, space: 'rgb' };

    params.space = b || params.space;
    return params
  }

  function cieSpace(space) {
    if (space === 'lab' || space === 'xyz' || space === 'lch') {
      return true
    } else {
      return false
    }
  }

  function hueToRgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t
    if (t < 1 / 2) return q
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6
    return p
  }

  class Color {
    constructor(...inputs) {
      this.init(...inputs);
    }

    // Test if given value is a color
    static isColor(color) {
      return (
        color && (color instanceof Color || this.isRgb(color) || this.test(color))
      )
    }

    // Test if given value is an rgb object
    static isRgb(color) {
      return (
        color &&
        typeof color.r === 'number' &&
        typeof color.g === 'number' &&
        typeof color.b === 'number'
      )
    }

    /*
    Generating random colors
    */
    static random(mode = 'vibrant', t) {
      // Get the math modules
      const { random, round, sin, PI: pi } = Math;

      // Run the correct generator
      if (mode === 'vibrant') {
        const l = (81 - 57) * random() + 57;
        const c = (83 - 45) * random() + 45;
        const h = 360 * random();
        const color = new Color(l, c, h, 'lch');
        return color
      } else if (mode === 'sine') {
        t = t == null ? random() : t;
        const r = round(80 * sin((2 * pi * t) / 0.5 + 0.01) + 150);
        const g = round(50 * sin((2 * pi * t) / 0.5 + 4.6) + 200);
        const b = round(100 * sin((2 * pi * t) / 0.5 + 2.3) + 150);
        const color = new Color(r, g, b);
        return color
      } else if (mode === 'pastel') {
        const l = (94 - 86) * random() + 86;
        const c = (26 - 9) * random() + 9;
        const h = 360 * random();
        const color = new Color(l, c, h, 'lch');
        return color
      } else if (mode === 'dark') {
        const l = 10 + 10 * random();
        const c = (125 - 75) * random() + 86;
        const h = 360 * random();
        const color = new Color(l, c, h, 'lch');
        return color
      } else if (mode === 'rgb') {
        const r = 255 * random();
        const g = 255 * random();
        const b = 255 * random();
        const color = new Color(r, g, b);
        return color
      } else if (mode === 'lab') {
        const l = 100 * random();
        const a = 256 * random() - 128;
        const b = 256 * random() - 128;
        const color = new Color(l, a, b, 'lab');
        return color
      } else if (mode === 'grey') {
        const grey = 255 * random();
        const color = new Color(grey, grey, grey);
        return color
      } else {
        throw new Error('Unsupported random color mode')
      }
    }

    // Test if given value is a color string
    static test(color) {
      return typeof color === 'string' && (isHex.test(color) || isRgb.test(color))
    }

    cmyk() {
      // Get the rgb values for the current color
      const { _a, _b, _c } = this.rgb();
      const [r, g, b] = [_a, _b, _c].map((v) => v / 255);

      // Get the cmyk values in an unbounded format
      const k = Math.min(1 - r, 1 - g, 1 - b);

      if (k === 1) {
        // Catch the black case
        return new Color(0, 0, 0, 1, 'cmyk')
      }

      const c = (1 - r - k) / (1 - k);
      const m = (1 - g - k) / (1 - k);
      const y = (1 - b - k) / (1 - k);

      // Construct the new color
      const color = new Color(c, m, y, k, 'cmyk');
      return color
    }

    hsl() {
      // Get the rgb values
      const { _a, _b, _c } = this.rgb();
      const [r, g, b] = [_a, _b, _c].map((v) => v / 255);

      // Find the maximum and minimum values to get the lightness
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const l = (max + min) / 2;

      // If the r, g, v values are identical then we are grey
      const isGrey = max === min;

      // Calculate the hue and saturation
      const delta = max - min;
      const s = isGrey
        ? 0
        : l > 0.5
          ? delta / (2 - max - min)
          : delta / (max + min);
      const h = isGrey
        ? 0
        : max === r
          ? ((g - b) / delta + (g < b ? 6 : 0)) / 6
          : max === g
            ? ((b - r) / delta + 2) / 6
            : max === b
              ? ((r - g) / delta + 4) / 6
              : 0;

      // Construct and return the new color
      const color = new Color(360 * h, 100 * s, 100 * l, 'hsl');
      return color
    }

    init(a = 0, b = 0, c = 0, d = 0, space = 'rgb') {
      // This catches the case when a falsy value is passed like ''
      a = !a ? 0 : a;

      // Reset all values in case the init function is rerun with new color space
      if (this.space) {
        for (const component in this.space) {
          delete this[this.space[component]];
        }
      }

      if (typeof a === 'number') {
        // Allow for the case that we don't need d...
        space = typeof d === 'string' ? d : space;
        d = typeof d === 'string' ? 0 : d;

        // Assign the values straight to the color
        Object.assign(this, { _a: a, _b: b, _c: c, _d: d, space });
        // If the user gave us an array, make the color from it
      } else if (a instanceof Array) {
        this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';
        Object.assign(this, { _a: a[0], _b: a[1], _c: a[2], _d: a[3] || 0 });
      } else if (a instanceof Object) {
        // Set the object up and assign its values directly
        const values = getParameters(a, b);
        Object.assign(this, values);
      } else if (typeof a === 'string') {
        if (isRgb.test(a)) {
          const noWhitespace = a.replace(whitespace, '');
          const [_a, _b, _c] = rgb
            .exec(noWhitespace)
            .slice(1, 4)
            .map((v) => parseInt(v));
          Object.assign(this, { _a, _b, _c, _d: 0, space: 'rgb' });
        } else if (isHex.test(a)) {
          const hexParse = (v) => parseInt(v, 16);
          const [, _a, _b, _c] = hex.exec(sixDigitHex(a)).map(hexParse);
          Object.assign(this, { _a, _b, _c, _d: 0, space: 'rgb' });
        } else throw Error("Unsupported string format, can't construct Color")
      }

      // Now add the components as a convenience
      const { _a, _b, _c, _d } = this;
      const components =
        this.space === 'rgb'
          ? { r: _a, g: _b, b: _c }
          : this.space === 'xyz'
            ? { x: _a, y: _b, z: _c }
            : this.space === 'hsl'
              ? { h: _a, s: _b, l: _c }
              : this.space === 'lab'
                ? { l: _a, a: _b, b: _c }
                : this.space === 'lch'
                  ? { l: _a, c: _b, h: _c }
                  : this.space === 'cmyk'
                    ? { c: _a, m: _b, y: _c, k: _d }
                    : {};
      Object.assign(this, components);
    }

    lab() {
      // Get the xyz color
      const { x, y, z } = this.xyz();

      // Get the lab components
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);

      // Construct and return a new color
      const color = new Color(l, a, b, 'lab');
      return color
    }

    lch() {
      // Get the lab color directly
      const { l, a, b } = this.lab();

      // Get the chromaticity and the hue using polar coordinates
      const c = Math.sqrt(a ** 2 + b ** 2);
      let h = (180 * Math.atan2(b, a)) / Math.PI;
      if (h < 0) {
        h *= -1;
        h = 360 - h;
      }

      // Make a new color and return it
      const color = new Color(l, c, h, 'lch');
      return color
    }
    /*
    Conversion Methods
    */

    rgb() {
      if (this.space === 'rgb') {
        return this
      } else if (cieSpace(this.space)) {
        // Convert to the xyz color space
        let { x, y, z } = this;
        if (this.space === 'lab' || this.space === 'lch') {
          // Get the values in the lab space
          let { l, a, b } = this;
          if (this.space === 'lch') {
            const { c, h } = this;
            const dToR = Math.PI / 180;
            a = c * Math.cos(dToR * h);
            b = c * Math.sin(dToR * h);
          }

          // Undo the nonlinear function
          const yL = (l + 16) / 116;
          const xL = a / 500 + yL;
          const zL = yL - b / 200;

          // Get the xyz values
          const ct = 16 / 116;
          const mx = 0.008856;
          const nm = 7.787;
          x = 0.95047 * (xL ** 3 > mx ? xL ** 3 : (xL - ct) / nm);
          y = 1.0 * (yL ** 3 > mx ? yL ** 3 : (yL - ct) / nm);
          z = 1.08883 * (zL ** 3 > mx ? zL ** 3 : (zL - ct) / nm);
        }

        // Convert xyz to unbounded rgb values
        const rU = x * 3.2406 + y * -1.5372 + z * -0.4986;
        const gU = x * -0.9689 + y * 1.8758 + z * 0.0415;
        const bU = x * 0.0557 + y * -0.204 + z * 1.057;

        // Convert the values to true rgb values
        const pow = Math.pow;
        const bd = 0.0031308;
        const r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;
        const g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;
        const b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU;

        // Make and return the color
        const color = new Color(255 * r, 255 * g, 255 * b);
        return color
      } else if (this.space === 'hsl') {
        // https://bgrins.github.io/TinyColor/docs/tinycolor.html
        // Get the current hsl values
        let { h, s, l } = this;
        h /= 360;
        s /= 100;
        l /= 100;

        // If we are grey, then just make the color directly
        if (s === 0) {
          l *= 255;
          const color = new Color(l, l, l);
          return color
        }

        // TODO I have no idea what this does :D If you figure it out, tell me!
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;

        // Get the rgb values
        const r = 255 * hueToRgb(p, q, h + 1 / 3);
        const g = 255 * hueToRgb(p, q, h);
        const b = 255 * hueToRgb(p, q, h - 1 / 3);

        // Make a new color
        const color = new Color(r, g, b);
        return color
      } else if (this.space === 'cmyk') {
        // https://gist.github.com/felipesabino/5066336
        // Get the normalised cmyk values
        const { c, m, y, k } = this;

        // Get the rgb values
        const r = 255 * (1 - Math.min(1, c * (1 - k) + k));
        const g = 255 * (1 - Math.min(1, m * (1 - k) + k));
        const b = 255 * (1 - Math.min(1, y * (1 - k) + k));

        // Form the color and return it
        const color = new Color(r, g, b);
        return color
      } else {
        return this
      }
    }

    toArray() {
      const { _a, _b, _c, _d, space } = this;
      return [_a, _b, _c, _d, space]
    }

    toHex() {
      const [r, g, b] = this._clamped().map(componentHex);
      return `#${r}${g}${b}`
    }

    toRgb() {
      const [rV, gV, bV] = this._clamped();
      const string = `rgb(${rV},${gV},${bV})`;
      return string
    }

    toString() {
      return this.toHex()
    }

    xyz() {
      // Normalise the red, green and blue values
      const { _a: r255, _b: g255, _c: b255 } = this.rgb();
      const [r, g, b] = [r255, g255, b255].map((v) => v / 255);

      // Convert to the lab rgb space
      const rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      const gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      const bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

      // Convert to the xyz color space without bounding the values
      const xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;
      const yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.0;
      const zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883;

      // Get the proper xyz values by applying the bounding
      const x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;
      const y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;
      const z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116;

      // Make and return the color
      const color = new Color(x, y, z, 'xyz');
      return color
    }

    /*
    Input and Output methods
    */

    _clamped() {
      const { _a, _b, _c } = this.rgb();
      const { max, min, round } = Math;
      const format = (v) => max(0, min(round(v), 255));
      return [_a, _b, _c].map(format)
    }

    /*
    Constructing colors
    */
  }

  class Point {
    // Initialize
    constructor(...args) {
      this.init(...args);
    }

    // Clone point
    clone() {
      return new Point(this)
    }

    init(x, y) {
      const base = { x: 0, y: 0 };

      // ensure source as object
      const source = Array.isArray(x)
        ? { x: x[0], y: x[1] }
        : typeof x === 'object'
          ? { x: x.x, y: x.y }
          : { x: x, y: y };

      // merge source
      this.x = source.x == null ? base.x : source.x;
      this.y = source.y == null ? base.y : source.y;

      return this
    }

    toArray() {
      return [this.x, this.y]
    }

    transform(m) {
      return this.clone().transformO(m)
    }

    // Transform point with matrix
    transformO(m) {
      if (!Matrix.isMatrixLike(m)) {
        m = new Matrix(m);
      }

      const { x, y } = this;

      // Perform the matrix multiplication
      this.x = m.a * x + m.c * y + m.e;
      this.y = m.b * x + m.d * y + m.f;

      return this
    }
  }

  function point(x, y) {
    return new Point(x, y).transformO(this.screenCTM().inverseO())
  }

  function closeEnough(a, b, threshold) {
    return Math.abs(b - a) < (threshold || 1e-6)
  }

  class Matrix {
    constructor(...args) {
      this.init(...args);
    }

    static formatTransforms(o) {
      // Get all of the parameters required to form the matrix
      const flipBoth = o.flip === 'both' || o.flip === true;
      const flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;
      const flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;
      const skewX =
        o.skew && o.skew.length
          ? o.skew[0]
          : isFinite(o.skew)
            ? o.skew
            : isFinite(o.skewX)
              ? o.skewX
              : 0;
      const skewY =
        o.skew && o.skew.length
          ? o.skew[1]
          : isFinite(o.skew)
            ? o.skew
            : isFinite(o.skewY)
              ? o.skewY
              : 0;
      const scaleX =
        o.scale && o.scale.length
          ? o.scale[0] * flipX
          : isFinite(o.scale)
            ? o.scale * flipX
            : isFinite(o.scaleX)
              ? o.scaleX * flipX
              : flipX;
      const scaleY =
        o.scale && o.scale.length
          ? o.scale[1] * flipY
          : isFinite(o.scale)
            ? o.scale * flipY
            : isFinite(o.scaleY)
              ? o.scaleY * flipY
              : flipY;
      const shear = o.shear || 0;
      const theta = o.rotate || o.theta || 0;
      const origin = new Point(
        o.origin || o.around || o.ox || o.originX,
        o.oy || o.originY
      );
      const ox = origin.x;
      const oy = origin.y;
      // We need Point to be invalid if nothing was passed because we cannot default to 0 here. That is why NaN
      const position = new Point(
        o.position || o.px || o.positionX || NaN,
        o.py || o.positionY || NaN
      );
      const px = position.x;
      const py = position.y;
      const translate = new Point(
        o.translate || o.tx || o.translateX,
        o.ty || o.translateY
      );
      const tx = translate.x;
      const ty = translate.y;
      const relative = new Point(
        o.relative || o.rx || o.relativeX,
        o.ry || o.relativeY
      );
      const rx = relative.x;
      const ry = relative.y;

      // Populate all of the values
      return {
        scaleX,
        scaleY,
        skewX,
        skewY,
        shear,
        theta,
        rx,
        ry,
        tx,
        ty,
        ox,
        oy,
        px,
        py
      }
    }

    static fromArray(a) {
      return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }
    }

    static isMatrixLike(o) {
      return (
        o.a != null ||
        o.b != null ||
        o.c != null ||
        o.d != null ||
        o.e != null ||
        o.f != null
      )
    }

    // left matrix, right matrix, target matrix which is overwritten
    static matrixMultiply(l, r, o) {
      // Work out the product directly
      const a = l.a * r.a + l.c * r.b;
      const b = l.b * r.a + l.d * r.b;
      const c = l.a * r.c + l.c * r.d;
      const d = l.b * r.c + l.d * r.d;
      const e = l.e + l.a * r.e + l.c * r.f;
      const f = l.f + l.b * r.e + l.d * r.f;

      // make sure to use local variables because l/r and o could be the same
      o.a = a;
      o.b = b;
      o.c = c;
      o.d = d;
      o.e = e;
      o.f = f;

      return o
    }

    around(cx, cy, matrix) {
      return this.clone().aroundO(cx, cy, matrix)
    }

    // Transform around a center point
    aroundO(cx, cy, matrix) {
      const dx = cx || 0;
      const dy = cy || 0;
      return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy)
    }

    // Clones this matrix
    clone() {
      return new Matrix(this)
    }

    // Decomposes this matrix into its affine parameters
    decompose(cx = 0, cy = 0) {
      // Get the parameters from the matrix
      const a = this.a;
      const b = this.b;
      const c = this.c;
      const d = this.d;
      const e = this.e;
      const f = this.f;

      // Figure out if the winding direction is clockwise or counterclockwise
      const determinant = a * d - b * c;
      const ccw = determinant > 0 ? 1 : -1;

      // Since we only shear in x, we can use the x basis to get the x scale
      // and the rotation of the resulting matrix
      const sx = ccw * Math.sqrt(a * a + b * b);
      const thetaRad = Math.atan2(ccw * b, ccw * a);
      const theta = (180 / Math.PI) * thetaRad;
      const ct = Math.cos(thetaRad);
      const st = Math.sin(thetaRad);

      // We can then solve the y basis vector simultaneously to get the other
      // two affine parameters directly from these parameters
      const lam = (a * c + b * d) / determinant;
      const sy = (c * sx) / (lam * a - b) || (d * sx) / (lam * b + a);

      // Use the translations
      const tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);
      const ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy);

      // Construct the decomposition and return it
      return {
        // Return the affine parameters
        scaleX: sx,
        scaleY: sy,
        shear: lam,
        rotate: theta,
        translateX: tx,
        translateY: ty,
        originX: cx,
        originY: cy,

        // Return the matrix parameters
        a: this.a,
        b: this.b,
        c: this.c,
        d: this.d,
        e: this.e,
        f: this.f
      }
    }

    // Check if two matrices are equal
    equals(other) {
      if (other === this) return true
      const comp = new Matrix(other);
      return (
        closeEnough(this.a, comp.a) &&
        closeEnough(this.b, comp.b) &&
        closeEnough(this.c, comp.c) &&
        closeEnough(this.d, comp.d) &&
        closeEnough(this.e, comp.e) &&
        closeEnough(this.f, comp.f)
      )
    }

    // Flip matrix on x or y, at a given offset
    flip(axis, around) {
      return this.clone().flipO(axis, around)
    }

    flipO(axis, around) {
      return axis === 'x'
        ? this.scaleO(-1, 1, around, 0)
        : axis === 'y'
          ? this.scaleO(1, -1, 0, around)
          : this.scaleO(-1, -1, axis, around || axis) // Define an x, y flip point
    }

    // Initialize
    init(source) {
      const base = Matrix.fromArray([1, 0, 0, 1, 0, 0]);

      // ensure source as object
      source =
        source instanceof Element$1
          ? source.matrixify()
          : typeof source === 'string'
            ? Matrix.fromArray(source.split(delimiter).map(parseFloat))
            : Array.isArray(source)
              ? Matrix.fromArray(source)
              : typeof source === 'object' && Matrix.isMatrixLike(source)
                ? source
                : typeof source === 'object'
                  ? new Matrix().transform(source)
                  : arguments.length === 6
                    ? Matrix.fromArray([].slice.call(arguments))
                    : base;

      // Merge the source matrix with the base matrix
      this.a = source.a != null ? source.a : base.a;
      this.b = source.b != null ? source.b : base.b;
      this.c = source.c != null ? source.c : base.c;
      this.d = source.d != null ? source.d : base.d;
      this.e = source.e != null ? source.e : base.e;
      this.f = source.f != null ? source.f : base.f;

      return this
    }

    inverse() {
      return this.clone().inverseO()
    }

    // Inverses matrix
    inverseO() {
      // Get the current parameters out of the matrix
      const a = this.a;
      const b = this.b;
      const c = this.c;
      const d = this.d;
      const e = this.e;
      const f = this.f;

      // Invert the 2x2 matrix in the top left
      const det = a * d - b * c;
      if (!det) throw new Error('Cannot invert ' + this)

      // Calculate the top 2x2 matrix
      const na = d / det;
      const nb = -b / det;
      const nc = -c / det;
      const nd = a / det;

      // Apply the inverted matrix to the top right
      const ne = -(na * e + nc * f);
      const nf = -(nb * e + nd * f);

      // Construct the inverted matrix
      this.a = na;
      this.b = nb;
      this.c = nc;
      this.d = nd;
      this.e = ne;
      this.f = nf;

      return this
    }

    lmultiply(matrix) {
      return this.clone().lmultiplyO(matrix)
    }

    lmultiplyO(matrix) {
      const r = this;
      const l = matrix instanceof Matrix ? matrix : new Matrix(matrix);

      return Matrix.matrixMultiply(l, r, this)
    }

    // Left multiplies by the given matrix
    multiply(matrix) {
      return this.clone().multiplyO(matrix)
    }

    multiplyO(matrix) {
      // Get the matrices
      const l = this;
      const r = matrix instanceof Matrix ? matrix : new Matrix(matrix);

      return Matrix.matrixMultiply(l, r, this)
    }

    // Rotate matrix
    rotate(r, cx, cy) {
      return this.clone().rotateO(r, cx, cy)
    }

    rotateO(r, cx = 0, cy = 0) {
      // Convert degrees to radians
      r = radians(r);

      const cos = Math.cos(r);
      const sin = Math.sin(r);

      const { a, b, c, d, e, f } = this;

      this.a = a * cos - b * sin;
      this.b = b * cos + a * sin;
      this.c = c * cos - d * sin;
      this.d = d * cos + c * sin;
      this.e = e * cos - f * sin + cy * sin - cx * cos + cx;
      this.f = f * cos + e * sin - cx * sin - cy * cos + cy;

      return this
    }

    // Scale matrix
    scale() {
      return this.clone().scaleO(...arguments)
    }

    scaleO(x, y = x, cx = 0, cy = 0) {
      // Support uniform scaling
      if (arguments.length === 3) {
        cy = cx;
        cx = y;
        y = x;
      }

      const { a, b, c, d, e, f } = this;

      this.a = a * x;
      this.b = b * y;
      this.c = c * x;
      this.d = d * y;
      this.e = e * x - cx * x + cx;
      this.f = f * y - cy * y + cy;

      return this
    }

    // Shear matrix
    shear(a, cx, cy) {
      return this.clone().shearO(a, cx, cy)
    }

    // eslint-disable-next-line no-unused-vars
    shearO(lx, cx = 0, cy = 0) {
      const { a, b, c, d, e, f } = this;

      this.a = a + b * lx;
      this.c = c + d * lx;
      this.e = e + f * lx - cy * lx;

      return this
    }

    // Skew Matrix
    skew() {
      return this.clone().skewO(...arguments)
    }

    skewO(x, y = x, cx = 0, cy = 0) {
      // support uniformal skew
      if (arguments.length === 3) {
        cy = cx;
        cx = y;
        y = x;
      }

      // Convert degrees to radians
      x = radians(x);
      y = radians(y);

      const lx = Math.tan(x);
      const ly = Math.tan(y);

      const { a, b, c, d, e, f } = this;

      this.a = a + b * lx;
      this.b = b + a * ly;
      this.c = c + d * lx;
      this.d = d + c * ly;
      this.e = e + f * lx - cy * lx;
      this.f = f + e * ly - cx * ly;

      return this
    }

    // SkewX
    skewX(x, cx, cy) {
      return this.skew(x, 0, cx, cy)
    }

    // SkewY
    skewY(y, cx, cy) {
      return this.skew(0, y, cx, cy)
    }

    toArray() {
      return [this.a, this.b, this.c, this.d, this.e, this.f]
    }

    // Convert matrix to string
    toString() {
      return (
        'matrix(' +
        this.a +
        ',' +
        this.b +
        ',' +
        this.c +
        ',' +
        this.d +
        ',' +
        this.e +
        ',' +
        this.f +
        ')'
      )
    }

    // Transform a matrix into another matrix by manipulating the space
    transform(o) {
      // Check if o is a matrix and then left multiply it directly
      if (Matrix.isMatrixLike(o)) {
        const matrix = new Matrix(o);
        return matrix.multiplyO(this)
      }

      // Get the proposed transformations and the current transformations
      const t = Matrix.formatTransforms(o);
      const current = this;
      const { x: ox, y: oy } = new Point(t.ox, t.oy).transform(current);

      // Construct the resulting matrix
      const transformer = new Matrix()
        .translateO(t.rx, t.ry)
        .lmultiplyO(current)
        .translateO(-ox, -oy)
        .scaleO(t.scaleX, t.scaleY)
        .skewO(t.skewX, t.skewY)
        .shearO(t.shear)
        .rotateO(t.theta)
        .translateO(ox, oy);

      // If we want the origin at a particular place, we force it there
      if (isFinite(t.px) || isFinite(t.py)) {
        const origin = new Point(ox, oy).transform(transformer);
        // TODO: Replace t.px with isFinite(t.px)
        // Doesn't work because t.px is also 0 if it wasn't passed
        const dx = isFinite(t.px) ? t.px - origin.x : 0;
        const dy = isFinite(t.py) ? t.py - origin.y : 0;
        transformer.translateO(dx, dy);
      }

      // Translate now after positioning
      transformer.translateO(t.tx, t.ty);
      return transformer
    }

    // Translate matrix
    translate(x, y) {
      return this.clone().translateO(x, y)
    }

    translateO(x, y) {
      this.e += x || 0;
      this.f += y || 0;
      return this
    }

    valueOf() {
      return {
        a: this.a,
        b: this.b,
        c: this.c,
        d: this.d,
        e: this.e,
        f: this.f
      }
    }
  }

  function ctm() {
    return new Matrix(this.node.getCTM())
  }

  function screenCTM() {
    try {
      /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
         This is needed because FF does not return the transformation matrix
         for the inner coordinate system when getScreenCTM() is called on nested svgs.
         However all other Browsers do that */
      if (typeof this.isRoot === 'function' && !this.isRoot()) {
        const rect = this.rect(1, 1);
        const m = rect.node.getScreenCTM();
        rect.remove();
        return new Matrix(m)
      }
      return new Matrix(this.node.getScreenCTM())
    } catch (e) {
      console.warn(
        `Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`
      );
      return new Matrix()
    }
  }

  register(Matrix, 'Matrix');

  function parser() {
    // Reuse cached element if possible
    if (!parser.nodes) {
      const svg = makeInstance().size(2, 0);
      svg.node.style.cssText = [
        'opacity: 0',
        'position: absolute',
        'left: -100%',
        'top: -100%',
        'overflow: hidden'
      ].join(';');

      svg.attr('focusable', 'false');
      svg.attr('aria-hidden', 'true');

      const path = svg.path().node;

      parser.nodes = { svg, path };
    }

    if (!parser.nodes.svg.node.parentNode) {
      const b = globals.document.body || globals.document.documentElement;
      parser.nodes.svg.addTo(b);
    }

    return parser.nodes
  }

  function isNulledBox(box) {
    return !box.width && !box.height && !box.x && !box.y
  }

  function domContains(node) {
    return (
      node === globals.document ||
      (
        globals.document.documentElement.contains ||
        function (node) {
          // This is IE - it does not support contains() for top-level SVGs
          while (node.parentNode) {
            node = node.parentNode;
          }
          return node === globals.document
        }
      ).call(globals.document.documentElement, node)
    )
  }

  class Box {
    constructor(...args) {
      this.init(...args);
    }

    addOffset() {
      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
      this.x += globals.window.pageXOffset;
      this.y += globals.window.pageYOffset;
      return new Box(this)
    }

    init(source) {
      const base = [0, 0, 0, 0];
      source =
        typeof source === 'string'
          ? source.split(delimiter).map(parseFloat)
          : Array.isArray(source)
            ? source
            : typeof source === 'object'
              ? [
                  source.left != null ? source.left : source.x,
                  source.top != null ? source.top : source.y,
                  source.width,
                  source.height
                ]
              : arguments.length === 4
                ? [].slice.call(arguments)
                : base;

      this.x = source[0] || 0;
      this.y = source[1] || 0;
      this.width = this.w = source[2] || 0;
      this.height = this.h = source[3] || 0;

      // Add more bounding box properties
      this.x2 = this.x + this.w;
      this.y2 = this.y + this.h;
      this.cx = this.x + this.w / 2;
      this.cy = this.y + this.h / 2;

      return this
    }

    isNulled() {
      return isNulledBox(this)
    }

    // Merge rect box with another, return a new instance
    merge(box) {
      const x = Math.min(this.x, box.x);
      const y = Math.min(this.y, box.y);
      const width = Math.max(this.x + this.width, box.x + box.width) - x;
      const height = Math.max(this.y + this.height, box.y + box.height) - y;

      return new Box(x, y, width, height)
    }

    toArray() {
      return [this.x, this.y, this.width, this.height]
    }

    toString() {
      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height
    }

    transform(m) {
      if (!(m instanceof Matrix)) {
        m = new Matrix(m);
      }

      let xMin = Infinity;
      let xMax = -Infinity;
      let yMin = Infinity;
      let yMax = -Infinity;

      const pts = [
        new Point(this.x, this.y),
        new Point(this.x2, this.y),
        new Point(this.x, this.y2),
        new Point(this.x2, this.y2)
      ];

      pts.forEach(function (p) {
        p = p.transform(m);
        xMin = Math.min(xMin, p.x);
        xMax = Math.max(xMax, p.x);
        yMin = Math.min(yMin, p.y);
        yMax = Math.max(yMax, p.y);
      });

      return new Box(xMin, yMin, xMax - xMin, yMax - yMin)
    }
  }

  function getBox(el, getBBoxFn, retry) {
    let box;

    try {
      // Try to get the box with the provided function
      box = getBBoxFn(el.node);

      // If the box is worthless and not even in the dom, retry
      // by throwing an error here...
      if (isNulledBox(box) && !domContains(el.node)) {
        throw new Error('Element not in the dom')
      }
    } catch (e) {
      // ... and calling the retry handler here
      box = retry(el);
    }

    return box
  }

  function bbox() {
    // Function to get bbox is getBBox()
    const getBBox = (node) => node.getBBox();

    // Take all measures so that a stupid browser renders the element
    // so we can get the bbox from it when we try again
    const retry = (el) => {
      try {
        const clone = el.clone().addTo(parser().svg).show();
        const box = clone.node.getBBox();
        clone.remove();
        return box
      } catch (e) {
        // We give up...
        throw new Error(
          `Getting bbox of element "${
          el.node.nodeName
        }" is not possible: ${e.toString()}`
        )
      }
    };

    const box = getBox(this, getBBox, retry);
    const bbox = new Box(box);

    return bbox
  }

  function rbox(el) {
    const getRBox = (node) => node.getBoundingClientRect();
    const retry = (el) => {
      // There is no point in trying tricks here because if we insert the element into the dom ourselves
      // it obviously will be at the wrong position
      throw new Error(
        `Getting rbox of element "${el.node.nodeName}" is not possible`
      )
    };

    const box = getBox(this, getRBox, retry);
    const rbox = new Box(box);

    // If an element was passed, we want the bbox in the coordinate system of that element
    if (el) {
      return rbox.transform(el.screenCTM().inverseO())
    }

    // Else we want it in absolute screen coordinates
    // Therefore we need to add the scrollOffset
    return rbox.addOffset()
  }

  // Checks whether the given point is inside the bounding box
  function inside(x, y) {
    const box = this.bbox();

    return (
      x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height
    )
  }

  registerMethods({
    viewbox: {
      viewbox(x, y, width, height) {
        // act as getter
        if (x == null) return new Box(this.attr('viewBox'))

        // act as setter
        return this.attr('viewBox', new Box(x, y, width, height))
      },

      zoom(level, point) {
        // Its best to rely on the attributes here and here is why:
        // clientXYZ: Doesn't work on non-root svgs because they dont have a CSSBox (silly!)
        // getBoundingClientRect: Doesn't work because Chrome just ignores width and height of nested svgs completely
        //                        that means, their clientRect is always as big as the content.
        //                        Furthermore this size is incorrect if the element is further transformed by its parents
        // computedStyle: Only returns meaningful values if css was used with px. We dont go this route here!
        // getBBox: returns the bounding box of its content - that doesn't help!
        let { width, height } = this.attr(['width', 'height']);

        // Width and height is a string when a number with a unit is present which we can't use
        // So we try clientXYZ
        if (
          (!width && !height) ||
          typeof width === 'string' ||
          typeof height === 'string'
        ) {
          width = this.node.clientWidth;
          height = this.node.clientHeight;
        }

        // Giving up...
        if (!width || !height) {
          throw new Error(
            'Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element'
          )
        }

        const v = this.viewbox();

        const zoomX = width / v.width;
        const zoomY = height / v.height;
        const zoom = Math.min(zoomX, zoomY);

        if (level == null) {
          return zoom
        }

        let zoomAmount = zoom / level;

        // Set the zoomAmount to the highest value which is safe to process and recover from
        // The * 100 is a bit of wiggle room for the matrix transformation
        if (zoomAmount === Infinity) zoomAmount = Number.MAX_SAFE_INTEGER / 100;

        point =
          point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);

        const box = new Box(v).transform(
          new Matrix({ scale: zoomAmount, origin: point })
        );

        return this.viewbox(box)
      }
    }
  });

  register(Box, 'Box');

  // import { subClassArray } from './ArrayPolyfill.js'

  class List extends Array {
    constructor(arr = [], ...args) {
      super(arr, ...args);
      if (typeof arr === 'number') return this
      this.length = 0;
      this.push(...arr);
    }
  }

  extend([List], {
    each(fnOrMethodName, ...args) {
      if (typeof fnOrMethodName === 'function') {
        return this.map((el, i, arr) => {
          return fnOrMethodName.call(el, el, i, arr)
        })
      } else {
        return this.map((el) => {
          return el[fnOrMethodName](...args)
        })
      }
    },

    toArray() {
      return Array.prototype.concat.apply([], this)
    }
  });

  const reserved = ['toArray', 'constructor', 'each'];

  List.extend = function (methods) {
    methods = methods.reduce((obj, name) => {
      // Don't overwrite own methods
      if (reserved.includes(name)) return obj

      // Don't add private methods
      if (name[0] === '_') return obj

      // Allow access to original Array methods through a prefix
      if (name in Array.prototype) {
        obj['$' + name] = Array.prototype[name];
      }

      // Relay every call to each()
      obj[name] = function (...attrs) {
        return this.each(name, ...attrs)
      };
      return obj
    }, {});

    extend([List], methods);
  };

  function baseFind(query, parent) {
    return new List(
      map((parent || globals.document).querySelectorAll(query), function (node) {
        return adopt(node)
      })
    )
  }

  // Scoped find method
  function find(query) {
    return baseFind(query, this.node)
  }

  function findOne(query) {
    return adopt(this.node.querySelector(query))
  }

  let listenerId = 0;
  const windowEvents = {};

  function getEvents(instance) {
    let n = instance.getEventHolder();

    // We dont want to save events in global space
    if (n === globals.window) n = windowEvents;
    if (!n.events) n.events = {};
    return n.events
  }

  function getEventTarget(instance) {
    return instance.getEventTarget()
  }

  function clearEvents(instance) {
    let n = instance.getEventHolder();
    if (n === globals.window) n = windowEvents;
    if (n.events) n.events = {};
  }

  // Add event binder in the SVG namespace
  function on(node, events, listener, binding, options) {
    const l = listener.bind(binding || node);
    const instance = makeInstance(node);
    const bag = getEvents(instance);
    const n = getEventTarget(instance);

    // events can be an array of events or a string of events
    events = Array.isArray(events) ? events : events.split(delimiter);

    // add id to listener
    if (!listener._svgjsListenerId) {
      listener._svgjsListenerId = ++listenerId;
    }

    events.forEach(function (event) {
      const ev = event.split('.')[0];
      const ns = event.split('.')[1] || '*';

      // ensure valid object
      bag[ev] = bag[ev] || {};
      bag[ev][ns] = bag[ev][ns] || {};

      // reference listener
      bag[ev][ns][listener._svgjsListenerId] = l;

      // add listener
      n.addEventListener(ev, l, options || false);
    });
  }

  // Add event unbinder in the SVG namespace
  function off(node, events, listener, options) {
    const instance = makeInstance(node);
    const bag = getEvents(instance);
    const n = getEventTarget(instance);

    // listener can be a function or a number
    if (typeof listener === 'function') {
      listener = listener._svgjsListenerId;
      if (!listener) return
    }

    // events can be an array of events or a string or undefined
    events = Array.isArray(events) ? events : (events || '').split(delimiter);

    events.forEach(function (event) {
      const ev = event && event.split('.')[0];
      const ns = event && event.split('.')[1];
      let namespace, l;

      if (listener) {
        // remove listener reference
        if (bag[ev] && bag[ev][ns || '*']) {
          // removeListener
          n.removeEventListener(
            ev,
            bag[ev][ns || '*'][listener],
            options || false
          );

          delete bag[ev][ns || '*'][listener];
        }
      } else if (ev && ns) {
        // remove all listeners for a namespaced event
        if (bag[ev] && bag[ev][ns]) {
          for (l in bag[ev][ns]) {
            off(n, [ev, ns].join('.'), l);
          }

          delete bag[ev][ns];
        }
      } else if (ns) {
        // remove all listeners for a specific namespace
        for (event in bag) {
          for (namespace in bag[event]) {
            if (ns === namespace) {
              off(n, [event, ns].join('.'));
            }
          }
        }
      } else if (ev) {
        // remove all listeners for the event
        if (bag[ev]) {
          for (namespace in bag[ev]) {
            off(n, [ev, namespace].join('.'));
          }

          delete bag[ev];
        }
      } else {
        // remove all listeners on a given node
        for (event in bag) {
          off(n, event);
        }

        clearEvents(instance);
      }
    });
  }

  function dispatch(node, event, data, options) {
    const n = getEventTarget(node);

    // Dispatch event
    if (event instanceof globals.window.Event) {
      n.dispatchEvent(event);
    } else {
      event = new globals.window.CustomEvent(event, {
        detail: data,
        cancelable: true,
        ...options
      });
      n.dispatchEvent(event);
    }
    return event
  }

  class EventTarget extends Base$1 {
    addEventListener() {}

    dispatch(event, data, options) {
      return dispatch(this, event, data, options)
    }

    dispatchEvent(event) {
      const bag = this.getEventHolder().events;
      if (!bag) return true

      const events = bag[event.type];

      for (const i in events) {
        for (const j in events[i]) {
          events[i][j](event);
        }
      }

      return !event.defaultPrevented
    }

    // Fire given event
    fire(event, data, options) {
      this.dispatch(event, data, options);
      return this
    }

    getEventHolder() {
      return this
    }

    getEventTarget() {
      return this
    }

    // Unbind event from listener
    off(event, listener, options) {
      off(this, event, listener, options);
      return this
    }

    // Bind given event to listener
    on(event, listener, binding, options) {
      on(this, event, listener, binding, options);
      return this
    }

    removeEventListener() {}
  }

  register(EventTarget, 'EventTarget');

  function noop() {}

  // Default animation values
  const timeline = {
    duration: 400,
    ease: '>',
    delay: 0
  };

  // Default attribute values
  const attrs = {
    // fill and stroke
    'fill-opacity': 1,
    'stroke-opacity': 1,
    'stroke-width': 0,
    'stroke-linejoin': 'miter',
    'stroke-linecap': 'butt',
    fill: '#000000',
    stroke: '#000000',
    opacity: 1,

    // position
    x: 0,
    y: 0,
    cx: 0,
    cy: 0,

    // size
    width: 0,
    height: 0,

    // radius
    r: 0,
    rx: 0,
    ry: 0,

    // gradient
    offset: 0,
    'stop-opacity': 1,
    'stop-color': '#000000',

    // text
    'text-anchor': 'start'
  };

  class SVGArray extends Array {
    constructor(...args) {
      super(...args);
      this.init(...args);
    }

    clone() {
      return new this.constructor(this)
    }

    init(arr) {
      // This catches the case, that native map tries to create an array with new Array(1)
      if (typeof arr === 'number') return this
      this.length = 0;
      this.push(...this.parse(arr));
      return this
    }

    // Parse whitespace separated string
    parse(array = []) {
      // If already is an array, no need to parse it
      if (array instanceof Array) return array

      return array.trim().split(delimiter).map(parseFloat)
    }

    toArray() {
      return Array.prototype.concat.apply([], this)
    }

    toSet() {
      return new Set(this)
    }

    toString() {
      return this.join(' ')
    }

    // Flattens the array if needed
    valueOf() {
      const ret = [];
      ret.push(...this);
      return ret
    }
  }

  // Module for unit conversions
  class SVGNumber {
    // Initialize
    constructor(...args) {
      this.init(...args);
    }

    convert(unit) {
      return new SVGNumber(this.value, unit)
    }

    // Divide number
    divide(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this / number, this.unit || number.unit)
    }

    init(value, unit) {
      unit = Array.isArray(value) ? value[1] : unit;
      value = Array.isArray(value) ? value[0] : value;

      // initialize defaults
      this.value = 0;
      this.unit = unit || '';

      // parse value
      if (typeof value === 'number') {
        // ensure a valid numeric value
        this.value = isNaN(value)
          ? 0
          : !isFinite(value)
            ? value < 0
              ? -3.4e38
              : +3.4e38
            : value;
      } else if (typeof value === 'string') {
        unit = value.match(numberAndUnit);

        if (unit) {
          // make value numeric
          this.value = parseFloat(unit[1]);

          // normalize
          if (unit[5] === '%') {
            this.value /= 100;
          } else if (unit[5] === 's') {
            this.value *= 1000;
          }

          // store unit
          this.unit = unit[5];
        }
      } else {
        if (value instanceof SVGNumber) {
          this.value = value.valueOf();
          this.unit = value.unit;
        }
      }

      return this
    }

    // Subtract number
    minus(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this - number, this.unit || number.unit)
    }

    // Add number
    plus(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this + number, this.unit || number.unit)
    }

    // Multiply number
    times(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this * number, this.unit || number.unit)
    }

    toArray() {
      return [this.value, this.unit]
    }

    toJSON() {
      return this.toString()
    }

    toString() {
      return (
        (this.unit === '%'
          ? ~~(this.value * 1e8) / 1e6
          : this.unit === 's'
            ? this.value / 1e3
            : this.value) + this.unit
      )
    }

    valueOf() {
      return this.value
    }
  }

  const colorAttributes = new Set([
    'fill',
    'stroke',
    'color',
    'bgcolor',
    'stop-color',
    'flood-color',
    'lighting-color'
  ]);

  const hooks = [];
  function registerAttrHook(fn) {
    hooks.push(fn);
  }

  // Set svg element attribute
  function attr(attr, val, ns) {
    // act as full getter
    if (attr == null) {
      // get an object of attributes
      attr = {};
      val = this.node.attributes;

      for (const node of val) {
        attr[node.nodeName] = isNumber.test(node.nodeValue)
          ? parseFloat(node.nodeValue)
          : node.nodeValue;
      }

      return attr
    } else if (attr instanceof Array) {
      // loop through array and get all values
      return attr.reduce((last, curr) => {
        last[curr] = this.attr(curr);
        return last
      }, {})
    } else if (typeof attr === 'object' && attr.constructor === Object) {
      // apply every attribute individually if an object is passed
      for (val in attr) this.attr(val, attr[val]);
    } else if (val === null) {
      // remove value
      this.node.removeAttribute(attr);
    } else if (val == null) {
      // act as a getter if the first and only argument is not an object
      val = this.node.getAttribute(attr);
      return val == null
        ? attrs[attr]
        : isNumber.test(val)
          ? parseFloat(val)
          : val
    } else {
      // Loop through hooks and execute them to convert value
      val = hooks.reduce((_val, hook) => {
        return hook(attr, _val, this)
      }, val);

      // ensure correct numeric values (also accepts NaN and Infinity)
      if (typeof val === 'number') {
        val = new SVGNumber(val);
      } else if (colorAttributes.has(attr) && Color.isColor(val)) {
        // ensure full hex color
        val = new Color(val);
      } else if (val.constructor === Array) {
        // Check for plain arrays and parse array values
        val = new SVGArray(val);
      }

      // if the passed attribute is leading...
      if (attr === 'leading') {
        // ... call the leading method instead
        if (this.leading) {
          this.leading(val);
        }
      } else {
        // set given attribute on node
        typeof ns === 'string'
          ? this.node.setAttributeNS(ns, attr, val.toString())
          : this.node.setAttribute(attr, val.toString());
      }

      // rebuild if required
      if (this.rebuild && (attr === 'font-size' || attr === 'x')) {
        this.rebuild();
      }
    }

    return this
  }

  class Dom extends EventTarget {
    constructor(node, attrs) {
      super();
      this.node = node;
      this.type = node.nodeName;

      if (attrs && node !== attrs) {
        this.attr(attrs);
      }
    }

    // Add given element at a position
    add(element, i) {
      element = makeInstance(element);

      // If non-root svg nodes are added we have to remove their namespaces
      if (
        element.removeNamespace &&
        this.node instanceof globals.window.SVGElement
      ) {
        element.removeNamespace();
      }

      if (i == null) {
        this.node.appendChild(element.node);
      } else if (element.node !== this.node.childNodes[i]) {
        this.node.insertBefore(element.node, this.node.childNodes[i]);
      }

      return this
    }

    // Add element to given container and return self
    addTo(parent, i) {
      return makeInstance(parent).put(this, i)
    }

    // Returns all child elements
    children() {
      return new List(
        map(this.node.children, function (node) {
          return adopt(node)
        })
      )
    }

    // Remove all elements in this container
    clear() {
      // remove children
      while (this.node.hasChildNodes()) {
        this.node.removeChild(this.node.lastChild);
      }

      return this
    }

    // Clone element
    clone(deep = true, assignNewIds = true) {
      // write dom data to the dom so the clone can pickup the data
      this.writeDataToDom();

      // clone element
      let nodeClone = this.node.cloneNode(deep);
      if (assignNewIds) {
        // assign new id
        nodeClone = assignNewId(nodeClone);
      }
      return new this.constructor(nodeClone)
    }

    // Iterates over all children and invokes a given block
    each(block, deep) {
      const children = this.children();
      let i, il;

      for (i = 0, il = children.length; i < il; i++) {
        block.apply(children[i], [i, children]);

        if (deep) {
          children[i].each(block, deep);
        }
      }

      return this
    }

    element(nodeName, attrs) {
      return this.put(new Dom(create(nodeName), attrs))
    }

    // Get first child
    first() {
      return adopt(this.node.firstChild)
    }

    // Get a element at the given index
    get(i) {
      return adopt(this.node.childNodes[i])
    }

    getEventHolder() {
      return this.node
    }

    getEventTarget() {
      return this.node
    }

    // Checks if the given element is a child
    has(element) {
      return this.index(element) >= 0
    }

    html(htmlOrFn, outerHTML) {
      return this.xml(htmlOrFn, outerHTML, html)
    }

    // Get / set id
    id(id) {
      // generate new id if no id set
      if (typeof id === 'undefined' && !this.node.id) {
        this.node.id = eid(this.type);
      }

      // don't set directly with this.node.id to make `null` work correctly
      return this.attr('id', id)
    }

    // Gets index of given element
    index(element) {
      return [].slice.call(this.node.childNodes).indexOf(element.node)
    }

    // Get the last child
    last() {
      return adopt(this.node.lastChild)
    }

    // matches the element vs a css selector
    matches(selector) {
      const el = this.node;
      const matcher =
        el.matches ||
        el.matchesSelector ||
        el.msMatchesSelector ||
        el.mozMatchesSelector ||
        el.webkitMatchesSelector ||
        el.oMatchesSelector ||
        null;
      return matcher && matcher.call(el, selector)
    }

    // Returns the parent element instance
    parent(type) {
      let parent = this;

      // check for parent
      if (!parent.node.parentNode) return null

      // get parent element
      parent = adopt(parent.node.parentNode);

      if (!type) return parent

      // loop through ancestors if type is given
      do {
        if (
          typeof type === 'string' ? parent.matches(type) : parent instanceof type
        )
          return parent
      } while ((parent = adopt(parent.node.parentNode)))

      return parent
    }

    // Basically does the same as `add()` but returns the added element instead
    put(element, i) {
      element = makeInstance(element);
      this.add(element, i);
      return element
    }

    // Add element to given container and return container
    putIn(parent, i) {
      return makeInstance(parent).add(this, i)
    }

    // Remove element
    remove() {
      if (this.parent()) {
        this.parent().removeElement(this);
      }

      return this
    }

    // Remove a given child
    removeElement(element) {
      this.node.removeChild(element.node);

      return this
    }

    // Replace this with element
    replace(element) {
      element = makeInstance(element);

      if (this.node.parentNode) {
        this.node.parentNode.replaceChild(element.node, this.node);
      }

      return element
    }

    round(precision = 2, map = null) {
      const factor = 10 ** precision;
      const attrs = this.attr(map);

      for (const i in attrs) {
        if (typeof attrs[i] === 'number') {
          attrs[i] = Math.round(attrs[i] * factor) / factor;
        }
      }

      this.attr(attrs);
      return this
    }

    // Import / Export raw svg
    svg(svgOrFn, outerSVG) {
      return this.xml(svgOrFn, outerSVG, svg)
    }

    // Return id on string conversion
    toString() {
      return this.id()
    }

    words(text) {
      // This is faster than removing all children and adding a new one
      this.node.textContent = text;
      return this
    }

    wrap(node) {
      const parent = this.parent();

      if (!parent) {
        return this.addTo(node)
      }

      const position = parent.index(this);
      return parent.put(node, position).put(this)
    }

    // write svgjs data to the dom
    writeDataToDom() {
      // dump variables recursively
      this.each(function () {
        this.writeDataToDom();
      });

      return this
    }

    // Import / Export raw svg
    xml(xmlOrFn, outerXML, ns) {
      if (typeof xmlOrFn === 'boolean') {
        ns = outerXML;
        outerXML = xmlOrFn;
        xmlOrFn = null;
      }

      // act as getter if no svg string is given
      if (xmlOrFn == null || typeof xmlOrFn === 'function') {
        // The default for exports is, that the outerNode is included
        outerXML = outerXML == null ? true : outerXML;

        // write svgjs data to the dom
        this.writeDataToDom();
        let current = this;

        // An export modifier was passed
        if (xmlOrFn != null) {
          current = adopt(current.node.cloneNode(true));

          // If the user wants outerHTML we need to process this node, too
          if (outerXML) {
            const result = xmlOrFn(current);
            current = result || current;

            // The user does not want this node? Well, then he gets nothing
            if (result === false) return ''
          }

          // Deep loop through all children and apply modifier
          current.each(function () {
            const result = xmlOrFn(this);
            const _this = result || this;

            // If modifier returns false, discard node
            if (result === false) {
              this.remove();

              // If modifier returns new node, use it
            } else if (result && this !== _this) {
              this.replace(_this);
            }
          }, true);
        }

        // Return outer or inner content
        return outerXML ? current.node.outerHTML : current.node.innerHTML
      }

      // Act as setter if we got a string

      // The default for import is, that the current node is not replaced
      outerXML = outerXML == null ? false : outerXML;

      // Create temporary holder
      const well = create('wrapper', ns);
      const fragment = globals.document.createDocumentFragment();

      // Dump raw svg
      well.innerHTML = xmlOrFn;

      // Transplant nodes into the fragment
      for (let len = well.children.length; len--; ) {
        fragment.appendChild(well.firstElementChild);
      }

      const parent = this.parent();

      // Add the whole fragment at once
      return outerXML ? this.replace(fragment) && parent : this.add(fragment)
    }
  }

  extend(Dom, { attr, find, findOne });
  register(Dom, 'Dom');

  let Element$1 = class Element extends Dom {
    constructor(node, attrs) {
      super(node, attrs);

      // initialize data object
      this.dom = {};

      // create circular reference
      this.node.instance = this;

      if (node.hasAttribute('data-svgjs') || node.hasAttribute('svgjs:data')) {
        // pull svgjs data from the dom (getAttributeNS doesn't work in html5)
        this.setData(
          JSON.parse(node.getAttribute('data-svgjs')) ??
            JSON.parse(node.getAttribute('svgjs:data')) ??
            {}
        );
      }
    }

    // Move element by its center
    center(x, y) {
      return this.cx(x).cy(y)
    }

    // Move by center over x-axis
    cx(x) {
      return x == null
        ? this.x() + this.width() / 2
        : this.x(x - this.width() / 2)
    }

    // Move by center over y-axis
    cy(y) {
      return y == null
        ? this.y() + this.height() / 2
        : this.y(y - this.height() / 2)
    }

    // Get defs
    defs() {
      const root = this.root();
      return root && root.defs()
    }

    // Relative move over x and y axes
    dmove(x, y) {
      return this.dx(x).dy(y)
    }

    // Relative move over x axis
    dx(x = 0) {
      return this.x(new SVGNumber(x).plus(this.x()))
    }

    // Relative move over y axis
    dy(y = 0) {
      return this.y(new SVGNumber(y).plus(this.y()))
    }

    getEventHolder() {
      return this
    }

    // Set height of element
    height(height) {
      return this.attr('height', height)
    }

    // Move element to given x and y values
    move(x, y) {
      return this.x(x).y(y)
    }

    // return array of all ancestors of given type up to the root svg
    parents(until = this.root()) {
      const isSelector = typeof until === 'string';
      if (!isSelector) {
        until = makeInstance(until);
      }
      const parents = new List();
      let parent = this;

      while (
        (parent = parent.parent()) &&
        parent.node !== globals.document &&
        parent.nodeName !== '#document-fragment'
      ) {
        parents.push(parent);

        if (!isSelector && parent.node === until.node) {
          break
        }
        if (isSelector && parent.matches(until)) {
          break
        }
        if (parent.node === this.root().node) {
          // We worked our way to the root and didn't match `until`
          return null
        }
      }

      return parents
    }

    // Get referenced element form attribute value
    reference(attr) {
      attr = this.attr(attr);
      if (!attr) return null

      const m = (attr + '').match(reference);
      return m ? makeInstance(m[1]) : null
    }

    // Get parent document
    root() {
      const p = this.parent(getClass(root));
      return p && p.root()
    }

    // set given data to the elements data property
    setData(o) {
      this.dom = o;
      return this
    }

    // Set element size to given width and height
    size(width, height) {
      const p = proportionalSize(this, width, height);

      return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height))
    }

    // Set width of element
    width(width) {
      return this.attr('width', width)
    }

    // write svgjs data to the dom
    writeDataToDom() {
      writeDataToDom(this, this.dom);
      return super.writeDataToDom()
    }

    // Move over x-axis
    x(x) {
      return this.attr('x', x)
    }

    // Move over y-axis
    y(y) {
      return this.attr('y', y)
    }
  };

  extend(Element$1, {
    bbox,
    rbox,
    inside,
    point,
    ctm,
    screenCTM
  });

  register(Element$1, 'Element');

  // Define list of available attributes for stroke and fill
  const sugar = {
    stroke: [
      'color',
      'width',
      'opacity',
      'linecap',
      'linejoin',
      'miterlimit',
      'dasharray',
      'dashoffset'
    ],
    fill: ['color', 'opacity', 'rule'],
    prefix: function (t, a) {
      return a === 'color' ? t : t + '-' + a
    }
  }

  // Add sugar for fill and stroke
  ;['fill', 'stroke'].forEach(function (m) {
    const extension = {};
    let i;

    extension[m] = function (o) {
      if (typeof o === 'undefined') {
        return this.attr(m)
      }
      if (
        typeof o === 'string' ||
        o instanceof Color ||
        Color.isRgb(o) ||
        o instanceof Element$1
      ) {
        this.attr(m, o);
      } else {
        // set all attributes from sugar.fill and sugar.stroke list
        for (i = sugar[m].length - 1; i >= 0; i--) {
          if (o[sugar[m][i]] != null) {
            this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);
          }
        }
      }

      return this
    };

    registerMethods(['Element', 'Runner'], extension);
  });

  registerMethods(['Element', 'Runner'], {
    // Let the user set the matrix directly
    matrix: function (mat, b, c, d, e, f) {
      // Act as a getter
      if (mat == null) {
        return new Matrix(this)
      }

      // Act as a setter, the user can pass a matrix or a set of numbers
      return this.attr('transform', new Matrix(mat, b, c, d, e, f))
    },

    // Map rotation to transform
    rotate: function (angle, cx, cy) {
      return this.transform({ rotate: angle, ox: cx, oy: cy }, true)
    },

    // Map skew to transform
    skew: function (x, y, cx, cy) {
      return arguments.length === 1 || arguments.length === 3
        ? this.transform({ skew: x, ox: y, oy: cx }, true)
        : this.transform({ skew: [x, y], ox: cx, oy: cy }, true)
    },

    shear: function (lam, cx, cy) {
      return this.transform({ shear: lam, ox: cx, oy: cy }, true)
    },

    // Map scale to transform
    scale: function (x, y, cx, cy) {
      return arguments.length === 1 || arguments.length === 3
        ? this.transform({ scale: x, ox: y, oy: cx }, true)
        : this.transform({ scale: [x, y], ox: cx, oy: cy }, true)
    },

    // Map translate to transform
    translate: function (x, y) {
      return this.transform({ translate: [x, y] }, true)
    },

    // Map relative translations to transform
    relative: function (x, y) {
      return this.transform({ relative: [x, y] }, true)
    },

    // Map flip to transform
    flip: function (direction = 'both', origin = 'center') {
      if ('xybothtrue'.indexOf(direction) === -1) {
        origin = direction;
        direction = 'both';
      }

      return this.transform({ flip: direction, origin: origin }, true)
    },

    // Opacity
    opacity: function (value) {
      return this.attr('opacity', value)
    }
  });

  registerMethods('radius', {
    // Add x and y radius
    radius: function (x, y = x) {
      const type = (this._element || this).type;
      return type === 'radialGradient'
        ? this.attr('r', new SVGNumber(x))
        : this.rx(x).ry(y)
    }
  });

  registerMethods('Path', {
    // Get path length
    length: function () {
      return this.node.getTotalLength()
    },
    // Get point at length
    pointAt: function (length) {
      return new Point(this.node.getPointAtLength(length))
    }
  });

  registerMethods(['Element', 'Runner'], {
    // Set font
    font: function (a, v) {
      if (typeof a === 'object') {
        for (v in a) this.font(v, a[v]);
        return this
      }

      return a === 'leading'
        ? this.leading(v)
        : a === 'anchor'
          ? this.attr('text-anchor', v)
          : a === 'size' ||
              a === 'family' ||
              a === 'weight' ||
              a === 'stretch' ||
              a === 'variant' ||
              a === 'style'
            ? this.attr('font-' + a, v)
            : this.attr(a, v)
    }
  });

  // Add events to elements
  const methods = [
    'click',
    'dblclick',
    'mousedown',
    'mouseup',
    'mouseover',
    'mouseout',
    'mousemove',
    'mouseenter',
    'mouseleave',
    'touchstart',
    'touchmove',
    'touchleave',
    'touchend',
    'touchcancel',
    'contextmenu',
    'wheel',
    'pointerdown',
    'pointermove',
    'pointerup',
    'pointerleave',
    'pointercancel'
  ].reduce(function (last, event) {
    // add event to Element
    const fn = function (f) {
      if (f === null) {
        this.off(event);
      } else {
        this.on(event, f);
      }
      return this
    };

    last[event] = fn;
    return last
  }, {});

  registerMethods('Element', methods);

  // Reset all transformations
  function untransform() {
    return this.attr('transform', null)
  }

  // merge the whole transformation chain into one matrix and returns it
  function matrixify() {
    const matrix = (this.attr('transform') || '')
      // split transformations
      .split(transforms)
      .slice(0, -1)
      .map(function (str) {
        // generate key => value pairs
        const kv = str.trim().split('(');
        return [
          kv[0],
          kv[1].split(delimiter).map(function (str) {
            return parseFloat(str)
          })
        ]
      })
      .reverse()
      // merge every transformation into one matrix
      .reduce(function (matrix, transform) {
        if (transform[0] === 'matrix') {
          return matrix.lmultiply(Matrix.fromArray(transform[1]))
        }
        return matrix[transform[0]].apply(matrix, transform[1])
      }, new Matrix());

    return matrix
  }

  // add an element to another parent without changing the visual representation on the screen
  function toParent(parent, i) {
    if (this === parent) return this

    if (isDescriptive(this.node)) return this.addTo(parent, i)

    const ctm = this.screenCTM();
    const pCtm = parent.screenCTM().inverse();

    this.addTo(parent, i).untransform().transform(pCtm.multiply(ctm));

    return this
  }

  // same as above with parent equals root-svg
  function toRoot(i) {
    return this.toParent(this.root(), i)
  }

  // Add transformations
  function transform(o, relative) {
    // Act as a getter if no object was passed
    if (o == null || typeof o === 'string') {
      const decomposed = new Matrix(this).decompose();
      return o == null ? decomposed : decomposed[o]
    }

    if (!Matrix.isMatrixLike(o)) {
      // Set the origin according to the defined transform
      o = { ...o, origin: getOrigin(o, this) };
    }

    // The user can pass a boolean, an Element or an Matrix or nothing
    const cleanRelative = relative === true ? this : relative || false;
    const result = new Matrix(cleanRelative).transform(o);
    return this.attr('transform', result)
  }

  registerMethods('Element', {
    untransform,
    matrixify,
    toParent,
    toRoot,
    transform
  });

  class Container extends Element$1 {
    flatten() {
      this.each(function () {
        if (this instanceof Container) {
          return this.flatten().ungroup()
        }
      });

      return this
    }

    ungroup(parent = this.parent(), index = parent.index(this)) {
      // when parent != this, we want append all elements to the end
      index = index === -1 ? parent.children().length : index;

      this.each(function (i, children) {
        // reverse each
        return children[children.length - i - 1].toParent(parent, index)
      });

      return this.remove()
    }
  }

  register(Container, 'Container');

  class Defs extends Container {
    constructor(node, attrs = node) {
      super(nodeOrNew('defs', node), attrs);
    }

    flatten() {
      return this
    }

    ungroup() {
      return this
    }
  }

  register(Defs, 'Defs');

  class Shape extends Element$1 {}

  register(Shape, 'Shape');

  // Radius x value
  function rx(rx) {
    return this.attr('rx', rx)
  }

  // Radius y value
  function ry(ry) {
    return this.attr('ry', ry)
  }

  // Move over x-axis
  function x$3(x) {
    return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())
  }

  // Move over y-axis
  function y$3(y) {
    return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())
  }

  // Move by center over x-axis
  function cx$1(x) {
    return this.attr('cx', x)
  }

  // Move by center over y-axis
  function cy$1(y) {
    return this.attr('cy', y)
  }

  // Set width of element
  function width$2(width) {
    return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2))
  }

  // Set height of element
  function height$2(height) {
    return height == null
      ? this.ry() * 2
      : this.ry(new SVGNumber(height).divide(2))
  }

  var circled = /*#__PURE__*/Object.freeze({
    __proto__: null,
    cx: cx$1,
    cy: cy$1,
    height: height$2,
    rx: rx,
    ry: ry,
    width: width$2,
    x: x$3,
    y: y$3
  });

  class Ellipse extends Shape {
    constructor(node, attrs = node) {
      super(nodeOrNew('ellipse', node), attrs);
    }

    size(width, height) {
      const p = proportionalSize(this, width, height);

      return this.rx(new SVGNumber(p.width).divide(2)).ry(
        new SVGNumber(p.height).divide(2)
      )
    }
  }

  extend(Ellipse, circled);

  registerMethods('Container', {
    // Create an ellipse
    ellipse: wrapWithAttrCheck(function (width = 0, height = width) {
      return this.put(new Ellipse()).size(width, height).move(0, 0)
    })
  });

  register(Ellipse, 'Ellipse');

  class Fragment extends Dom {
    constructor(node = globals.document.createDocumentFragment()) {
      super(node);
    }

    // Import / Export raw xml
    xml(xmlOrFn, outerXML, ns) {
      if (typeof xmlOrFn === 'boolean') {
        ns = outerXML;
        outerXML = xmlOrFn;
        xmlOrFn = null;
      }

      // because this is a fragment we have to put all elements into a wrapper first
      // before we can get the innerXML from it
      if (xmlOrFn == null || typeof xmlOrFn === 'function') {
        const wrapper = new Dom(create('wrapper', ns));
        wrapper.add(this.node.cloneNode(true));

        return wrapper.xml(false, ns)
      }

      // Act as setter if we got a string
      return super.xml(xmlOrFn, false, ns)
    }
  }

  register(Fragment, 'Fragment');

  function from(x, y) {
    return (this._element || this).type === 'radialGradient'
      ? this.attr({ fx: new SVGNumber(x), fy: new SVGNumber(y) })
      : this.attr({ x1: new SVGNumber(x), y1: new SVGNumber(y) })
  }

  function to(x, y) {
    return (this._element || this).type === 'radialGradient'
      ? this.attr({ cx: new SVGNumber(x), cy: new SVGNumber(y) })
      : this.attr({ x2: new SVGNumber(x), y2: new SVGNumber(y) })
  }

  var gradiented = /*#__PURE__*/Object.freeze({
    __proto__: null,
    from: from,
    to: to
  });

  class Gradient extends Container {
    constructor(type, attrs) {
      super(
        nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type),
        attrs
      );
    }

    // custom attr to handle transform
    attr(a, b, c) {
      if (a === 'transform') a = 'gradientTransform';
      return super.attr(a, b, c)
    }

    bbox() {
      return new Box()
    }

    targets() {
      return baseFind('svg [fill*=' + this.id() + ']')
    }

    // Alias string conversion to fill
    toString() {
      return this.url()
    }

    // Update gradient
    update(block) {
      // remove all stops
      this.clear();

      // invoke passed block
      if (typeof block === 'function') {
        block.call(this, this);
      }

      return this
    }

    // Return the fill id
    url() {
      return 'url(#' + this.id() + ')'
    }
  }

  extend(Gradient, gradiented);

  registerMethods({
    Container: {
      // Create gradient element in defs
      gradient(...args) {
        return this.defs().gradient(...args)
      }
    },
    // define gradient
    Defs: {
      gradient: wrapWithAttrCheck(function (type, block) {
        return this.put(new Gradient(type)).update(block)
      })
    }
  });

  register(Gradient, 'Gradient');

  class Pattern extends Container {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('pattern', node), attrs);
    }

    // custom attr to handle transform
    attr(a, b, c) {
      if (a === 'transform') a = 'patternTransform';
      return super.attr(a, b, c)
    }

    bbox() {
      return new Box()
    }

    targets() {
      return baseFind('svg [fill*=' + this.id() + ']')
    }

    // Alias string conversion to fill
    toString() {
      return this.url()
    }

    // Update pattern by rebuilding
    update(block) {
      // remove content
      this.clear();

      // invoke passed block
      if (typeof block === 'function') {
        block.call(this, this);
      }

      return this
    }

    // Return the fill id
    url() {
      return 'url(#' + this.id() + ')'
    }
  }

  registerMethods({
    Container: {
      // Create pattern element in defs
      pattern(...args) {
        return this.defs().pattern(...args)
      }
    },
    Defs: {
      pattern: wrapWithAttrCheck(function (width, height, block) {
        return this.put(new Pattern()).update(block).attr({
          x: 0,
          y: 0,
          width: width,
          height: height,
          patternUnits: 'userSpaceOnUse'
        })
      })
    }
  });

  register(Pattern, 'Pattern');

  let Image$1 = class Image extends Shape {
    constructor(node, attrs = node) {
      super(nodeOrNew('image', node), attrs);
    }

    // (re)load image
    load(url, callback) {
      if (!url) return this

      const img = new globals.window.Image();

      on(
        img,
        'load',
        function (e) {
          const p = this.parent(Pattern);

          // ensure image size
          if (this.width() === 0 && this.height() === 0) {
            this.size(img.width, img.height);
          }

          if (p instanceof Pattern) {
            // ensure pattern size if not set
            if (p.width() === 0 && p.height() === 0) {
              p.size(this.width(), this.height());
            }
          }

          if (typeof callback === 'function') {
            callback.call(this, e);
          }
        },
        this
      );

      on(img, 'load error', function () {
        // dont forget to unbind memory leaking events
        off(img);
      });

      return this.attr('href', (img.src = url), xlink)
    }
  };

  registerAttrHook(function (attr, val, _this) {
    // convert image fill and stroke to patterns
    if (attr === 'fill' || attr === 'stroke') {
      if (isImage.test(val)) {
        val = _this.root().defs().image(val);
      }
    }

    if (val instanceof Image$1) {
      val = _this
        .root()
        .defs()
        .pattern(0, 0, (pattern) => {
          pattern.add(val);
        });
    }

    return val
  });

  registerMethods({
    Container: {
      // create image element, load image and set its size
      image: wrapWithAttrCheck(function (source, callback) {
        return this.put(new Image$1()).size(0, 0).load(source, callback)
      })
    }
  });

  register(Image$1, 'Image');

  class PointArray extends SVGArray {
    // Get bounding box of points
    bbox() {
      let maxX = -Infinity;
      let maxY = -Infinity;
      let minX = Infinity;
      let minY = Infinity;
      this.forEach(function (el) {
        maxX = Math.max(el[0], maxX);
        maxY = Math.max(el[1], maxY);
        minX = Math.min(el[0], minX);
        minY = Math.min(el[1], minY);
      });
      return new Box(minX, minY, maxX - minX, maxY - minY)
    }

    // Move point string
    move(x, y) {
      const box = this.bbox();

      // get relative offset
      x -= box.x;
      y -= box.y;

      // move every point
      if (!isNaN(x) && !isNaN(y)) {
        for (let i = this.length - 1; i >= 0; i--) {
          this[i] = [this[i][0] + x, this[i][1] + y];
        }
      }

      return this
    }

    // Parse point string and flat array
    parse(array = [0, 0]) {
      const points = [];

      // if it is an array, we flatten it and therefore clone it to 1 depths
      if (array instanceof Array) {
        array = Array.prototype.concat.apply([], array);
      } else {
        // Else, it is considered as a string
        // parse points
        array = array.trim().split(delimiter).map(parseFloat);
      }

      // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
      // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.
      if (array.length % 2 !== 0) array.pop();

      // wrap points in two-tuples
      for (let i = 0, len = array.length; i < len; i = i + 2) {
        points.push([array[i], array[i + 1]]);
      }

      return points
    }

    // Resize poly string
    size(width, height) {
      let i;
      const box = this.bbox();

      // recalculate position of all points according to new size
      for (i = this.length - 1; i >= 0; i--) {
        if (box.width)
          this[i][0] = ((this[i][0] - box.x) * width) / box.width + box.x;
        if (box.height)
          this[i][1] = ((this[i][1] - box.y) * height) / box.height + box.y;
      }

      return this
    }

    // Convert array to line object
    toLine() {
      return {
        x1: this[0][0],
        y1: this[0][1],
        x2: this[1][0],
        y2: this[1][1]
      }
    }

    // Convert array to string
    toString() {
      const array = [];
      // convert to a poly point string
      for (let i = 0, il = this.length; i < il; i++) {
        array.push(this[i].join(','));
      }

      return array.join(' ')
    }

    transform(m) {
      return this.clone().transformO(m)
    }

    // transform points with matrix (similar to Point.transform)
    transformO(m) {
      if (!Matrix.isMatrixLike(m)) {
        m = new Matrix(m);
      }

      for (let i = this.length; i--; ) {
        // Perform the matrix multiplication
        const [x, y] = this[i];
        this[i][0] = m.a * x + m.c * y + m.e;
        this[i][1] = m.b * x + m.d * y + m.f;
      }

      return this
    }
  }

  const MorphArray = PointArray;

  // Move by left top corner over x-axis
  function x$2(x) {
    return x == null ? this.bbox().x : this.move(x, this.bbox().y)
  }

  // Move by left top corner over y-axis
  function y$2(y) {
    return y == null ? this.bbox().y : this.move(this.bbox().x, y)
  }

  // Set width of element
  function width$1(width) {
    const b = this.bbox();
    return width == null ? b.width : this.size(width, b.height)
  }

  // Set height of element
  function height$1(height) {
    const b = this.bbox();
    return height == null ? b.height : this.size(b.width, height)
  }

  var pointed = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MorphArray: MorphArray,
    height: height$1,
    width: width$1,
    x: x$2,
    y: y$2
  });

  let Line$1 = class Line extends Shape {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('line', node), attrs);
    }

    // Get array
    array() {
      return new PointArray([
        [this.attr('x1'), this.attr('y1')],
        [this.attr('x2'), this.attr('y2')]
      ])
    }

    // Move by left top corner
    move(x, y) {
      return this.attr(this.array().move(x, y).toLine())
    }

    // Overwrite native plot() method
    plot(x1, y1, x2, y2) {
      if (x1 == null) {
        return this.array()
      } else if (typeof y1 !== 'undefined') {
        x1 = { x1, y1, x2, y2 };
      } else {
        x1 = new PointArray(x1).toLine();
      }

      return this.attr(x1)
    }

    // Set element size to given width and height
    size(width, height) {
      const p = proportionalSize(this, width, height);
      return this.attr(this.array().size(p.width, p.height).toLine())
    }
  };

  extend(Line$1, pointed);

  registerMethods({
    Container: {
      // Create a line element
      line: wrapWithAttrCheck(function (...args) {
        // make sure plot is called as a setter
        // x1 is not necessarily a number, it can also be an array, a string and a PointArray
        return Line$1.prototype.plot.apply(
          this.put(new Line$1()),
          args[0] != null ? args : [0, 0, 0, 0]
        )
      })
    }
  });

  register(Line$1, 'Line');

  let Marker$1 = class Marker extends Container {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('marker', node), attrs);
    }

    // Set height of element
    height(height) {
      return this.attr('markerHeight', height)
    }

    orient(orient) {
      return this.attr('orient', orient)
    }

    // Set marker refX and refY
    ref(x, y) {
      return this.attr('refX', x).attr('refY', y)
    }

    // Return the fill id
    toString() {
      return 'url(#' + this.id() + ')'
    }

    // Update marker
    update(block) {
      // remove all content
      this.clear();

      // invoke passed block
      if (typeof block === 'function') {
        block.call(this, this);
      }

      return this
    }

    // Set width of element
    width(width) {
      return this.attr('markerWidth', width)
    }
  };

  registerMethods({
    Container: {
      marker(...args) {
        // Create marker element in defs
        return this.defs().marker(...args)
      }
    },
    Defs: {
      // Create marker
      marker: wrapWithAttrCheck(function (width, height, block) {
        // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
        return this.put(new Marker$1())
          .size(width, height)
          .ref(width / 2, height / 2)
          .viewbox(0, 0, width, height)
          .attr('orient', 'auto')
          .update(block)
      })
    },
    marker: {
      // Create and attach markers
      marker(marker, width, height, block) {
        let attr = ['marker'];

        // Build attribute name
        if (marker !== 'all') attr.push(marker);
        attr = attr.join('-');

        // Set marker attribute
        marker =
          arguments[1] instanceof Marker$1
            ? arguments[1]
            : this.defs().marker(width, height, block);

        return this.attr(attr, marker)
      }
    }
  });

  register(Marker$1, 'Marker');

  /***
  Base Class
  ==========
  The base stepper class that will be
  ***/

  function makeSetterGetter(k, f) {
    return function (v) {
      if (v == null) return this[k]
      this[k] = v;
      if (f) f.call(this);
      return this
    }
  }

  const easing = {
    '-': function (pos) {
      return pos
    },
    '<>': function (pos) {
      return -Math.cos(pos * Math.PI) / 2 + 0.5
    },
    '>': function (pos) {
      return Math.sin((pos * Math.PI) / 2)
    },
    '<': function (pos) {
      return -Math.cos((pos * Math.PI) / 2) + 1
    },
    bezier: function (x1, y1, x2, y2) {
      // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo
      return function (t) {
        if (t < 0) {
          if (x1 > 0) {
            return (y1 / x1) * t
          } else if (x2 > 0) {
            return (y2 / x2) * t
          } else {
            return 0
          }
        } else if (t > 1) {
          if (x2 < 1) {
            return ((1 - y2) / (1 - x2)) * t + (y2 - x2) / (1 - x2)
          } else if (x1 < 1) {
            return ((1 - y1) / (1 - x1)) * t + (y1 - x1) / (1 - x1)
          } else {
            return 1
          }
        } else {
          return 3 * t * (1 - t) ** 2 * y1 + 3 * t ** 2 * (1 - t) * y2 + t ** 3
        }
      }
    },
    // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo
    steps: function (steps, stepPosition = 'end') {
      // deal with "jump-" prefix
      stepPosition = stepPosition.split('-').reverse()[0];

      let jumps = steps;
      if (stepPosition === 'none') {
        --jumps;
      } else if (stepPosition === 'both') {
        ++jumps;
      }

      // The beforeFlag is essentially useless
      return (t, beforeFlag = false) => {
        // Step is called currentStep in referenced url
        let step = Math.floor(t * steps);
        const jumping = (t * step) % 1 === 0;

        if (stepPosition === 'start' || stepPosition === 'both') {
          ++step;
        }

        if (beforeFlag && jumping) {
          --step;
        }

        if (t >= 0 && step < 0) {
          step = 0;
        }

        if (t <= 1 && step > jumps) {
          step = jumps;
        }

        return step / jumps
      }
    }
  };

  class Stepper {
    done() {
      return false
    }
  }

  /***
  Easing Functions
  ================
  ***/

  class Ease extends Stepper {
    constructor(fn = timeline.ease) {
      super();
      this.ease = easing[fn] || fn;
    }

    step(from, to, pos) {
      if (typeof from !== 'number') {
        return pos < 1 ? from : to
      }
      return from + (to - from) * this.ease(pos)
    }
  }

  /***
  Controller Types
  ================
  ***/

  class Controller extends Stepper {
    constructor(fn) {
      super();
      this.stepper = fn;
    }

    done(c) {
      return c.done
    }

    step(current, target, dt, c) {
      return this.stepper(current, target, dt, c)
    }
  }

  function recalculate() {
    // Apply the default parameters
    const duration = (this._duration || 500) / 1000;
    const overshoot = this._overshoot || 0;

    // Calculate the PID natural response
    const eps = 1e-10;
    const pi = Math.PI;
    const os = Math.log(overshoot / 100 + eps);
    const zeta = -os / Math.sqrt(pi * pi + os * os);
    const wn = 3.9 / (zeta * duration);

    // Calculate the Spring values
    this.d = 2 * zeta * wn;
    this.k = wn * wn;
  }

  class Spring extends Controller {
    constructor(duration = 500, overshoot = 0) {
      super();
      this.duration(duration).overshoot(overshoot);
    }

    step(current, target, dt, c) {
      if (typeof current === 'string') return current
      c.done = dt === Infinity;
      if (dt === Infinity) return target
      if (dt === 0) return current

      if (dt > 100) dt = 16;

      dt /= 1000;

      // Get the previous velocity
      const velocity = c.velocity || 0;

      // Apply the control to get the new position and store it
      const acceleration = -this.d * velocity - this.k * (current - target);
      const newPosition = current + velocity * dt + (acceleration * dt * dt) / 2;

      // Store the velocity
      c.velocity = velocity + acceleration * dt;

      // Figure out if we have converged, and if so, pass the value
      c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;
      return c.done ? target : newPosition
    }
  }

  extend(Spring, {
    duration: makeSetterGetter('_duration', recalculate),
    overshoot: makeSetterGetter('_overshoot', recalculate)
  });

  class PID extends Controller {
    constructor(p = 0.1, i = 0.01, d = 0, windup = 1000) {
      super();
      this.p(p).i(i).d(d).windup(windup);
    }

    step(current, target, dt, c) {
      if (typeof current === 'string') return current
      c.done = dt === Infinity;

      if (dt === Infinity) return target
      if (dt === 0) return current

      const p = target - current;
      let i = (c.integral || 0) + p * dt;
      const d = (p - (c.error || 0)) / dt;
      const windup = this._windup;

      // antiwindup
      if (windup !== false) {
        i = Math.max(-windup, Math.min(i, windup));
      }

      c.error = p;
      c.integral = i;

      c.done = Math.abs(p) < 0.001;

      return c.done ? target : current + (this.P * p + this.I * i + this.D * d)
    }
  }

  extend(PID, {
    windup: makeSetterGetter('_windup'),
    p: makeSetterGetter('P'),
    i: makeSetterGetter('I'),
    d: makeSetterGetter('D')
  });

  const segmentParameters = {
    M: 2,
    L: 2,
    H: 1,
    V: 1,
    C: 6,
    S: 4,
    Q: 4,
    T: 2,
    A: 7,
    Z: 0
  };

  const pathHandlers = {
    M: function (c, p, p0) {
      p.x = p0.x = c[0];
      p.y = p0.y = c[1];

      return ['M', p.x, p.y]
    },
    L: function (c, p) {
      p.x = c[0];
      p.y = c[1];
      return ['L', c[0], c[1]]
    },
    H: function (c, p) {
      p.x = c[0];
      return ['H', c[0]]
    },
    V: function (c, p) {
      p.y = c[0];
      return ['V', c[0]]
    },
    C: function (c, p) {
      p.x = c[4];
      p.y = c[5];
      return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]
    },
    S: function (c, p) {
      p.x = c[2];
      p.y = c[3];
      return ['S', c[0], c[1], c[2], c[3]]
    },
    Q: function (c, p) {
      p.x = c[2];
      p.y = c[3];
      return ['Q', c[0], c[1], c[2], c[3]]
    },
    T: function (c, p) {
      p.x = c[0];
      p.y = c[1];
      return ['T', c[0], c[1]]
    },
    Z: function (c, p, p0) {
      p.x = p0.x;
      p.y = p0.y;
      return ['Z']
    },
    A: function (c, p) {
      p.x = c[5];
      p.y = c[6];
      return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]
    }
  };

  const mlhvqtcsaz = 'mlhvqtcsaz'.split('');

  for (let i = 0, il = mlhvqtcsaz.length; i < il; ++i) {
    pathHandlers[mlhvqtcsaz[i]] = (function (i) {
      return function (c, p, p0) {
        if (i === 'H') c[0] = c[0] + p.x;
        else if (i === 'V') c[0] = c[0] + p.y;
        else if (i === 'A') {
          c[5] = c[5] + p.x;
          c[6] = c[6] + p.y;
        } else {
          for (let j = 0, jl = c.length; j < jl; ++j) {
            c[j] = c[j] + (j % 2 ? p.y : p.x);
          }
        }

        return pathHandlers[i](c, p, p0)
      }
    })(mlhvqtcsaz[i].toUpperCase());
  }

  function makeAbsolut(parser) {
    const command = parser.segment[0];
    return pathHandlers[command](parser.segment.slice(1), parser.p, parser.p0)
  }

  function segmentComplete(parser) {
    return (
      parser.segment.length &&
      parser.segment.length - 1 ===
        segmentParameters[parser.segment[0].toUpperCase()]
    )
  }

  function startNewSegment(parser, token) {
    parser.inNumber && finalizeNumber(parser, false);
    const pathLetter = isPathLetter.test(token);

    if (pathLetter) {
      parser.segment = [token];
    } else {
      const lastCommand = parser.lastCommand;
      const small = lastCommand.toLowerCase();
      const isSmall = lastCommand === small;
      parser.segment = [small === 'm' ? (isSmall ? 'l' : 'L') : lastCommand];
    }

    parser.inSegment = true;
    parser.lastCommand = parser.segment[0];

    return pathLetter
  }

  function finalizeNumber(parser, inNumber) {
    if (!parser.inNumber) throw new Error('Parser Error')
    parser.number && parser.segment.push(parseFloat(parser.number));
    parser.inNumber = inNumber;
    parser.number = '';
    parser.pointSeen = false;
    parser.hasExponent = false;

    if (segmentComplete(parser)) {
      finalizeSegment(parser);
    }
  }

  function finalizeSegment(parser) {
    parser.inSegment = false;
    if (parser.absolute) {
      parser.segment = makeAbsolut(parser);
    }
    parser.segments.push(parser.segment);
  }

  function isArcFlag(parser) {
    if (!parser.segment.length) return false
    const isArc = parser.segment[0].toUpperCase() === 'A';
    const length = parser.segment.length;

    return isArc && (length === 4 || length === 5)
  }

  function isExponential(parser) {
    return parser.lastToken.toUpperCase() === 'E'
  }

  const pathDelimiters = new Set([' ', ',', '\t', '\n', '\r', '\f']);
  function pathParser(d, toAbsolute = true) {
    let index = 0;
    let token = '';
    const parser = {
      segment: [],
      inNumber: false,
      number: '',
      lastToken: '',
      inSegment: false,
      segments: [],
      pointSeen: false,
      hasExponent: false,
      absolute: toAbsolute,
      p0: new Point(),
      p: new Point()
    };

    while (((parser.lastToken = token), (token = d.charAt(index++)))) {
      if (!parser.inSegment) {
        if (startNewSegment(parser, token)) {
          continue
        }
      }

      if (token === '.') {
        if (parser.pointSeen || parser.hasExponent) {
          finalizeNumber(parser, false);
          --index;
          continue
        }
        parser.inNumber = true;
        parser.pointSeen = true;
        parser.number += token;
        continue
      }

      if (!isNaN(parseInt(token))) {
        if (parser.number === '0' || isArcFlag(parser)) {
          parser.inNumber = true;
          parser.number = token;
          finalizeNumber(parser, true);
          continue
        }

        parser.inNumber = true;
        parser.number += token;
        continue
      }

      if (pathDelimiters.has(token)) {
        if (parser.inNumber) {
          finalizeNumber(parser, false);
        }
        continue
      }

      if (token === '-' || token === '+') {
        if (parser.inNumber && !isExponential(parser)) {
          finalizeNumber(parser, false);
          --index;
          continue
        }
        parser.number += token;
        parser.inNumber = true;
        continue
      }

      if (token.toUpperCase() === 'E') {
        parser.number += token;
        parser.hasExponent = true;
        continue
      }

      if (isPathLetter.test(token)) {
        if (parser.inNumber) {
          finalizeNumber(parser, false);
        } else if (!segmentComplete(parser)) {
          throw new Error('parser Error')
        } else {
          finalizeSegment(parser);
        }
        --index;
      }
    }

    if (parser.inNumber) {
      finalizeNumber(parser, false);
    }

    if (parser.inSegment && segmentComplete(parser)) {
      finalizeSegment(parser);
    }

    return parser.segments
  }

  function arrayToString(a) {
    let s = '';
    for (let i = 0, il = a.length; i < il; i++) {
      s += a[i][0];

      if (a[i][1] != null) {
        s += a[i][1];

        if (a[i][2] != null) {
          s += ' ';
          s += a[i][2];

          if (a[i][3] != null) {
            s += ' ';
            s += a[i][3];
            s += ' ';
            s += a[i][4];

            if (a[i][5] != null) {
              s += ' ';
              s += a[i][5];
              s += ' ';
              s += a[i][6];

              if (a[i][7] != null) {
                s += ' ';
                s += a[i][7];
              }
            }
          }
        }
      }
    }

    return s + ' '
  }

  class PathArray extends SVGArray {
    // Get bounding box of path
    bbox() {
      parser().path.setAttribute('d', this.toString());
      return new Box(parser.nodes.path.getBBox())
    }

    // Move path string
    move(x, y) {
      // get bounding box of current situation
      const box = this.bbox();

      // get relative offset
      x -= box.x;
      y -= box.y;

      if (!isNaN(x) && !isNaN(y)) {
        // move every point
        for (let l, i = this.length - 1; i >= 0; i--) {
          l = this[i][0];

          if (l === 'M' || l === 'L' || l === 'T') {
            this[i][1] += x;
            this[i][2] += y;
          } else if (l === 'H') {
            this[i][1] += x;
          } else if (l === 'V') {
            this[i][1] += y;
          } else if (l === 'C' || l === 'S' || l === 'Q') {
            this[i][1] += x;
            this[i][2] += y;
            this[i][3] += x;
            this[i][4] += y;

            if (l === 'C') {
              this[i][5] += x;
              this[i][6] += y;
            }
          } else if (l === 'A') {
            this[i][6] += x;
            this[i][7] += y;
          }
        }
      }

      return this
    }

    // Absolutize and parse path to array
    parse(d = 'M0 0') {
      if (Array.isArray(d)) {
        d = Array.prototype.concat.apply([], d).toString();
      }

      return pathParser(d)
    }

    // Resize path string
    size(width, height) {
      // get bounding box of current situation
      const box = this.bbox();
      let i, l;

      // If the box width or height is 0 then we ignore
      // transformations on the respective axis
      box.width = box.width === 0 ? 1 : box.width;
      box.height = box.height === 0 ? 1 : box.height;

      // recalculate position of all points according to new size
      for (i = this.length - 1; i >= 0; i--) {
        l = this[i][0];

        if (l === 'M' || l === 'L' || l === 'T') {
          this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x;
          this[i][2] = ((this[i][2] - box.y) * height) / box.height + box.y;
        } else if (l === 'H') {
          this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x;
        } else if (l === 'V') {
          this[i][1] = ((this[i][1] - box.y) * height) / box.height + box.y;
        } else if (l === 'C' || l === 'S' || l === 'Q') {
          this[i][1] = ((this[i][1] - box.x) * width) / box.width + box.x;
          this[i][2] = ((this[i][2] - box.y) * height) / box.height + box.y;
          this[i][3] = ((this[i][3] - box.x) * width) / box.width + box.x;
          this[i][4] = ((this[i][4] - box.y) * height) / box.height + box.y;

          if (l === 'C') {
            this[i][5] = ((this[i][5] - box.x) * width) / box.width + box.x;
            this[i][6] = ((this[i][6] - box.y) * height) / box.height + box.y;
          }
        } else if (l === 'A') {
          // resize radii
          this[i][1] = (this[i][1] * width) / box.width;
          this[i][2] = (this[i][2] * height) / box.height;

          // move position values
          this[i][6] = ((this[i][6] - box.x) * width) / box.width + box.x;
          this[i][7] = ((this[i][7] - box.y) * height) / box.height + box.y;
        }
      }

      return this
    }

    // Convert array to string
    toString() {
      return arrayToString(this)
    }
  }

  const getClassForType = (value) => {
    const type = typeof value;

    if (type === 'number') {
      return SVGNumber
    } else if (type === 'string') {
      if (Color.isColor(value)) {
        return Color
      } else if (delimiter.test(value)) {
        return isPathLetter.test(value) ? PathArray : SVGArray
      } else if (numberAndUnit.test(value)) {
        return SVGNumber
      } else {
        return NonMorphable
      }
    } else if (morphableTypes.indexOf(value.constructor) > -1) {
      return value.constructor
    } else if (Array.isArray(value)) {
      return SVGArray
    } else if (type === 'object') {
      return ObjectBag
    } else {
      return NonMorphable
    }
  };

  class Morphable {
    constructor(stepper) {
      this._stepper = stepper || new Ease('-');

      this._from = null;
      this._to = null;
      this._type = null;
      this._context = null;
      this._morphObj = null;
    }

    at(pos) {
      return this._morphObj.morph(
        this._from,
        this._to,
        pos,
        this._stepper,
        this._context
      )
    }

    done() {
      const complete = this._context.map(this._stepper.done).reduce(function (
        last,
        curr
      ) {
        return last && curr
      }, true);
      return complete
    }

    from(val) {
      if (val == null) {
        return this._from
      }

      this._from = this._set(val);
      return this
    }

    stepper(stepper) {
      if (stepper == null) return this._stepper
      this._stepper = stepper;
      return this
    }

    to(val) {
      if (val == null) {
        return this._to
      }

      this._to = this._set(val);
      return this
    }

    type(type) {
      // getter
      if (type == null) {
        return this._type
      }

      // setter
      this._type = type;
      return this
    }

    _set(value) {
      if (!this._type) {
        this.type(getClassForType(value));
      }

      let result = new this._type(value);
      if (this._type === Color) {
        result = this._to
          ? result[this._to[4]]()
          : this._from
            ? result[this._from[4]]()
            : result;
      }

      if (this._type === ObjectBag) {
        result = this._to
          ? result.align(this._to)
          : this._from
            ? result.align(this._from)
            : result;
      }

      result = result.toConsumable();

      this._morphObj = this._morphObj || new this._type();
      this._context =
        this._context ||
        Array.apply(null, Array(result.length))
          .map(Object)
          .map(function (o) {
            o.done = true;
            return o
          });
      return result
    }
  }

  class NonMorphable {
    constructor(...args) {
      this.init(...args);
    }

    init(val) {
      val = Array.isArray(val) ? val[0] : val;
      this.value = val;
      return this
    }

    toArray() {
      return [this.value]
    }

    valueOf() {
      return this.value
    }
  }

  class TransformBag {
    constructor(...args) {
      this.init(...args);
    }

    init(obj) {
      if (Array.isArray(obj)) {
        obj = {
          scaleX: obj[0],
          scaleY: obj[1],
          shear: obj[2],
          rotate: obj[3],
          translateX: obj[4],
          translateY: obj[5],
          originX: obj[6],
          originY: obj[7]
        };
      }

      Object.assign(this, TransformBag.defaults, obj);
      return this
    }

    toArray() {
      const v = this;

      return [
        v.scaleX,
        v.scaleY,
        v.shear,
        v.rotate,
        v.translateX,
        v.translateY,
        v.originX,
        v.originY
      ]
    }
  }

  TransformBag.defaults = {
    scaleX: 1,
    scaleY: 1,
    shear: 0,
    rotate: 0,
    translateX: 0,
    translateY: 0,
    originX: 0,
    originY: 0
  };

  const sortByKey = (a, b) => {
    return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0
  };

  class ObjectBag {
    constructor(...args) {
      this.init(...args);
    }

    align(other) {
      const values = this.values;
      for (let i = 0, il = values.length; i < il; ++i) {
        // If the type is the same we only need to check if the color is in the correct format
        if (values[i + 1] === other[i + 1]) {
          if (values[i + 1] === Color && other[i + 7] !== values[i + 7]) {
            const space = other[i + 7];
            const color = new Color(this.values.splice(i + 3, 5))
              [space]()
              .toArray();
            this.values.splice(i + 3, 0, ...color);
          }

          i += values[i + 2] + 2;
          continue
        }

        if (!other[i + 1]) {
          return this
        }

        // The types differ, so we overwrite the new type with the old one
        // And initialize it with the types default (e.g. black for color or 0 for number)
        const defaultObject = new other[i + 1]().toArray();

        // Than we fix the values array
        const toDelete = values[i + 2] + 3;

        values.splice(
          i,
          toDelete,
          other[i],
          other[i + 1],
          other[i + 2],
          ...defaultObject
        );

        i += values[i + 2] + 2;
      }
      return this
    }

    init(objOrArr) {
      this.values = [];

      if (Array.isArray(objOrArr)) {
        this.values = objOrArr.slice();
        return
      }

      objOrArr = objOrArr || {};
      const entries = [];

      for (const i in objOrArr) {
        const Type = getClassForType(objOrArr[i]);
        const val = new Type(objOrArr[i]).toArray();
        entries.push([i, Type, val.length, ...val]);
      }

      entries.sort(sortByKey);

      this.values = entries.reduce((last, curr) => last.concat(curr), []);
      return this
    }

    toArray() {
      return this.values
    }

    valueOf() {
      const obj = {};
      const arr = this.values;

      // for (var i = 0, len = arr.length; i < len; i += 2) {
      while (arr.length) {
        const key = arr.shift();
        const Type = arr.shift();
        const num = arr.shift();
        const values = arr.splice(0, num);
        obj[key] = new Type(values); // .valueOf()
      }

      return obj
    }
  }

  const morphableTypes = [NonMorphable, TransformBag, ObjectBag];

  function registerMorphableType(type = []) {
    morphableTypes.push(...[].concat(type));
  }

  function makeMorphable() {
    extend(morphableTypes, {
      to(val) {
        return new Morphable()
          .type(this.constructor)
          .from(this.toArray()) // this.valueOf())
          .to(val)
      },
      fromArray(arr) {
        this.init(arr);
        return this
      },
      toConsumable() {
        return this.toArray()
      },
      morph(from, to, pos, stepper, context) {
        const mapper = function (i, index) {
          return stepper.step(i, to[index], pos, context[index], context)
        };

        return this.fromArray(from.map(mapper))
      }
    });
  }

  class Path extends Shape {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('path', node), attrs);
    }

    // Get array
    array() {
      return this._array || (this._array = new PathArray(this.attr('d')))
    }

    // Clear array cache
    clear() {
      delete this._array;
      return this
    }

    // Set height of element
    height(height) {
      return height == null
        ? this.bbox().height
        : this.size(this.bbox().width, height)
    }

    // Move by left top corner
    move(x, y) {
      return this.attr('d', this.array().move(x, y))
    }

    // Plot new path
    plot(d) {
      return d == null
        ? this.array()
        : this.clear().attr(
            'd',
            typeof d === 'string' ? d : (this._array = new PathArray(d))
          )
    }

    // Set element size to given width and height
    size(width, height) {
      const p = proportionalSize(this, width, height);
      return this.attr('d', this.array().size(p.width, p.height))
    }

    // Set width of element
    width(width) {
      return width == null
        ? this.bbox().width
        : this.size(width, this.bbox().height)
    }

    // Move by left top corner over x-axis
    x(x) {
      return x == null ? this.bbox().x : this.move(x, this.bbox().y)
    }

    // Move by left top corner over y-axis
    y(y) {
      return y == null ? this.bbox().y : this.move(this.bbox().x, y)
    }
  }

  // Define morphable array
  Path.prototype.MorphArray = PathArray;

  // Add parent method
  registerMethods({
    Container: {
      // Create a wrapped path element
      path: wrapWithAttrCheck(function (d) {
        // make sure plot is called as a setter
        return this.put(new Path()).plot(d || new PathArray())
      })
    }
  });

  register(Path, 'Path');

  // Get array
  function array() {
    return this._array || (this._array = new PointArray(this.attr('points')))
  }

  // Clear array cache
  function clear() {
    delete this._array;
    return this
  }

  // Move by left top corner
  function move$2(x, y) {
    return this.attr('points', this.array().move(x, y))
  }

  // Plot new path
  function plot(p) {
    return p == null
      ? this.array()
      : this.clear().attr(
          'points',
          typeof p === 'string' ? p : (this._array = new PointArray(p))
        )
  }

  // Set element size to given width and height
  function size$1(width, height) {
    const p = proportionalSize(this, width, height);
    return this.attr('points', this.array().size(p.width, p.height))
  }

  var poly = /*#__PURE__*/Object.freeze({
    __proto__: null,
    array: array,
    clear: clear,
    move: move$2,
    plot: plot,
    size: size$1
  });

  class Polygon extends Shape {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('polygon', node), attrs);
    }
  }

  registerMethods({
    Container: {
      // Create a wrapped polygon element
      polygon: wrapWithAttrCheck(function (p) {
        // make sure plot is called as a setter
        return this.put(new Polygon()).plot(p || new PointArray())
      })
    }
  });

  extend(Polygon, pointed);
  extend(Polygon, poly);
  register(Polygon, 'Polygon');

  class Polyline extends Shape {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('polyline', node), attrs);
    }
  }

  registerMethods({
    Container: {
      // Create a wrapped polygon element
      polyline: wrapWithAttrCheck(function (p) {
        // make sure plot is called as a setter
        return this.put(new Polyline()).plot(p || new PointArray())
      })
    }
  });

  extend(Polyline, pointed);
  extend(Polyline, poly);
  register(Polyline, 'Polyline');

  class Rect extends Shape {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('rect', node), attrs);
    }
  }

  extend(Rect, { rx, ry });

  registerMethods({
    Container: {
      // Create a rect element
      rect: wrapWithAttrCheck(function (width, height) {
        return this.put(new Rect()).size(width, height)
      })
    }
  });

  register(Rect, 'Rect');

  class Queue {
    constructor() {
      this._first = null;
      this._last = null;
    }

    // Shows us the first item in the list
    first() {
      return this._first && this._first.value
    }

    // Shows us the last item in the list
    last() {
      return this._last && this._last.value
    }

    push(value) {
      // An item stores an id and the provided value
      const item =
        typeof value.next !== 'undefined'
          ? value
          : { value: value, next: null, prev: null };

      // Deal with the queue being empty or populated
      if (this._last) {
        item.prev = this._last;
        this._last.next = item;
        this._last = item;
      } else {
        this._last = item;
        this._first = item;
      }

      // Return the current item
      return item
    }

    // Removes the item that was returned from the push
    remove(item) {
      // Relink the previous item
      if (item.prev) item.prev.next = item.next;
      if (item.next) item.next.prev = item.prev;
      if (item === this._last) this._last = item.prev;
      if (item === this._first) this._first = item.next;

      // Invalidate item
      item.prev = null;
      item.next = null;
    }

    shift() {
      // Check if we have a value
      const remove = this._first;
      if (!remove) return null

      // If we do, remove it and relink things
      this._first = remove.next;
      if (this._first) this._first.prev = null;
      this._last = this._first ? this._last : null;
      return remove.value
    }
  }

  const Animator = {
    nextDraw: null,
    frames: new Queue(),
    timeouts: new Queue(),
    immediates: new Queue(),
    timer: () => globals.window.performance || globals.window.Date,
    transforms: [],

    frame(fn) {
      // Store the node
      const node = Animator.frames.push({ run: fn });

      // Request an animation frame if we don't have one
      if (Animator.nextDraw === null) {
        Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
      }

      // Return the node so we can remove it easily
      return node
    },

    timeout(fn, delay) {
      delay = delay || 0;

      // Work out when the event should fire
      const time = Animator.timer().now() + delay;

      // Add the timeout to the end of the queue
      const node = Animator.timeouts.push({ run: fn, time: time });

      // Request another animation frame if we need one
      if (Animator.nextDraw === null) {
        Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
      }

      return node
    },

    immediate(fn) {
      // Add the immediate fn to the end of the queue
      const node = Animator.immediates.push(fn);
      // Request another animation frame if we need one
      if (Animator.nextDraw === null) {
        Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
      }

      return node
    },

    cancelFrame(node) {
      node != null && Animator.frames.remove(node);
    },

    clearTimeout(node) {
      node != null && Animator.timeouts.remove(node);
    },

    cancelImmediate(node) {
      node != null && Animator.immediates.remove(node);
    },

    _draw(now) {
      // Run all the timeouts we can run, if they are not ready yet, add them
      // to the end of the queue immediately! (bad timeouts!!! [sarcasm])
      let nextTimeout = null;
      const lastTimeout = Animator.timeouts.last();
      while ((nextTimeout = Animator.timeouts.shift())) {
        // Run the timeout if its time, or push it to the end
        if (now >= nextTimeout.time) {
          nextTimeout.run();
        } else {
          Animator.timeouts.push(nextTimeout);
        }

        // If we hit the last item, we should stop shifting out more items
        if (nextTimeout === lastTimeout) break
      }

      // Run all of the animation frames
      let nextFrame = null;
      const lastFrame = Animator.frames.last();
      while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {
        nextFrame.run(now);
      }

      let nextImmediate = null;
      while ((nextImmediate = Animator.immediates.shift())) {
        nextImmediate();
      }

      // If we have remaining timeouts or frames, draw until we don't anymore
      Animator.nextDraw =
        Animator.timeouts.first() || Animator.frames.first()
          ? globals.window.requestAnimationFrame(Animator._draw)
          : null;
    }
  };

  const makeSchedule = function (runnerInfo) {
    const start = runnerInfo.start;
    const duration = runnerInfo.runner.duration();
    const end = start + duration;
    return {
      start: start,
      duration: duration,
      end: end,
      runner: runnerInfo.runner
    }
  };

  const defaultSource = function () {
    const w = globals.window;
    return (w.performance || w.Date).now()
  };

  class Timeline extends EventTarget {
    // Construct a new timeline on the given element
    constructor(timeSource = defaultSource) {
      super();

      this._timeSource = timeSource;

      // terminate resets all variables to their initial state
      this.terminate();
    }

    active() {
      return !!this._nextFrame
    }

    finish() {
      // Go to end and pause
      this.time(this.getEndTimeOfTimeline() + 1);
      return this.pause()
    }

    // Calculates the end of the timeline
    getEndTime() {
      const lastRunnerInfo = this.getLastRunnerInfo();
      const lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;
      const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
      return lastStartTime + lastDuration
    }

    getEndTimeOfTimeline() {
      const endTimes = this._runners.map((i) => i.start + i.runner.duration());
      return Math.max(0, ...endTimes)
    }

    getLastRunnerInfo() {
      return this.getRunnerInfoById(this._lastRunnerId)
    }

    getRunnerInfoById(id) {
      return this._runners[this._runnerIds.indexOf(id)] || null
    }

    pause() {
      this._paused = true;
      return this._continue()
    }

    persist(dtOrForever) {
      if (dtOrForever == null) return this._persist
      this._persist = dtOrForever;
      return this
    }

    play() {
      // Now make sure we are not paused and continue the animation
      this._paused = false;
      return this.updateTime()._continue()
    }

    reverse(yes) {
      const currentSpeed = this.speed();
      if (yes == null) return this.speed(-currentSpeed)

      const positive = Math.abs(currentSpeed);
      return this.speed(yes ? -positive : positive)
    }

    // schedules a runner on the timeline
    schedule(runner, delay, when) {
      if (runner == null) {
        return this._runners.map(makeSchedule)
      }

      // The start time for the next animation can either be given explicitly,
      // derived from the current timeline time or it can be relative to the
      // last start time to chain animations directly

      let absoluteStartTime = 0;
      const endTime = this.getEndTime();
      delay = delay || 0;

      // Work out when to start the animation
      if (when == null || when === 'last' || when === 'after') {
        // Take the last time and increment
        absoluteStartTime = endTime;
      } else if (when === 'absolute' || when === 'start') {
        absoluteStartTime = delay;
        delay = 0;
      } else if (when === 'now') {
        absoluteStartTime = this._time;
      } else if (when === 'relative') {
        const runnerInfo = this.getRunnerInfoById(runner.id);
        if (runnerInfo) {
          absoluteStartTime = runnerInfo.start + delay;
          delay = 0;
        }
      } else if (when === 'with-last') {
        const lastRunnerInfo = this.getLastRunnerInfo();
        const lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : this._time;
        absoluteStartTime = lastStartTime;
      } else {
        throw new Error('Invalid value for the "when" parameter')
      }

      // Manage runner
      runner.unschedule();
      runner.timeline(this);

      const persist = runner.persist();
      const runnerInfo = {
        persist: persist === null ? this._persist : persist,
        start: absoluteStartTime + delay,
        runner
      };

      this._lastRunnerId = runner.id;

      this._runners.push(runnerInfo);
      this._runners.sort((a, b) => a.start - b.start);
      this._runnerIds = this._runners.map((info) => info.runner.id);

      this.updateTime()._continue();
      return this
    }

    seek(dt) {
      return this.time(this._time + dt)
    }

    source(fn) {
      if (fn == null) return this._timeSource
      this._timeSource = fn;
      return this
    }

    speed(speed) {
      if (speed == null) return this._speed
      this._speed = speed;
      return this
    }

    stop() {
      // Go to start and pause
      this.time(0);
      return this.pause()
    }

    time(time) {
      if (time == null) return this._time
      this._time = time;
      return this._continue(true)
    }

    // Remove the runner from this timeline
    unschedule(runner) {
      const index = this._runnerIds.indexOf(runner.id);
      if (index < 0) return this

      this._runners.splice(index, 1);
      this._runnerIds.splice(index, 1);

      runner.timeline(null);
      return this
    }

    // Makes sure, that after pausing the time doesn't jump
    updateTime() {
      if (!this.active()) {
        this._lastSourceTime = this._timeSource();
      }
      return this
    }

    // Checks if we are running and continues the animation
    _continue(immediateStep = false) {
      Animator.cancelFrame(this._nextFrame);
      this._nextFrame = null;

      if (immediateStep) return this._stepImmediate()
      if (this._paused) return this

      this._nextFrame = Animator.frame(this._step);
      return this
    }

    _stepFn(immediateStep = false) {
      // Get the time delta from the last time and update the time
      const time = this._timeSource();
      let dtSource = time - this._lastSourceTime;

      if (immediateStep) dtSource = 0;

      const dtTime = this._speed * dtSource + (this._time - this._lastStepTime);
      this._lastSourceTime = time;

      // Only update the time if we use the timeSource.
      // Otherwise use the current time
      if (!immediateStep) {
        // Update the time
        this._time += dtTime;
        this._time = this._time < 0 ? 0 : this._time;
      }
      this._lastStepTime = this._time;
      this.fire('time', this._time);

      // This is for the case that the timeline was seeked so that the time
      // is now before the startTime of the runner. That is why we need to set
      // the runner to position 0

      // FIXME:
      // However, resetting in insertion order leads to bugs. Considering the case,
      // where 2 runners change the same attribute but in different times,
      // resetting both of them will lead to the case where the later defined
      // runner always wins the reset even if the other runner started earlier
      // and therefore should win the attribute battle
      // this can be solved by resetting them backwards
      for (let k = this._runners.length; k--; ) {
        // Get and run the current runner and ignore it if its inactive
        const runnerInfo = this._runners[k];
        const runner = runnerInfo.runner;

        // Make sure that we give the actual difference
        // between runner start time and now
        const dtToStart = this._time - runnerInfo.start;

        // Dont run runner if not started yet
        // and try to reset it
        if (dtToStart <= 0) {
          runner.reset();
        }
      }

      // Run all of the runners directly
      let runnersLeft = false;
      for (let i = 0, len = this._runners.length; i < len; i++) {
        // Get and run the current runner and ignore it if its inactive
        const runnerInfo = this._runners[i];
        const runner = runnerInfo.runner;
        let dt = dtTime;

        // Make sure that we give the actual difference
        // between runner start time and now
        const dtToStart = this._time - runnerInfo.start;

        // Dont run runner if not started yet
        if (dtToStart <= 0) {
          runnersLeft = true;
          continue
        } else if (dtToStart < dt) {
          // Adjust dt to make sure that animation is on point
          dt = dtToStart;
        }

        if (!runner.active()) continue

        // If this runner is still going, signal that we need another animation
        // frame, otherwise, remove the completed runner
        const finished = runner.step(dt).done;
        if (!finished) {
          runnersLeft = true;
          // continue
        } else if (runnerInfo.persist !== true) {
          // runner is finished. And runner might get removed
          const endTime = runner.duration() - runner.time() + this._time;

          if (endTime + runnerInfo.persist < this._time) {
            // Delete runner and correct index
            runner.unschedule();
            --i;
            --len;
          }
        }
      }

      // Basically: we continue when there are runners right from us in time
      // when -->, and when runners are left from us when <--
      if (
        (runnersLeft && !(this._speed < 0 && this._time === 0)) ||
        (this._runnerIds.length && this._speed < 0 && this._time > 0)
      ) {
        this._continue();
      } else {
        this.pause();
        this.fire('finished');
      }

      return this
    }

    terminate() {
      // cleanup memory

      // Store the timing variables
      this._startTime = 0;
      this._speed = 1.0;

      // Determines how long a runner is hold in memory. Can be a dt or true/false
      this._persist = 0;

      // Keep track of the running animations and their starting parameters
      this._nextFrame = null;
      this._paused = true;
      this._runners = [];
      this._runnerIds = [];
      this._lastRunnerId = -1;
      this._time = 0;
      this._lastSourceTime = 0;
      this._lastStepTime = 0;

      // Make sure that step is always called in class context
      this._step = this._stepFn.bind(this, false);
      this._stepImmediate = this._stepFn.bind(this, true);
    }
  }

  registerMethods({
    Element: {
      timeline: function (timeline) {
        if (timeline == null) {
          this._timeline = this._timeline || new Timeline();
          return this._timeline
        } else {
          this._timeline = timeline;
          return this
        }
      }
    }
  });

  class Runner extends EventTarget {
    constructor(options) {
      super();

      // Store a unique id on the runner, so that we can identify it later
      this.id = Runner.id++;

      // Ensure a default value
      options = options == null ? timeline.duration : options;

      // Ensure that we get a controller
      options = typeof options === 'function' ? new Controller(options) : options;

      // Declare all of the variables
      this._element = null;
      this._timeline = null;
      this.done = false;
      this._queue = [];

      // Work out the stepper and the duration
      this._duration = typeof options === 'number' && options;
      this._isDeclarative = options instanceof Controller;
      this._stepper = this._isDeclarative ? options : new Ease();

      // We copy the current values from the timeline because they can change
      this._history = {};

      // Store the state of the runner
      this.enabled = true;
      this._time = 0;
      this._lastTime = 0;

      // At creation, the runner is in reset state
      this._reseted = true;

      // Save transforms applied to this runner
      this.transforms = new Matrix();
      this.transformId = 1;

      // Looping variables
      this._haveReversed = false;
      this._reverse = false;
      this._loopsDone = 0;
      this._swing = false;
      this._wait = 0;
      this._times = 1;

      this._frameId = null;

      // Stores how long a runner is stored after being done
      this._persist = this._isDeclarative ? true : null;
    }

    static sanitise(duration, delay, when) {
      // Initialise the default parameters
      let times = 1;
      let swing = false;
      let wait = 0;
      duration = duration ?? timeline.duration;
      delay = delay ?? timeline.delay;
      when = when || 'last';

      // If we have an object, unpack the values
      if (typeof duration === 'object' && !(duration instanceof Stepper)) {
        delay = duration.delay ?? delay;
        when = duration.when ?? when;
        swing = duration.swing || swing;
        times = duration.times ?? times;
        wait = duration.wait ?? wait;
        duration = duration.duration ?? timeline.duration;
      }

      return {
        duration: duration,
        delay: delay,
        swing: swing,
        times: times,
        wait: wait,
        when: when
      }
    }

    active(enabled) {
      if (enabled == null) return this.enabled
      this.enabled = enabled;
      return this
    }

    /*
    Private Methods
    ===============
    Methods that shouldn't be used externally
    */
    addTransform(transform) {
      this.transforms.lmultiplyO(transform);
      return this
    }

    after(fn) {
      return this.on('finished', fn)
    }

    animate(duration, delay, when) {
      const o = Runner.sanitise(duration, delay, when);
      const runner = new Runner(o.duration);
      if (this._timeline) runner.timeline(this._timeline);
      if (this._element) runner.element(this._element);
      return runner.loop(o).schedule(o.delay, o.when)
    }

    clearTransform() {
      this.transforms = new Matrix();
      return this
    }

    // TODO: Keep track of all transformations so that deletion is faster
    clearTransformsFromQueue() {
      if (
        !this.done ||
        !this._timeline ||
        !this._timeline._runnerIds.includes(this.id)
      ) {
        this._queue = this._queue.filter((item) => {
          return !item.isTransform
        });
      }
    }

    delay(delay) {
      return this.animate(0, delay)
    }

    duration() {
      return this._times * (this._wait + this._duration) - this._wait
    }

    during(fn) {
      return this.queue(null, fn)
    }

    ease(fn) {
      this._stepper = new Ease(fn);
      return this
    }
    /*
    Runner Definitions
    ==================
    These methods help us define the runtime behaviour of the Runner or they
    help us make new runners from the current runner
    */

    element(element) {
      if (element == null) return this._element
      this._element = element;
      element._prepareRunner();
      return this
    }

    finish() {
      return this.step(Infinity)
    }

    loop(times, swing, wait) {
      // Deal with the user passing in an object
      if (typeof times === 'object') {
        swing = times.swing;
        wait = times.wait;
        times = times.times;
      }

      // Sanitise the values and store them
      this._times = times || Infinity;
      this._swing = swing || false;
      this._wait = wait || 0;

      // Allow true to be passed
      if (this._times === true) {
        this._times = Infinity;
      }

      return this
    }

    loops(p) {
      const loopDuration = this._duration + this._wait;
      if (p == null) {
        const loopsDone = Math.floor(this._time / loopDuration);
        const relativeTime = this._time - loopsDone * loopDuration;
        const position = relativeTime / this._duration;
        return Math.min(loopsDone + position, this._times)
      }
      const whole = Math.floor(p);
      const partial = p % 1;
      const time = loopDuration * whole + this._duration * partial;
      return this.time(time)
    }

    persist(dtOrForever) {
      if (dtOrForever == null) return this._persist
      this._persist = dtOrForever;
      return this
    }

    position(p) {
      // Get all of the variables we need
      const x = this._time;
      const d = this._duration;
      const w = this._wait;
      const t = this._times;
      const s = this._swing;
      const r = this._reverse;
      let position;

      if (p == null) {
        /*
        This function converts a time to a position in the range [0, 1]
        The full explanation can be found in this desmos demonstration
          https://www.desmos.com/calculator/u4fbavgche
        The logic is slightly simplified here because we can use booleans
        */

        // Figure out the value without thinking about the start or end time
        const f = function (x) {
          const swinging = s * Math.floor((x % (2 * (w + d))) / (w + d));
          const backwards = (swinging && !r) || (!swinging && r);
          const uncliped =
            (Math.pow(-1, backwards) * (x % (w + d))) / d + backwards;
          const clipped = Math.max(Math.min(uncliped, 1), 0);
          return clipped
        };

        // Figure out the value by incorporating the start time
        const endTime = t * (w + d) - w;
        position =
          x <= 0
            ? Math.round(f(1e-5))
            : x < endTime
              ? f(x)
              : Math.round(f(endTime - 1e-5));
        return position
      }

      // Work out the loops done and add the position to the loops done
      const loopsDone = Math.floor(this.loops());
      const swingForward = s && loopsDone % 2 === 0;
      const forwards = (swingForward && !r) || (r && swingForward);
      position = loopsDone + (forwards ? p : 1 - p);
      return this.loops(position)
    }

    progress(p) {
      if (p == null) {
        return Math.min(1, this._time / this.duration())
      }
      return this.time(p * this.duration())
    }

    /*
    Basic Functionality
    ===================
    These methods allow us to attach basic functions to the runner directly
    */
    queue(initFn, runFn, retargetFn, isTransform) {
      this._queue.push({
        initialiser: initFn || noop,
        runner: runFn || noop,
        retarget: retargetFn,
        isTransform: isTransform,
        initialised: false,
        finished: false
      });
      const timeline = this.timeline();
      timeline && this.timeline()._continue();
      return this
    }

    reset() {
      if (this._reseted) return this
      this.time(0);
      this._reseted = true;
      return this
    }

    reverse(reverse) {
      this._reverse = reverse == null ? !this._reverse : reverse;
      return this
    }

    schedule(timeline, delay, when) {
      // The user doesn't need to pass a timeline if we already have one
      if (!(timeline instanceof Timeline)) {
        when = delay;
        delay = timeline;
        timeline = this.timeline();
      }

      // If there is no timeline, yell at the user...
      if (!timeline) {
        throw Error('Runner cannot be scheduled without timeline')
      }

      // Schedule the runner on the timeline provided
      timeline.schedule(this, delay, when);
      return this
    }

    step(dt) {
      // If we are inactive, this stepper just gets skipped
      if (!this.enabled) return this

      // Update the time and get the new position
      dt = dt == null ? 16 : dt;
      this._time += dt;
      const position = this.position();

      // Figure out if we need to run the stepper in this frame
      const running = this._lastPosition !== position && this._time >= 0;
      this._lastPosition = position;

      // Figure out if we just started
      const duration = this.duration();
      const justStarted = this._lastTime <= 0 && this._time > 0;
      const justFinished = this._lastTime < duration && this._time >= duration;

      this._lastTime = this._time;
      if (justStarted) {
        this.fire('start', this);
      }

      // Work out if the runner is finished set the done flag here so animations
      // know, that they are running in the last step (this is good for
      // transformations which can be merged)
      const declarative = this._isDeclarative;
      this.done = !declarative && !justFinished && this._time >= duration;

      // Runner is running. So its not in reset state anymore
      this._reseted = false;

      let converged = false;
      // Call initialise and the run function
      if (running || declarative) {
        this._initialise(running);

        // clear the transforms on this runner so they dont get added again and again
        this.transforms = new Matrix();
        converged = this._run(declarative ? dt : position);

        this.fire('step', this);
      }
      // correct the done flag here
      // declarative animations itself know when they converged
      this.done = this.done || (converged && declarative);
      if (justFinished) {
        this.fire('finished', this);
      }
      return this
    }

    /*
    Runner animation methods
    ========================
    Control how the animation plays
    */
    time(time) {
      if (time == null) {
        return this._time
      }
      const dt = time - this._time;
      this.step(dt);
      return this
    }

    timeline(timeline) {
      // check explicitly for undefined so we can set the timeline to null
      if (typeof timeline === 'undefined') return this._timeline
      this._timeline = timeline;
      return this
    }

    unschedule() {
      const timeline = this.timeline();
      timeline && timeline.unschedule(this);
      return this
    }

    // Run each initialise function in the runner if required
    _initialise(running) {
      // If we aren't running, we shouldn't initialise when not declarative
      if (!running && !this._isDeclarative) return

      // Loop through all of the initialisers
      for (let i = 0, len = this._queue.length; i < len; ++i) {
        // Get the current initialiser
        const current = this._queue[i];

        // Determine whether we need to initialise
        const needsIt = this._isDeclarative || (!current.initialised && running);
        running = !current.finished;

        // Call the initialiser if we need to
        if (needsIt && running) {
          current.initialiser.call(this);
          current.initialised = true;
        }
      }
    }

    // Save a morpher to the morpher list so that we can retarget it later
    _rememberMorpher(method, morpher) {
      this._history[method] = {
        morpher: morpher,
        caller: this._queue[this._queue.length - 1]
      };

      // We have to resume the timeline in case a controller
      // is already done without being ever run
      // This can happen when e.g. this is done:
      //    anim = el.animate(new SVG.Spring)
      // and later
      //    anim.move(...)
      if (this._isDeclarative) {
        const timeline = this.timeline();
        timeline && timeline.play();
      }
    }

    // Try to set the target for a morpher if the morpher exists, otherwise
    // Run each run function for the position or dt given
    _run(positionOrDt) {
      // Run all of the _queue directly
      let allfinished = true;
      for (let i = 0, len = this._queue.length; i < len; ++i) {
        // Get the current function to run
        const current = this._queue[i];

        // Run the function if its not finished, we keep track of the finished
        // flag for the sake of declarative _queue
        const converged = current.runner.call(this, positionOrDt);
        current.finished = current.finished || converged === true;
        allfinished = allfinished && current.finished;
      }

      // We report when all of the constructors are finished
      return allfinished
    }

    // do nothing and return false
    _tryRetarget(method, target, extra) {
      if (this._history[method]) {
        // if the last method wasn't even initialised, throw it away
        if (!this._history[method].caller.initialised) {
          const index = this._queue.indexOf(this._history[method].caller);
          this._queue.splice(index, 1);
          return false
        }

        // for the case of transformations, we use the special retarget function
        // which has access to the outer scope
        if (this._history[method].caller.retarget) {
          this._history[method].caller.retarget.call(this, target, extra);
          // for everything else a simple morpher change is sufficient
        } else {
          this._history[method].morpher.to(target);
        }

        this._history[method].caller.finished = false;
        const timeline = this.timeline();
        timeline && timeline.play();
        return true
      }
      return false
    }
  }

  Runner.id = 0;

  class FakeRunner {
    constructor(transforms = new Matrix(), id = -1, done = true) {
      this.transforms = transforms;
      this.id = id;
      this.done = done;
    }

    clearTransformsFromQueue() {}
  }

  extend([Runner, FakeRunner], {
    mergeWith(runner) {
      return new FakeRunner(
        runner.transforms.lmultiply(this.transforms),
        runner.id
      )
    }
  });

  // FakeRunner.emptyRunner = new FakeRunner()

  const lmultiply = (last, curr) => last.lmultiplyO(curr);
  const getRunnerTransform = (runner) => runner.transforms;

  function mergeTransforms() {
    // Find the matrix to apply to the element and apply it
    const runners = this._transformationRunners.runners;
    const netTransform = runners
      .map(getRunnerTransform)
      .reduce(lmultiply, new Matrix());

    this.transform(netTransform);

    this._transformationRunners.merge();

    if (this._transformationRunners.length() === 1) {
      this._frameId = null;
    }
  }

  class RunnerArray {
    constructor() {
      this.runners = [];
      this.ids = [];
    }

    add(runner) {
      if (this.runners.includes(runner)) return
      const id = runner.id + 1;

      this.runners.push(runner);
      this.ids.push(id);

      return this
    }

    clearBefore(id) {
      const deleteCnt = this.ids.indexOf(id + 1) || 1;
      this.ids.splice(0, deleteCnt, 0);
      this.runners
        .splice(0, deleteCnt, new FakeRunner())
        .forEach((r) => r.clearTransformsFromQueue());
      return this
    }

    edit(id, newRunner) {
      const index = this.ids.indexOf(id + 1);
      this.ids.splice(index, 1, id + 1);
      this.runners.splice(index, 1, newRunner);
      return this
    }

    getByID(id) {
      return this.runners[this.ids.indexOf(id + 1)]
    }

    length() {
      return this.ids.length
    }

    merge() {
      let lastRunner = null;
      for (let i = 0; i < this.runners.length; ++i) {
        const runner = this.runners[i];

        const condition =
          lastRunner &&
          runner.done &&
          lastRunner.done &&
          // don't merge runner when persisted on timeline
          (!runner._timeline ||
            !runner._timeline._runnerIds.includes(runner.id)) &&
          (!lastRunner._timeline ||
            !lastRunner._timeline._runnerIds.includes(lastRunner.id));

        if (condition) {
          // the +1 happens in the function
          this.remove(runner.id);
          const newRunner = runner.mergeWith(lastRunner);
          this.edit(lastRunner.id, newRunner);
          lastRunner = newRunner;
          --i;
        } else {
          lastRunner = runner;
        }
      }

      return this
    }

    remove(id) {
      const index = this.ids.indexOf(id + 1);
      this.ids.splice(index, 1);
      this.runners.splice(index, 1);
      return this
    }
  }

  registerMethods({
    Element: {
      animate(duration, delay, when) {
        const o = Runner.sanitise(duration, delay, when);
        const timeline = this.timeline();
        return new Runner(o.duration)
          .loop(o)
          .element(this)
          .timeline(timeline.play())
          .schedule(o.delay, o.when)
      },

      delay(by, when) {
        return this.animate(0, by, when)
      },

      // this function searches for all runners on the element and deletes the ones
      // which run before the current one. This is because absolute transformations
      // overwrite anything anyway so there is no need to waste time computing
      // other runners
      _clearTransformRunnersBefore(currentRunner) {
        this._transformationRunners.clearBefore(currentRunner.id);
      },

      _currentTransform(current) {
        return (
          this._transformationRunners.runners
            // we need the equal sign here to make sure, that also transformations
            // on the same runner which execute before the current transformation are
            // taken into account
            .filter((runner) => runner.id <= current.id)
            .map(getRunnerTransform)
            .reduce(lmultiply, new Matrix())
        )
      },

      _addRunner(runner) {
        this._transformationRunners.add(runner);

        // Make sure that the runner merge is executed at the very end of
        // all Animator functions. That is why we use immediate here to execute
        // the merge right after all frames are run
        Animator.cancelImmediate(this._frameId);
        this._frameId = Animator.immediate(mergeTransforms.bind(this));
      },

      _prepareRunner() {
        if (this._frameId == null) {
          this._transformationRunners = new RunnerArray().add(
            new FakeRunner(new Matrix(this))
          );
        }
      }
    }
  });

  // Will output the elements from array A that are not in the array B
  const difference = (a, b) => a.filter((x) => !b.includes(x));

  extend(Runner, {
    attr(a, v) {
      return this.styleAttr('attr', a, v)
    },

    // Add animatable styles
    css(s, v) {
      return this.styleAttr('css', s, v)
    },

    styleAttr(type, nameOrAttrs, val) {
      if (typeof nameOrAttrs === 'string') {
        return this.styleAttr(type, { [nameOrAttrs]: val })
      }

      let attrs = nameOrAttrs;
      if (this._tryRetarget(type, attrs)) return this

      let morpher = new Morphable(this._stepper).to(attrs);
      let keys = Object.keys(attrs);

      this.queue(
        function () {
          morpher = morpher.from(this.element()[type](keys));
        },
        function (pos) {
          this.element()[type](morpher.at(pos).valueOf());
          return morpher.done()
        },
        function (newToAttrs) {
          // Check if any new keys were added
          const newKeys = Object.keys(newToAttrs);
          const differences = difference(newKeys, keys);

          // If their are new keys, initialize them and add them to morpher
          if (differences.length) {
            // Get the values
            const addedFromAttrs = this.element()[type](differences);

            // Get the already initialized values
            const oldFromAttrs = new ObjectBag(morpher.from()).valueOf();

            // Merge old and new
            Object.assign(oldFromAttrs, addedFromAttrs);
            morpher.from(oldFromAttrs);
          }

          // Get the object from the morpher
          const oldToAttrs = new ObjectBag(morpher.to()).valueOf();

          // Merge in new attributes
          Object.assign(oldToAttrs, newToAttrs);

          // Change morpher target
          morpher.to(oldToAttrs);

          // Make sure that we save the work we did so we don't need it to do again
          keys = newKeys;
          attrs = newToAttrs;
        }
      );

      this._rememberMorpher(type, morpher);
      return this
    },

    zoom(level, point) {
      if (this._tryRetarget('zoom', level, point)) return this

      let morpher = new Morphable(this._stepper).to(new SVGNumber(level));

      this.queue(
        function () {
          morpher = morpher.from(this.element().zoom());
        },
        function (pos) {
          this.element().zoom(morpher.at(pos), point);
          return morpher.done()
        },
        function (newLevel, newPoint) {
          point = newPoint;
          morpher.to(newLevel);
        }
      );

      this._rememberMorpher('zoom', morpher);
      return this
    },

    /**
     ** absolute transformations
     **/

    //
    // M v -----|-----(D M v = F v)------|----->  T v
    //
    // 1. define the final state (T) and decompose it (once)
    //    t = [tx, ty, the, lam, sy, sx]
    // 2. on every frame: pull the current state of all previous transforms
    //    (M - m can change)
    //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]
    // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)
    //   - Note F(0) = M
    //   - Note F(1) = T
    // 4. Now you get the delta matrix as a result: D = F * inv(M)

    transform(transforms, relative, affine) {
      // If we have a declarative function, we should retarget it if possible
      relative = transforms.relative || relative;
      if (
        this._isDeclarative &&
        !relative &&
        this._tryRetarget('transform', transforms)
      ) {
        return this
      }

      // Parse the parameters
      const isMatrix = Matrix.isMatrixLike(transforms);
      affine =
        transforms.affine != null
          ? transforms.affine
          : affine != null
            ? affine
            : !isMatrix;

      // Create a morpher and set its type
      const morpher = new Morphable(this._stepper).type(
        affine ? TransformBag : Matrix
      );

      let origin;
      let element;
      let current;
      let currentAngle;
      let startTransform;

      function setup() {
        // make sure element and origin is defined
        element = element || this.element();
        origin = origin || getOrigin(transforms, element);

        startTransform = new Matrix(relative ? undefined : element);

        // add the runner to the element so it can merge transformations
        element._addRunner(this);

        // Deactivate all transforms that have run so far if we are absolute
        if (!relative) {
          element._clearTransformRunnersBefore(this);
        }
      }

      function run(pos) {
        // clear all other transforms before this in case something is saved
        // on this runner. We are absolute. We dont need these!
        if (!relative) this.clearTransform();

        const { x, y } = new Point(origin).transform(
          element._currentTransform(this)
        );

        let target = new Matrix({ ...transforms, origin: [x, y] });
        let start = this._isDeclarative && current ? current : startTransform;

        if (affine) {
          target = target.decompose(x, y);
          start = start.decompose(x, y);

          // Get the current and target angle as it was set
          const rTarget = target.rotate;
          const rCurrent = start.rotate;

          // Figure out the shortest path to rotate directly
          const possibilities = [rTarget - 360, rTarget, rTarget + 360];
          const distances = possibilities.map((a) => Math.abs(a - rCurrent));
          const shortest = Math.min(...distances);
          const index = distances.indexOf(shortest);
          target.rotate = possibilities[index];
        }

        if (relative) {
          // we have to be careful here not to overwrite the rotation
          // with the rotate method of Matrix
          if (!isMatrix) {
            target.rotate = transforms.rotate || 0;
          }
          if (this._isDeclarative && currentAngle) {
            start.rotate = currentAngle;
          }
        }

        morpher.from(start);
        morpher.to(target);

        const affineParameters = morpher.at(pos);
        currentAngle = affineParameters.rotate;
        current = new Matrix(affineParameters);

        this.addTransform(current);
        element._addRunner(this);
        return morpher.done()
      }

      function retarget(newTransforms) {
        // only get a new origin if it changed since the last call
        if (
          (newTransforms.origin || 'center').toString() !==
          (transforms.origin || 'center').toString()
        ) {
          origin = getOrigin(newTransforms, element);
        }

        // overwrite the old transformations with the new ones
        transforms = { ...newTransforms, origin };
      }

      this.queue(setup, run, retarget, true);
      this._isDeclarative && this._rememberMorpher('transform', morpher);
      return this
    },

    // Animatable x-axis
    x(x) {
      return this._queueNumber('x', x)
    },

    // Animatable y-axis
    y(y) {
      return this._queueNumber('y', y)
    },

    ax(x) {
      return this._queueNumber('ax', x)
    },

    ay(y) {
      return this._queueNumber('ay', y)
    },

    dx(x = 0) {
      return this._queueNumberDelta('x', x)
    },

    dy(y = 0) {
      return this._queueNumberDelta('y', y)
    },

    dmove(x, y) {
      return this.dx(x).dy(y)
    },

    _queueNumberDelta(method, to) {
      to = new SVGNumber(to);

      // Try to change the target if we have this method already registered
      if (this._tryRetarget(method, to)) return this

      // Make a morpher and queue the animation
      const morpher = new Morphable(this._stepper).to(to);
      let from = null;
      this.queue(
        function () {
          from = this.element()[method]();
          morpher.from(from);
          morpher.to(from + to);
        },
        function (pos) {
          this.element()[method](morpher.at(pos));
          return morpher.done()
        },
        function (newTo) {
          morpher.to(from + new SVGNumber(newTo));
        }
      );

      // Register the morpher so that if it is changed again, we can retarget it
      this._rememberMorpher(method, morpher);
      return this
    },

    _queueObject(method, to) {
      // Try to change the target if we have this method already registered
      if (this._tryRetarget(method, to)) return this

      // Make a morpher and queue the animation
      const morpher = new Morphable(this._stepper).to(to);
      this.queue(
        function () {
          morpher.from(this.element()[method]());
        },
        function (pos) {
          this.element()[method](morpher.at(pos));
          return morpher.done()
        }
      );

      // Register the morpher so that if it is changed again, we can retarget it
      this._rememberMorpher(method, morpher);
      return this
    },

    _queueNumber(method, value) {
      return this._queueObject(method, new SVGNumber(value))
    },

    // Animatable center x-axis
    cx(x) {
      return this._queueNumber('cx', x)
    },

    // Animatable center y-axis
    cy(y) {
      return this._queueNumber('cy', y)
    },

    // Add animatable move
    move(x, y) {
      return this.x(x).y(y)
    },

    amove(x, y) {
      return this.ax(x).ay(y)
    },

    // Add animatable center
    center(x, y) {
      return this.cx(x).cy(y)
    },

    // Add animatable size
    size(width, height) {
      // animate bbox based size for all other elements
      let box;

      if (!width || !height) {
        box = this._element.bbox();
      }

      if (!width) {
        width = (box.width / box.height) * height;
      }

      if (!height) {
        height = (box.height / box.width) * width;
      }

      return this.width(width).height(height)
    },

    // Add animatable width
    width(width) {
      return this._queueNumber('width', width)
    },

    // Add animatable height
    height(height) {
      return this._queueNumber('height', height)
    },

    // Add animatable plot
    plot(a, b, c, d) {
      // Lines can be plotted with 4 arguments
      if (arguments.length === 4) {
        return this.plot([a, b, c, d])
      }

      if (this._tryRetarget('plot', a)) return this

      const morpher = new Morphable(this._stepper)
        .type(this._element.MorphArray)
        .to(a);

      this.queue(
        function () {
          morpher.from(this._element.array());
        },
        function (pos) {
          this._element.plot(morpher.at(pos));
          return morpher.done()
        }
      );

      this._rememberMorpher('plot', morpher);
      return this
    },

    // Add leading method
    leading(value) {
      return this._queueNumber('leading', value)
    },

    // Add animatable viewbox
    viewbox(x, y, width, height) {
      return this._queueObject('viewbox', new Box(x, y, width, height))
    },

    update(o) {
      if (typeof o !== 'object') {
        return this.update({
          offset: arguments[0],
          color: arguments[1],
          opacity: arguments[2]
        })
      }

      if (o.opacity != null) this.attr('stop-opacity', o.opacity);
      if (o.color != null) this.attr('stop-color', o.color);
      if (o.offset != null) this.attr('offset', o.offset);

      return this
    }
  });

  extend(Runner, { rx, ry, from, to });
  register(Runner, 'Runner');

  class Svg extends Container {
    constructor(node, attrs = node) {
      super(nodeOrNew('svg', node), attrs);
      this.namespace();
    }

    // Creates and returns defs element
    defs() {
      if (!this.isRoot()) return this.root().defs()

      return adopt(this.node.querySelector('defs')) || this.put(new Defs())
    }

    isRoot() {
      return (
        !this.node.parentNode ||
        (!(this.node.parentNode instanceof globals.window.SVGElement) &&
          this.node.parentNode.nodeName !== '#document-fragment')
      )
    }

    // Add namespaces
    namespace() {
      if (!this.isRoot()) return this.root().namespace()
      return this.attr({ xmlns: svg, version: '1.1' }).attr(
        'xmlns:xlink',
        xlink,
        xmlns
      )
    }

    removeNamespace() {
      return this.attr({ xmlns: null, version: null })
        .attr('xmlns:xlink', null, xmlns)
        .attr('xmlns:svgjs', null, xmlns)
    }

    // Check if this is a root svg
    // If not, call root() from this element
    root() {
      if (this.isRoot()) return this
      return super.root()
    }
  }

  registerMethods({
    Container: {
      // Create nested svg document
      nested: wrapWithAttrCheck(function () {
        return this.put(new Svg())
      })
    }
  });

  register(Svg, 'Svg', true);

  let Symbol$1 = class Symbol extends Container {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('symbol', node), attrs);
    }
  };

  registerMethods({
    Container: {
      symbol: wrapWithAttrCheck(function () {
        return this.put(new Symbol$1())
      })
    }
  });

  register(Symbol$1, 'Symbol');

  // Create plain text node
  function plain(text) {
    // clear if build mode is disabled
    if (this._build === false) {
      this.clear();
    }

    // create text node
    this.node.appendChild(globals.document.createTextNode(text));

    return this
  }

  // Get length of text element
  function length() {
    return this.node.getComputedTextLength()
  }

  // Move over x-axis
  // Text is moved by its bounding box
  // text-anchor does NOT matter
  function x$1(x, box = this.bbox()) {
    if (x == null) {
      return box.x
    }

    return this.attr('x', this.attr('x') + x - box.x)
  }

  // Move over y-axis
  function y$1(y, box = this.bbox()) {
    if (y == null) {
      return box.y
    }

    return this.attr('y', this.attr('y') + y - box.y)
  }

  function move$1(x, y, box = this.bbox()) {
    return this.x(x, box).y(y, box)
  }

  // Move center over x-axis
  function cx(x, box = this.bbox()) {
    if (x == null) {
      return box.cx
    }

    return this.attr('x', this.attr('x') + x - box.cx)
  }

  // Move center over y-axis
  function cy(y, box = this.bbox()) {
    if (y == null) {
      return box.cy
    }

    return this.attr('y', this.attr('y') + y - box.cy)
  }

  function center(x, y, box = this.bbox()) {
    return this.cx(x, box).cy(y, box)
  }

  function ax(x) {
    return this.attr('x', x)
  }

  function ay(y) {
    return this.attr('y', y)
  }

  function amove(x, y) {
    return this.ax(x).ay(y)
  }

  // Enable / disable build mode
  function build(build) {
    this._build = !!build;
    return this
  }

  var textable = /*#__PURE__*/Object.freeze({
    __proto__: null,
    amove: amove,
    ax: ax,
    ay: ay,
    build: build,
    center: center,
    cx: cx,
    cy: cy,
    length: length,
    move: move$1,
    plain: plain,
    x: x$1,
    y: y$1
  });

  class Text extends Shape {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('text', node), attrs);

      this.dom.leading = this.dom.leading ?? new SVGNumber(1.3); // store leading value for rebuilding
      this._rebuild = true; // enable automatic updating of dy values
      this._build = false; // disable build mode for adding multiple lines
    }

    // Set / get leading
    leading(value) {
      // act as getter
      if (value == null) {
        return this.dom.leading
      }

      // act as setter
      this.dom.leading = new SVGNumber(value);

      return this.rebuild()
    }

    // Rebuild appearance type
    rebuild(rebuild) {
      // store new rebuild flag if given
      if (typeof rebuild === 'boolean') {
        this._rebuild = rebuild;
      }

      // define position of all lines
      if (this._rebuild) {
        const self = this;
        let blankLineOffset = 0;
        const leading = this.dom.leading;

        this.each(function (i) {
          if (isDescriptive(this.node)) return

          const fontSize = globals.window
            .getComputedStyle(this.node)
            .getPropertyValue('font-size');

          const dy = leading * new SVGNumber(fontSize);

          if (this.dom.newLined) {
            this.attr('x', self.attr('x'));

            if (this.text() === '\n') {
              blankLineOffset += dy;
            } else {
              this.attr('dy', i ? dy + blankLineOffset : 0);
              blankLineOffset = 0;
            }
          }
        });

        this.fire('rebuild');
      }

      return this
    }

    // overwrite method from parent to set data properly
    setData(o) {
      this.dom = o;
      this.dom.leading = new SVGNumber(o.leading || 1.3);
      return this
    }

    writeDataToDom() {
      writeDataToDom(this, this.dom, { leading: 1.3 });
      return this
    }

    // Set the text content
    text(text) {
      // act as getter
      if (text === undefined) {
        const children = this.node.childNodes;
        let firstLine = 0;
        text = '';

        for (let i = 0, len = children.length; i < len; ++i) {
          // skip textPaths - they are no lines
          if (children[i].nodeName === 'textPath' || isDescriptive(children[i])) {
            if (i === 0) firstLine = i + 1;
            continue
          }

          // add newline if its not the first child and newLined is set to true
          if (
            i !== firstLine &&
            children[i].nodeType !== 3 &&
            adopt(children[i]).dom.newLined === true
          ) {
            text += '\n';
          }

          // add content of this node
          text += children[i].textContent;
        }

        return text
      }

      // remove existing content
      this.clear().build(true);

      if (typeof text === 'function') {
        // call block
        text.call(this, this);
      } else {
        // store text and make sure text is not blank
        text = (text + '').split('\n');

        // build new lines
        for (let j = 0, jl = text.length; j < jl; j++) {
          this.newLine(text[j]);
        }
      }

      // disable build mode and rebuild lines
      return this.build(false).rebuild()
    }
  }

  extend(Text, textable);

  registerMethods({
    Container: {
      // Create text element
      text: wrapWithAttrCheck(function (text = '') {
        return this.put(new Text()).text(text)
      }),

      // Create plain text element
      plain: wrapWithAttrCheck(function (text = '') {
        return this.put(new Text()).plain(text)
      })
    }
  });

  register(Text, 'Text');

  class Tspan extends Shape {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('tspan', node), attrs);
      this._build = false; // disable build mode for adding multiple lines
    }

    // Shortcut dx
    dx(dx) {
      return this.attr('dx', dx)
    }

    // Shortcut dy
    dy(dy) {
      return this.attr('dy', dy)
    }

    // Create new line
    newLine() {
      // mark new line
      this.dom.newLined = true;

      // fetch parent
      const text = this.parent();

      // early return in case we are not in a text element
      if (!(text instanceof Text)) {
        return this
      }

      const i = text.index(this);

      const fontSize = globals.window
        .getComputedStyle(this.node)
        .getPropertyValue('font-size');
      const dy = text.dom.leading * new SVGNumber(fontSize);

      // apply new position
      return this.dy(i ? dy : 0).attr('x', text.x())
    }

    // Set text content
    text(text) {
      if (text == null)
        return this.node.textContent + (this.dom.newLined ? '\n' : '')

      if (typeof text === 'function') {
        this.clear().build(true);
        text.call(this, this);
        this.build(false);
      } else {
        this.plain(text);
      }

      return this
    }
  }

  extend(Tspan, textable);

  registerMethods({
    Tspan: {
      tspan: wrapWithAttrCheck(function (text = '') {
        const tspan = new Tspan();

        // clear if build mode is disabled
        if (!this._build) {
          this.clear();
        }

        // add new tspan
        return this.put(tspan).text(text)
      })
    },
    Text: {
      newLine: function (text = '') {
        return this.tspan(text).newLine()
      }
    }
  });

  register(Tspan, 'Tspan');

  class Circle extends Shape {
    constructor(node, attrs = node) {
      super(nodeOrNew('circle', node), attrs);
    }

    radius(r) {
      return this.attr('r', r)
    }

    // Radius x value
    rx(rx) {
      return this.attr('r', rx)
    }

    // Alias radius x value
    ry(ry) {
      return this.rx(ry)
    }

    size(size) {
      return this.radius(new SVGNumber(size).divide(2))
    }
  }

  extend(Circle, { x: x$3, y: y$3, cx: cx$1, cy: cy$1, width: width$2, height: height$2 });

  registerMethods({
    Container: {
      // Create circle element
      circle: wrapWithAttrCheck(function (size = 0) {
        return this.put(new Circle()).size(size).move(0, 0)
      })
    }
  });

  register(Circle, 'Circle');

  class ClipPath extends Container {
    constructor(node, attrs = node) {
      super(nodeOrNew('clipPath', node), attrs);
    }

    // Unclip all clipped elements and remove itself
    remove() {
      // unclip all targets
      this.targets().forEach(function (el) {
        el.unclip();
      });

      // remove clipPath from parent
      return super.remove()
    }

    targets() {
      return baseFind('svg [clip-path*=' + this.id() + ']')
    }
  }

  registerMethods({
    Container: {
      // Create clipping element
      clip: wrapWithAttrCheck(function () {
        return this.defs().put(new ClipPath())
      })
    },
    Element: {
      // Distribute clipPath to svg element
      clipper() {
        return this.reference('clip-path')
      },

      clipWith(element) {
        // use given clip or create a new one
        const clipper =
          element instanceof ClipPath
            ? element
            : this.parent().clip().add(element);

        // apply mask
        return this.attr('clip-path', 'url(#' + clipper.id() + ')')
      },

      // Unclip element
      unclip() {
        return this.attr('clip-path', null)
      }
    }
  });

  register(ClipPath, 'ClipPath');

  class ForeignObject extends Element$1 {
    constructor(node, attrs = node) {
      super(nodeOrNew('foreignObject', node), attrs);
    }
  }

  registerMethods({
    Container: {
      foreignObject: wrapWithAttrCheck(function (width, height) {
        return this.put(new ForeignObject()).size(width, height)
      })
    }
  });

  register(ForeignObject, 'ForeignObject');

  function dmove(dx, dy) {
    this.children().forEach((child) => {
      let bbox;

      // We have to wrap this for elements that dont have a bbox
      // e.g. title and other descriptive elements
      try {
        // Get the childs bbox
        // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1905039
        // Because bbox for nested svgs returns the contents bbox in the coordinate space of the svg itself (weird!), we cant use bbox for svgs
        // Therefore we have to use getBoundingClientRect. But THAT is broken (as explained in the bug).
        // Funnily enough the broken behavior would work for us but that breaks it in chrome
        // So we have to replicate the broken behavior of FF by just reading the attributes of the svg itself
        bbox =
          child.node instanceof getWindow().SVGSVGElement
            ? new Box(child.attr(['x', 'y', 'width', 'height']))
            : child.bbox();
      } catch (e) {
        return
      }

      // Get childs matrix
      const m = new Matrix(child);
      // Translate childs matrix by amount and
      // transform it back into parents space
      const matrix = m.translate(dx, dy).transform(m.inverse());
      // Calculate new x and y from old box
      const p = new Point(bbox.x, bbox.y).transform(matrix);
      // Move element
      child.move(p.x, p.y);
    });

    return this
  }

  function dx(dx) {
    return this.dmove(dx, 0)
  }

  function dy(dy) {
    return this.dmove(0, dy)
  }

  function height(height, box = this.bbox()) {
    if (height == null) return box.height
    return this.size(box.width, height, box)
  }

  function move(x = 0, y = 0, box = this.bbox()) {
    const dx = x - box.x;
    const dy = y - box.y;

    return this.dmove(dx, dy)
  }

  function size(width, height, box = this.bbox()) {
    const p = proportionalSize(this, width, height, box);
    const scaleX = p.width / box.width;
    const scaleY = p.height / box.height;

    this.children().forEach((child) => {
      const o = new Point(box).transform(new Matrix(child).inverse());
      child.scale(scaleX, scaleY, o.x, o.y);
    });

    return this
  }

  function width(width, box = this.bbox()) {
    if (width == null) return box.width
    return this.size(width, box.height, box)
  }

  function x(x, box = this.bbox()) {
    if (x == null) return box.x
    return this.move(x, box.y, box)
  }

  function y(y, box = this.bbox()) {
    if (y == null) return box.y
    return this.move(box.x, y, box)
  }

  var containerGeometry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    dmove: dmove,
    dx: dx,
    dy: dy,
    height: height,
    move: move,
    size: size,
    width: width,
    x: x,
    y: y
  });

  class G extends Container {
    constructor(node, attrs = node) {
      super(nodeOrNew('g', node), attrs);
    }
  }

  extend(G, containerGeometry);

  registerMethods({
    Container: {
      // Create a group element
      group: wrapWithAttrCheck(function () {
        return this.put(new G())
      })
    }
  });

  register(G, 'G');

  class A extends Container {
    constructor(node, attrs = node) {
      super(nodeOrNew('a', node), attrs);
    }

    // Link target attribute
    target(target) {
      return this.attr('target', target)
    }

    // Link url
    to(url) {
      return this.attr('href', url, xlink)
    }
  }

  extend(A, containerGeometry);

  registerMethods({
    Container: {
      // Create a hyperlink element
      link: wrapWithAttrCheck(function (url) {
        return this.put(new A()).to(url)
      })
    },
    Element: {
      unlink() {
        const link = this.linker();

        if (!link) return this

        const parent = link.parent();

        if (!parent) {
          return this.remove()
        }

        const index = parent.index(link);
        parent.add(this, index);

        link.remove();
        return this
      },
      linkTo(url) {
        // reuse old link if possible
        let link = this.linker();

        if (!link) {
          link = new A();
          this.wrap(link);
        }

        if (typeof url === 'function') {
          url.call(link, link);
        } else {
          link.to(url);
        }

        return this
      },
      linker() {
        const link = this.parent();
        if (link && link.node.nodeName.toLowerCase() === 'a') {
          return link
        }

        return null
      }
    }
  });

  register(A, 'A');

  class Mask extends Container {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('mask', node), attrs);
    }

    // Unmask all masked elements and remove itself
    remove() {
      // unmask all targets
      this.targets().forEach(function (el) {
        el.unmask();
      });

      // remove mask from parent
      return super.remove()
    }

    targets() {
      return baseFind('svg [mask*=' + this.id() + ']')
    }
  }

  registerMethods({
    Container: {
      mask: wrapWithAttrCheck(function () {
        return this.defs().put(new Mask())
      })
    },
    Element: {
      // Distribute mask to svg element
      masker() {
        return this.reference('mask')
      },

      maskWith(element) {
        // use given mask or create a new one
        const masker =
          element instanceof Mask ? element : this.parent().mask().add(element);

        // apply mask
        return this.attr('mask', 'url(#' + masker.id() + ')')
      },

      // Unmask element
      unmask() {
        return this.attr('mask', null)
      }
    }
  });

  register(Mask, 'Mask');

  class Stop extends Element$1 {
    constructor(node, attrs = node) {
      super(nodeOrNew('stop', node), attrs);
    }

    // add color stops
    update(o) {
      if (typeof o === 'number' || o instanceof SVGNumber) {
        o = {
          offset: arguments[0],
          color: arguments[1],
          opacity: arguments[2]
        };
      }

      // set attributes
      if (o.opacity != null) this.attr('stop-opacity', o.opacity);
      if (o.color != null) this.attr('stop-color', o.color);
      if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));

      return this
    }
  }

  registerMethods({
    Gradient: {
      // Add a color stop
      stop: function (offset, color, opacity) {
        return this.put(new Stop()).update(offset, color, opacity)
      }
    }
  });

  register(Stop, 'Stop');

  function cssRule(selector, rule) {
    if (!selector) return ''
    if (!rule) return selector

    let ret = selector + '{';

    for (const i in rule) {
      ret += unCamelCase(i) + ':' + rule[i] + ';';
    }

    ret += '}';

    return ret
  }

  class Style extends Element$1 {
    constructor(node, attrs = node) {
      super(nodeOrNew('style', node), attrs);
    }

    addText(w = '') {
      this.node.textContent += w;
      return this
    }

    font(name, src, params = {}) {
      return this.rule('@font-face', {
        fontFamily: name,
        src: src,
        ...params
      })
    }

    rule(selector, obj) {
      return this.addText(cssRule(selector, obj))
    }
  }

  registerMethods('Dom', {
    style(selector, obj) {
      return this.put(new Style()).rule(selector, obj)
    },
    fontface(name, src, params) {
      return this.put(new Style()).font(name, src, params)
    }
  });

  register(Style, 'Style');

  class TextPath extends Text {
    // Initialize node
    constructor(node, attrs = node) {
      super(nodeOrNew('textPath', node), attrs);
    }

    // return the array of the path track element
    array() {
      const track = this.track();

      return track ? track.array() : null
    }

    // Plot path if any
    plot(d) {
      const track = this.track();
      let pathArray = null;

      if (track) {
        pathArray = track.plot(d);
      }

      return d == null ? pathArray : this
    }

    // Get the path element
    track() {
      return this.reference('href')
    }
  }

  registerMethods({
    Container: {
      textPath: wrapWithAttrCheck(function (text, path) {
        // Convert text to instance if needed
        if (!(text instanceof Text)) {
          text = this.text(text);
        }

        return text.path(path)
      })
    },
    Text: {
      // Create path for text to run on
      path: wrapWithAttrCheck(function (track, importNodes = true) {
        const textPath = new TextPath();

        // if track is a path, reuse it
        if (!(track instanceof Path)) {
          // create path element
          track = this.defs().path(track);
        }

        // link textPath to path and add content
        textPath.attr('href', '#' + track, xlink);

        // Transplant all nodes from text to textPath
        let node;
        if (importNodes) {
          while ((node = this.node.firstChild)) {
            textPath.node.appendChild(node);
          }
        }

        // add textPath element as child node and return textPath
        return this.put(textPath)
      }),

      // Get the textPath children
      textPath() {
        return this.findOne('textPath')
      }
    },
    Path: {
      // creates a textPath from this path
      text: wrapWithAttrCheck(function (text) {
        // Convert text to instance if needed
        if (!(text instanceof Text)) {
          text = new Text().addTo(this.parent()).text(text);
        }

        // Create textPath from text and path and return
        return text.path(this)
      }),

      targets() {
        return baseFind('svg textPath').filter((node) => {
          return (node.attr('href') || '').includes(this.id())
        })

        // Does not work in IE11. Use when IE support is dropped
        // return baseFind('svg textPath[*|href*=' + this.id() + ']')
      }
    }
  });

  TextPath.prototype.MorphArray = PathArray;
  register(TextPath, 'TextPath');

  class Use extends Shape {
    constructor(node, attrs = node) {
      super(nodeOrNew('use', node), attrs);
    }

    // Use element as a reference
    use(element, file) {
      // Set lined element
      return this.attr('href', (file || '') + '#' + element, xlink)
    }
  }

  registerMethods({
    Container: {
      // Create a use element
      use: wrapWithAttrCheck(function (element, file) {
        return this.put(new Use()).use(element, file)
      })
    }
  });

  register(Use, 'Use');

  /* Optional Modules */
  const SVG = makeInstance;

  extend([Svg, Symbol$1, Image$1, Pattern, Marker$1], getMethodsFor('viewbox'));

  extend([Line$1, Polyline, Polygon, Path], getMethodsFor('marker'));

  extend(Text, getMethodsFor('Text'));
  extend(Path, getMethodsFor('Path'));

  extend(Defs, getMethodsFor('Defs'));

  extend([Text, Tspan], getMethodsFor('Tspan'));

  extend([Rect, Ellipse, Gradient, Runner], getMethodsFor('radius'));

  extend(EventTarget, getMethodsFor('EventTarget'));
  extend(Dom, getMethodsFor('Dom'));
  extend(Element$1, getMethodsFor('Element'));
  extend(Shape, getMethodsFor('Shape'));
  extend([Container, Fragment], getMethodsFor('Container'));
  extend(Gradient, getMethodsFor('Gradient'));

  extend(Runner, getMethodsFor('Runner'));

  List.extend(getMethodNames());

  registerMorphableType([
    SVGNumber,
    Color,
    Box,
    Matrix,
    SVGArray,
    PointArray,
    PathArray,
    Point
  ]);

  makeMorphable();

  class Filter extends Element$1 {
    constructor (node) {
      super(nodeOrNew('filter', node), node);

      this.$source = 'SourceGraphic';
      this.$sourceAlpha = 'SourceAlpha';
      this.$background = 'BackgroundImage';
      this.$backgroundAlpha = 'BackgroundAlpha';
      this.$fill = 'FillPaint';
      this.$stroke = 'StrokePaint';
      this.$autoSetIn = true;
    }

    put (element, i) {
      element = super.put(element, i);

      if (!element.attr('in') && this.$autoSetIn) {
        element.attr('in', this.$source);
      }
      if (!element.attr('result')) {
        element.attr('result', element.id());
      }

      return element
    }

    // Unmask all masked elements and remove itself
    remove () {
      // unmask all targets
      this.targets().each('unfilter');

      // remove mask from parent
      return super.remove()
    }

    targets () {
      return baseFind('svg [filter*="' + this.id() + '"]')
    }

    toString () {
      return 'url(#' + this.id() + ')'
    }
  }

  // Create Effect class
  class Effect extends Element$1 {
    constructor (node, attr) {
      super(node, attr);
      this.result(this.id());
    }

    in (effect) {
      // Act as getter
      if (effect == null) {
        const _in = this.attr('in');
        const ref = this.parent() && this.parent().find(`[result="${_in}"]`)[0];
        return ref || _in
      }

      // Avr as setter
      return this.attr('in', effect)
    }

    // Named result
    result (result) {
      return this.attr('result', result)
    }

    // Stringification
    toString () {
      return this.result()
    }
  }

  // This function takes an array with attr keys and sets for every key the
  // attribute to the value of one paramater
  // getAttrSetter(['a', 'b']) becomes this.attr({a: param1, b: param2})
  const getAttrSetter = (params) => {
    return function (...args) {
      for (let i = params.length; i--;) {
        if (args[i] != null) {
          this.attr(params[i], args[i]);
        }
      }
    }
  };

  const updateFunctions = {
    blend: getAttrSetter(['in', 'in2', 'mode']),
    // ColorMatrix effect
    colorMatrix: getAttrSetter(['type', 'values']),
    // Composite effect
    composite: getAttrSetter(['in', 'in2', 'operator']),
    // ConvolveMatrix effect
    convolveMatrix: function (matrix) {
      matrix = new SVGArray(matrix).toString();

      this.attr({
        order: Math.sqrt(matrix.split(' ').length),
        kernelMatrix: matrix
      });
    },
    // DiffuseLighting effect
    diffuseLighting: getAttrSetter(['surfaceScale', 'lightingColor', 'diffuseConstant', 'kernelUnitLength']),
    // DisplacementMap effect
    displacementMap: getAttrSetter(['in', 'in2', 'scale', 'xChannelSelector', 'yChannelSelector']),
    // DropShadow effect
    dropShadow: getAttrSetter(['in', 'dx', 'dy', 'stdDeviation']),
    // Flood effect
    flood: getAttrSetter(['flood-color', 'flood-opacity']),
    // Gaussian Blur effect
    gaussianBlur: function (x = 0, y = x) {
      this.attr('stdDeviation', x + ' ' + y);
    },
    // Image effect
    image: function (src) {
      this.attr('href', src, xlink);
    },
    // Morphology effect
    morphology: getAttrSetter(['operator', 'radius']),
    // Offset effect
    offset: getAttrSetter(['dx', 'dy']),
    // SpecularLighting effect
    specularLighting: getAttrSetter(['surfaceScale', 'lightingColor', 'diffuseConstant', 'specularExponent', 'kernelUnitLength']),
    // Tile effect
    tile: getAttrSetter([]),
    // Turbulence effect
    turbulence: getAttrSetter(['baseFrequency', 'numOctaves', 'seed', 'stitchTiles', 'type'])
  };

  const filterNames = [
    'blend',
    'colorMatrix',
    'componentTransfer',
    'composite',
    'convolveMatrix',
    'diffuseLighting',
    'displacementMap',
    'dropShadow',
    'flood',
    'gaussianBlur',
    'image',
    'merge',
    'morphology',
    'offset',
    'specularLighting',
    'tile',
    'turbulence'
  ];

  // For every filter create a class
  filterNames.forEach((effect) => {
    const name = capitalize(effect);
    const fn = updateFunctions[effect];

    Filter[name + 'Effect'] = class extends Effect {
      constructor (node) {
        super(nodeOrNew('fe' + name, node), node);
      }

      // This function takes all parameters from the factory call
      // and updates the attributes according to the updateFunctions
      update (args) {
        fn.apply(this, args);
        return this
      }
    };

    // Add factory function to filter
    // Allow to pass a function or object
    // The attr object is catched from "wrapWithAttrCheck"
    Filter.prototype[effect] = wrapWithAttrCheck(function (fn, ...args) {
      const effect = new Filter[name + 'Effect']();

      if (fn == null) return this.put(effect)

      // For Effects which can take children, a function is allowed
      if (typeof fn === 'function') {
        fn.call(effect, effect);
      } else {
        // In case it is not a function, add it to arguments
        args.unshift(fn);
      }
      return this.put(effect).update(args)
    });
  });

  // Correct factories which are not that simple
  extend(Filter, {
    merge (arrayOrFn) {
      const node = this.put(new Filter.MergeEffect());

      // If a function was passed, execute it
      // That makes stuff like this possible:
      // filter.merge((mergeEffect) => mergeEffect.mergeNode(in))
      if (typeof arrayOrFn === 'function') {
        arrayOrFn.call(node, node);
        return node
      }

      // Check if first child is an array, otherwise use arguments as array
      const children = arrayOrFn instanceof Array ? arrayOrFn : [...arguments];

      children.forEach((child) => {
        if (child instanceof Filter.MergeNode) {
          node.put(child);
        } else {
          node.mergeNode(child);
        }
      });

      return node
    },
    componentTransfer (components = {}) {
      const node = this.put(new Filter.ComponentTransferEffect());

      if (typeof components === 'function') {
        components.call(node, node);
        return node
      }

      // If no component is set, we use the given object for all components
      if (!components.r && !components.g && !components.b && !components.a) {
        const temp = components;
        components = {
          r: temp, g: temp, b: temp, a: temp
        };
      }

      for (const c in components) {
        // components[c] has to hold an attributes object
        node.add(new Filter['Func' + c.toUpperCase()](components[c]));
      }

      return node
    }
  });

  const filterChildNodes = [
    'distantLight',
    'pointLight',
    'spotLight',
    'mergeNode',
    'FuncR',
    'FuncG',
    'FuncB',
    'FuncA'
  ];

  filterChildNodes.forEach((child) => {
    const name = capitalize(child);
    Filter[name] = class extends Effect {
      constructor (node) {
        super(nodeOrNew('fe' + name, node), node);
      }
    };
  });

  const componentFuncs = [
    'funcR',
    'funcG',
    'funcB',
    'funcA'
  ];

  // Add an update function for componentTransfer-children
  componentFuncs.forEach(function (c) {
    const _class = Filter[capitalize(c)];
    const fn = wrapWithAttrCheck(function () {
      return this.put(new _class())
    });

    Filter.ComponentTransferEffect.prototype[c] = fn;
  });

  const lights = [
    'distantLight',
    'pointLight',
    'spotLight'
  ];

  // Add light sources factories to lightining effects
  lights.forEach((light) => {
    const _class = Filter[capitalize(light)];
    const fn = wrapWithAttrCheck(function () {
      return this.put(new _class())
    });

    Filter.DiffuseLightingEffect.prototype[light] = fn;
    Filter.SpecularLightingEffect.prototype[light] = fn;
  });

  extend(Filter.MergeEffect, {
    mergeNode (_in) {
      return this.put(new Filter.MergeNode()).attr('in', _in)
    }
  });

  // add .filter function
  extend(Defs, {
    // Define filter
    filter: function (block) {
      const filter = this.put(new Filter());

      /* invoke passed block */
      if (typeof block === 'function') { block.call(filter, filter); }

      return filter
    }
  });

  extend(Container, {
    // Define filter on defs
    filter: function (block) {
      return this.defs().filter(block)
    }
  });

  extend(Element$1, {
    // Create filter element in defs and store reference
    filterWith: function (block) {
      const filter = block instanceof Filter
        ? block
        : this.defs().filter(block);

      return this.attr('filter', filter)
    },
    // Remove filter
    unfilter: function (remove) {
      /* remove filter attribute */
      return this.attr('filter', null)
    },
    filterer () {
      return this.reference('filter')
    }
  });

  // chaining
  const chainingEffects = {
    // Blend effect
    blend: function (in2, mode) {
      return this.parent() && this.parent().blend(this, in2, mode) // pass this as the first input
    },
    // ColorMatrix effect
    colorMatrix: function (type, values) {
      return this.parent() && this.parent().colorMatrix(type, values).in(this)
    },
    // ComponentTransfer effect
    componentTransfer: function (components) {
      return this.parent() && this.parent().componentTransfer(components).in(this)
    },
    // Composite effect
    composite: function (in2, operator) {
      return this.parent() && this.parent().composite(this, in2, operator) // pass this as the first input
    },
    // ConvolveMatrix effect
    convolveMatrix: function (matrix) {
      return this.parent() && this.parent().convolveMatrix(matrix).in(this)
    },
    // DiffuseLighting effect
    diffuseLighting: function (surfaceScale, lightingColor, diffuseConstant, kernelUnitLength) {
      return this.parent() && this.parent().diffuseLighting(surfaceScale, diffuseConstant, kernelUnitLength).in(this)
    },
    // DisplacementMap effect
    displacementMap: function (in2, scale, xChannelSelector, yChannelSelector) {
      return this.parent() && this.parent().displacementMap(this, in2, scale, xChannelSelector, yChannelSelector) // pass this as the first input
    },
    // DisplacementMap effect
    dropShadow: function (x, y, stdDeviation) {
      return this.parent() && this.parent().dropShadow(this, x, y, stdDeviation).in(this) // pass this as the first input
    },
    // Flood effect
    flood: function (color, opacity) {
      return this.parent() && this.parent().flood(color, opacity) // this effect dont have inputs
    },
    // Gaussian Blur effect
    gaussianBlur: function (x, y) {
      return this.parent() && this.parent().gaussianBlur(x, y).in(this)
    },
    // Image effect
    image: function (src) {
      return this.parent() && this.parent().image(src) // this effect dont have inputs
    },
    // Merge effect
    merge: function (arg) {
      arg = arg instanceof Array ? arg : [...arg];
      return this.parent() && this.parent().merge(this, ...arg) // pass this as the first argument
    },
    // Morphology effect
    morphology: function (operator, radius) {
      return this.parent() && this.parent().morphology(operator, radius).in(this)
    },
    // Offset effect
    offset: function (dx, dy) {
      return this.parent() && this.parent().offset(dx, dy).in(this)
    },
    // SpecularLighting effect
    specularLighting: function (surfaceScale, lightingColor, diffuseConstant, specularExponent, kernelUnitLength) {
      return this.parent() && this.parent().specularLighting(surfaceScale, diffuseConstant, specularExponent, kernelUnitLength).in(this)
    },
    // Tile effect
    tile: function () {
      return this.parent() && this.parent().tile().in(this)
    },
    // Turbulence effect
    turbulence: function (baseFrequency, numOctaves, seed, stitchTiles, type) {
      return this.parent() && this.parent().turbulence(baseFrequency, numOctaves, seed, stitchTiles, type).in(this)
    }
  };

  extend(Effect, chainingEffects);

  // Effect-specific extensions
  extend(Filter.MergeEffect, {
    in: function (effect) {
      if (effect instanceof Filter.MergeNode) {
        this.add(effect, 0);
      } else {
        this.add(new Filter.MergeNode().in(effect), 0);
      }

      return this
    }
  });

  extend([Filter.CompositeEffect, Filter.BlendEffect, Filter.DisplacementMapEffect], {
    in2: function (effect) {
      if (effect == null) {
        const in2 = this.attr('in2');
        const ref = this.parent() && this.parent().find(`[result="${in2}"]`)[0];
        return ref || in2
      }
      return this.attr('in2', effect)
    }
  });

  // Presets
  Filter.filter = {
    sepiatone: [
      0.343, 0.669, 0.119, 0, 0,
      0.249, 0.626, 0.130, 0, 0,
      0.172, 0.334, 0.111, 0, 0,
      0.000, 0.000, 0.000, 1, 0]
  };

  /**
   * ApexCharts Filters Class for setting hover/active states on the paths.
   *
   * @module Formatters
   **/
  var Filters = /*#__PURE__*/function () {
    function Filters(ctx) {
      _classCallCheck(this, Filters);
      this.ctx = ctx;
      this.w = ctx.w;
    }

    // create a re-usable filter which can be appended other filter effects and applied to multiple elements
    _createClass(Filters, [{
      key: "getDefaultFilter",
      value: function getDefaultFilter(el, i) {
        var w = this.w;
        el.unfilter(true);
        var filter = new Filter();
        filter.size('120%', '180%', '-5%', '-40%');
        if (w.config.chart.dropShadow.enabled) {
          this.dropShadow(el, w.config.chart.dropShadow, i);
        }
      }
    }, {
      key: "applyFilter",
      value: function applyFilter(el, i, filterType) {
        var _this = this,
          _el$filterer2;
        var w = this.w;
        el.unfilter(true);
        if (filterType === 'none') {
          this.getDefaultFilter(el, i);
          return;
        }
        var shadowAttr = w.config.chart.dropShadow;
        var brightnessFactor = filterType === 'lighten' ? 2 : 0.3;
        el.filterWith(function (add) {
          add.colorMatrix({
            type: 'matrix',
            values: "\n          ".concat(brightnessFactor, " 0 0 0 0\n          0 ").concat(brightnessFactor, " 0 0 0\n          0 0 ").concat(brightnessFactor, " 0 0\n          0 0 0 1 0\n        "),
            in: 'SourceGraphic',
            result: 'brightness'
          });
          if (shadowAttr.enabled) {
            _this.addShadow(add, i, shadowAttr, 'brightness');
          }
        });
        if (!shadowAttr.noUserSpaceOnUse) {
          var _el$filterer, _el$filterer$node;
          (_el$filterer = el.filterer()) === null || _el$filterer === void 0 ? void 0 : (_el$filterer$node = _el$filterer.node) === null || _el$filterer$node === void 0 ? void 0 : _el$filterer$node.setAttribute('filterUnits', 'userSpaceOnUse');
        }

        // this scales the filter to a bigger size so that the dropshadow doesn't crops
        this._scaleFilterSize((_el$filterer2 = el.filterer()) === null || _el$filterer2 === void 0 ? void 0 : _el$filterer2.node);
      }

      // appends dropShadow to the filter object which can be chained with other filter effects
    }, {
      key: "addShadow",
      value: function addShadow(add, i, attrs, source) {
        var _w$config$chart$dropS;
        var w = this.w;
        var blur = attrs.blur,
          top = attrs.top,
          left = attrs.left,
          color = attrs.color,
          opacity = attrs.opacity;
        color = Array.isArray(color) ? color[i] : color;
        if (((_w$config$chart$dropS = w.config.chart.dropShadow.enabledOnSeries) === null || _w$config$chart$dropS === void 0 ? void 0 : _w$config$chart$dropS.length) > 0) {
          if (w.config.chart.dropShadow.enabledOnSeries.indexOf(i) === -1) {
            return add;
          }
        }
        add.offset({
          in: source,
          dx: left,
          dy: top,
          result: 'offset'
        });
        add.gaussianBlur({
          in: 'offset',
          stdDeviation: blur,
          result: 'blur'
        });
        add.flood({
          'flood-color': color,
          'flood-opacity': opacity,
          result: 'flood'
        });
        add.composite({
          in: 'flood',
          in2: 'blur',
          operator: 'in',
          result: 'shadow'
        });
        add.merge(['shadow', source]);
      }

      // directly adds dropShadow to the element and returns the same element.
    }, {
      key: "dropShadow",
      value: function dropShadow(el, attrs) {
        var _w$config$chart$dropS2,
          _this2 = this,
          _el$filterer4;
        var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var w = this.w;
        el.unfilter(true);
        if (Utils$1.isMsEdge() && w.config.chart.type === 'radialBar') {
          // in radialbar charts, dropshadow is clipping actual drawing in IE
          return el;
        }
        if (((_w$config$chart$dropS2 = w.config.chart.dropShadow.enabledOnSeries) === null || _w$config$chart$dropS2 === void 0 ? void 0 : _w$config$chart$dropS2.length) > 0) {
          var _w$config$chart$dropS3;
          if (((_w$config$chart$dropS3 = w.config.chart.dropShadow.enabledOnSeries) === null || _w$config$chart$dropS3 === void 0 ? void 0 : _w$config$chart$dropS3.indexOf(i)) === -1) {
            return el;
          }
        }
        el.filterWith(function (add) {
          _this2.addShadow(add, i, attrs, 'SourceGraphic');
        });
        if (!attrs.noUserSpaceOnUse) {
          var _el$filterer3, _el$filterer3$node;
          (_el$filterer3 = el.filterer()) === null || _el$filterer3 === void 0 ? void 0 : (_el$filterer3$node = _el$filterer3.node) === null || _el$filterer3$node === void 0 ? void 0 : _el$filterer3$node.setAttribute('filterUnits', 'userSpaceOnUse');
        }

        // this scales the filter to a bigger size so that the dropshadow doesn't crops
        this._scaleFilterSize((_el$filterer4 = el.filterer()) === null || _el$filterer4 === void 0 ? void 0 : _el$filterer4.node);
        return el;
      }
    }, {
      key: "setSelectionFilter",
      value: function setSelectionFilter(el, realIndex, dataPointIndex) {
        var w = this.w;
        if (typeof w.globals.selectedDataPoints[realIndex] !== 'undefined') {
          if (w.globals.selectedDataPoints[realIndex].indexOf(dataPointIndex) > -1) {
            el.node.setAttribute('selected', true);
            var activeFilter = w.config.states.active.filter;
            if (activeFilter !== 'none') {
              this.applyFilter(el, realIndex, activeFilter.type);
            }
          }
        }
      }
    }, {
      key: "_scaleFilterSize",
      value: function _scaleFilterSize(el) {
        if (!el) return;
        var setAttributes = function setAttributes(attrs) {
          for (var key in attrs) {
            if (attrs.hasOwnProperty(key)) {
              el.setAttribute(key, attrs[key]);
            }
          }
        };
        setAttributes({
          width: '200%',
          height: '200%',
          x: '-50%',
          y: '-50%'
        });
      }
    }]);
    return Filters;
  }();

  /**
   * ApexCharts Graphics Class for all drawing operations.
   *
   * @module Graphics
   **/
  var Graphics = /*#__PURE__*/function () {
    function Graphics(ctx) {
      _classCallCheck(this, Graphics);
      this.ctx = ctx;
      this.w = ctx.w;
    }

    /*****************************************************************************
     *                                                                            *
     *  SVG Path Rounding Function                                                *
     *  Copyright (C) 2014 Yona Appletree                                         *
     *                                                                            *
     *  Licensed under the Apache License, Version 2.0 (the "License");           *
     *  you may not use this file except in compliance with the License.          *
     *  You may obtain a copy of the License at                                   *
     *                                                                            *
     *      http://www.apache.org/licenses/LICENSE-2.0                            *
     *                                                                            *
     *  Unless required by applicable law or agreed to in writing, software       *
     *  distributed under the License is distributed on an "AS IS" BASIS,         *
     *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *
     *  See the License for the specific language governing permissions and       *
     *  limitations under the License.                                            *
     *                                                                            *
     *****************************************************************************/

    /**
     * SVG Path rounding function. Takes an input path string and outputs a path
     * string where all line-line corners have been rounded. Only supports absolute
     * commands at the moment.
     *
     * @param pathString The SVG input path
     * @param radius The amount to round the corners, either a value in the SVG
     *               coordinate space, or, if useFractionalRadius is true, a value
     *               from 0 to 1.
     * @returns A new SVG path string with the rounding
     */
    _createClass(Graphics, [{
      key: "roundPathCorners",
      value: function roundPathCorners(pathString, radius) {
        if (pathString.indexOf('NaN') > -1) pathString = '';
        function moveTowardsLength(movingPoint, targetPoint, amount) {
          var width = targetPoint.x - movingPoint.x;
          var height = targetPoint.y - movingPoint.y;
          var distance = Math.sqrt(width * width + height * height);
          return moveTowardsFractional(movingPoint, targetPoint, Math.min(1, amount / distance));
        }
        function moveTowardsFractional(movingPoint, targetPoint, fraction) {
          return {
            x: movingPoint.x + (targetPoint.x - movingPoint.x) * fraction,
            y: movingPoint.y + (targetPoint.y - movingPoint.y) * fraction
          };
        }

        // Adjusts the ending position of a command
        function adjustCommand(cmd, newPoint) {
          if (cmd.length > 2) {
            cmd[cmd.length - 2] = newPoint.x;
            cmd[cmd.length - 1] = newPoint.y;
          }
        }

        // Gives an {x, y} object for a command's ending position
        function pointForCommand(cmd) {
          return {
            x: parseFloat(cmd[cmd.length - 2]),
            y: parseFloat(cmd[cmd.length - 1])
          };
        }

        // Split apart the path, handing concatonated letters and numbers
        var pathParts = pathString.split(/[,\s]/).reduce(function (parts, part) {
          var match = part.match(/^([a-zA-Z])(.+)/);
          if (match) {
            parts.push(match[1]);
            parts.push(match[2]);
          } else {
            parts.push(part);
          }
          return parts;
        }, []);

        // Group the commands with their arguments for easier handling
        var commands = pathParts.reduce(function (commands, part) {
          if (parseFloat(part) == part && commands.length) {
            commands[commands.length - 1].push(part);
          } else {
            commands.push([part]);
          }
          return commands;
        }, []);

        // The resulting commands, also grouped
        var resultCommands = [];
        if (commands.length > 1) {
          var startPoint = pointForCommand(commands[0]);

          // Handle the close path case with a "virtual" closing line
          var virtualCloseLine = null;
          if (commands[commands.length - 1][0] == 'Z' && commands[0].length > 2) {
            virtualCloseLine = ['L', startPoint.x, startPoint.y];
            commands[commands.length - 1] = virtualCloseLine;
          }

          // We always use the first command (but it may be mutated)
          resultCommands.push(commands[0]);
          for (var cmdIndex = 1; cmdIndex < commands.length; cmdIndex++) {
            var prevCmd = resultCommands[resultCommands.length - 1];
            var curCmd = commands[cmdIndex];

            // Handle closing case
            var nextCmd = curCmd == virtualCloseLine ? commands[1] : commands[cmdIndex + 1];

            // Nasty logic to decide if this path is a candidite.
            if (nextCmd && prevCmd && prevCmd.length > 2 && curCmd[0] == 'L' && nextCmd.length > 2 && nextCmd[0] == 'L') {
              // Calc the points we're dealing with
              var prevPoint = pointForCommand(prevCmd);
              var curPoint = pointForCommand(curCmd);
              var nextPoint = pointForCommand(nextCmd);

              // The start and end of the cuve are just our point moved towards the previous and next points, respectivly
              var curveStart, curveEnd;
              curveStart = moveTowardsLength(curPoint, prevPoint, radius);
              curveEnd = moveTowardsLength(curPoint, nextPoint, radius);

              // Adjust the current command and add it
              adjustCommand(curCmd, curveStart);
              curCmd.origPoint = curPoint;
              resultCommands.push(curCmd);

              // The curve control points are halfway between the start/end of the curve and
              // the original point
              var startControl = moveTowardsFractional(curveStart, curPoint, 0.5);
              var endControl = moveTowardsFractional(curPoint, curveEnd, 0.5);

              // Create the curve
              var curveCmd = ['C', startControl.x, startControl.y, endControl.x, endControl.y, curveEnd.x, curveEnd.y];
              // Save the original point for fractional calculations
              curveCmd.origPoint = curPoint;
              resultCommands.push(curveCmd);
            } else {
              // Pass through commands that don't qualify
              resultCommands.push(curCmd);
            }
          }

          // Fix up the starting point and restore the close path if the path was orignally closed
          if (virtualCloseLine) {
            var newStartPoint = pointForCommand(resultCommands[resultCommands.length - 1]);
            resultCommands.push(['Z']);
            adjustCommand(resultCommands[0], newStartPoint);
          }
        } else {
          resultCommands = commands;
        }
        return resultCommands.reduce(function (str, c) {
          return str + c.join(' ') + ' ';
        }, '');
      }
    }, {
      key: "drawLine",
      value: function drawLine(x1, y1, x2, y2) {
        var lineColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '#a8a8a8';
        var dashArray = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        var strokeWidth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
        var strokeLineCap = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'butt';
        var w = this.w;
        var line = w.globals.dom.Paper.line().attr({
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          stroke: lineColor,
          'stroke-dasharray': dashArray,
          'stroke-width': strokeWidth,
          'stroke-linecap': strokeLineCap
        });
        return line;
      }
    }, {
      key: "drawRect",
      value: function drawRect() {
        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '#fefefe';
        var opacity = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
        var strokeWidth = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
        var strokeColor = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
        var strokeDashArray = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
        var w = this.w;
        var rect = w.globals.dom.Paper.rect();
        rect.attr({
          x: x1,
          y: y1,
          width: x2 > 0 ? x2 : 0,
          height: y2 > 0 ? y2 : 0,
          rx: radius,
          ry: radius,
          opacity: opacity,
          'stroke-width': strokeWidth !== null ? strokeWidth : 0,
          stroke: strokeColor !== null ? strokeColor : 'none',
          'stroke-dasharray': strokeDashArray
        });

        // fix apexcharts.js#1410
        rect.node.setAttribute('fill', color);
        return rect;
      }
    }, {
      key: "drawPolygon",
      value: function drawPolygon(polygonString) {
        var stroke = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#e1e1e1';
        var strokeWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        var fill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';
        var w = this.w;
        var polygon = w.globals.dom.Paper.polygon(polygonString).attr({
          fill: fill,
          stroke: stroke,
          'stroke-width': strokeWidth
        });
        return polygon;
      }
    }, {
      key: "drawCircle",
      value: function drawCircle(radius) {
        var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var w = this.w;
        if (radius < 0) radius = 0;
        var c = w.globals.dom.Paper.circle(radius * 2);
        if (attrs !== null) {
          c.attr(attrs);
        }
        return c;
      }
    }, {
      key: "drawPath",
      value: function drawPath(_ref) {
        var _ref$d = _ref.d,
          d = _ref$d === void 0 ? '' : _ref$d,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? '#a8a8a8' : _ref$stroke,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth,
          fill = _ref.fill,
          _ref$fillOpacity = _ref.fillOpacity,
          fillOpacity = _ref$fillOpacity === void 0 ? 1 : _ref$fillOpacity,
          _ref$strokeOpacity = _ref.strokeOpacity,
          strokeOpacity = _ref$strokeOpacity === void 0 ? 1 : _ref$strokeOpacity,
          classes = _ref.classes,
          _ref$strokeLinecap = _ref.strokeLinecap,
          strokeLinecap = _ref$strokeLinecap === void 0 ? null : _ref$strokeLinecap,
          _ref$strokeDashArray = _ref.strokeDashArray,
          strokeDashArray = _ref$strokeDashArray === void 0 ? 0 : _ref$strokeDashArray;
        var w = this.w;
        if (strokeLinecap === null) {
          strokeLinecap = w.config.stroke.lineCap;
        }
        if (d.indexOf('undefined') > -1 || d.indexOf('NaN') > -1) {
          d = "M 0 ".concat(w.globals.gridHeight);
        }
        var p = w.globals.dom.Paper.path(d).attr({
          fill: fill,
          'fill-opacity': fillOpacity,
          stroke: stroke,
          'stroke-opacity': strokeOpacity,
          'stroke-linecap': strokeLinecap,
          'stroke-width': strokeWidth,
          'stroke-dasharray': strokeDashArray,
          class: classes
        });
        return p;
      }
    }, {
      key: "group",
      value: function group() {
        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var w = this.w;
        var g = w.globals.dom.Paper.group();
        if (attrs !== null) {
          g.attr(attrs);
        }
        return g;
      }
    }, {
      key: "move",
      value: function move(x, y) {
        var move = ['M', x, y].join(' ');
        return move;
      }
    }, {
      key: "line",
      value: function line(x, y) {
        var hORv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var line = null;
        if (hORv === null) {
          line = [' L', x, y].join(' ');
        } else if (hORv === 'H') {
          line = [' H', x].join(' ');
        } else if (hORv === 'V') {
          line = [' V', y].join(' ');
        }
        return line;
      }
    }, {
      key: "curve",
      value: function curve(x1, y1, x2, y2, x, y) {
        var curve = ['C', x1, y1, x2, y2, x, y].join(' ');
        return curve;
      }
    }, {
      key: "quadraticCurve",
      value: function quadraticCurve(x1, y1, x, y) {
        var curve = ['Q', x1, y1, x, y].join(' ');
        return curve;
      }
    }, {
      key: "arc",
      value: function arc(rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y) {
        var relative = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
        var coord = 'A';
        if (relative) coord = 'a';
        var arc = [coord, rx, ry, axisRotation, largeArcFlag, sweepFlag, x, y].join(' ');
        return arc;
      }

      /**
       * @memberof Graphics
       * @param {object}
       *  i = series's index
       *  realIndex = realIndex is series's actual index when it was drawn time. After several redraws, the iterating "i" may change in loops, but realIndex doesn't
       *  pathFrom = existing pathFrom to animateTo
       *  pathTo = new Path to which d attr will be animated from pathFrom to pathTo
       *  stroke = line Color
       *  strokeWidth = width of path Line
       *  fill = it can be gradient, single color, pattern or image
       *  animationDelay = how much to delay when starting animation (in milliseconds)
       *  dataChangeSpeed = for dynamic animations, when data changes
       *  className = class attribute to add
       * @return {object} svg.js path object
       **/
    }, {
      key: "renderPaths",
      value: function renderPaths(_ref2) {
        var j = _ref2.j,
          realIndex = _ref2.realIndex,
          pathFrom = _ref2.pathFrom,
          pathTo = _ref2.pathTo,
          stroke = _ref2.stroke,
          strokeWidth = _ref2.strokeWidth,
          strokeLinecap = _ref2.strokeLinecap,
          fill = _ref2.fill,
          animationDelay = _ref2.animationDelay,
          initialSpeed = _ref2.initialSpeed,
          dataChangeSpeed = _ref2.dataChangeSpeed,
          className = _ref2.className,
          chartType = _ref2.chartType,
          _ref2$shouldClipToGri = _ref2.shouldClipToGrid,
          shouldClipToGrid = _ref2$shouldClipToGri === void 0 ? true : _ref2$shouldClipToGri,
          _ref2$bindEventsOnPat = _ref2.bindEventsOnPaths,
          bindEventsOnPaths = _ref2$bindEventsOnPat === void 0 ? true : _ref2$bindEventsOnPat,
          _ref2$drawShadow = _ref2.drawShadow,
          drawShadow = _ref2$drawShadow === void 0 ? true : _ref2$drawShadow;
        var w = this.w;
        var filters = new Filters(this.ctx);
        var anim = new Animations(this.ctx);
        var initialAnim = this.w.config.chart.animations.enabled;
        var dynamicAnim = initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;

        // Fix for paths starting with M 0 0
        if (pathFrom && pathFrom.startsWith('M 0 0') && pathTo) {
          var moveCommand = pathTo.match(/^M\s+[\d.-]+\s+[\d.-]+/);
          if (moveCommand) {
            pathFrom = pathFrom.replace(/^M\s+0\s+0/, moveCommand[0]);
          }
        }
        var d;
        var shouldAnimate = !!(initialAnim && !w.globals.resized || dynamicAnim && w.globals.dataChanged && w.globals.shouldAnimate);
        if (shouldAnimate) {
          d = pathFrom;
        } else {
          d = pathTo;
          w.globals.animationEnded = true;
        }
        var strokeDashArrayOpt = w.config.stroke.dashArray;
        var strokeDashArray = 0;
        if (Array.isArray(strokeDashArrayOpt)) {
          strokeDashArray = strokeDashArrayOpt[realIndex];
        } else {
          strokeDashArray = w.config.stroke.dashArray;
        }
        var el = this.drawPath({
          d: d,
          stroke: stroke,
          strokeWidth: strokeWidth,
          fill: fill,
          fillOpacity: 1,
          classes: className,
          strokeLinecap: strokeLinecap,
          strokeDashArray: strokeDashArray
        });
        el.attr('index', realIndex);
        if (shouldClipToGrid) {
          if (chartType === 'bar' && !w.globals.isHorizontal || w.globals.comboCharts) {
            el.attr({
              'clip-path': "url(#gridRectBarMask".concat(w.globals.cuid, ")")
            });
          } else {
            el.attr({
              'clip-path': "url(#gridRectMask".concat(w.globals.cuid, ")")
            });
          }
        }
        if (w.config.chart.dropShadow.enabled && drawShadow) {
          filters.dropShadow(el, w.config.chart.dropShadow, realIndex);
        }
        if (bindEventsOnPaths) {
          el.node.addEventListener('mouseenter', this.pathMouseEnter.bind(this, el));
          el.node.addEventListener('mouseleave', this.pathMouseLeave.bind(this, el));
          el.node.addEventListener('mousedown', this.pathMouseDown.bind(this, el));
        }
        el.attr({
          pathTo: pathTo,
          pathFrom: pathFrom
        });
        var defaultAnimateOpts = {
          el: el,
          j: j,
          realIndex: realIndex,
          pathFrom: pathFrom,
          pathTo: pathTo,
          fill: fill,
          strokeWidth: strokeWidth,
          delay: animationDelay
        };
        if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {
          anim.animatePathsGradually(_objectSpread2(_objectSpread2({}, defaultAnimateOpts), {}, {
            speed: initialSpeed
          }));
        } else {
          if (w.globals.resized || !w.globals.dataChanged) {
            anim.showDelayedElements();
          }
        }
        if (w.globals.dataChanged && dynamicAnim && shouldAnimate) {
          anim.animatePathsGradually(_objectSpread2(_objectSpread2({}, defaultAnimateOpts), {}, {
            speed: dataChangeSpeed
          }));
        }
        return el;
      }
    }, {
      key: "drawPattern",
      value: function drawPattern(style, width, height) {
        var stroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '#a8a8a8';
        var strokeWidth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var w = this.w;
        var p = w.globals.dom.Paper.pattern(width, height, function (add) {
          if (style === 'horizontalLines') {
            add.line(0, 0, height, 0).stroke({
              color: stroke,
              width: strokeWidth + 1
            });
          } else if (style === 'verticalLines') {
            add.line(0, 0, 0, width).stroke({
              color: stroke,
              width: strokeWidth + 1
            });
          } else if (style === 'slantedLines') {
            add.line(0, 0, width, height).stroke({
              color: stroke,
              width: strokeWidth
            });
          } else if (style === 'squares') {
            add.rect(width, height).fill('none').stroke({
              color: stroke,
              width: strokeWidth
            });
          } else if (style === 'circles') {
            add.circle(width).fill('none').stroke({
              color: stroke,
              width: strokeWidth
            });
          }
        });
        return p;
      }
    }, {
      key: "drawGradient",
      value: function drawGradient(style, gfrom, gto, opacityFrom, opacityTo) {
        var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
        var stops = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
        var colorStops = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];
        var i = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
        var w = this.w;
        var g;
        if (gfrom.length < 9 && gfrom.indexOf('#') === 0) {
          // if the hex contains alpha and is of 9 digit, skip the opacity
          gfrom = Utils$1.hexToRgba(gfrom, opacityFrom);
        }
        if (gto.length < 9 && gto.indexOf('#') === 0) {
          gto = Utils$1.hexToRgba(gto, opacityTo);
        }
        var stop1 = 0;
        var stop2 = 1;
        var stop3 = 1;
        var stop4 = null;
        if (stops !== null) {
          stop1 = typeof stops[0] !== 'undefined' ? stops[0] / 100 : 0;
          stop2 = typeof stops[1] !== 'undefined' ? stops[1] / 100 : 1;
          stop3 = typeof stops[2] !== 'undefined' ? stops[2] / 100 : 1;
          stop4 = typeof stops[3] !== 'undefined' ? stops[3] / 100 : null;
        }
        var radial = !!(w.config.chart.type === 'donut' || w.config.chart.type === 'pie' || w.config.chart.type === 'polarArea' || w.config.chart.type === 'bubble');
        if (!colorStops || colorStops.length === 0) {
          g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (add) {
            add.stop(stop1, gfrom, opacityFrom);
            add.stop(stop2, gto, opacityTo);
            add.stop(stop3, gto, opacityTo);
            if (stop4 !== null) {
              add.stop(stop4, gfrom, opacityFrom);
            }
          });
        } else {
          g = w.globals.dom.Paper.gradient(radial ? 'radial' : 'linear', function (add) {
            var gradientStops = Array.isArray(colorStops[i]) ? colorStops[i] : colorStops;
            gradientStops.forEach(function (s) {
              add.stop(s.offset / 100, s.color, s.opacity);
            });
          });
        }
        if (!radial) {
          if (style === 'vertical') {
            g.from(0, 0).to(0, 1);
          } else if (style === 'diagonal') {
            g.from(0, 0).to(1, 1);
          } else if (style === 'horizontal') {
            g.from(0, 1).to(1, 1);
          } else if (style === 'diagonal2') {
            g.from(1, 0).to(0, 1);
          }
        } else {
          var offx = w.globals.gridWidth / 2;
          var offy = w.globals.gridHeight / 2;
          if (w.config.chart.type !== 'bubble') {
            g.attr({
              gradientUnits: 'userSpaceOnUse',
              cx: offx,
              cy: offy,
              r: size
            });
          } else {
            g.attr({
              cx: 0.5,
              cy: 0.5,
              r: 0.8,
              fx: 0.2,
              fy: 0.2
            });
          }
        }
        return g;
      }
    }, {
      key: "getTextBasedOnMaxWidth",
      value: function getTextBasedOnMaxWidth(_ref3) {
        var text = _ref3.text,
          maxWidth = _ref3.maxWidth,
          fontSize = _ref3.fontSize,
          fontFamily = _ref3.fontFamily;
        var tRects = this.getTextRects(text, fontSize, fontFamily);
        var wordWidth = tRects.width / text.length;
        var wordsBasedOnWidth = Math.floor(maxWidth / wordWidth);
        if (maxWidth < tRects.width) {
          return text.slice(0, wordsBasedOnWidth - 3) + '...';
        }
        return text;
      }
    }, {
      key: "drawText",
      value: function drawText(_ref4) {
        var _this = this;
        var x = _ref4.x,
          y = _ref4.y,
          text = _ref4.text,
          textAnchor = _ref4.textAnchor,
          fontSize = _ref4.fontSize,
          fontFamily = _ref4.fontFamily,
          fontWeight = _ref4.fontWeight,
          foreColor = _ref4.foreColor,
          opacity = _ref4.opacity,
          maxWidth = _ref4.maxWidth,
          _ref4$cssClass = _ref4.cssClass,
          cssClass = _ref4$cssClass === void 0 ? '' : _ref4$cssClass,
          _ref4$isPlainText = _ref4.isPlainText,
          isPlainText = _ref4$isPlainText === void 0 ? true : _ref4$isPlainText,
          _ref4$dominantBaselin = _ref4.dominantBaseline,
          dominantBaseline = _ref4$dominantBaselin === void 0 ? 'auto' : _ref4$dominantBaselin;
        var w = this.w;
        if (typeof text === 'undefined') text = '';
        var truncatedText = text;
        if (!textAnchor) {
          textAnchor = 'start';
        }
        if (!foreColor || !foreColor.length) {
          foreColor = w.config.chart.foreColor;
        }
        fontFamily = fontFamily || w.config.chart.fontFamily;
        fontSize = fontSize || '11px';
        fontWeight = fontWeight || 'regular';
        var commonProps = {
          maxWidth: maxWidth,
          fontSize: fontSize,
          fontFamily: fontFamily
        };
        var elText;
        if (Array.isArray(text)) {
          elText = w.globals.dom.Paper.text(function (add) {
            for (var i = 0; i < text.length; i++) {
              truncatedText = text[i];
              if (maxWidth) {
                truncatedText = _this.getTextBasedOnMaxWidth(_objectSpread2({
                  text: text[i]
                }, commonProps));
              }
              i === 0 ? add.tspan(truncatedText) : add.tspan(truncatedText).newLine();
            }
          });
        } else {
          if (maxWidth) {
            truncatedText = this.getTextBasedOnMaxWidth(_objectSpread2({
              text: text
            }, commonProps));
          }
          elText = isPlainText ? w.globals.dom.Paper.plain(text) : w.globals.dom.Paper.text(function (add) {
            return add.tspan(truncatedText);
          });
        }
        elText.attr({
          x: x,
          y: y,
          'text-anchor': textAnchor,
          'dominant-baseline': dominantBaseline,
          'font-size': fontSize,
          'font-family': fontFamily,
          'font-weight': fontWeight,
          fill: foreColor,
          class: 'apexcharts-text ' + cssClass
        });
        elText.node.style.fontFamily = fontFamily;
        elText.node.style.opacity = opacity;
        return elText;
      }
    }, {
      key: "getMarkerPath",
      value: function getMarkerPath(x, y, type, size) {
        var d = '';
        switch (type) {
          case 'cross':
            size = size / 1.4;
            d = "M ".concat(x - size, " ").concat(y - size, " L ").concat(x + size, " ").concat(y + size, "  M ").concat(x - size, " ").concat(y + size, " L ").concat(x + size, " ").concat(y - size);
            break;
          case 'plus':
            size = size / 1.12;
            d = "M ".concat(x - size, " ").concat(y, " L ").concat(x + size, " ").concat(y, "  M ").concat(x, " ").concat(y - size, " L ").concat(x, " ").concat(y + size);
            break;
          case 'star':
          case 'sparkle':
            var points = 5;
            size = size * 1.15;
            if (type === 'sparkle') {
              size = size / 1.1;
              points = 4;
            }
            var step = Math.PI / points;
            for (var i = 0; i <= 2 * points; i++) {
              var angle = i * step;
              var radius = i % 2 === 0 ? size : size / 2;
              var xPos = x + radius * Math.sin(angle);
              var yPos = y - radius * Math.cos(angle);
              d += (i === 0 ? 'M' : 'L') + xPos + ',' + yPos;
            }
            d += 'Z';
            break;
          case 'triangle':
            d = "M ".concat(x, " ").concat(y - size, " \n             L ").concat(x + size, " ").concat(y + size, " \n             L ").concat(x - size, " ").concat(y + size, " \n             Z");
            break;
          case 'square':
          case 'rect':
            size = size / 1.125;
            d = "M ".concat(x - size, " ").concat(y - size, " \n           L ").concat(x + size, " ").concat(y - size, " \n           L ").concat(x + size, " ").concat(y + size, " \n           L ").concat(x - size, " ").concat(y + size, " \n           Z");
            break;
          case 'diamond':
            size = size * 1.05;
            d = "M ".concat(x, " ").concat(y - size, " \n             L ").concat(x + size, " ").concat(y, " \n             L ").concat(x, " ").concat(y + size, " \n             L ").concat(x - size, " ").concat(y, " \n            Z");
            break;
          case 'line':
            size = size / 1.1;
            d = "M ".concat(x - size, " ").concat(y, " \n           L ").concat(x + size, " ").concat(y);
            break;
          case 'circle':
          default:
            size = size * 2;
            d = "M ".concat(x, ", ").concat(y, " \n           m -").concat(size / 2, ", 0 \n           a ").concat(size / 2, ",").concat(size / 2, " 0 1,0 ").concat(size, ",0 \n           a ").concat(size / 2, ",").concat(size / 2, " 0 1,0 -").concat(size, ",0");
            break;
        }
        return d;
      }

      /**
       * @param {number} x - The x-coordinate of the marker
       * @param {number} y - The y-coordinate of the marker.
       * @param {number} size - The size of the marker
       * @param {Object} opts - The options for the marker.
       * @returns {Object} The created marker.
       */
    }, {
      key: "drawMarkerShape",
      value: function drawMarkerShape(x, y, type, size, opts) {
        var path = this.drawPath({
          d: this.getMarkerPath(x, y, type, size, opts),
          stroke: opts.pointStrokeColor,
          strokeDashArray: opts.pointStrokeDashArray,
          strokeWidth: opts.pointStrokeWidth,
          fill: opts.pointFillColor,
          fillOpacity: opts.pointFillOpacity,
          strokeOpacity: opts.pointStrokeOpacity
        });
        path.attr({
          cx: x,
          cy: y,
          shape: opts.shape,
          class: opts.class ? opts.class : ''
        });
        return path;
      }
    }, {
      key: "drawMarker",
      value: function drawMarker(x, y, opts) {
        x = x || 0;
        var size = opts.pSize || 0;
        if (!Utils$1.isNumber(y)) {
          size = 0;
          y = 0;
        }
        return this.drawMarkerShape(x, y, opts === null || opts === void 0 ? void 0 : opts.shape, size, _objectSpread2(_objectSpread2({}, opts), opts.shape === 'line' || opts.shape === 'plus' || opts.shape === 'cross' ? {
          pointStrokeColor: opts.pointFillColor,
          pointStrokeOpacity: opts.pointFillOpacity
        } : {}));
      }
    }, {
      key: "pathMouseEnter",
      value: function pathMouseEnter(path, e) {
        var w = this.w;
        var filters = new Filters(this.ctx);
        var i = parseInt(path.node.getAttribute('index'), 10);
        var j = parseInt(path.node.getAttribute('j'), 10);
        if (typeof w.config.chart.events.dataPointMouseEnter === 'function') {
          w.config.chart.events.dataPointMouseEnter(e, this.ctx, {
            seriesIndex: i,
            dataPointIndex: j,
            w: w
          });
        }
        this.ctx.events.fireEvent('dataPointMouseEnter', [e, this.ctx, {
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        }]);
        if (w.config.states.active.filter.type !== 'none') {
          if (path.node.getAttribute('selected') === 'true') {
            return;
          }
        }
        if (w.config.states.hover.filter.type !== 'none') {
          if (!w.globals.isTouchDevice) {
            var hoverFilter = w.config.states.hover.filter;
            filters.applyFilter(path, i, hoverFilter.type);
          }
        }
      }
    }, {
      key: "pathMouseLeave",
      value: function pathMouseLeave(path, e) {
        var w = this.w;
        var filters = new Filters(this.ctx);
        var i = parseInt(path.node.getAttribute('index'), 10);
        var j = parseInt(path.node.getAttribute('j'), 10);
        if (typeof w.config.chart.events.dataPointMouseLeave === 'function') {
          w.config.chart.events.dataPointMouseLeave(e, this.ctx, {
            seriesIndex: i,
            dataPointIndex: j,
            w: w
          });
        }
        this.ctx.events.fireEvent('dataPointMouseLeave', [e, this.ctx, {
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        }]);
        if (w.config.states.active.filter.type !== 'none') {
          if (path.node.getAttribute('selected') === 'true') {
            return;
          }
        }
        if (w.config.states.hover.filter.type !== 'none') {
          filters.getDefaultFilter(path, i);
        }
      }
    }, {
      key: "pathMouseDown",
      value: function pathMouseDown(path, e) {
        var w = this.w;
        var filters = new Filters(this.ctx);
        var i = parseInt(path.node.getAttribute('index'), 10);
        var j = parseInt(path.node.getAttribute('j'), 10);
        var selected = 'false';
        if (path.node.getAttribute('selected') === 'true') {
          path.node.setAttribute('selected', 'false');
          if (w.globals.selectedDataPoints[i].indexOf(j) > -1) {
            var index = w.globals.selectedDataPoints[i].indexOf(j);
            w.globals.selectedDataPoints[i].splice(index, 1);
          }
        } else {
          if (!w.config.states.active.allowMultipleDataPointsSelection && w.globals.selectedDataPoints.length > 0) {
            w.globals.selectedDataPoints = [];
            var elPaths = w.globals.dom.Paper.find('.apexcharts-series path:not(.apexcharts-decoration-element)');
            var elCircles = w.globals.dom.Paper.find('.apexcharts-series circle:not(.apexcharts-decoration-element), .apexcharts-series rect:not(.apexcharts-decoration-element)');
            var deSelect = function deSelect(els) {
              Array.prototype.forEach.call(els, function (el) {
                el.node.setAttribute('selected', 'false');
                filters.getDefaultFilter(el, i);
              });
            };
            deSelect(elPaths);
            deSelect(elCircles);
          }
          path.node.setAttribute('selected', 'true');
          selected = 'true';
          if (typeof w.globals.selectedDataPoints[i] === 'undefined') {
            w.globals.selectedDataPoints[i] = [];
          }
          w.globals.selectedDataPoints[i].push(j);
        }
        if (selected === 'true') {
          var activeFilter = w.config.states.active.filter;
          if (activeFilter !== 'none') {
            filters.applyFilter(path, i, activeFilter.type);
          } else {
            // Reapply the hover filter in case it was removed by `deselect`when there is no active filter and it is not a touch device
            if (w.config.states.hover.filter !== 'none') {
              if (!w.globals.isTouchDevice) {
                var hoverFilter = w.config.states.hover.filter;
                filters.applyFilter(path, i, hoverFilter.type);
              }
            }
          }
        } else {
          // If the item was deselected, apply hover state filter if it is not a touch device
          if (w.config.states.active.filter.type !== 'none') {
            if (w.config.states.hover.filter.type !== 'none' && !w.globals.isTouchDevice) {
              var hoverFilter = w.config.states.hover.filter;
              filters.applyFilter(path, i, hoverFilter.type);
            } else {
              filters.getDefaultFilter(path, i);
            }
          }
        }
        if (typeof w.config.chart.events.dataPointSelection === 'function') {
          w.config.chart.events.dataPointSelection(e, this.ctx, {
            selectedDataPoints: w.globals.selectedDataPoints,
            seriesIndex: i,
            dataPointIndex: j,
            w: w
          });
        }
        if (e) {
          this.ctx.events.fireEvent('dataPointSelection', [e, this.ctx, {
            selectedDataPoints: w.globals.selectedDataPoints,
            seriesIndex: i,
            dataPointIndex: j,
            w: w
          }]);
        }
      }
    }, {
      key: "rotateAroundCenter",
      value: function rotateAroundCenter(el) {
        var coord = {};
        if (el && typeof el.getBBox === 'function') {
          coord = el.getBBox();
        }
        var x = coord.x + coord.width / 2;
        var y = coord.y + coord.height / 2;
        return {
          x: x,
          y: y
        };
      }
    }, {
      key: "getTextRects",
      value: function getTextRects(text, fontSize, fontFamily, transform) {
        var useBBox = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        var w = this.w;
        var virtualText = this.drawText({
          x: -200,
          y: -200,
          text: text,
          textAnchor: 'start',
          fontSize: fontSize,
          fontFamily: fontFamily,
          foreColor: '#fff',
          opacity: 0
        });
        if (transform) {
          virtualText.attr('transform', transform);
        }
        w.globals.dom.Paper.add(virtualText);
        var rect = virtualText.bbox();
        if (!useBBox) {
          rect = virtualText.node.getBoundingClientRect();
        }
        virtualText.remove();
        return {
          width: rect.width,
          height: rect.height
        };
      }

      /**
       * append ... to long text
       * http://stackoverflow.com/questions/9241315/trimming-text-to-a-given-pixel-width-in-svg
       * @memberof Graphics
       **/
    }, {
      key: "placeTextWithEllipsis",
      value: function placeTextWithEllipsis(textObj, textString, width) {
        if (typeof textObj.getComputedTextLength !== 'function') return;
        textObj.textContent = textString;
        if (textString.length > 0) {
          // ellipsis is needed
          if (textObj.getComputedTextLength() >= width / 1.1) {
            for (var x = textString.length - 3; x > 0; x -= 3) {
              if (textObj.getSubStringLength(0, x) <= width / 1.1) {
                textObj.textContent = textString.substring(0, x) + '...';
                return;
              }
            }
            textObj.textContent = '.'; // can't place at all
          }
        }
      }
    }], [{
      key: "setAttrs",
      value: function setAttrs(el, attrs) {
        for (var key in attrs) {
          if (attrs.hasOwnProperty(key)) {
            el.setAttribute(key, attrs[key]);
          }
        }
      }
    }]);
    return Graphics;
  }();

  /*
   ** Util functions which are dependent on ApexCharts instance
   */
  var CoreUtils = /*#__PURE__*/function () {
    function CoreUtils(ctx) {
      _classCallCheck(this, CoreUtils);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(CoreUtils, [{
      key: "getStackedSeriesTotals",
      value:
      /**
       * @memberof CoreUtils
       * returns the sum of all individual values in a multiple stacked series
       * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]
       *  @return [34,36,48,13]
       **/
      function getStackedSeriesTotals() {
        var excludedSeriesIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var w = this.w;
        var total = [];
        if (w.globals.series.length === 0) return total;
        for (var i = 0; i < w.globals.series[w.globals.maxValsInArrayIndex].length; i++) {
          var t = 0;
          for (var j = 0; j < w.globals.series.length; j++) {
            if (typeof w.globals.series[j][i] !== 'undefined' && excludedSeriesIndices.indexOf(j) === -1) {
              t += w.globals.series[j][i];
            }
          }
          total.push(t);
        }
        return total;
      }

      // get total of the all values inside all series
    }, {
      key: "getSeriesTotalByIndex",
      value: function getSeriesTotalByIndex() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        if (index === null) {
          // non-plot chart types - pie / donut / circle
          return this.w.config.series.reduce(function (acc, cur) {
            return acc + cur;
          }, 0);
        } else {
          // axis charts - supporting multiple series
          return this.w.globals.series[index].reduce(function (acc, cur) {
            return acc + cur;
          }, 0);
        }
      }

      /**
       * @memberof CoreUtils
       * returns the sum of values in a multiple stacked grouped charts
       * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1], [43, 23, 34, 22]]
       * series 1 and 2 are in a group, while series 3 is in another group
       *  @return [[34, 36, 48, 12], [43, 23, 34, 22]]
       **/
    }, {
      key: "getStackedSeriesTotalsByGroups",
      value: function getStackedSeriesTotalsByGroups() {
        var _this = this;
        var w = this.w;
        var total = [];
        w.globals.seriesGroups.forEach(function (sg) {
          var includedIndexes = [];
          w.config.series.forEach(function (s, si) {
            if (sg.indexOf(w.globals.seriesNames[si]) > -1) {
              includedIndexes.push(si);
            }
          });
          var excludedIndices = w.globals.series.map(function (_, fi) {
            return includedIndexes.indexOf(fi) === -1 ? fi : -1;
          }).filter(function (f) {
            return f !== -1;
          });
          total.push(_this.getStackedSeriesTotals(excludedIndices));
        });
        return total;
      }
    }, {
      key: "setSeriesYAxisMappings",
      value: function setSeriesYAxisMappings() {
        var gl = this.w.globals;
        var cnf = this.w.config;

        // The old config method to map multiple series to a y axis is to
        // include one yaxis config per series but set each yaxis seriesName to the
        // same series name. This relies on indexing equivalence to map series to
        // an axis: series[n] => yaxis[n]. This needs to be retained for compatibility.
        // But we introduce an alternative that explicitly configures yaxis elements
        // with the series that will be referenced to them (seriesName: []). This
        // only requires including the yaxis elements that will be seen on the chart.
        // Old way:
        // ya: s
        // 0: 0
        // 1: 1
        // 2: 1
        // 3: 1
        // 4: 1
        // Axes 0..4 are all scaled and all will be rendered unless the axes are
        // show: false. If the chart is stacked, it's assumed that series 1..4 are
        // the contributing series. This is not particularly intuitive.
        // New way:
        // ya: s
        // 0: [0]
        // 1: [1,2,3,4]
        // If the chart is stacked, it can be assumed that any axis with multiple
        // series is stacked.
        //
        // If this is an old chart and we are being backward compatible, it will be
        // expected that each series is associated with it's corresponding yaxis
        // through their indices, one-to-one.
        // If yaxis.seriesName matches series.name, we have indices yi and si.
        // A name match where yi != si is interpretted as yaxis[yi] and yaxis[si]
        // will both be scaled to fit the combined series[si] and series[yi].
        // Consider series named: S0,S1,S2 and yaxes A0,A1,A2.
        //
        // Example 1: A0 and A1 scaled the same.
        // A0.seriesName: S0
        // A1.seriesName: S0
        // A2.seriesName: S2
        // Then A1 <-> A0
        //
        // Example 2: A0, A1 and A2 all scaled the same.
        // A0.seriesName: S2
        // A1.seriesName: S0
        // A2.seriesName: S1
        // A0 <-> A2, A1 <-> A0, A2 <-> A1 --->>> A0 <-> A1 <-> A2

        var axisSeriesMap = [];
        var seriesYAxisReverseMap = [];
        var unassignedSeriesIndices = [];
        var seriesNameArrayStyle = gl.series.length > cnf.yaxis.length || cnf.yaxis.some(function (a) {
          return Array.isArray(a.seriesName);
        });
        cnf.series.forEach(function (s, i) {
          unassignedSeriesIndices.push(i);
          seriesYAxisReverseMap.push(null);
        });
        cnf.yaxis.forEach(function (yaxe, yi) {
          axisSeriesMap[yi] = [];
        });
        var unassignedYAxisIndices = [];

        // here, we loop through the yaxis array and find the item which has "seriesName" property
        cnf.yaxis.forEach(function (yaxe, yi) {
          var assigned = false;
          // Allow seriesName to be either a string (for backward compatibility),
          // in which case, handle multiple yaxes referencing the same series.
          // or an array of strings so that a yaxis can reference multiple series.
          // Feature request #4237
          if (yaxe.seriesName) {
            var seriesNames = [];
            if (Array.isArray(yaxe.seriesName)) {
              seriesNames = yaxe.seriesName;
            } else {
              seriesNames.push(yaxe.seriesName);
            }
            seriesNames.forEach(function (name) {
              cnf.series.forEach(function (s, si) {
                if (s.name === name) {
                  var remove = si;
                  if (yi === si || seriesNameArrayStyle) {
                    // New style, don't allow series to be double referenced
                    if (!seriesNameArrayStyle || unassignedSeriesIndices.indexOf(si) > -1) {
                      axisSeriesMap[yi].push([yi, si]);
                    } else {
                      console.warn("Series '" + s.name + "' referenced more than once in what looks like the new style." + ' That is, when using either seriesName: [],' + ' or when there are more series than yaxes.');
                    }
                  } else {
                    // The series index refers to the target yaxis and the current
                    // yaxis index refers to the actual referenced series.
                    axisSeriesMap[si].push([si, yi]);
                    remove = yi;
                  }
                  assigned = true;
                  remove = unassignedSeriesIndices.indexOf(remove);
                  if (remove !== -1) {
                    unassignedSeriesIndices.splice(remove, 1);
                  }
                }
              });
            });
          }
          if (!assigned) {
            unassignedYAxisIndices.push(yi);
          }
        });
        axisSeriesMap = axisSeriesMap.map(function (yaxe, yi) {
          var ra = [];
          yaxe.forEach(function (sa) {
            seriesYAxisReverseMap[sa[1]] = sa[0];
            ra.push(sa[1]);
          });
          return ra;
        });

        // All series referenced directly by yaxes have been assigned to those axes.
        // Any series so far unassigned will be assigned to any yaxes that have yet
        // to reference series directly, one-for-one in order of appearance, with
        // all left-over series assigned to either the last unassigned yaxis, or the
        // last yaxis if all have assigned series. This captures the
        // default single and multiaxis config options which simply includes zero,
        // one or as many yaxes as there are series but do not reference them by name.
        var lastUnassignedYAxis = cnf.yaxis.length - 1;
        for (var i = 0; i < unassignedYAxisIndices.length; i++) {
          lastUnassignedYAxis = unassignedYAxisIndices[i];
          axisSeriesMap[lastUnassignedYAxis] = [];
          if (unassignedSeriesIndices) {
            var si = unassignedSeriesIndices[0];
            unassignedSeriesIndices.shift();
            axisSeriesMap[lastUnassignedYAxis].push(si);
            seriesYAxisReverseMap[si] = lastUnassignedYAxis;
          } else {
            break;
          }
        }
        unassignedSeriesIndices.forEach(function (i) {
          axisSeriesMap[lastUnassignedYAxis].push(i);
          seriesYAxisReverseMap[i] = lastUnassignedYAxis;
        });

        // For the old-style seriesName-as-string-only, leave the zero-length yaxis
        // array elements in for compatibility so that series.length == yaxes.length
        // for multi axis charts.
        gl.seriesYAxisMap = axisSeriesMap.map(function (x) {
          return x;
        });
        gl.seriesYAxisReverseMap = seriesYAxisReverseMap.map(function (x) {
          return x;
        });
        // Set default series group names
        gl.seriesYAxisMap.forEach(function (axisSeries, ai) {
          axisSeries.forEach(function (si) {
            // series may be bare until loaded in realtime
            if (cnf.series[si] && cnf.series[si].group === undefined) {
              // A series with no group defined will be named after the axis that
              // referenced it and thus form a group automatically.
              cnf.series[si].group = 'apexcharts-axis-'.concat(ai.toString());
            }
          });
        });
      }
    }, {
      key: "isSeriesNull",
      value: function isSeriesNull() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var r = [];
        if (index === null) {
          // non-plot chart types - pie / donut / circle
          r = this.w.config.series.filter(function (d) {
            return d !== null;
          });
        } else {
          // axis charts - supporting multiple series
          r = this.w.config.series[index].data.filter(function (d) {
            return d !== null;
          });
        }
        return r.length === 0;
      }
    }, {
      key: "seriesHaveSameValues",
      value: function seriesHaveSameValues(index) {
        return this.w.globals.series[index].every(function (val, i, arr) {
          return val === arr[0];
        });
      }
    }, {
      key: "getCategoryLabels",
      value: function getCategoryLabels(labels) {
        var w = this.w;
        var catLabels = labels.slice();
        if (w.config.xaxis.convertedCatToNumeric) {
          catLabels = labels.map(function (i, li) {
            return w.config.xaxis.labels.formatter(i - w.globals.minX + 1);
          });
        }
        return catLabels;
      }
      // maxValsInArrayIndex is the index of series[] which has the largest number of items
    }, {
      key: "getLargestSeries",
      value: function getLargestSeries() {
        var w = this.w;
        w.globals.maxValsInArrayIndex = w.globals.series.map(function (a) {
          return a.length;
        }).indexOf(Math.max.apply(Math, w.globals.series.map(function (a) {
          return a.length;
        })));
      }
    }, {
      key: "getLargestMarkerSize",
      value: function getLargestMarkerSize() {
        var w = this.w;
        var size = 0;
        w.globals.markers.size.forEach(function (m) {
          size = Math.max(size, m);
        });
        if (w.config.markers.discrete && w.config.markers.discrete.length) {
          w.config.markers.discrete.forEach(function (m) {
            size = Math.max(size, m.size);
          });
        }
        if (size > 0) {
          if (w.config.markers.hover.size > 0) {
            size = w.config.markers.hover.size;
          } else {
            size += w.config.markers.hover.sizeOffset;
          }
        }
        w.globals.markers.largestSize = size;
        return size;
      }

      /**
       * @memberof Core
       * returns the sum of all values in a series
       * Eg. w.globals.series = [[32,33,43,12], [2,3,5,1]]
       *  @return [120, 11]
       **/
    }, {
      key: "getSeriesTotals",
      value: function getSeriesTotals() {
        var w = this.w;
        w.globals.seriesTotals = w.globals.series.map(function (ser, index) {
          var total = 0;
          if (Array.isArray(ser)) {
            for (var j = 0; j < ser.length; j++) {
              total += ser[j];
            }
          } else {
            // for pie/donuts/gauges
            total += ser;
          }
          return total;
        });
      }
    }, {
      key: "getSeriesTotalsXRange",
      value: function getSeriesTotalsXRange(minX, maxX) {
        var w = this.w;
        var seriesTotalsXRange = w.globals.series.map(function (ser, index) {
          var total = 0;
          for (var j = 0; j < ser.length; j++) {
            if (w.globals.seriesX[index][j] > minX && w.globals.seriesX[index][j] < maxX) {
              total += ser[j];
            }
          }
          return total;
        });
        return seriesTotalsXRange;
      }

      /**
       * @memberof CoreUtils
       * returns the percentage value of all individual values which can be used in a 100% stacked series
       * Eg. w.globals.series = [[32, 33, 43, 12], [2, 3, 5, 1]]
       *  @return [[94.11, 91.66, 89.58, 92.30], [5.88, 8.33, 10.41, 7.7]]
       **/
    }, {
      key: "getPercentSeries",
      value: function getPercentSeries() {
        var w = this.w;
        w.globals.seriesPercent = w.globals.series.map(function (ser, index) {
          var seriesPercent = [];
          if (Array.isArray(ser)) {
            for (var j = 0; j < ser.length; j++) {
              var total = w.globals.stackedSeriesTotals[j];
              var percent = 0;
              if (total) {
                percent = 100 * ser[j] / total;
              }
              seriesPercent.push(percent);
            }
          } else {
            var _total = w.globals.seriesTotals.reduce(function (acc, val) {
              return acc + val;
            }, 0);
            var _percent = 100 * ser / _total;
            seriesPercent.push(_percent);
          }
          return seriesPercent;
        });
      }
    }, {
      key: "getCalculatedRatios",
      value: function getCalculatedRatios() {
        var _this2 = this;
        var w = this.w;
        var gl = w.globals;
        var yRatio = [];
        var invertedYRatio = 0;
        var xRatio = 0;
        var invertedXRatio = 0;
        var zRatio = 0;
        var baseLineY = [];
        var baseLineInvertedY = 0.1;
        var baseLineX = 0;
        gl.yRange = [];
        if (gl.isMultipleYAxis) {
          for (var i = 0; i < gl.minYArr.length; i++) {
            gl.yRange.push(Math.abs(gl.minYArr[i] - gl.maxYArr[i]));
            baseLineY.push(0);
          }
        } else {
          gl.yRange.push(Math.abs(gl.minY - gl.maxY));
        }
        gl.xRange = Math.abs(gl.maxX - gl.minX);
        gl.zRange = Math.abs(gl.maxZ - gl.minZ);

        // multiple y axis
        for (var _i = 0; _i < gl.yRange.length; _i++) {
          yRatio.push(gl.yRange[_i] / gl.gridHeight);
        }
        xRatio = gl.xRange / gl.gridWidth;
        invertedYRatio = gl.yRange / gl.gridWidth;
        invertedXRatio = gl.xRange / gl.gridHeight;
        zRatio = gl.zRange / gl.gridHeight * 16;
        if (!zRatio) {
          zRatio = 1;
        }
        if (gl.minY !== Number.MIN_VALUE && Math.abs(gl.minY) !== 0) {
          // Negative numbers present in series
          gl.hasNegs = true;
        }

        // Check we have a map as series may still to be added/updated.
        if (w.globals.seriesYAxisReverseMap.length > 0) {
          var scaleBaseLineYScale = function scaleBaseLineYScale(y, i) {
            var yAxis = w.config.yaxis[w.globals.seriesYAxisReverseMap[i]];
            var sign = y < 0 ? -1 : 1;
            y = Math.abs(y);
            if (yAxis.logarithmic) {
              y = _this2.getBaseLog(yAxis.logBase, y);
            }
            return -sign * y / yRatio[i];
          };
          if (gl.isMultipleYAxis) {
            baseLineY = [];
            // baseline variables is the 0 of the yaxis which will be needed when there are negatives
            for (var _i2 = 0; _i2 < yRatio.length; _i2++) {
              baseLineY.push(scaleBaseLineYScale(gl.minYArr[_i2], _i2));
            }
          } else {
            baseLineY = [];
            baseLineY.push(scaleBaseLineYScale(gl.minY, 0));
            if (gl.minY !== Number.MIN_VALUE && Math.abs(gl.minY) !== 0) {
              baseLineInvertedY = -gl.minY / invertedYRatio; // this is for bar chart
              baseLineX = gl.minX / xRatio;
            }
          }
        } else {
          baseLineY = [];
          baseLineY.push(0);
          baseLineInvertedY = 0;
          baseLineX = 0;
        }
        return {
          yRatio: yRatio,
          invertedYRatio: invertedYRatio,
          zRatio: zRatio,
          xRatio: xRatio,
          invertedXRatio: invertedXRatio,
          baseLineInvertedY: baseLineInvertedY,
          baseLineY: baseLineY,
          baseLineX: baseLineX
        };
      }
    }, {
      key: "getLogSeries",
      value: function getLogSeries(series) {
        var _this3 = this;
        var w = this.w;
        w.globals.seriesLog = series.map(function (s, i) {
          var yAxisIndex = w.globals.seriesYAxisReverseMap[i];
          if (w.config.yaxis[yAxisIndex] && w.config.yaxis[yAxisIndex].logarithmic) {
            return s.map(function (d) {
              if (d === null) return null;
              return _this3.getLogVal(w.config.yaxis[yAxisIndex].logBase, d, i);
            });
          } else {
            return s;
          }
        });
        return w.globals.invalidLogScale ? series : w.globals.seriesLog;
      }
    }, {
      key: "getLogValAtSeriesIndex",
      value: function getLogValAtSeriesIndex(val, seriesIndex) {
        if (val === null) return null;
        var w = this.w;
        var yAxisIndex = w.globals.seriesYAxisReverseMap[seriesIndex];
        if (w.config.yaxis[yAxisIndex] && w.config.yaxis[yAxisIndex].logarithmic) {
          return this.getLogVal(w.config.yaxis[yAxisIndex].logBase, val, seriesIndex);
        }
        return val;
      }
    }, {
      key: "getBaseLog",
      value: function getBaseLog(base, value) {
        return Math.log(value) / Math.log(base);
      }
    }, {
      key: "getLogVal",
      value: function getLogVal(b, d, seriesIndex) {
        if (d <= 0) {
          return 0; // Should be Number.NEGATIVE_INFINITY
        }
        var w = this.w;
        var min_log_val = w.globals.minYArr[seriesIndex] === 0 ? -1 // make sure we dont calculate log of 0
        : this.getBaseLog(b, w.globals.minYArr[seriesIndex]);
        var max_log_val = w.globals.maxYArr[seriesIndex] === 0 ? 0 // make sure we dont calculate log of 0
        : this.getBaseLog(b, w.globals.maxYArr[seriesIndex]);
        var number_of_height_levels = max_log_val - min_log_val;
        if (d < 1) return d / number_of_height_levels;
        var log_height_value = this.getBaseLog(b, d) - min_log_val;
        return log_height_value / number_of_height_levels;
      }
    }, {
      key: "getLogYRatios",
      value: function getLogYRatios(yRatio) {
        var _this4 = this;
        var w = this.w;
        var gl = this.w.globals;
        gl.yLogRatio = yRatio.slice();
        gl.logYRange = gl.yRange.map(function (_, i) {
          var yAxisIndex = w.globals.seriesYAxisReverseMap[i];
          if (w.config.yaxis[yAxisIndex] && _this4.w.config.yaxis[yAxisIndex].logarithmic) {
            var maxY = -Number.MAX_VALUE;
            var minY = Number.MIN_VALUE;
            var range = 1;
            gl.seriesLog.forEach(function (s, si) {
              s.forEach(function (v) {
                if (w.config.yaxis[si] && w.config.yaxis[si].logarithmic) {
                  maxY = Math.max(v, maxY);
                  minY = Math.min(v, minY);
                }
              });
            });
            range = Math.pow(gl.yRange[i], Math.abs(minY - maxY) / gl.yRange[i]);
            gl.yLogRatio[i] = range / gl.gridHeight;
            return range;
          }
        });
        return gl.invalidLogScale ? yRatio.slice() : gl.yLogRatio;
      }

      // Some config objects can be array - and we need to extend them correctly
    }, {
      key: "drawSeriesByGroup",
      value:
      // Series of the same group and type can be stacked together distinct from
      // other series of the same type on the same axis.
      function drawSeriesByGroup(typeSeries, typeGroups, type, chartClass) {
        var w = this.w;
        var graph = [];
        if (typeSeries.series.length > 0) {
          // draw each group separately
          typeGroups.forEach(function (gn) {
            var gs = [];
            var gi = [];
            typeSeries.i.forEach(function (i, ii) {
              if (w.config.series[i].group === gn) {
                gs.push(typeSeries.series[ii]);
                gi.push(i);
              }
            });
            gs.length > 0 && graph.push(chartClass.draw(gs, type, gi));
          });
        }
        return graph;
      }
    }], [{
      key: "checkComboSeries",
      value: function checkComboSeries(series, chartType) {
        var comboCharts = false;
        var comboBarCount = 0;
        var comboCount = 0;
        if (chartType === undefined) {
          chartType = 'line';
        }

        // Check if user specified a type in series that may make us a combo chart.
        // The default type for chart is "line" and the default for series is the
        // chart type, therefore, if the types of all series match the chart type,
        // this should not be considered a combo chart.
        if (series.length && typeof series[0].type !== 'undefined') {
          series.forEach(function (s) {
            if (s.type === 'bar' || s.type === 'column' || s.type === 'candlestick' || s.type === 'boxPlot') {
              comboBarCount++;
            }
            if (typeof s.type !== 'undefined' && s.type !== chartType) {
              comboCount++;
            }
          });
        }
        if (comboCount > 0) {
          comboCharts = true;
        }
        return {
          comboBarCount: comboBarCount,
          comboCharts: comboCharts
        };
      }
    }, {
      key: "extendArrayProps",
      value: function extendArrayProps(configInstance, options, w) {
        var _options, _options2;
        if ((_options = options) !== null && _options !== void 0 && _options.yaxis) {
          options = configInstance.extendYAxis(options, w);
        }
        if ((_options2 = options) !== null && _options2 !== void 0 && _options2.annotations) {
          var _options3, _options3$annotations, _options4, _options4$annotations;
          if (options.annotations.yaxis) {
            options = configInstance.extendYAxisAnnotations(options);
          }
          if ((_options3 = options) !== null && _options3 !== void 0 && (_options3$annotations = _options3.annotations) !== null && _options3$annotations !== void 0 && _options3$annotations.xaxis) {
            options = configInstance.extendXAxisAnnotations(options);
          }
          if ((_options4 = options) !== null && _options4 !== void 0 && (_options4$annotations = _options4.annotations) !== null && _options4$annotations !== void 0 && _options4$annotations.points) {
            options = configInstance.extendPointAnnotations(options);
          }
        }
        return options;
      }
    }]);
    return CoreUtils;
  }();

  var Helpers$4 = /*#__PURE__*/function () {
    function Helpers(annoCtx) {
      _classCallCheck(this, Helpers);
      this.w = annoCtx.w;
      this.annoCtx = annoCtx;
    }
    _createClass(Helpers, [{
      key: "setOrientations",
      value: function setOrientations(anno) {
        var annoIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var w = this.w;
        if (anno.label.orientation === 'vertical') {
          var i = annoIndex !== null ? annoIndex : 0;
          var xAnno = w.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(i, "']"));
          if (xAnno !== null) {
            var xAnnoCoord = xAnno.getBoundingClientRect();
            xAnno.setAttribute('x', parseFloat(xAnno.getAttribute('x')) - xAnnoCoord.height + 4);
            var yOffset = anno.label.position === 'top' ? xAnnoCoord.width : -xAnnoCoord.width;
            xAnno.setAttribute('y', parseFloat(xAnno.getAttribute('y')) + yOffset);
            var _this$annoCtx$graphic = this.annoCtx.graphics.rotateAroundCenter(xAnno),
              x = _this$annoCtx$graphic.x,
              y = _this$annoCtx$graphic.y;
            xAnno.setAttribute('transform', "rotate(-90 ".concat(x, " ").concat(y, ")"));
          }
        }
      }
    }, {
      key: "addBackgroundToAnno",
      value: function addBackgroundToAnno(annoEl, anno) {
        var w = this.w;
        if (!annoEl || !anno.label.text || !String(anno.label.text).trim()) {
          return null;
        }
        var elGridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid').getBoundingClientRect();
        var coords = annoEl.getBoundingClientRect();
        var _anno$label$style$pad = anno.label.style.padding,
          pleft = _anno$label$style$pad.left,
          pright = _anno$label$style$pad.right,
          ptop = _anno$label$style$pad.top,
          pbottom = _anno$label$style$pad.bottom;
        if (anno.label.orientation === 'vertical') {
          var _ref = [pleft, pright, ptop, pbottom];
          ptop = _ref[0];
          pbottom = _ref[1];
          pleft = _ref[2];
          pright = _ref[3];
        }
        var x1 = coords.left - elGridRect.left - pleft;
        var y1 = coords.top - elGridRect.top - ptop;
        var elRect = this.annoCtx.graphics.drawRect(x1 - w.globals.barPadForNumericAxis, y1, coords.width + pleft + pright, coords.height + ptop + pbottom, anno.label.borderRadius, anno.label.style.background, 1, anno.label.borderWidth, anno.label.borderColor, 0);
        if (anno.id) {
          elRect.node.classList.add(anno.id);
        }
        return elRect;
      }
    }, {
      key: "annotationsBackground",
      value: function annotationsBackground() {
        var _this = this;
        var w = this.w;
        var add = function add(anno, i, type) {
          var annoLabel = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-annotations .apexcharts-").concat(type, "-annotation-label[rel='").concat(i, "']"));
          if (annoLabel) {
            var parent = annoLabel.parentNode;
            var elRect = _this.addBackgroundToAnno(annoLabel, anno);
            if (elRect) {
              parent.insertBefore(elRect.node, annoLabel);
              if (anno.label.mouseEnter) {
                elRect.node.addEventListener('mouseenter', anno.label.mouseEnter.bind(_this, anno));
              }
              if (anno.label.mouseLeave) {
                elRect.node.addEventListener('mouseleave', anno.label.mouseLeave.bind(_this, anno));
              }
              if (anno.label.click) {
                elRect.node.addEventListener('click', anno.label.click.bind(_this, anno));
              }
            }
          }
        };
        w.config.annotations.xaxis.forEach(function (anno, i) {
          return add(anno, i, 'xaxis');
        });
        w.config.annotations.yaxis.forEach(function (anno, i) {
          return add(anno, i, 'yaxis');
        });
        w.config.annotations.points.forEach(function (anno, i) {
          return add(anno, i, 'point');
        });
      }
    }, {
      key: "getY1Y2",
      value: function getY1Y2(type, anno) {
        var w = this.w;
        var y = type === 'y1' ? anno.y : anno.y2;
        var yP;
        var clipped = false;
        if (this.annoCtx.invertAxis) {
          var labels = w.config.xaxis.convertedCatToNumeric ? w.globals.categoryLabels : w.globals.labels;
          var catIndex = labels.indexOf(y);
          var xLabel = w.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(".concat(catIndex + 1, ")"));
          yP = xLabel ? parseFloat(xLabel.getAttribute('y')) : (w.globals.gridHeight / labels.length - 1) * (catIndex + 1) - w.globals.barHeight;
          if (anno.seriesIndex !== undefined && w.globals.barHeight) {
            yP -= w.globals.barHeight / 2 * (w.globals.series.length - 1) - w.globals.barHeight * anno.seriesIndex;
          }
        } else {
          var _w$config$yaxis$anno$;
          var seriesIndex = w.globals.seriesYAxisMap[anno.yAxisIndex][0];
          var yPos = w.config.yaxis[anno.yAxisIndex].logarithmic ? new CoreUtils(this.annoCtx.ctx).getLogVal(w.config.yaxis[anno.yAxisIndex].logBase, y, seriesIndex) / w.globals.yLogRatio[seriesIndex] : (y - w.globals.minYArr[seriesIndex]) / (w.globals.yRange[seriesIndex] / w.globals.gridHeight);
          yP = w.globals.gridHeight - Math.min(Math.max(yPos, 0), w.globals.gridHeight);
          clipped = yPos > w.globals.gridHeight || yPos < 0;
          if (anno.marker && (anno.y === undefined || anno.y === null)) {
            yP = 0;
          }
          if ((_w$config$yaxis$anno$ = w.config.yaxis[anno.yAxisIndex]) !== null && _w$config$yaxis$anno$ !== void 0 && _w$config$yaxis$anno$.reversed) {
            yP = yPos;
          }
        }
        if (typeof y === 'string' && y.includes('px')) {
          yP = parseFloat(y);
        }
        return {
          yP: yP,
          clipped: clipped
        };
      }
    }, {
      key: "getX1X2",
      value: function getX1X2(type, anno) {
        var w = this.w;
        var x = type === 'x1' ? anno.x : anno.x2;
        var min = this.annoCtx.invertAxis ? w.globals.minY : w.globals.minX;
        var max = this.annoCtx.invertAxis ? w.globals.maxY : w.globals.maxX;
        var range = this.annoCtx.invertAxis ? w.globals.yRange[0] : w.globals.xRange;
        var clipped = false;
        var xP = this.annoCtx.inversedReversedAxis ? (max - x) / (range / w.globals.gridWidth) : (x - min) / (range / w.globals.gridWidth);
        if ((w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) && !this.annoCtx.invertAxis && !w.globals.dataFormatXNumeric) {
          if (!w.config.chart.sparkline.enabled) {
            xP = this.getStringX(x);
          }
        }
        if (typeof x === 'string' && x.includes('px')) {
          xP = parseFloat(x);
        }
        if ((x === undefined || x === null) && anno.marker) {
          xP = w.globals.gridWidth;
        }
        if (anno.seriesIndex !== undefined && w.globals.barWidth && !this.annoCtx.invertAxis) {
          xP -= w.globals.barWidth / 2 * (w.globals.series.length - 1) - w.globals.barWidth * anno.seriesIndex;
        }
        if (typeof xP !== 'number') {
          xP = 0;
          clipped = true;
        }
        if (parseFloat(xP.toFixed(10)) > parseFloat(w.globals.gridWidth.toFixed(10))) {
          xP = w.globals.gridWidth;
          clipped = true;
        } else if (xP < 0) {
          xP = 0;
          clipped = true;
        }
        return {
          x: xP,
          clipped: clipped
        };
      }
    }, {
      key: "getStringX",
      value: function getStringX(x) {
        var w = this.w;
        var rX = x;
        if (w.config.xaxis.convertedCatToNumeric && w.globals.categoryLabels.length) {
          x = w.globals.categoryLabels.indexOf(x) + 1;
        }
        var catIndex = w.globals.labels.map(function (item) {
          return Array.isArray(item) ? item.join(' ') : item;
        }).indexOf(x);
        var xLabel = w.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(".concat(catIndex + 1, ")"));
        if (xLabel) {
          rX = parseFloat(xLabel.getAttribute('x'));
        }
        return rX;
      }
    }]);
    return Helpers;
  }();

  var XAnnotations = /*#__PURE__*/function () {
    function XAnnotations(annoCtx) {
      _classCallCheck(this, XAnnotations);
      this.w = annoCtx.w;
      this.annoCtx = annoCtx;
      this.invertAxis = this.annoCtx.invertAxis;
      this.helpers = new Helpers$4(this.annoCtx);
    }
    _createClass(XAnnotations, [{
      key: "addXaxisAnnotation",
      value: function addXaxisAnnotation(anno, parent, index) {
        var w = this.w;
        var result = this.helpers.getX1X2('x1', anno);
        var x1 = result.x;
        var clipX1 = result.clipped;
        var clipX2 = true;
        var x2;
        var text = anno.label.text;
        var strokeDashArray = anno.strokeDashArray;
        if (!Utils$1.isNumber(x1)) return;
        if (anno.x2 === null || typeof anno.x2 === 'undefined') {
          if (!clipX1) {
            var line = this.annoCtx.graphics.drawLine(x1 + anno.offsetX,
            // x1
            0 + anno.offsetY,
            // y1
            x1 + anno.offsetX,
            // x2
            w.globals.gridHeight + anno.offsetY,
            // y2
            anno.borderColor,
            // lineColor
            strokeDashArray,
            //dashArray
            anno.borderWidth);
            parent.appendChild(line.node);
            if (anno.id) {
              line.node.classList.add(anno.id);
            }
          }
        } else {
          var _result = this.helpers.getX1X2('x2', anno);
          x2 = _result.x;
          clipX2 = _result.clipped;
          if (x2 < x1) {
            var temp = x1;
            x1 = x2;
            x2 = temp;
          }
          var rect = this.annoCtx.graphics.drawRect(x1 + anno.offsetX,
          // x1
          0 + anno.offsetY,
          // y1
          x2 - x1,
          // x2
          w.globals.gridHeight + anno.offsetY,
          // y2
          0,
          // radius
          anno.fillColor,
          // color
          anno.opacity,
          // opacity,
          1,
          // strokeWidth
          anno.borderColor,
          // strokeColor
          strokeDashArray // stokeDashArray
          );
          rect.node.classList.add('apexcharts-annotation-rect');
          rect.attr('clip-path', "url(#gridRectMask".concat(w.globals.cuid, ")"));
          parent.appendChild(rect.node);
          if (anno.id) {
            rect.node.classList.add(anno.id);
          }
        }
        if (!(clipX1 && clipX2)) {
          var textRects = this.annoCtx.graphics.getTextRects(text, parseFloat(anno.label.style.fontSize));
          var textY = anno.label.position === 'top' ? 4 : anno.label.position === 'center' ? w.globals.gridHeight / 2 + (anno.label.orientation === 'vertical' ? textRects.width / 2 : 0) : w.globals.gridHeight;
          var elText = this.annoCtx.graphics.drawText({
            x: x1 + anno.label.offsetX,
            y: textY + anno.label.offsetY - (anno.label.orientation === 'vertical' ? anno.label.position === 'top' ? textRects.width / 2 - 12 : -textRects.width / 2 : 0),
            text: text,
            textAnchor: anno.label.textAnchor,
            fontSize: anno.label.style.fontSize,
            fontFamily: anno.label.style.fontFamily,
            fontWeight: anno.label.style.fontWeight,
            foreColor: anno.label.style.color,
            cssClass: "apexcharts-xaxis-annotation-label ".concat(anno.label.style.cssClass, " ").concat(anno.id ? anno.id : '')
          });
          elText.attr({
            rel: index
          });
          parent.appendChild(elText.node);

          // after placing the annotations on svg, set any vertically placed annotations
          this.annoCtx.helpers.setOrientations(anno, index);
        }
      }
    }, {
      key: "drawXAxisAnnotations",
      value: function drawXAxisAnnotations() {
        var _this = this;
        var w = this.w;
        var elg = this.annoCtx.graphics.group({
          class: 'apexcharts-xaxis-annotations'
        });
        w.config.annotations.xaxis.map(function (anno, index) {
          _this.addXaxisAnnotation(anno, elg.node, index);
        });
        return elg;
      }
    }]);
    return XAnnotations;
  }();

  /**
   * DateTime Class to manipulate datetime values.
   *
   * @module DateTime
   **/
  var DateTime = /*#__PURE__*/function () {
    function DateTime(ctx) {
      _classCallCheck(this, DateTime);
      this.ctx = ctx;
      this.w = ctx.w;
      this.months31 = [1, 3, 5, 7, 8, 10, 12];
      this.months30 = [2, 4, 6, 9, 11];
      this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    }
    _createClass(DateTime, [{
      key: "isValidDate",
      value: function isValidDate(date) {
        if (typeof date === 'number') {
          return false; // don't test for timestamps
        }
        return !isNaN(this.parseDate(date));
      }
    }, {
      key: "getTimeStamp",
      value: function getTimeStamp(dateStr) {
        if (!Date.parse(dateStr)) {
          return dateStr;
        }
        var utc = this.w.config.xaxis.labels.datetimeUTC;
        return !utc ? new Date(dateStr).getTime() : new Date(new Date(dateStr).toISOString().substr(0, 25)).getTime();
      }
    }, {
      key: "getDate",
      value: function getDate(timestamp) {
        var utc = this.w.config.xaxis.labels.datetimeUTC;
        return utc ? new Date(new Date(timestamp).toUTCString()) : new Date(timestamp);
      }
    }, {
      key: "parseDate",
      value: function parseDate(dateStr) {
        var parsed = Date.parse(dateStr);
        if (!isNaN(parsed)) {
          return this.getTimeStamp(dateStr);
        }
        var output = Date.parse(dateStr.replace(/-/g, '/').replace(/[a-z]+/gi, ' '));
        output = this.getTimeStamp(output);
        return output;
      }

      // This fixes the difference of x-axis labels between chrome/safari
      // Fixes #1726, #1544, #1485, #1255
    }, {
      key: "parseDateWithTimezone",
      value: function parseDateWithTimezone(dateStr) {
        return Date.parse(dateStr.replace(/-/g, '/').replace(/[a-z]+/gi, ' '));
      }

      // http://stackoverflow.com/questions/14638018/current-time-formatting-with-javascript#answer-14638191
    }, {
      key: "formatDate",
      value: function formatDate(date, format) {
        var locale = this.w.globals.locale;
        var utc = this.w.config.xaxis.labels.datetimeUTC;
        var MMMM = ['\x00'].concat(_toConsumableArray(locale.months));
        var MMM = ['\x01'].concat(_toConsumableArray(locale.shortMonths));
        var dddd = ['\x02'].concat(_toConsumableArray(locale.days));
        var ddd = ['\x03'].concat(_toConsumableArray(locale.shortDays));
        function ii(i, len) {
          var s = i + '';
          len = len || 2;
          while (s.length < len) {
            s = '0' + s;
          }
          return s;
        }
        var y = utc ? date.getUTCFullYear() : date.getFullYear();
        format = format.replace(/(^|[^\\])yyyy+/g, '$1' + y);
        format = format.replace(/(^|[^\\])yy/g, '$1' + y.toString().substr(2, 2));
        format = format.replace(/(^|[^\\])y/g, '$1' + y);
        var M = (utc ? date.getUTCMonth() : date.getMonth()) + 1;
        format = format.replace(/(^|[^\\])MMMM+/g, '$1' + MMMM[0]);
        format = format.replace(/(^|[^\\])MMM/g, '$1' + MMM[0]);
        format = format.replace(/(^|[^\\])MM/g, '$1' + ii(M));
        format = format.replace(/(^|[^\\])M/g, '$1' + M);
        var d = utc ? date.getUTCDate() : date.getDate();
        format = format.replace(/(^|[^\\])dddd+/g, '$1' + dddd[0]);
        format = format.replace(/(^|[^\\])ddd/g, '$1' + ddd[0]);
        format = format.replace(/(^|[^\\])dd/g, '$1' + ii(d));
        format = format.replace(/(^|[^\\])d/g, '$1' + d);
        var H = utc ? date.getUTCHours() : date.getHours();
        format = format.replace(/(^|[^\\])HH+/g, '$1' + ii(H));
        format = format.replace(/(^|[^\\])H/g, '$1' + H);
        var h = H > 12 ? H - 12 : H === 0 ? 12 : H;
        format = format.replace(/(^|[^\\])hh+/g, '$1' + ii(h));
        format = format.replace(/(^|[^\\])h/g, '$1' + h);
        var m = utc ? date.getUTCMinutes() : date.getMinutes();
        format = format.replace(/(^|[^\\])mm+/g, '$1' + ii(m));
        format = format.replace(/(^|[^\\])m/g, '$1' + m);
        var s = utc ? date.getUTCSeconds() : date.getSeconds();
        format = format.replace(/(^|[^\\])ss+/g, '$1' + ii(s));
        format = format.replace(/(^|[^\\])s/g, '$1' + s);
        var f = utc ? date.getUTCMilliseconds() : date.getMilliseconds();
        format = format.replace(/(^|[^\\])fff+/g, '$1' + ii(f, 3));
        f = Math.round(f / 10);
        format = format.replace(/(^|[^\\])ff/g, '$1' + ii(f));
        f = Math.round(f / 10);
        format = format.replace(/(^|[^\\])f/g, '$1' + f);
        var T = H < 12 ? 'AM' : 'PM';
        format = format.replace(/(^|[^\\])TT+/g, '$1' + T);
        format = format.replace(/(^|[^\\])T/g, '$1' + T.charAt(0));
        var t = T.toLowerCase();
        format = format.replace(/(^|[^\\])tt+/g, '$1' + t);
        format = format.replace(/(^|[^\\])t/g, '$1' + t.charAt(0));
        var tz = -date.getTimezoneOffset();
        var K = utc || !tz ? 'Z' : tz > 0 ? '+' : '-';
        if (!utc) {
          tz = Math.abs(tz);
          var tzHrs = Math.floor(tz / 60);
          var tzMin = tz % 60;
          K += ii(tzHrs) + ':' + ii(tzMin);
        }
        format = format.replace(/(^|[^\\])K/g, '$1' + K);
        var day = (utc ? date.getUTCDay() : date.getDay()) + 1;
        format = format.replace(new RegExp(dddd[0], 'g'), dddd[day]);
        format = format.replace(new RegExp(ddd[0], 'g'), ddd[day]);
        format = format.replace(new RegExp(MMMM[0], 'g'), MMMM[M]);
        format = format.replace(new RegExp(MMM[0], 'g'), MMM[M]);
        format = format.replace(/\\(.)/g, '$1');
        return format;
      }
    }, {
      key: "getTimeUnitsfromTimestamp",
      value: function getTimeUnitsfromTimestamp(minX, maxX, utc) {
        var w = this.w;
        if (w.config.xaxis.min !== undefined) {
          minX = w.config.xaxis.min;
        }
        if (w.config.xaxis.max !== undefined) {
          maxX = w.config.xaxis.max;
        }
        var tsMin = this.getDate(minX);
        var tsMax = this.getDate(maxX);
        var minD = this.formatDate(tsMin, 'yyyy MM dd HH mm ss fff').split(' ');
        var maxD = this.formatDate(tsMax, 'yyyy MM dd HH mm ss fff').split(' ');
        return {
          minMillisecond: parseInt(minD[6], 10),
          maxMillisecond: parseInt(maxD[6], 10),
          minSecond: parseInt(minD[5], 10),
          maxSecond: parseInt(maxD[5], 10),
          minMinute: parseInt(minD[4], 10),
          maxMinute: parseInt(maxD[4], 10),
          minHour: parseInt(minD[3], 10),
          maxHour: parseInt(maxD[3], 10),
          minDate: parseInt(minD[2], 10),
          maxDate: parseInt(maxD[2], 10),
          minMonth: parseInt(minD[1], 10) - 1,
          maxMonth: parseInt(maxD[1], 10) - 1,
          minYear: parseInt(minD[0], 10),
          maxYear: parseInt(maxD[0], 10)
        };
      }
    }, {
      key: "isLeapYear",
      value: function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
    }, {
      key: "calculcateLastDaysOfMonth",
      value: function calculcateLastDaysOfMonth(month, year, subtract) {
        var days = this.determineDaysOfMonths(month, year);

        // whatever days we get, subtract the number of days asked
        return days - subtract;
      }
    }, {
      key: "determineDaysOfYear",
      value: function determineDaysOfYear(year) {
        var days = 365;
        if (this.isLeapYear(year)) {
          days = 366;
        }
        return days;
      }
    }, {
      key: "determineRemainingDaysOfYear",
      value: function determineRemainingDaysOfYear(year, month, date) {
        var dayOfYear = this.daysCntOfYear[month] + date;
        if (month > 1 && this.isLeapYear()) dayOfYear++;
        return dayOfYear;
      }
    }, {
      key: "determineDaysOfMonths",
      value: function determineDaysOfMonths(month, year) {
        var days = 30;
        month = Utils$1.monthMod(month);
        switch (true) {
          case this.months30.indexOf(month) > -1:
            if (month === 2) {
              if (this.isLeapYear(year)) {
                days = 29;
              } else {
                days = 28;
              }
            }
            break;
          case this.months31.indexOf(month) > -1:
            days = 31;
            break;
          default:
            days = 31;
            break;
        }
        return days;
      }
    }]);
    return DateTime;
  }();

  /**
   * ApexCharts Formatter Class for setting value formatters for axes as well as tooltips.
   *
   * @module Formatters
   **/
  var Formatters = /*#__PURE__*/function () {
    function Formatters(ctx) {
      _classCallCheck(this, Formatters);
      this.ctx = ctx;
      this.w = ctx.w;
      this.tooltipKeyFormat = 'dd MMM';
    }
    _createClass(Formatters, [{
      key: "xLabelFormat",
      value: function xLabelFormat(fn, val, timestamp, opts) {
        var w = this.w;
        if (w.config.xaxis.type === 'datetime') {
          if (w.config.xaxis.labels.formatter === undefined) {
            // if user has not specified a custom formatter, use the default tooltip.x.format
            if (w.config.tooltip.x.formatter === undefined) {
              var datetimeObj = new DateTime(this.ctx);
              return datetimeObj.formatDate(datetimeObj.getDate(val), w.config.tooltip.x.format);
            }
          }
        }
        return fn(val, timestamp, opts);
      }
    }, {
      key: "defaultGeneralFormatter",
      value: function defaultGeneralFormatter(val) {
        if (Array.isArray(val)) {
          return val.map(function (v) {
            return v;
          });
        } else {
          return val;
        }
      }
    }, {
      key: "defaultYFormatter",
      value: function defaultYFormatter(v, yaxe, i) {
        var w = this.w;
        if (Utils$1.isNumber(v)) {
          if (w.globals.yValueDecimal !== 0) {
            v = v.toFixed(yaxe.decimalsInFloat !== undefined ? yaxe.decimalsInFloat : w.globals.yValueDecimal);
          } else {
            // We have an integer value but the label is not an integer. We can
            // deduce this is due to the number of ticks exceeding the even lower
            // integer range. Add an additional decimal place only in this case.
            var f = v.toFixed(0);
            // Do not change the == to ===
            v = v == f ? f : v.toFixed(1);
          }
        }
        return v;
      }
    }, {
      key: "setLabelFormatters",
      value: function setLabelFormatters() {
        var _this = this;
        var w = this.w;
        w.globals.xaxisTooltipFormatter = function (val) {
          return _this.defaultGeneralFormatter(val);
        };
        w.globals.ttKeyFormatter = function (val) {
          return _this.defaultGeneralFormatter(val);
        };
        w.globals.ttZFormatter = function (val) {
          return val;
        };
        w.globals.legendFormatter = function (val) {
          return _this.defaultGeneralFormatter(val);
        };

        // formatter function will always overwrite format property
        if (w.config.xaxis.labels.formatter !== undefined) {
          w.globals.xLabelFormatter = w.config.xaxis.labels.formatter;
        } else {
          w.globals.xLabelFormatter = function (val) {
            if (Utils$1.isNumber(val)) {
              if (!w.config.xaxis.convertedCatToNumeric && w.config.xaxis.type === 'numeric') {
                if (Utils$1.isNumber(w.config.xaxis.decimalsInFloat)) {
                  return val.toFixed(w.config.xaxis.decimalsInFloat);
                } else {
                  var diff = w.globals.maxX - w.globals.minX;
                  if (diff > 0 && diff < 100) {
                    return val.toFixed(1);
                  }
                  return val.toFixed(0);
                }
              }
              if (w.globals.isBarHorizontal) {
                var range = w.globals.maxY - w.globals.minYArr;
                if (range < 4) {
                  return val.toFixed(1);
                }
              }
              return val.toFixed(0);
            }
            return val;
          };
        }
        if (typeof w.config.tooltip.x.formatter === 'function') {
          w.globals.ttKeyFormatter = w.config.tooltip.x.formatter;
        } else {
          w.globals.ttKeyFormatter = w.globals.xLabelFormatter;
        }
        if (typeof w.config.xaxis.tooltip.formatter === 'function') {
          w.globals.xaxisTooltipFormatter = w.config.xaxis.tooltip.formatter;
        }
        if (Array.isArray(w.config.tooltip.y)) {
          w.globals.ttVal = w.config.tooltip.y;
        } else {
          if (w.config.tooltip.y.formatter !== undefined) {
            w.globals.ttVal = w.config.tooltip.y;
          }
        }
        if (w.config.tooltip.z.formatter !== undefined) {
          w.globals.ttZFormatter = w.config.tooltip.z.formatter;
        }

        // legend formatter - if user wants to append any global values of series to legend text
        if (w.config.legend.formatter !== undefined) {
          w.globals.legendFormatter = w.config.legend.formatter;
        }

        // formatter function will always overwrite format property
        w.config.yaxis.forEach(function (yaxe, i) {
          if (yaxe.labels.formatter !== undefined) {
            w.globals.yLabelFormatters[i] = yaxe.labels.formatter;
          } else {
            w.globals.yLabelFormatters[i] = function (val) {
              if (!w.globals.xyCharts) return val;
              if (Array.isArray(val)) {
                return val.map(function (v) {
                  return _this.defaultYFormatter(v, yaxe, i);
                });
              } else {
                return _this.defaultYFormatter(val, yaxe, i);
              }
            };
          }
        });
        return w.globals;
      }
    }, {
      key: "heatmapLabelFormatters",
      value: function heatmapLabelFormatters() {
        var w = this.w;
        if (w.config.chart.type === 'heatmap') {
          w.globals.yAxisScale[0].result = w.globals.seriesNames.slice();

          //  get the longest string from the labels array and also apply label formatter to it
          var longest = w.globals.seriesNames.reduce(function (a, b) {
            return a.length > b.length ? a : b;
          }, 0);
          w.globals.yAxisScale[0].niceMax = longest;
          w.globals.yAxisScale[0].niceMin = longest;
        }
      }
    }]);
    return Formatters;
  }();

  var AxesUtils = /*#__PURE__*/function () {
    function AxesUtils(ctx) {
      _classCallCheck(this, AxesUtils);
      this.ctx = ctx;
      this.w = ctx.w;
    }

    // Based on the formatter function, get the label text and position
    _createClass(AxesUtils, [{
      key: "getLabel",
      value: function getLabel(labels, timescaleLabels, x, i) {
        var drawnLabels = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
        var fontSize = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '12px';
        var isLeafGroup = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
        var w = this.w;
        var rawLabel = typeof labels[i] === 'undefined' ? '' : labels[i];
        var label = rawLabel;
        var xlbFormatter = w.globals.xLabelFormatter;
        var customFormatter = w.config.xaxis.labels.formatter;
        var isBold = false;
        var xFormat = new Formatters(this.ctx);
        var timestamp = rawLabel;
        if (isLeafGroup) {
          label = xFormat.xLabelFormat(xlbFormatter, rawLabel, timestamp, {
            i: i,
            dateFormatter: new DateTime(this.ctx).formatDate,
            w: w
          });
          if (customFormatter !== undefined) {
            label = customFormatter(rawLabel, labels[i], {
              i: i,
              dateFormatter: new DateTime(this.ctx).formatDate,
              w: w
            });
          }
        }
        var determineHighestUnit = function determineHighestUnit(unit) {
          var highestUnit = null;
          timescaleLabels.forEach(function (t) {
            if (t.unit === 'month') {
              highestUnit = 'year';
            } else if (t.unit === 'day') {
              highestUnit = 'month';
            } else if (t.unit === 'hour') {
              highestUnit = 'day';
            } else if (t.unit === 'minute') {
              highestUnit = 'hour';
            }
          });
          return highestUnit === unit;
        };
        if (timescaleLabels.length > 0) {
          isBold = determineHighestUnit(timescaleLabels[i].unit);
          x = timescaleLabels[i].position;
          label = timescaleLabels[i].value;
        } else {
          if (w.config.xaxis.type === 'datetime' && customFormatter === undefined) {
            label = '';
          }
        }
        if (typeof label === 'undefined') label = '';
        label = Array.isArray(label) ? label : label.toString();
        var graphics = new Graphics(this.ctx);
        var textRect = {};
        if (w.globals.rotateXLabels && isLeafGroup) {
          textRect = graphics.getTextRects(label, parseInt(fontSize, 10), null, "rotate(".concat(w.config.xaxis.labels.rotate, " 0 0)"), false);
        } else {
          textRect = graphics.getTextRects(label, parseInt(fontSize, 10));
        }
        var allowDuplicatesInTimeScale = !w.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
        if (!Array.isArray(label) && (String(label) === 'NaN' || drawnLabels.indexOf(label) >= 0 && allowDuplicatesInTimeScale)) {
          label = '';
        }
        return {
          x: x,
          text: label,
          textRect: textRect,
          isBold: isBold
        };
      }
    }, {
      key: "checkLabelBasedOnTickamount",
      value: function checkLabelBasedOnTickamount(i, label, labelsLen) {
        var w = this.w;
        var ticks = w.config.xaxis.tickAmount;
        if (ticks === 'dataPoints') ticks = Math.round(w.globals.gridWidth / 120);
        if (ticks > labelsLen) return label;
        var tickMultiple = Math.round(labelsLen / (ticks + 1));
        if (i % tickMultiple === 0) {
          return label;
        } else {
          label.text = '';
        }
        return label;
      }
    }, {
      key: "checkForOverflowingLabels",
      value: function checkForOverflowingLabels(i, label, labelsLen, drawnLabels, drawnLabelsRects) {
        var w = this.w;
        if (i === 0) {
          // check if first label is being truncated
          if (w.globals.skipFirstTimelinelabel) {
            label.text = '';
          }
        }
        if (i === labelsLen - 1) {
          // check if last label is being truncated
          if (w.globals.skipLastTimelinelabel) {
            label.text = '';
          }
        }
        if (w.config.xaxis.labels.hideOverlappingLabels && drawnLabels.length > 0) {
          var prev = drawnLabelsRects[drawnLabelsRects.length - 1];
          if (w.config.xaxis.labels.trim && w.config.xaxis.type !== 'datetime') {
            return label;
          }
          if (label.x < prev.textRect.width / (w.globals.rotateXLabels ? Math.abs(w.config.xaxis.labels.rotate) / 12 : 1.01) + prev.x) {
            label.text = '';
          }
        }
        return label;
      }
    }, {
      key: "checkForReversedLabels",
      value: function checkForReversedLabels(i, labels) {
        var w = this.w;
        if (w.config.yaxis[i] && w.config.yaxis[i].reversed) {
          labels.reverse();
        }
        return labels;
      }
    }, {
      key: "yAxisAllSeriesCollapsed",
      value: function yAxisAllSeriesCollapsed(index) {
        var gl = this.w.globals;
        return !gl.seriesYAxisMap[index].some(function (si) {
          return gl.collapsedSeriesIndices.indexOf(si) === -1;
        });
      }

      // Method to translate annotation.yAxisIndex values from
      // seriesName-as-a-string values to seriesName-as-an-array values (old style
      // series mapping to new style).
    }, {
      key: "translateYAxisIndex",
      value: function translateYAxisIndex(index) {
        var w = this.w;
        var gl = w.globals;
        var yaxis = w.config.yaxis;
        var newStyle = gl.series.length > yaxis.length || yaxis.some(function (a) {
          return Array.isArray(a.seriesName);
        });
        if (newStyle) {
          return index;
        } else {
          return gl.seriesYAxisReverseMap[index];
        }
      }
    }, {
      key: "isYAxisHidden",
      value: function isYAxisHidden(index) {
        var w = this.w;
        var yaxis = w.config.yaxis[index];
        if (!yaxis.show || this.yAxisAllSeriesCollapsed(index)) {
          return true;
        }
        if (!yaxis.showForNullSeries) {
          var seriesIndices = w.globals.seriesYAxisMap[index];
          var coreUtils = new CoreUtils(this.ctx);
          return seriesIndices.every(function (si) {
            return coreUtils.isSeriesNull(si);
          });
        }
        return false;
      }

      // get the label color for y-axis
      // realIndex is the actual series index, while i is the tick Index
    }, {
      key: "getYAxisForeColor",
      value: function getYAxisForeColor(yColors, realIndex) {
        var w = this.w;
        if (Array.isArray(yColors) && w.globals.yAxisScale[realIndex]) {
          this.ctx.theme.pushExtraColors(yColors, w.globals.yAxisScale[realIndex].result.length, false);
        }
        return yColors;
      }
    }, {
      key: "drawYAxisTicks",
      value: function drawYAxisTicks(x, tickAmount, axisBorder, axisTicks, realIndex, labelsDivider, elYaxis) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);

        // initial label position = 0;
        var tY = w.globals.translateY + w.config.yaxis[realIndex].labels.offsetY;
        if (w.globals.isBarHorizontal) {
          tY = 0;
        } else if (w.config.chart.type === 'heatmap') {
          tY += labelsDivider / 2;
        }
        if (axisTicks.show && tickAmount > 0) {
          if (w.config.yaxis[realIndex].opposite === true) x = x + axisTicks.width;
          for (var i = tickAmount; i >= 0; i--) {
            var elTick = graphics.drawLine(x + axisBorder.offsetX - axisTicks.width + axisTicks.offsetX, tY + axisTicks.offsetY, x + axisBorder.offsetX + axisTicks.offsetX, tY + axisTicks.offsetY, axisTicks.color);
            elYaxis.add(elTick);
            tY += labelsDivider;
          }
        }
      }
    }]);
    return AxesUtils;
  }();

  var YAnnotations = /*#__PURE__*/function () {
    function YAnnotations(annoCtx) {
      _classCallCheck(this, YAnnotations);
      this.w = annoCtx.w;
      this.annoCtx = annoCtx;
      this.helpers = new Helpers$4(this.annoCtx);
      this.axesUtils = new AxesUtils(this.annoCtx);
    }
    _createClass(YAnnotations, [{
      key: "addYaxisAnnotation",
      value: function addYaxisAnnotation(anno, parent, index) {
        var w = this.w;
        var strokeDashArray = anno.strokeDashArray;
        var result = this.helpers.getY1Y2('y1', anno);
        var y1 = result.yP;
        var clipY1 = result.clipped;
        var y2;
        var clipY2 = true;
        var drawn = false;
        var text = anno.label.text;
        if (anno.y2 === null || typeof anno.y2 === 'undefined') {
          if (!clipY1) {
            drawn = true;
            var line = this.annoCtx.graphics.drawLine(0 + anno.offsetX,
            // x1
            y1 + anno.offsetY,
            // y1
            this._getYAxisAnnotationWidth(anno),
            // x2
            y1 + anno.offsetY,
            // y2
            anno.borderColor,
            // lineColor
            strokeDashArray,
            // dashArray
            anno.borderWidth);
            parent.appendChild(line.node);
            if (anno.id) {
              line.node.classList.add(anno.id);
            }
          }
        } else {
          result = this.helpers.getY1Y2('y2', anno);
          y2 = result.yP;
          clipY2 = result.clipped;
          if (y2 > y1) {
            var temp = y1;
            y1 = y2;
            y2 = temp;
          }
          if (!(clipY1 && clipY2)) {
            drawn = true;
            var rect = this.annoCtx.graphics.drawRect(0 + anno.offsetX,
            // x1
            y2 + anno.offsetY,
            // y1
            this._getYAxisAnnotationWidth(anno),
            // x2
            y1 - y2,
            // y2
            0,
            // radius
            anno.fillColor,
            // color
            anno.opacity,
            // opacity,
            1,
            // strokeWidth
            anno.borderColor,
            // strokeColor
            strokeDashArray // stokeDashArray
            );
            rect.node.classList.add('apexcharts-annotation-rect');
            rect.attr('clip-path', "url(#gridRectMask".concat(w.globals.cuid, ")"));
            parent.appendChild(rect.node);
            if (anno.id) {
              rect.node.classList.add(anno.id);
            }
          }
        }
        if (drawn) {
          var textX = anno.label.position === 'right' ? w.globals.gridWidth : anno.label.position === 'center' ? w.globals.gridWidth / 2 : 0;
          var elText = this.annoCtx.graphics.drawText({
            x: textX + anno.label.offsetX,
            y: (y2 != null ? y2 : y1) + anno.label.offsetY - 3,
            text: text,
            textAnchor: anno.label.textAnchor,
            fontSize: anno.label.style.fontSize,
            fontFamily: anno.label.style.fontFamily,
            fontWeight: anno.label.style.fontWeight,
            foreColor: anno.label.style.color,
            cssClass: "apexcharts-yaxis-annotation-label ".concat(anno.label.style.cssClass, " ").concat(anno.id ? anno.id : '')
          });
          elText.attr({
            rel: index
          });
          parent.appendChild(elText.node);
        }
      }
    }, {
      key: "_getYAxisAnnotationWidth",
      value: function _getYAxisAnnotationWidth(anno) {
        // issue apexcharts.js#2009
        var w = this.w;
        var width = w.globals.gridWidth;
        if (anno.width.indexOf('%') > -1) {
          width = w.globals.gridWidth * parseInt(anno.width, 10) / 100;
        } else {
          width = parseInt(anno.width, 10);
        }
        return width + anno.offsetX;
      }
    }, {
      key: "drawYAxisAnnotations",
      value: function drawYAxisAnnotations() {
        var _this = this;
        var w = this.w;
        var elg = this.annoCtx.graphics.group({
          class: 'apexcharts-yaxis-annotations'
        });
        w.config.annotations.yaxis.forEach(function (anno, index) {
          anno.yAxisIndex = _this.axesUtils.translateYAxisIndex(anno.yAxisIndex);
          if (!(_this.axesUtils.isYAxisHidden(anno.yAxisIndex) && _this.axesUtils.yAxisAllSeriesCollapsed(anno.yAxisIndex))) {
            _this.addYaxisAnnotation(anno, elg.node, index);
          }
        });
        return elg;
      }
    }]);
    return YAnnotations;
  }();

  var PointAnnotations = /*#__PURE__*/function () {
    function PointAnnotations(annoCtx) {
      _classCallCheck(this, PointAnnotations);
      this.w = annoCtx.w;
      this.annoCtx = annoCtx;
      this.helpers = new Helpers$4(this.annoCtx);
    }
    _createClass(PointAnnotations, [{
      key: "addPointAnnotation",
      value: function addPointAnnotation(anno, parent, index) {
        var w = this.w;
        if (w.globals.collapsedSeriesIndices.indexOf(anno.seriesIndex) > -1) {
          return;
        }
        var result = this.helpers.getX1X2('x1', anno);
        var x = result.x;
        var clipX = result.clipped;
        result = this.helpers.getY1Y2('y1', anno);
        var y = result.yP;
        var clipY = result.clipped;
        if (!Utils$1.isNumber(x)) return;
        if (!(clipY || clipX)) {
          var optsPoints = {
            pSize: anno.marker.size,
            pointStrokeWidth: anno.marker.strokeWidth,
            pointFillColor: anno.marker.fillColor,
            pointStrokeColor: anno.marker.strokeColor,
            shape: anno.marker.shape,
            pRadius: anno.marker.radius,
            class: "apexcharts-point-annotation-marker ".concat(anno.marker.cssClass, " ").concat(anno.id ? anno.id : '')
          };
          var point = this.annoCtx.graphics.drawMarker(x + anno.marker.offsetX, y + anno.marker.offsetY, optsPoints);
          parent.appendChild(point.node);
          var text = anno.label.text ? anno.label.text : '';
          var elText = this.annoCtx.graphics.drawText({
            x: x + anno.label.offsetX,
            y: y + anno.label.offsetY - anno.marker.size - parseFloat(anno.label.style.fontSize) / 1.6,
            text: text,
            textAnchor: anno.label.textAnchor,
            fontSize: anno.label.style.fontSize,
            fontFamily: anno.label.style.fontFamily,
            fontWeight: anno.label.style.fontWeight,
            foreColor: anno.label.style.color,
            cssClass: "apexcharts-point-annotation-label ".concat(anno.label.style.cssClass, " ").concat(anno.id ? anno.id : '')
          });
          elText.attr({
            rel: index
          });
          parent.appendChild(elText.node);

          // TODO: deprecate this as we will use custom
          if (anno.customSVG.SVG) {
            var g = this.annoCtx.graphics.group({
              class: 'apexcharts-point-annotations-custom-svg ' + anno.customSVG.cssClass
            });
            g.attr({
              transform: "translate(".concat(x + anno.customSVG.offsetX, ", ").concat(y + anno.customSVG.offsetY, ")")
            });
            g.node.innerHTML = anno.customSVG.SVG;
            parent.appendChild(g.node);
          }
          if (anno.image.path) {
            var imgWidth = anno.image.width ? anno.image.width : 20;
            var imgHeight = anno.image.height ? anno.image.height : 20;
            point = this.annoCtx.addImage({
              x: x + anno.image.offsetX - imgWidth / 2,
              y: y + anno.image.offsetY - imgHeight / 2,
              width: imgWidth,
              height: imgHeight,
              path: anno.image.path,
              appendTo: '.apexcharts-point-annotations'
            });
          }
          if (anno.mouseEnter) {
            point.node.addEventListener('mouseenter', anno.mouseEnter.bind(this, anno));
          }
          if (anno.mouseLeave) {
            point.node.addEventListener('mouseleave', anno.mouseLeave.bind(this, anno));
          }
          if (anno.click) {
            point.node.addEventListener('click', anno.click.bind(this, anno));
          }
        }
      }
    }, {
      key: "drawPointAnnotations",
      value: function drawPointAnnotations() {
        var _this = this;
        var w = this.w;
        var elg = this.annoCtx.graphics.group({
          class: 'apexcharts-point-annotations'
        });
        w.config.annotations.points.map(function (anno, index) {
          _this.addPointAnnotation(anno, elg.node, index);
        });
        return elg;
      }
    }]);
    return PointAnnotations;
  }();

  const name = "en";
  const options = {
  	months: [
  		"January",
  		"February",
  		"March",
  		"April",
  		"May",
  		"June",
  		"July",
  		"August",
  		"September",
  		"October",
  		"November",
  		"December"
  	],
  	shortMonths: [
  		"Jan",
  		"Feb",
  		"Mar",
  		"Apr",
  		"May",
  		"Jun",
  		"Jul",
  		"Aug",
  		"Sep",
  		"Oct",
  		"Nov",
  		"Dec"
  	],
  	days: [
  		"Sunday",
  		"Monday",
  		"Tuesday",
  		"Wednesday",
  		"Thursday",
  		"Friday",
  		"Saturday"
  	],
  	shortDays: [
  		"Sun",
  		"Mon",
  		"Tue",
  		"Wed",
  		"Thu",
  		"Fri",
  		"Sat"
  	],
  	toolbar: {
  		exportToSVG: "Download SVG",
  		exportToPNG: "Download PNG",
  		exportToCSV: "Download CSV",
  		exportToXLS: "Download XLS",
  		menu: "Menu",
  		selection: "Selection",
  		selectionZoom: "Selection Zoom",
  		zoomIn: "Zoom In",
  		zoomOut: "Zoom Out",
  		pan: "Panning",
  		reset: "Reset Zoom"
  	}
  };
  var en = {
  	name: name,
  	options: options
  };

  var Options = /*#__PURE__*/function () {
    function Options() {
      _classCallCheck(this, Options);
      this.yAxis = {
        show: true,
        showAlways: false,
        showForNullSeries: true,
        seriesName: undefined,
        opposite: false,
        reversed: false,
        logarithmic: false,
        logBase: 10,
        tickAmount: undefined,
        stepSize: undefined,
        forceNiceScale: false,
        max: undefined,
        min: undefined,
        floating: false,
        decimalsInFloat: undefined,
        labels: {
          show: true,
          showDuplicates: false,
          minWidth: 0,
          maxWidth: 160,
          offsetX: 0,
          offsetY: 0,
          align: undefined,
          rotate: 0,
          padding: 20,
          style: {
            colors: [],
            fontSize: '11px',
            fontWeight: 400,
            fontFamily: undefined,
            cssClass: ''
          },
          formatter: undefined
        },
        axisBorder: {
          show: false,
          color: '#e0e0e0',
          width: 1,
          offsetX: 0,
          offsetY: 0
        },
        axisTicks: {
          show: false,
          color: '#e0e0e0',
          width: 6,
          offsetX: 0,
          offsetY: 0
        },
        title: {
          text: undefined,
          rotate: -90,
          offsetY: 0,
          offsetX: 0,
          style: {
            color: undefined,
            fontSize: '11px',
            fontWeight: 900,
            fontFamily: undefined,
            cssClass: ''
          }
        },
        tooltip: {
          enabled: false,
          offsetX: 0
        },
        crosshairs: {
          show: true,
          position: 'front',
          stroke: {
            color: '#b6b6b6',
            width: 1,
            dashArray: 0
          }
        }
      };
      this.pointAnnotation = {
        id: undefined,
        x: 0,
        y: null,
        yAxisIndex: 0,
        seriesIndex: undefined,
        mouseEnter: undefined,
        mouseLeave: undefined,
        click: undefined,
        marker: {
          size: 4,
          fillColor: '#fff',
          strokeWidth: 2,
          strokeColor: '#333',
          shape: 'circle',
          offsetX: 0,
          offsetY: 0,
          // radius: 2, // DEPRECATED
          cssClass: ''
        },
        label: {
          borderColor: '#c2c2c2',
          borderWidth: 1,
          borderRadius: 2,
          text: undefined,
          textAnchor: 'middle',
          offsetX: 0,
          offsetY: 0,
          mouseEnter: undefined,
          mouseLeave: undefined,
          click: undefined,
          style: {
            background: '#fff',
            color: undefined,
            fontSize: '11px',
            fontFamily: undefined,
            fontWeight: 400,
            cssClass: '',
            padding: {
              left: 5,
              right: 5,
              top: 2,
              bottom: 2
            }
          }
        },
        customSVG: {
          // this will be deprecated in the next major version as it is going to be replaced with a better alternative below (image)
          SVG: undefined,
          cssClass: undefined,
          offsetX: 0,
          offsetY: 0
        },
        image: {
          path: undefined,
          width: 20,
          height: 20,
          offsetX: 0,
          offsetY: 0
        }
      };
      this.yAxisAnnotation = {
        id: undefined,
        y: 0,
        y2: null,
        strokeDashArray: 1,
        fillColor: '#c2c2c2',
        borderColor: '#c2c2c2',
        borderWidth: 1,
        opacity: 0.3,
        offsetX: 0,
        offsetY: 0,
        width: '100%',
        yAxisIndex: 0,
        label: {
          borderColor: '#c2c2c2',
          borderWidth: 1,
          borderRadius: 2,
          text: undefined,
          textAnchor: 'end',
          position: 'right',
          offsetX: 0,
          offsetY: -3,
          mouseEnter: undefined,
          mouseLeave: undefined,
          click: undefined,
          style: {
            background: '#fff',
            color: undefined,
            fontSize: '11px',
            fontFamily: undefined,
            fontWeight: 400,
            cssClass: '',
            padding: {
              left: 5,
              right: 5,
              top: 2,
              bottom: 2
            }
          }
        }
      };
      this.xAxisAnnotation = {
        id: undefined,
        x: 0,
        x2: null,
        strokeDashArray: 1,
        fillColor: '#c2c2c2',
        borderColor: '#c2c2c2',
        borderWidth: 1,
        opacity: 0.3,
        offsetX: 0,
        offsetY: 0,
        label: {
          borderColor: '#c2c2c2',
          borderWidth: 1,
          borderRadius: 2,
          text: undefined,
          textAnchor: 'middle',
          orientation: 'vertical',
          position: 'top',
          offsetX: 0,
          offsetY: 0,
          mouseEnter: undefined,
          mouseLeave: undefined,
          click: undefined,
          style: {
            background: '#fff',
            color: undefined,
            fontSize: '11px',
            fontFamily: undefined,
            fontWeight: 400,
            cssClass: '',
            padding: {
              left: 5,
              right: 5,
              top: 2,
              bottom: 2
            }
          }
        }
      };
      this.text = {
        x: 0,
        y: 0,
        text: '',
        textAnchor: 'start',
        foreColor: undefined,
        fontSize: '13px',
        fontFamily: undefined,
        fontWeight: 400,
        appendTo: '.apexcharts-annotations',
        backgroundColor: 'transparent',
        borderColor: '#c2c2c2',
        borderRadius: 0,
        borderWidth: 0,
        paddingLeft: 4,
        paddingRight: 4,
        paddingTop: 2,
        paddingBottom: 2
      };
    }
    _createClass(Options, [{
      key: "init",
      value: function init() {
        return {
          annotations: {
            yaxis: [this.yAxisAnnotation],
            xaxis: [this.xAxisAnnotation],
            points: [this.pointAnnotation],
            texts: [],
            images: [],
            shapes: []
          },
          chart: {
            animations: {
              enabled: true,
              speed: 800,
              animateGradually: {
                delay: 150,
                enabled: true
              },
              dynamicAnimation: {
                enabled: true,
                speed: 350
              }
            },
            background: '',
            locales: [en],
            defaultLocale: 'en',
            dropShadow: {
              enabled: false,
              enabledOnSeries: undefined,
              top: 2,
              left: 2,
              blur: 4,
              color: '#000',
              opacity: 0.7
            },
            events: {
              animationEnd: undefined,
              beforeMount: undefined,
              mounted: undefined,
              updated: undefined,
              click: undefined,
              mouseMove: undefined,
              mouseLeave: undefined,
              xAxisLabelClick: undefined,
              legendClick: undefined,
              markerClick: undefined,
              selection: undefined,
              dataPointSelection: undefined,
              dataPointMouseEnter: undefined,
              dataPointMouseLeave: undefined,
              beforeZoom: undefined,
              beforeResetZoom: undefined,
              zoomed: undefined,
              scrolled: undefined,
              brushScrolled: undefined
            },
            foreColor: '#373d3f',
            fontFamily: 'Helvetica, Arial, sans-serif',
            height: 'auto',
            parentHeightOffset: 15,
            redrawOnParentResize: true,
            redrawOnWindowResize: true,
            id: undefined,
            group: undefined,
            nonce: undefined,
            offsetX: 0,
            offsetY: 0,
            injectStyleSheet: true,
            selection: {
              enabled: false,
              type: 'x',
              // selectedPoints: undefined, // default datapoints that should be selected automatically
              fill: {
                color: '#24292e',
                opacity: 0.1
              },
              stroke: {
                width: 1,
                color: '#24292e',
                opacity: 0.4,
                dashArray: 3
              },
              xaxis: {
                min: undefined,
                max: undefined
              },
              yaxis: {
                min: undefined,
                max: undefined
              }
            },
            sparkline: {
              enabled: false
            },
            brush: {
              enabled: false,
              autoScaleYaxis: true,
              target: undefined,
              targets: undefined
            },
            stacked: false,
            stackOnlyBar: true,
            // mixed chart with stacked bars and line series - incorrect line draw #907
            stackType: 'normal',
            toolbar: {
              show: true,
              offsetX: 0,
              offsetY: 0,
              tools: {
                download: true,
                selection: true,
                zoom: true,
                zoomin: true,
                zoomout: true,
                pan: true,
                reset: true,
                customIcons: []
              },
              export: {
                csv: {
                  filename: undefined,
                  columnDelimiter: ',',
                  headerCategory: 'category',
                  headerValue: 'value',
                  categoryFormatter: undefined,
                  valueFormatter: undefined
                },
                png: {
                  filename: undefined
                },
                svg: {
                  filename: undefined
                },
                scale: undefined,
                width: undefined
              },
              autoSelected: 'zoom' // accepts -> zoom, pan, selection
            },
            type: 'line',
            width: '100%',
            zoom: {
              enabled: true,
              type: 'x',
              autoScaleYaxis: false,
              allowMouseWheelZoom: true,
              zoomedArea: {
                fill: {
                  color: '#90CAF9',
                  opacity: 0.4
                },
                stroke: {
                  color: '#0D47A1',
                  opacity: 0.4,
                  width: 1
                }
              }
            }
          },
          parsing: {
            x: undefined,
            y: undefined
          },
          plotOptions: {
            line: {
              isSlopeChart: false,
              colors: {
                threshold: 0,
                colorAboveThreshold: undefined,
                colorBelowThreshold: undefined
              }
            },
            area: {
              fillTo: 'origin'
            },
            bar: {
              horizontal: false,
              columnWidth: '70%',
              // should be in percent 0 - 100
              barHeight: '70%',
              // should be in percent 0 - 100
              distributed: false,
              borderRadius: 0,
              borderRadiusApplication: 'around',
              // [around, end]
              borderRadiusWhenStacked: 'last',
              // [all, last]
              rangeBarOverlap: true,
              rangeBarGroupRows: false,
              hideZeroBarsWhenGrouped: false,
              isDumbbell: false,
              dumbbellColors: undefined,
              isFunnel: false,
              isFunnel3d: true,
              colors: {
                ranges: [],
                backgroundBarColors: [],
                backgroundBarOpacity: 1,
                backgroundBarRadius: 0
              },
              dataLabels: {
                position: 'top',
                // top, center, bottom
                maxItems: 100,
                hideOverflowingLabels: true,
                orientation: 'horizontal',
                total: {
                  enabled: false,
                  formatter: undefined,
                  offsetX: 0,
                  offsetY: 0,
                  style: {
                    color: '#373d3f',
                    fontSize: '12px',
                    fontFamily: undefined,
                    fontWeight: 600
                  }
                }
              }
            },
            bubble: {
              zScaling: true,
              minBubbleRadius: undefined,
              maxBubbleRadius: undefined
            },
            candlestick: {
              colors: {
                upward: '#00B746',
                downward: '#EF403C'
              },
              wick: {
                useFillColor: true
              }
            },
            boxPlot: {
              colors: {
                upper: '#00E396',
                lower: '#008FFB'
              }
            },
            heatmap: {
              radius: 2,
              enableShades: true,
              shadeIntensity: 0.5,
              reverseNegativeShade: false,
              distributed: false,
              useFillColorAsStroke: false,
              colorScale: {
                inverse: false,
                ranges: [],
                min: undefined,
                max: undefined
              }
            },
            treemap: {
              enableShades: true,
              shadeIntensity: 0.5,
              distributed: false,
              reverseNegativeShade: false,
              useFillColorAsStroke: false,
              borderRadius: 4,
              dataLabels: {
                format: 'scale' // scale | truncate
              },
              colorScale: {
                inverse: false,
                ranges: [],
                min: undefined,
                max: undefined
              },
              seriesTitle: {
                show: true,
                offsetY: 1,
                offsetX: 1,
                borderColor: '#000',
                borderWidth: 1,
                borderRadius: 2,
                style: {
                  background: 'rgba(0, 0, 0, 0.6)',
                  color: '#fff',
                  fontSize: '12px',
                  fontFamily: undefined,
                  fontWeight: 400,
                  cssClass: '',
                  padding: {
                    left: 6,
                    right: 6,
                    top: 2,
                    bottom: 2
                  }
                }
              }
            },
            radialBar: {
              inverseOrder: false,
              startAngle: 0,
              endAngle: 360,
              offsetX: 0,
              offsetY: 0,
              hollow: {
                margin: 5,
                size: '50%',
                background: 'transparent',
                image: undefined,
                imageWidth: 150,
                imageHeight: 150,
                imageOffsetX: 0,
                imageOffsetY: 0,
                imageClipped: true,
                position: 'front',
                dropShadow: {
                  enabled: false,
                  top: 0,
                  left: 0,
                  blur: 3,
                  color: '#000',
                  opacity: 0.5
                }
              },
              track: {
                show: true,
                startAngle: undefined,
                endAngle: undefined,
                background: '#f2f2f2',
                strokeWidth: '97%',
                opacity: 1,
                margin: 5,
                // margin is in pixels
                dropShadow: {
                  enabled: false,
                  top: 0,
                  left: 0,
                  blur: 3,
                  color: '#000',
                  opacity: 0.5
                }
              },
              dataLabels: {
                show: true,
                name: {
                  show: true,
                  fontSize: '16px',
                  fontFamily: undefined,
                  fontWeight: 600,
                  color: undefined,
                  offsetY: 0,
                  formatter: function formatter(val) {
                    return val;
                  }
                },
                value: {
                  show: true,
                  fontSize: '14px',
                  fontFamily: undefined,
                  fontWeight: 400,
                  color: undefined,
                  offsetY: 16,
                  formatter: function formatter(val) {
                    return val + '%';
                  }
                },
                total: {
                  show: false,
                  label: 'Total',
                  fontSize: '16px',
                  fontWeight: 600,
                  fontFamily: undefined,
                  color: undefined,
                  formatter: function formatter(w) {
                    return w.globals.seriesTotals.reduce(function (a, b) {
                      return a + b;
                    }, 0) / w.globals.series.length + '%';
                  }
                }
              },
              barLabels: {
                enabled: false,
                offsetX: 0,
                offsetY: 0,
                useSeriesColors: true,
                fontFamily: undefined,
                fontWeight: 600,
                fontSize: '16px',
                formatter: function formatter(val) {
                  return val;
                },
                onClick: undefined
              }
            },
            pie: {
              customScale: 1,
              offsetX: 0,
              offsetY: 0,
              startAngle: 0,
              endAngle: 360,
              expandOnClick: true,
              dataLabels: {
                // These are the percentage values which are displayed on slice
                offset: 0,
                // offset by which labels will move outside
                minAngleToShowLabel: 10
              },
              donut: {
                size: '65%',
                background: 'transparent',
                labels: {
                  // These are the inner labels appearing inside donut
                  show: false,
                  name: {
                    show: true,
                    fontSize: '16px',
                    fontFamily: undefined,
                    fontWeight: 600,
                    color: undefined,
                    offsetY: -10,
                    formatter: function formatter(val) {
                      return val;
                    }
                  },
                  value: {
                    show: true,
                    fontSize: '20px',
                    fontFamily: undefined,
                    fontWeight: 400,
                    color: undefined,
                    offsetY: 10,
                    formatter: function formatter(val) {
                      return val;
                    }
                  },
                  total: {
                    show: false,
                    showAlways: false,
                    label: 'Total',
                    fontSize: '16px',
                    fontWeight: 400,
                    fontFamily: undefined,
                    color: undefined,
                    formatter: function formatter(w) {
                      return w.globals.seriesTotals.reduce(function (a, b) {
                        return a + b;
                      }, 0);
                    }
                  }
                }
              }
            },
            polarArea: {
              rings: {
                strokeWidth: 1,
                strokeColor: '#e8e8e8'
              },
              spokes: {
                strokeWidth: 1,
                connectorColors: '#e8e8e8'
              }
            },
            radar: {
              size: undefined,
              offsetX: 0,
              offsetY: 0,
              polygons: {
                // strokeColor: '#e8e8e8', // should be deprecated in the minor version i.e 3.2
                strokeWidth: 1,
                strokeColors: '#e8e8e8',
                connectorColors: '#e8e8e8',
                fill: {
                  colors: undefined
                }
              }
            }
          },
          colors: undefined,
          dataLabels: {
            enabled: true,
            enabledOnSeries: undefined,
            formatter: function formatter(val) {
              return val !== null ? val : '';
            },
            textAnchor: 'middle',
            distributed: false,
            offsetX: 0,
            offsetY: 0,
            style: {
              fontSize: '12px',
              fontFamily: undefined,
              fontWeight: 600,
              colors: undefined
            },
            background: {
              enabled: true,
              foreColor: '#fff',
              backgroundColor: undefined,
              borderRadius: 2,
              padding: 4,
              opacity: 0.9,
              borderWidth: 1,
              borderColor: '#fff',
              dropShadow: {
                enabled: false,
                top: 1,
                left: 1,
                blur: 1,
                color: '#000',
                opacity: 0.8
              }
            },
            dropShadow: {
              enabled: false,
              top: 1,
              left: 1,
              blur: 1,
              color: '#000',
              opacity: 0.8
            }
          },
          fill: {
            type: 'solid',
            colors: undefined,
            // array of colors
            opacity: 0.85,
            gradient: {
              shade: 'dark',
              type: 'horizontal',
              shadeIntensity: 0.5,
              gradientToColors: undefined,
              inverseColors: true,
              opacityFrom: 1,
              opacityTo: 1,
              stops: [0, 50, 100],
              colorStops: []
            },
            image: {
              src: [],
              width: undefined,
              // optional
              height: undefined // optional
            },
            pattern: {
              style: 'squares',
              // String | Array of Strings
              width: 6,
              height: 6,
              strokeWidth: 2
            }
          },
          forecastDataPoints: {
            count: 0,
            fillOpacity: 0.5,
            strokeWidth: undefined,
            dashArray: 4
          },
          grid: {
            show: true,
            borderColor: '#e0e0e0',
            strokeDashArray: 0,
            position: 'back',
            xaxis: {
              lines: {
                show: false
              }
            },
            yaxis: {
              lines: {
                show: true
              }
            },
            row: {
              colors: undefined,
              // takes as array which will be repeated on rows
              opacity: 0.5
            },
            column: {
              colors: undefined,
              // takes an array which will be repeated on columns
              opacity: 0.5
            },
            padding: {
              top: 0,
              right: 10,
              bottom: 0,
              left: 12
            }
          },
          labels: [],
          legend: {
            show: true,
            showForSingleSeries: false,
            showForNullSeries: true,
            showForZeroSeries: true,
            floating: false,
            position: 'bottom',
            // whether to position legends in 1 of 4
            // direction - top, bottom, left, right
            horizontalAlign: 'center',
            // when position top/bottom, you can specify whether to align legends left, right or center
            inverseOrder: false,
            fontSize: '12px',
            fontFamily: undefined,
            fontWeight: 400,
            width: undefined,
            height: undefined,
            formatter: undefined,
            tooltipHoverFormatter: undefined,
            offsetX: -20,
            offsetY: 4,
            customLegendItems: [],
            clusterGroupedSeries: true,
            clusterGroupedSeriesOrientation: 'vertical',
            labels: {
              colors: undefined,
              useSeriesColors: false
            },
            markers: {
              size: 7,
              fillColors: undefined,
              strokeWidth: 1,
              shape: undefined,
              offsetX: 0,
              offsetY: 0,
              customHTML: undefined,
              onClick: undefined
            },
            itemMargin: {
              horizontal: 5,
              vertical: 4
            },
            onItemClick: {
              toggleDataSeries: true
            },
            onItemHover: {
              highlightDataSeries: true
            }
          },
          markers: {
            discrete: [],
            size: 0,
            colors: undefined,
            strokeColors: '#fff',
            strokeWidth: 2,
            strokeOpacity: 0.9,
            strokeDashArray: 0,
            fillOpacity: 1,
            shape: 'circle',
            offsetX: 0,
            offsetY: 0,
            showNullDataPoints: true,
            onClick: undefined,
            onDblClick: undefined,
            hover: {
              size: undefined,
              sizeOffset: 3
            }
          },
          noData: {
            text: undefined,
            align: 'center',
            verticalAlign: 'middle',
            offsetX: 0,
            offsetY: 0,
            style: {
              color: undefined,
              fontSize: '14px',
              fontFamily: undefined
            }
          },
          responsive: [],
          // breakpoints should follow ascending order 400, then 700, then 1000
          series: undefined,
          states: {
            hover: {
              filter: {
                type: 'lighten'
              }
            },
            active: {
              allowMultipleDataPointsSelection: false,
              filter: {
                type: 'darken'
              }
            }
          },
          title: {
            text: undefined,
            align: 'left',
            margin: 5,
            offsetX: 0,
            offsetY: 0,
            floating: false,
            style: {
              fontSize: '14px',
              fontWeight: 900,
              fontFamily: undefined,
              color: undefined
            }
          },
          subtitle: {
            text: undefined,
            align: 'left',
            margin: 5,
            offsetX: 0,
            offsetY: 30,
            floating: false,
            style: {
              fontSize: '12px',
              fontWeight: 400,
              fontFamily: undefined,
              color: undefined
            }
          },
          stroke: {
            show: true,
            curve: 'smooth',
            // "smooth" / "straight" / "monotoneCubic" / "stepline" / "linestep"
            lineCap: 'butt',
            // round, butt , square
            width: 2,
            colors: undefined,
            // array of colors
            dashArray: 0,
            // single value or array of values
            fill: {
              type: 'solid',
              colors: undefined,
              // array of colors
              opacity: 0.85,
              gradient: {
                shade: 'dark',
                type: 'horizontal',
                shadeIntensity: 0.5,
                gradientToColors: undefined,
                inverseColors: true,
                opacityFrom: 1,
                opacityTo: 1,
                stops: [0, 50, 100],
                colorStops: []
              }
            }
          },
          tooltip: {
            enabled: true,
            enabledOnSeries: undefined,
            shared: true,
            hideEmptySeries: false,
            followCursor: false,
            // when disabled, the tooltip will show on top of the series instead of mouse position
            intersect: false,
            // when enabled, tooltip will only show when user directly hovers over point
            inverseOrder: false,
            custom: undefined,
            fillSeriesColor: false,
            theme: 'light',
            cssClass: '',
            style: {
              fontSize: '12px',
              fontFamily: undefined
            },
            onDatasetHover: {
              highlightDataSeries: false
            },
            x: {
              // x value
              show: true,
              format: 'dd MMM',
              // dd/MM, dd MMM yy, dd MMM yyyy
              formatter: undefined // a custom user supplied formatter function
            },
            y: {
              formatter: undefined,
              title: {
                formatter: function formatter(seriesName) {
                  return seriesName ? seriesName + ': ' : '';
                }
              }
            },
            z: {
              formatter: undefined,
              title: 'Size: '
            },
            marker: {
              show: true,
              fillColors: undefined
            },
            items: {
              display: 'flex'
            },
            fixed: {
              enabled: false,
              position: 'topRight',
              // topRight, topLeft, bottomRight, bottomLeft
              offsetX: 0,
              offsetY: 0
            }
          },
          xaxis: {
            type: 'category',
            categories: [],
            convertedCatToNumeric: false,
            // internal property which should not be altered outside
            offsetX: 0,
            offsetY: 0,
            overwriteCategories: undefined,
            labels: {
              show: true,
              rotate: -45,
              rotateAlways: false,
              hideOverlappingLabels: true,
              trim: false,
              minHeight: undefined,
              maxHeight: 120,
              showDuplicates: true,
              style: {
                colors: [],
                fontSize: '12px',
                fontWeight: 400,
                fontFamily: undefined,
                cssClass: ''
              },
              offsetX: 0,
              offsetY: 0,
              format: undefined,
              formatter: undefined,
              // custom formatter function which will override format
              datetimeUTC: true,
              datetimeFormatter: {
                year: 'yyyy',
                month: "MMM 'yy",
                day: 'dd MMM',
                hour: 'HH:mm',
                minute: 'HH:mm:ss',
                second: 'HH:mm:ss'
              }
            },
            group: {
              groups: [],
              style: {
                colors: [],
                fontSize: '12px',
                fontWeight: 400,
                fontFamily: undefined,
                cssClass: ''
              }
            },
            axisBorder: {
              show: true,
              color: '#e0e0e0',
              width: '100%',
              height: 1,
              offsetX: 0,
              offsetY: 0
            },
            axisTicks: {
              show: true,
              color: '#e0e0e0',
              height: 6,
              offsetX: 0,
              offsetY: 0
            },
            stepSize: undefined,
            tickAmount: undefined,
            tickPlacement: 'on',
            min: undefined,
            max: undefined,
            range: undefined,
            floating: false,
            decimalsInFloat: undefined,
            position: 'bottom',
            title: {
              text: undefined,
              offsetX: 0,
              offsetY: 0,
              style: {
                color: undefined,
                fontSize: '12px',
                fontWeight: 900,
                fontFamily: undefined,
                cssClass: ''
              }
            },
            crosshairs: {
              show: true,
              width: 1,
              // tickWidth/barWidth or an integer
              position: 'back',
              opacity: 0.9,
              stroke: {
                color: '#b6b6b6',
                width: 1,
                dashArray: 3
              },
              fill: {
                type: 'solid',
                // solid, gradient
                color: '#B1B9C4',
                gradient: {
                  colorFrom: '#D8E3F0',
                  colorTo: '#BED1E6',
                  stops: [0, 100],
                  opacityFrom: 0.4,
                  opacityTo: 0.5
                }
              },
              dropShadow: {
                enabled: false,
                left: 0,
                top: 0,
                blur: 1,
                opacity: 0.8
              }
            },
            tooltip: {
              enabled: true,
              offsetY: 0,
              formatter: undefined,
              style: {
                fontSize: '12px',
                fontFamily: undefined
              }
            }
          },
          yaxis: this.yAxis,
          theme: {
            mode: '',
            palette: 'palette1',
            // If defined, it will overwrite globals.colors variable
            monochrome: {
              // monochrome allows you to select just 1 color and fill out the rest with light/dark shade (intensity can be selected)
              enabled: false,
              color: '#008FFB',
              shadeTo: 'light',
              shadeIntensity: 0.65
            }
          }
        };
      }
    }]);
    return Options;
  }();

  /**
   * ApexCharts Annotations Class for drawing lines/rects on both xaxis and yaxis.
   *
   * @module Annotations
   **/
  var Annotations = /*#__PURE__*/function () {
    function Annotations(ctx) {
      _classCallCheck(this, Annotations);
      this.ctx = ctx;
      this.w = ctx.w;
      this.graphics = new Graphics(this.ctx);
      if (this.w.globals.isBarHorizontal) {
        this.invertAxis = true;
      }
      this.helpers = new Helpers$4(this);
      this.xAxisAnnotations = new XAnnotations(this);
      this.yAxisAnnotations = new YAnnotations(this);
      this.pointsAnnotations = new PointAnnotations(this);
      if (this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed) {
        this.inversedReversedAxis = true;
      }
      this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
    }
    _createClass(Annotations, [{
      key: "drawAxesAnnotations",
      value: function drawAxesAnnotations() {
        var w = this.w;
        if (w.globals.axisCharts && w.globals.dataPoints) {
          // w.globals.dataPoints check added to fix  #1832
          var yAnnotations = this.yAxisAnnotations.drawYAxisAnnotations();
          var xAnnotations = this.xAxisAnnotations.drawXAxisAnnotations();
          var pointAnnotations = this.pointsAnnotations.drawPointAnnotations();
          var initialAnim = w.config.chart.animations.enabled;
          var annoArray = [yAnnotations, xAnnotations, pointAnnotations];
          var annoElArray = [xAnnotations.node, yAnnotations.node, pointAnnotations.node];
          for (var i = 0; i < 3; i++) {
            w.globals.dom.elGraphical.add(annoArray[i]);
            if (initialAnim && !w.globals.resized && !w.globals.dataChanged) {
              // fixes apexcharts/apexcharts.js#685
              if (w.config.chart.type !== 'scatter' && w.config.chart.type !== 'bubble' && w.globals.dataPoints > 1) {
                annoElArray[i].classList.add('apexcharts-element-hidden');
              }
            }
            w.globals.delayedElements.push({
              el: annoElArray[i],
              index: 0
            });
          }

          // background sizes needs to be calculated after text is drawn, so calling them last
          this.helpers.annotationsBackground();
        }
      }
    }, {
      key: "drawImageAnnos",
      value: function drawImageAnnos() {
        var _this = this;
        var w = this.w;
        w.config.annotations.images.map(function (s, index) {
          _this.addImage(s, index);
        });
      }
    }, {
      key: "drawTextAnnos",
      value: function drawTextAnnos() {
        var _this2 = this;
        var w = this.w;
        w.config.annotations.texts.map(function (t, index) {
          _this2.addText(t, index);
        });
      }
    }, {
      key: "addXaxisAnnotation",
      value: function addXaxisAnnotation(anno, parent, index) {
        this.xAxisAnnotations.addXaxisAnnotation(anno, parent, index);
      }
    }, {
      key: "addYaxisAnnotation",
      value: function addYaxisAnnotation(anno, parent, index) {
        this.yAxisAnnotations.addYaxisAnnotation(anno, parent, index);
      }
    }, {
      key: "addPointAnnotation",
      value: function addPointAnnotation(anno, parent, index) {
        this.pointsAnnotations.addPointAnnotation(anno, parent, index);
      }
    }, {
      key: "addText",
      value: function addText(params, index) {
        var x = params.x,
          y = params.y,
          text = params.text,
          textAnchor = params.textAnchor,
          foreColor = params.foreColor,
          fontSize = params.fontSize,
          fontFamily = params.fontFamily,
          fontWeight = params.fontWeight,
          cssClass = params.cssClass,
          backgroundColor = params.backgroundColor,
          borderWidth = params.borderWidth,
          strokeDashArray = params.strokeDashArray,
          borderRadius = params.borderRadius,
          borderColor = params.borderColor,
          _params$appendTo = params.appendTo,
          appendTo = _params$appendTo === void 0 ? '.apexcharts-svg' : _params$appendTo,
          _params$paddingLeft = params.paddingLeft,
          paddingLeft = _params$paddingLeft === void 0 ? 4 : _params$paddingLeft,
          _params$paddingRight = params.paddingRight,
          paddingRight = _params$paddingRight === void 0 ? 4 : _params$paddingRight,
          _params$paddingBottom = params.paddingBottom,
          paddingBottom = _params$paddingBottom === void 0 ? 2 : _params$paddingBottom,
          _params$paddingTop = params.paddingTop,
          paddingTop = _params$paddingTop === void 0 ? 2 : _params$paddingTop;
        var w = this.w;
        var elText = this.graphics.drawText({
          x: x,
          y: y,
          text: text,
          textAnchor: textAnchor || 'start',
          fontSize: fontSize || '12px',
          fontWeight: fontWeight || 'regular',
          fontFamily: fontFamily || w.config.chart.fontFamily,
          foreColor: foreColor || w.config.chart.foreColor,
          cssClass: 'apexcharts-text ' + cssClass ? cssClass : ''
        });
        var parent = w.globals.dom.baseEl.querySelector(appendTo);
        if (parent) {
          parent.appendChild(elText.node);
        }
        var textRect = elText.bbox();
        if (text) {
          var elRect = this.graphics.drawRect(textRect.x - paddingLeft, textRect.y - paddingTop, textRect.width + paddingLeft + paddingRight, textRect.height + paddingBottom + paddingTop, borderRadius, backgroundColor ? backgroundColor : 'transparent', 1, borderWidth, borderColor, strokeDashArray);
          parent.insertBefore(elRect.node, elText.node);
        }
      }
    }, {
      key: "addImage",
      value: function addImage(params, index) {
        var w = this.w;
        var path = params.path,
          _params$x = params.x,
          x = _params$x === void 0 ? 0 : _params$x,
          _params$y = params.y,
          y = _params$y === void 0 ? 0 : _params$y,
          _params$width = params.width,
          width = _params$width === void 0 ? 20 : _params$width,
          _params$height = params.height,
          height = _params$height === void 0 ? 20 : _params$height,
          _params$appendTo2 = params.appendTo,
          appendTo = _params$appendTo2 === void 0 ? '.apexcharts-svg' : _params$appendTo2;
        var img = w.globals.dom.Paper.image(path);
        img.size(width, height).move(x, y);
        var parent = w.globals.dom.baseEl.querySelector(appendTo);
        if (parent) {
          parent.appendChild(img.node);
        }
        return img;
      }

      // The addXaxisAnnotation method requires a parent class, and user calling this method externally on the chart instance may not specify parent, hence a different method
    }, {
      key: "addXaxisAnnotationExternal",
      value: function addXaxisAnnotationExternal(params, pushToMemory, context) {
        this.addAnnotationExternal({
          params: params,
          pushToMemory: pushToMemory,
          context: context,
          type: 'xaxis',
          contextMethod: context.addXaxisAnnotation
        });
        return context;
      }
    }, {
      key: "addYaxisAnnotationExternal",
      value: function addYaxisAnnotationExternal(params, pushToMemory, context) {
        this.addAnnotationExternal({
          params: params,
          pushToMemory: pushToMemory,
          context: context,
          type: 'yaxis',
          contextMethod: context.addYaxisAnnotation
        });
        return context;
      }
    }, {
      key: "addPointAnnotationExternal",
      value: function addPointAnnotationExternal(params, pushToMemory, context) {
        if (typeof this.invertAxis === 'undefined') {
          this.invertAxis = context.w.globals.isBarHorizontal;
        }
        this.addAnnotationExternal({
          params: params,
          pushToMemory: pushToMemory,
          context: context,
          type: 'point',
          contextMethod: context.addPointAnnotation
        });
        return context;
      }
    }, {
      key: "addAnnotationExternal",
      value: function addAnnotationExternal(_ref) {
        var params = _ref.params,
          pushToMemory = _ref.pushToMemory,
          context = _ref.context,
          type = _ref.type,
          contextMethod = _ref.contextMethod;
        var me = context;
        var w = me.w;
        var parent = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-annotations"));
        var index = parent.childNodes.length + 1;
        var options = new Options();
        var axesAnno = Object.assign({}, type === 'xaxis' ? options.xAxisAnnotation : type === 'yaxis' ? options.yAxisAnnotation : options.pointAnnotation);
        var anno = Utils$1.extend(axesAnno, params);
        switch (type) {
          case 'xaxis':
            this.addXaxisAnnotation(anno, parent, index);
            break;
          case 'yaxis':
            this.addYaxisAnnotation(anno, parent, index);
            break;
          case 'point':
            this.addPointAnnotation(anno, parent, index);
            break;
        }

        // add background
        var axesAnnoLabel = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-annotations .apexcharts-").concat(type, "-annotation-label[rel='").concat(index, "']"));
        var elRect = this.helpers.addBackgroundToAnno(axesAnnoLabel, anno);
        if (elRect) {
          parent.insertBefore(elRect.node, axesAnnoLabel);
        }
        if (pushToMemory) {
          w.globals.memory.methodsToExec.push({
            context: me,
            id: anno.id ? anno.id : Utils$1.randomId(),
            method: contextMethod,
            label: 'addAnnotation',
            params: params
          });
        }
        return context;
      }
    }, {
      key: "clearAnnotations",
      value: function clearAnnotations(ctx) {
        var w = ctx.w;
        var annos = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations');

        // annotations added externally should be cleared out too
        for (var i = w.globals.memory.methodsToExec.length - 1; i >= 0; i--) {
          if (w.globals.memory.methodsToExec[i].label === 'addText' || w.globals.memory.methodsToExec[i].label === 'addAnnotation') {
            w.globals.memory.methodsToExec.splice(i, 1);
          }
        }
        annos = Utils$1.listToArray(annos);

        // delete the DOM elements
        Array.prototype.forEach.call(annos, function (a) {
          while (a.firstChild) {
            a.removeChild(a.firstChild);
          }
        });
      }
    }, {
      key: "removeAnnotation",
      value: function removeAnnotation(ctx, id) {
        var w = ctx.w;
        var annos = w.globals.dom.baseEl.querySelectorAll(".".concat(id));
        if (annos) {
          w.globals.memory.methodsToExec.map(function (m, i) {
            if (m.id === id) {
              w.globals.memory.methodsToExec.splice(i, 1);
            }
          });
          Object.keys(w.config.annotations).forEach(function (key) {
            var annotationArray = w.config.annotations[key];
            if (Array.isArray(annotationArray)) {
              // remove entry from the config, so on the next update it doesn't come back
              w.config.annotations[key] = annotationArray.filter(function (m) {
                return m.id !== id;
              });
            }
          });
          Array.prototype.forEach.call(annos, function (a) {
            a.parentElement.removeChild(a);
          });
        }
      }
    }]);
    return Annotations;
  }();

  /**
   * ApexCharts Default Class for setting default options for all chart types.
   *
   * @module Defaults
   **/

  var getRangeValues = function getRangeValues(_ref) {
    var _w$config$series$seri;
    var isTimeline = _ref.isTimeline,
      ctx = _ref.ctx,
      seriesIndex = _ref.seriesIndex,
      dataPointIndex = _ref.dataPointIndex,
      y1 = _ref.y1,
      y2 = _ref.y2,
      w = _ref.w;
    var start = w.globals.seriesRangeStart[seriesIndex][dataPointIndex];
    var end = w.globals.seriesRangeEnd[seriesIndex][dataPointIndex];
    var ylabel = w.globals.labels[dataPointIndex];
    var seriesName = w.config.series[seriesIndex].name ? w.config.series[seriesIndex].name : '';
    var yLbFormatter = w.globals.ttKeyFormatter;
    var yLbTitleFormatter = w.config.tooltip.y.title.formatter;
    var opts = {
      w: w,
      seriesIndex: seriesIndex,
      dataPointIndex: dataPointIndex,
      start: start,
      end: end
    };
    if (typeof yLbTitleFormatter === 'function') {
      seriesName = yLbTitleFormatter(seriesName, opts);
    }
    if ((_w$config$series$seri = w.config.series[seriesIndex].data[dataPointIndex]) !== null && _w$config$series$seri !== void 0 && _w$config$series$seri.x) {
      ylabel = w.config.series[seriesIndex].data[dataPointIndex].x;
    }
    if (!isTimeline) {
      if (w.config.xaxis.type === 'datetime') {
        var xFormat = new Formatters(ctx);
        ylabel = xFormat.xLabelFormat(w.globals.ttKeyFormatter, ylabel, ylabel, {
          i: undefined,
          dateFormatter: new DateTime(ctx).formatDate,
          w: w
        });
      }
    }
    if (typeof yLbFormatter === 'function') {
      ylabel = yLbFormatter(ylabel, opts);
    }
    if (Number.isFinite(y1) && Number.isFinite(y2)) {
      start = y1;
      end = y2;
    }
    var startVal = '';
    var endVal = '';
    var color = w.globals.colors[seriesIndex];
    if (w.config.tooltip.x.formatter === undefined) {
      if (w.config.xaxis.type === 'datetime') {
        var datetimeObj = new DateTime(ctx);
        startVal = datetimeObj.formatDate(datetimeObj.getDate(start), w.config.tooltip.x.format);
        endVal = datetimeObj.formatDate(datetimeObj.getDate(end), w.config.tooltip.x.format);
      } else {
        startVal = start;
        endVal = end;
      }
    } else {
      startVal = w.config.tooltip.x.formatter(start);
      endVal = w.config.tooltip.x.formatter(end);
    }
    return {
      start: start,
      end: end,
      startVal: startVal,
      endVal: endVal,
      ylabel: ylabel,
      color: color,
      seriesName: seriesName
    };
  };
  var buildRangeTooltipHTML = function buildRangeTooltipHTML(opts) {
    var color = opts.color,
      seriesName = opts.seriesName,
      ylabel = opts.ylabel,
      start = opts.start,
      end = opts.end,
      seriesIndex = opts.seriesIndex,
      dataPointIndex = opts.dataPointIndex;
    var formatter = opts.ctx.tooltip.tooltipLabels.getFormatters(seriesIndex);
    start = formatter.yLbFormatter(start);
    end = formatter.yLbFormatter(end);
    var val = formatter.yLbFormatter(opts.w.globals.series[seriesIndex][dataPointIndex]);
    var valueHTML = '';
    var rangeValues = "<span class=\"value start-value\">\n  ".concat(start, "\n  </span> <span class=\"separator\">-</span> <span class=\"value end-value\">\n  ").concat(end, "\n  </span>");
    if (opts.w.globals.comboCharts) {
      if (opts.w.config.series[seriesIndex].type === 'rangeArea' || opts.w.config.series[seriesIndex].type === 'rangeBar') {
        valueHTML = rangeValues;
      } else {
        valueHTML = "<span>".concat(val, "</span>");
      }
    } else {
      valueHTML = rangeValues;
    }
    return '<div class="apexcharts-tooltip-rangebar">' + '<div> <span class="series-name" style="color: ' + color + '">' + (seriesName ? seriesName : '') + '</span></div>' + '<div> <span class="category">' + ylabel + ': </span> ' + valueHTML + ' </div>' + '</div>';
  };
  var Defaults = /*#__PURE__*/function () {
    function Defaults(opts) {
      _classCallCheck(this, Defaults);
      this.opts = opts;
    }
    _createClass(Defaults, [{
      key: "hideYAxis",
      value: function hideYAxis() {
        this.opts.yaxis[0].show = false;
        this.opts.yaxis[0].title.text = '';
        this.opts.yaxis[0].axisBorder.show = false;
        this.opts.yaxis[0].axisTicks.show = false;
        this.opts.yaxis[0].floating = true;
      }
    }, {
      key: "line",
      value: function line() {
        return {
          dataLabels: {
            enabled: false
          },
          stroke: {
            width: 5,
            curve: 'straight'
          },
          markers: {
            size: 0,
            hover: {
              sizeOffset: 6
            }
          },
          xaxis: {
            crosshairs: {
              width: 1
            }
          }
        };
      }
    }, {
      key: "sparkline",
      value: function sparkline(defaults) {
        this.hideYAxis();
        var ret = {
          grid: {
            show: false,
            padding: {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }
          },
          legend: {
            show: false
          },
          xaxis: {
            labels: {
              show: false
            },
            tooltip: {
              enabled: false
            },
            axisBorder: {
              show: false
            },
            axisTicks: {
              show: false
            }
          },
          chart: {
            toolbar: {
              show: false
            },
            zoom: {
              enabled: false
            }
          },
          dataLabels: {
            enabled: false
          }
        };
        return Utils$1.extend(defaults, ret);
      }
    }, {
      key: "slope",
      value: function slope() {
        this.hideYAxis();
        return {
          chart: {
            toolbar: {
              show: false
            },
            zoom: {
              enabled: false
            }
          },
          dataLabels: {
            enabled: true,
            formatter: function formatter(val, opts) {
              var seriesName = opts.w.config.series[opts.seriesIndex].name;
              return val !== null ? seriesName + ': ' + val : '';
            },
            background: {
              enabled: false
            },
            offsetX: -5
          },
          grid: {
            xaxis: {
              lines: {
                show: true
              }
            },
            yaxis: {
              lines: {
                show: false
              }
            }
          },
          xaxis: {
            position: 'top',
            labels: {
              style: {
                fontSize: 14,
                fontWeight: 900
              }
            },
            tooltip: {
              enabled: false
            },
            crosshairs: {
              show: false
            }
          },
          markers: {
            size: 8,
            hover: {
              sizeOffset: 1
            }
          },
          legend: {
            show: false
          },
          tooltip: {
            shared: false,
            intersect: true,
            followCursor: true
          },
          stroke: {
            width: 5,
            curve: 'straight'
          }
        };
      }
    }, {
      key: "bar",
      value: function bar() {
        return {
          chart: {
            stacked: false
          },
          plotOptions: {
            bar: {
              dataLabels: {
                position: 'center'
              }
            }
          },
          dataLabels: {
            style: {
              colors: ['#fff']
            },
            background: {
              enabled: false
            }
          },
          stroke: {
            width: 0,
            lineCap: 'square'
          },
          fill: {
            opacity: 0.85
          },
          legend: {
            markers: {
              shape: 'square'
            }
          },
          tooltip: {
            shared: false,
            intersect: true
          },
          xaxis: {
            tooltip: {
              enabled: false
            },
            tickPlacement: 'between',
            crosshairs: {
              width: 'barWidth',
              position: 'back',
              fill: {
                type: 'gradient'
              },
              dropShadow: {
                enabled: false
              },
              stroke: {
                width: 0
              }
            }
          }
        };
      }
    }, {
      key: "funnel",
      value: function funnel() {
        this.hideYAxis();
        return _objectSpread2(_objectSpread2({}, this.bar()), {}, {
          chart: {
            animations: {
              speed: 800,
              animateGradually: {
                enabled: false
              }
            }
          },
          plotOptions: {
            bar: {
              horizontal: true,
              borderRadiusApplication: 'around',
              borderRadius: 0,
              dataLabels: {
                position: 'center'
              }
            }
          },
          grid: {
            show: false,
            padding: {
              left: 0,
              right: 0
            }
          },
          xaxis: {
            labels: {
              show: false
            },
            tooltip: {
              enabled: false
            },
            axisBorder: {
              show: false
            },
            axisTicks: {
              show: false
            }
          }
        });
      }
    }, {
      key: "candlestick",
      value: function candlestick() {
        var _this = this;
        return {
          stroke: {
            width: 1
          },
          fill: {
            opacity: 1
          },
          dataLabels: {
            enabled: false
          },
          tooltip: {
            shared: true,
            custom: function custom(_ref2) {
              var seriesIndex = _ref2.seriesIndex,
                dataPointIndex = _ref2.dataPointIndex,
                w = _ref2.w;
              return _this._getBoxTooltip(w, seriesIndex, dataPointIndex, ['Open', 'High', '', 'Low', 'Close'], 'candlestick');
            }
          },
          states: {
            active: {
              filter: {
                type: 'none'
              }
            }
          },
          xaxis: {
            crosshairs: {
              width: 1
            }
          }
        };
      }
    }, {
      key: "boxPlot",
      value: function boxPlot() {
        var _this2 = this;
        return {
          chart: {
            animations: {
              dynamicAnimation: {
                enabled: false
              }
            }
          },
          stroke: {
            width: 1,
            colors: ['#24292e']
          },
          dataLabels: {
            enabled: false
          },
          tooltip: {
            shared: true,
            custom: function custom(_ref3) {
              var seriesIndex = _ref3.seriesIndex,
                dataPointIndex = _ref3.dataPointIndex,
                w = _ref3.w;
              return _this2._getBoxTooltip(w, seriesIndex, dataPointIndex, ['Minimum', 'Q1', 'Median', 'Q3', 'Maximum'], 'boxPlot');
            }
          },
          markers: {
            size: 7,
            strokeWidth: 1,
            strokeColors: '#111'
          },
          xaxis: {
            crosshairs: {
              width: 1
            }
          }
        };
      }
    }, {
      key: "rangeBar",
      value: function rangeBar() {
        var handleTimelineTooltip = function handleTimelineTooltip(opts) {
          var _getRangeValues = getRangeValues(_objectSpread2(_objectSpread2({}, opts), {}, {
              isTimeline: true
            })),
            color = _getRangeValues.color,
            seriesName = _getRangeValues.seriesName,
            ylabel = _getRangeValues.ylabel,
            startVal = _getRangeValues.startVal,
            endVal = _getRangeValues.endVal;
          return buildRangeTooltipHTML(_objectSpread2(_objectSpread2({}, opts), {}, {
            color: color,
            seriesName: seriesName,
            ylabel: ylabel,
            start: startVal,
            end: endVal
          }));
        };
        var handleRangeColumnTooltip = function handleRangeColumnTooltip(opts) {
          var _getRangeValues2 = getRangeValues(opts),
            color = _getRangeValues2.color,
            seriesName = _getRangeValues2.seriesName,
            ylabel = _getRangeValues2.ylabel,
            start = _getRangeValues2.start,
            end = _getRangeValues2.end;
          return buildRangeTooltipHTML(_objectSpread2(_objectSpread2({}, opts), {}, {
            color: color,
            seriesName: seriesName,
            ylabel: ylabel,
            start: start,
            end: end
          }));
        };
        return {
          chart: {
            animations: {
              animateGradually: false
            }
          },
          stroke: {
            width: 0,
            lineCap: 'square'
          },
          plotOptions: {
            bar: {
              borderRadius: 0,
              dataLabels: {
                position: 'center'
              }
            }
          },
          dataLabels: {
            enabled: false,
            formatter: function formatter(val, _ref4) {
              _ref4.ctx;
                var seriesIndex = _ref4.seriesIndex,
                dataPointIndex = _ref4.dataPointIndex,
                w = _ref4.w;
              var getVal = function getVal() {
                var start = w.globals.seriesRangeStart[seriesIndex][dataPointIndex];
                var end = w.globals.seriesRangeEnd[seriesIndex][dataPointIndex];
                return end - start;
              };
              if (w.globals.comboCharts) {
                if (w.config.series[seriesIndex].type === 'rangeBar' || w.config.series[seriesIndex].type === 'rangeArea') {
                  return getVal();
                } else {
                  return val;
                }
              } else {
                return getVal();
              }
            },
            background: {
              enabled: false
            },
            style: {
              colors: ['#fff']
            }
          },
          markers: {
            size: 10
          },
          tooltip: {
            shared: false,
            followCursor: true,
            custom: function custom(opts) {
              if (opts.w.config.plotOptions && opts.w.config.plotOptions.bar && opts.w.config.plotOptions.bar.horizontal) {
                return handleTimelineTooltip(opts);
              } else {
                return handleRangeColumnTooltip(opts);
              }
            }
          },
          xaxis: {
            tickPlacement: 'between',
            tooltip: {
              enabled: false
            },
            crosshairs: {
              stroke: {
                width: 0
              }
            }
          }
        };
      }
    }, {
      key: "dumbbell",
      value: function dumbbell(opts) {
        var _opts$plotOptions$bar, _opts$plotOptions$bar2;
        if (!((_opts$plotOptions$bar = opts.plotOptions.bar) !== null && _opts$plotOptions$bar !== void 0 && _opts$plotOptions$bar.barHeight)) {
          opts.plotOptions.bar.barHeight = 2;
        }
        if (!((_opts$plotOptions$bar2 = opts.plotOptions.bar) !== null && _opts$plotOptions$bar2 !== void 0 && _opts$plotOptions$bar2.columnWidth)) {
          opts.plotOptions.bar.columnWidth = 2;
        }
        return opts;
      }
    }, {
      key: "area",
      value: function area() {
        return {
          stroke: {
            width: 4,
            fill: {
              type: 'solid',
              gradient: {
                inverseColors: false,
                shade: 'light',
                type: 'vertical',
                opacityFrom: 0.65,
                opacityTo: 0.5,
                stops: [0, 100, 100]
              }
            }
          },
          fill: {
            type: 'gradient',
            gradient: {
              inverseColors: false,
              shade: 'light',
              type: 'vertical',
              opacityFrom: 0.65,
              opacityTo: 0.5,
              stops: [0, 100, 100]
            }
          },
          markers: {
            size: 0,
            hover: {
              sizeOffset: 6
            }
          },
          tooltip: {
            followCursor: false
          }
        };
      }
    }, {
      key: "rangeArea",
      value: function rangeArea() {
        var handleRangeAreaTooltip = function handleRangeAreaTooltip(opts) {
          var _getRangeValues3 = getRangeValues(opts),
            color = _getRangeValues3.color,
            seriesName = _getRangeValues3.seriesName,
            ylabel = _getRangeValues3.ylabel,
            start = _getRangeValues3.start,
            end = _getRangeValues3.end;
          return buildRangeTooltipHTML(_objectSpread2(_objectSpread2({}, opts), {}, {
            color: color,
            seriesName: seriesName,
            ylabel: ylabel,
            start: start,
            end: end
          }));
        };
        return {
          stroke: {
            curve: 'straight',
            width: 0
          },
          fill: {
            type: 'solid',
            opacity: 0.6
          },
          markers: {
            size: 0
          },
          states: {
            hover: {
              filter: {
                type: 'none'
              }
            },
            active: {
              filter: {
                type: 'none'
              }
            }
          },
          tooltip: {
            intersect: false,
            shared: true,
            followCursor: true,
            custom: function custom(opts) {
              return handleRangeAreaTooltip(opts);
            }
          }
        };
      }
    }, {
      key: "brush",
      value: function brush(defaults) {
        var ret = {
          chart: {
            toolbar: {
              autoSelected: 'selection',
              show: false
            },
            zoom: {
              enabled: false
            }
          },
          dataLabels: {
            enabled: false
          },
          stroke: {
            width: 1
          },
          tooltip: {
            enabled: false
          },
          xaxis: {
            tooltip: {
              enabled: false
            }
          }
        };
        return Utils$1.extend(defaults, ret);
      }
    }, {
      key: "stacked100",
      value: function stacked100(opts) {
        opts.dataLabels = opts.dataLabels || {};
        opts.dataLabels.formatter = opts.dataLabels.formatter || undefined;
        var existingDataLabelFormatter = opts.dataLabels.formatter;
        opts.yaxis.forEach(function (yaxe, index) {
          opts.yaxis[index].min = 0;
          opts.yaxis[index].max = 100;
        });
        var isBar = opts.chart.type === 'bar';
        if (isBar) {
          opts.dataLabels.formatter = existingDataLabelFormatter || function (val) {
            if (typeof val === 'number') {
              return val ? val.toFixed(0) + '%' : val;
            }
            return val;
          };
        }
        return opts;
      }
    }, {
      key: "stackedBars",
      value: function stackedBars() {
        var barDefaults = this.bar();
        return _objectSpread2(_objectSpread2({}, barDefaults), {}, {
          plotOptions: _objectSpread2(_objectSpread2({}, barDefaults.plotOptions), {}, {
            bar: _objectSpread2(_objectSpread2({}, barDefaults.plotOptions.bar), {}, {
              borderRadiusApplication: 'end',
              borderRadiusWhenStacked: 'last'
            })
          })
        });
      }

      // This function removes the left and right spacing in chart for line/area/scatter if xaxis type = category for those charts by converting xaxis = numeric. Numeric/Datetime xaxis prevents the unnecessary spacing in the left/right of the chart area
    }, {
      key: "convertCatToNumeric",
      value: function convertCatToNumeric(opts) {
        opts.xaxis.convertedCatToNumeric = true;
        return opts;
      }
    }, {
      key: "convertCatToNumericXaxis",
      value: function convertCatToNumericXaxis(opts, ctx, cats) {
        opts.xaxis.type = 'numeric';
        opts.xaxis.labels = opts.xaxis.labels || {};
        opts.xaxis.labels.formatter = opts.xaxis.labels.formatter || function (val) {
          return Utils$1.isNumber(val) ? Math.floor(val) : val;
        };
        var defaultFormatter = opts.xaxis.labels.formatter;
        var labels = opts.xaxis.categories && opts.xaxis.categories.length ? opts.xaxis.categories : opts.labels;
        if (cats && cats.length) {
          labels = cats.map(function (c) {
            return Array.isArray(c) ? c : String(c);
          });
        }
        if (labels && labels.length) {
          opts.xaxis.labels.formatter = function (val) {
            return Utils$1.isNumber(val) ? defaultFormatter(labels[Math.floor(val) - 1]) : defaultFormatter(val);
          };
        }
        opts.xaxis.categories = [];
        opts.labels = [];
        opts.xaxis.tickAmount = opts.xaxis.tickAmount || 'dataPoints';
        return opts;
      }
    }, {
      key: "bubble",
      value: function bubble() {
        return {
          dataLabels: {
            style: {
              colors: ['#fff']
            }
          },
          tooltip: {
            shared: false,
            intersect: true
          },
          xaxis: {
            crosshairs: {
              width: 0
            }
          },
          fill: {
            type: 'solid',
            gradient: {
              shade: 'light',
              inverse: true,
              shadeIntensity: 0.55,
              opacityFrom: 0.4,
              opacityTo: 0.8
            }
          }
        };
      }
    }, {
      key: "scatter",
      value: function scatter() {
        return {
          dataLabels: {
            enabled: false
          },
          tooltip: {
            shared: false,
            intersect: true
          },
          markers: {
            size: 6,
            strokeWidth: 1,
            hover: {
              sizeOffset: 2
            }
          }
        };
      }
    }, {
      key: "heatmap",
      value: function heatmap() {
        return {
          chart: {
            stacked: false
          },
          fill: {
            opacity: 1
          },
          dataLabels: {
            style: {
              colors: ['#fff']
            }
          },
          stroke: {
            colors: ['#fff']
          },
          tooltip: {
            followCursor: true,
            marker: {
              show: false
            },
            x: {
              show: false
            }
          },
          legend: {
            position: 'top',
            markers: {
              shape: 'square'
            }
          },
          grid: {
            padding: {
              right: 20
            }
          }
        };
      }
    }, {
      key: "treemap",
      value: function treemap() {
        return {
          chart: {
            zoom: {
              enabled: false
            }
          },
          dataLabels: {
            style: {
              fontSize: 14,
              fontWeight: 600,
              colors: ['#fff']
            }
          },
          stroke: {
            show: true,
            width: 2,
            colors: ['#fff']
          },
          legend: {
            show: false
          },
          fill: {
            opacity: 1,
            gradient: {
              stops: [0, 100]
            }
          },
          tooltip: {
            followCursor: true,
            x: {
              show: false
            }
          },
          grid: {
            padding: {
              left: 0,
              right: 0
            }
          },
          xaxis: {
            crosshairs: {
              show: false
            },
            tooltip: {
              enabled: false
            }
          }
        };
      }
    }, {
      key: "pie",
      value: function pie() {
        return {
          chart: {
            toolbar: {
              show: false
            }
          },
          plotOptions: {
            pie: {
              donut: {
                labels: {
                  show: false
                }
              }
            }
          },
          dataLabels: {
            formatter: function formatter(val) {
              return val.toFixed(1) + '%';
            },
            style: {
              colors: ['#fff']
            },
            background: {
              enabled: false
            },
            dropShadow: {
              enabled: true
            }
          },
          stroke: {
            colors: ['#fff']
          },
          fill: {
            opacity: 1,
            gradient: {
              shade: 'light',
              stops: [0, 100]
            }
          },
          tooltip: {
            theme: 'dark',
            fillSeriesColor: true
          },
          legend: {
            position: 'right'
          },
          grid: {
            padding: {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }
          }
        };
      }
    }, {
      key: "donut",
      value: function donut() {
        return {
          chart: {
            toolbar: {
              show: false
            }
          },
          dataLabels: {
            formatter: function formatter(val) {
              return val.toFixed(1) + '%';
            },
            style: {
              colors: ['#fff']
            },
            background: {
              enabled: false
            },
            dropShadow: {
              enabled: true
            }
          },
          stroke: {
            colors: ['#fff']
          },
          fill: {
            opacity: 1,
            gradient: {
              shade: 'light',
              shadeIntensity: 0.35,
              stops: [80, 100],
              opacityFrom: 1,
              opacityTo: 1
            }
          },
          tooltip: {
            theme: 'dark',
            fillSeriesColor: true
          },
          legend: {
            position: 'right'
          },
          grid: {
            padding: {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }
          }
        };
      }
    }, {
      key: "polarArea",
      value: function polarArea() {
        return {
          chart: {
            toolbar: {
              show: false
            }
          },
          dataLabels: {
            formatter: function formatter(val) {
              return val.toFixed(1) + '%';
            },
            enabled: false
          },
          stroke: {
            show: true,
            width: 2
          },
          fill: {
            opacity: 0.7
          },
          tooltip: {
            theme: 'dark',
            fillSeriesColor: true
          },
          legend: {
            position: 'right'
          },
          grid: {
            padding: {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }
          }
        };
      }
    }, {
      key: "radar",
      value: function radar() {
        this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6;
        return {
          dataLabels: {
            enabled: false,
            style: {
              fontSize: '11px'
            }
          },
          stroke: {
            width: 2
          },
          markers: {
            size: 5,
            strokeWidth: 1,
            strokeOpacity: 1
          },
          fill: {
            opacity: 0.2
          },
          tooltip: {
            shared: false,
            intersect: true,
            followCursor: true
          },
          grid: {
            show: false,
            padding: {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }
          },
          xaxis: {
            labels: {
              formatter: function formatter(val) {
                return val;
              },
              style: {
                colors: ['#a8a8a8'],
                fontSize: '11px'
              }
            },
            tooltip: {
              enabled: false
            },
            crosshairs: {
              show: false
            }
          }
        };
      }
    }, {
      key: "radialBar",
      value: function radialBar() {
        return {
          chart: {
            animations: {
              dynamicAnimation: {
                enabled: true,
                speed: 800
              }
            },
            toolbar: {
              show: false
            }
          },
          fill: {
            gradient: {
              shade: 'dark',
              shadeIntensity: 0.4,
              inverseColors: false,
              type: 'diagonal2',
              opacityFrom: 1,
              opacityTo: 1,
              stops: [70, 98, 100]
            }
          },
          legend: {
            show: false,
            position: 'right'
          },
          tooltip: {
            enabled: false,
            fillSeriesColor: true
          },
          grid: {
            padding: {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }
          }
        };
      }
    }, {
      key: "_getBoxTooltip",
      value: function _getBoxTooltip(w, seriesIndex, dataPointIndex, labels, chartType) {
        var o = w.globals.seriesCandleO[seriesIndex][dataPointIndex];
        var h = w.globals.seriesCandleH[seriesIndex][dataPointIndex];
        var m = w.globals.seriesCandleM[seriesIndex][dataPointIndex];
        var l = w.globals.seriesCandleL[seriesIndex][dataPointIndex];
        var c = w.globals.seriesCandleC[seriesIndex][dataPointIndex];
        if (w.config.series[seriesIndex].type && w.config.series[seriesIndex].type !== chartType) {
          return "<div class=\"apexcharts-custom-tooltip\">\n          ".concat(w.config.series[seriesIndex].name ? w.config.series[seriesIndex].name : 'series-' + (seriesIndex + 1), ": <strong>").concat(w.globals.series[seriesIndex][dataPointIndex], "</strong>\n        </div>");
        } else {
          return "<div class=\"apexcharts-tooltip-box apexcharts-tooltip-".concat(w.config.chart.type, "\">") + "<div>".concat(labels[0], ": <span class=\"value\">") + o + '</span></div>' + "<div>".concat(labels[1], ": <span class=\"value\">") + h + '</span></div>' + (m ? "<div>".concat(labels[2], ": <span class=\"value\">") + m + '</span></div>' : '') + "<div>".concat(labels[3], ": <span class=\"value\">") + l + '</span></div>' + "<div>".concat(labels[4], ": <span class=\"value\">") + c + '</span></div>' + '</div>';
        }
      }
    }]);
    return Defaults;
  }();

  /**
   * ApexCharts Config Class for extending user options with pre-defined ApexCharts config.
   *
   * @module Config
   **/
  var Config = /*#__PURE__*/function () {
    function Config(opts) {
      _classCallCheck(this, Config);
      this.opts = opts;
    }
    _createClass(Config, [{
      key: "init",
      value: function init(_ref) {
        var responsiveOverride = _ref.responsiveOverride;
        var opts = this.opts;
        var options = new Options();
        var defaults = new Defaults(opts);
        this.chartType = opts.chart.type;
        opts = this.extendYAxis(opts);
        opts = this.extendAnnotations(opts);
        var config = options.init();
        var newDefaults = {};
        if (opts && _typeof(opts) === 'object') {
          var _opts$plotOptions, _opts$plotOptions$bar, _opts$chart$brush, _opts$plotOptions2, _opts$plotOptions2$li, _opts$plotOptions3, _opts$plotOptions3$ba, _opts$chart$sparkline, _window$Apex$chart, _window$Apex$chart$sp;
          var chartDefaults = {};
          var chartTypes = ['line', 'area', 'bar', 'candlestick', 'boxPlot', 'rangeBar', 'rangeArea', 'bubble', 'scatter', 'heatmap', 'treemap', 'pie', 'polarArea', 'donut', 'radar', 'radialBar'];
          if (chartTypes.indexOf(opts.chart.type) !== -1) {
            chartDefaults = defaults[opts.chart.type]();
          } else {
            chartDefaults = defaults.line();
          }
          if ((_opts$plotOptions = opts.plotOptions) !== null && _opts$plotOptions !== void 0 && (_opts$plotOptions$bar = _opts$plotOptions.bar) !== null && _opts$plotOptions$bar !== void 0 && _opts$plotOptions$bar.isFunnel) {
            chartDefaults = defaults.funnel();
          }
          if (opts.chart.stacked && opts.chart.type === 'bar') {
            chartDefaults = defaults.stackedBars();
          }
          if ((_opts$chart$brush = opts.chart.brush) !== null && _opts$chart$brush !== void 0 && _opts$chart$brush.enabled) {
            chartDefaults = defaults.brush(chartDefaults);
          }
          if ((_opts$plotOptions2 = opts.plotOptions) !== null && _opts$plotOptions2 !== void 0 && (_opts$plotOptions2$li = _opts$plotOptions2.line) !== null && _opts$plotOptions2$li !== void 0 && _opts$plotOptions2$li.isSlopeChart) {
            chartDefaults = defaults.slope();
          }
          if (opts.chart.stacked && opts.chart.stackType === '100%') {
            opts = defaults.stacked100(opts);
          }
          if ((_opts$plotOptions3 = opts.plotOptions) !== null && _opts$plotOptions3 !== void 0 && (_opts$plotOptions3$ba = _opts$plotOptions3.bar) !== null && _opts$plotOptions3$ba !== void 0 && _opts$plotOptions3$ba.isDumbbell) {
            opts = defaults.dumbbell(opts);
          }

          // If user has specified a dark theme, make the tooltip dark too
          this.checkForDarkTheme(window.Apex); // check global window Apex options
          this.checkForDarkTheme(opts); // check locally passed options

          opts.xaxis = opts.xaxis || window.Apex.xaxis || {};

          // an important boolean needs to be set here
          // otherwise all the charts will have this flag set to true window.Apex.xaxis is set globally
          if (!responsiveOverride) {
            opts.xaxis.convertedCatToNumeric = false;
          }
          opts = this.checkForCatToNumericXAxis(this.chartType, chartDefaults, opts);
          if ((_opts$chart$sparkline = opts.chart.sparkline) !== null && _opts$chart$sparkline !== void 0 && _opts$chart$sparkline.enabled || (_window$Apex$chart = window.Apex.chart) !== null && _window$Apex$chart !== void 0 && (_window$Apex$chart$sp = _window$Apex$chart.sparkline) !== null && _window$Apex$chart$sp !== void 0 && _window$Apex$chart$sp.enabled) {
            chartDefaults = defaults.sparkline(chartDefaults);
          }
          newDefaults = Utils$1.extend(config, chartDefaults);
        }

        // config should cascade in this fashion
        // default-config < global-apex-variable-config < user-defined-config

        // get GLOBALLY defined options and merge with the default config
        var mergedWithDefaultConfig = Utils$1.extend(newDefaults, window.Apex);

        // get the merged config and extend with user defined config
        config = Utils$1.extend(mergedWithDefaultConfig, opts);

        // some features are not supported. those mismatches should be handled
        config = this.handleUserInputErrors(config);
        return config;
      }
    }, {
      key: "checkForCatToNumericXAxis",
      value: function checkForCatToNumericXAxis(chartType, chartDefaults, opts) {
        var _opts$plotOptions4, _opts$plotOptions4$ba;
        var defaults = new Defaults(opts);
        var isBarHorizontal = (chartType === 'bar' || chartType === 'boxPlot') && ((_opts$plotOptions4 = opts.plotOptions) === null || _opts$plotOptions4 === void 0 ? void 0 : (_opts$plotOptions4$ba = _opts$plotOptions4.bar) === null || _opts$plotOptions4$ba === void 0 ? void 0 : _opts$plotOptions4$ba.horizontal);
        var unsupportedZoom = chartType === 'pie' || chartType === 'polarArea' || chartType === 'donut' || chartType === 'radar' || chartType === 'radialBar' || chartType === 'heatmap';
        var notNumericXAxis = opts.xaxis.type !== 'datetime' && opts.xaxis.type !== 'numeric';
        var tickPlacement = opts.xaxis.tickPlacement ? opts.xaxis.tickPlacement : chartDefaults.xaxis && chartDefaults.xaxis.tickPlacement;
        if (!isBarHorizontal && !unsupportedZoom && notNumericXAxis && tickPlacement !== 'between') {
          opts = defaults.convertCatToNumeric(opts);
        }
        return opts;
      }
    }, {
      key: "extendYAxis",
      value: function extendYAxis(opts, w) {
        var options = new Options();
        if (typeof opts.yaxis === 'undefined' || !opts.yaxis || Array.isArray(opts.yaxis) && opts.yaxis.length === 0) {
          opts.yaxis = {};
        }

        // extend global yaxis config (only if object is provided / not an array)
        if (opts.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array) {
          opts.yaxis = Utils$1.extend(opts.yaxis, window.Apex.yaxis);
        }

        // as we can't extend nested object's array with extend, we need to do it first
        // user can provide either an array or object in yaxis config
        if (opts.yaxis.constructor !== Array) {
          // convert the yaxis to array if user supplied object
          opts.yaxis = [Utils$1.extend(options.yAxis, opts.yaxis)];
        } else {
          opts.yaxis = Utils$1.extendArray(opts.yaxis, options.yAxis);
        }
        var isLogY = false;
        opts.yaxis.forEach(function (y) {
          if (y.logarithmic) {
            isLogY = true;
          }
        });
        var series = opts.series;
        if (w && !series) {
          series = w.config.series;
        }

        // A logarithmic chart works correctly when each series has a corresponding y-axis
        // If this is not the case, we manually create yaxis for multi-series log chart
        if (isLogY && series.length !== opts.yaxis.length && series.length) {
          opts.yaxis = series.map(function (s, i) {
            if (!s.name) {
              series[i].name = "series-".concat(i + 1);
            }
            if (opts.yaxis[i]) {
              opts.yaxis[i].seriesName = series[i].name;
              return opts.yaxis[i];
            } else {
              var newYaxis = Utils$1.extend(options.yAxis, opts.yaxis[0]);
              newYaxis.show = false;
              return newYaxis;
            }
          });
        }
        if (isLogY && series.length > 1 && series.length !== opts.yaxis.length) {
          console.warn('A multi-series logarithmic chart should have equal number of series and y-axes');
        }
        return opts;
      }

      // annotations also accepts array, so we need to extend them manually
    }, {
      key: "extendAnnotations",
      value: function extendAnnotations(opts) {
        if (typeof opts.annotations === 'undefined') {
          opts.annotations = {};
          opts.annotations.yaxis = [];
          opts.annotations.xaxis = [];
          opts.annotations.points = [];
        }
        opts = this.extendYAxisAnnotations(opts);
        opts = this.extendXAxisAnnotations(opts);
        opts = this.extendPointAnnotations(opts);
        return opts;
      }
    }, {
      key: "extendYAxisAnnotations",
      value: function extendYAxisAnnotations(opts) {
        var options = new Options();
        opts.annotations.yaxis = Utils$1.extendArray(typeof opts.annotations.yaxis !== 'undefined' ? opts.annotations.yaxis : [], options.yAxisAnnotation);
        return opts;
      }
    }, {
      key: "extendXAxisAnnotations",
      value: function extendXAxisAnnotations(opts) {
        var options = new Options();
        opts.annotations.xaxis = Utils$1.extendArray(typeof opts.annotations.xaxis !== 'undefined' ? opts.annotations.xaxis : [], options.xAxisAnnotation);
        return opts;
      }
    }, {
      key: "extendPointAnnotations",
      value: function extendPointAnnotations(opts) {
        var options = new Options();
        opts.annotations.points = Utils$1.extendArray(typeof opts.annotations.points !== 'undefined' ? opts.annotations.points : [], options.pointAnnotation);
        return opts;
      }
    }, {
      key: "checkForDarkTheme",
      value: function checkForDarkTheme(opts) {
        if (opts.theme && opts.theme.mode === 'dark') {
          if (!opts.tooltip) {
            opts.tooltip = {};
          }
          if (opts.tooltip.theme !== 'light') {
            opts.tooltip.theme = 'dark';
          }
          if (!opts.chart.foreColor) {
            opts.chart.foreColor = '#f6f7f8';
          }
          if (!opts.theme.palette) {
            opts.theme.palette = 'palette4';
          }
        }
      }
    }, {
      key: "handleUserInputErrors",
      value: function handleUserInputErrors(opts) {
        var config = opts;
        // conflicting tooltip option. intersect makes sure to focus on 1 point at a time. Shared cannot be used along with it
        if (config.tooltip.shared && config.tooltip.intersect) {
          throw new Error('tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.');
        }
        if (config.chart.type === 'bar' && config.plotOptions.bar.horizontal) {
          // No multiple yaxis for bars
          if (config.yaxis.length > 1) {
            throw new Error('Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false');
          }

          // if yaxis is reversed in horizontal bar chart, you should draw the y-axis on right side
          if (config.yaxis[0].reversed) {
            config.yaxis[0].opposite = true;
          }
          config.xaxis.tooltip.enabled = false; // no xaxis tooltip for horizontal bar
          config.yaxis[0].tooltip.enabled = false; // no xaxis tooltip for horizontal bar
          config.chart.zoom.enabled = false; // no zooming for horz bars
        }
        if (config.chart.type === 'bar' || config.chart.type === 'rangeBar') {
          if (config.tooltip.shared) {
            if (config.xaxis.crosshairs.width === 'barWidth' && config.series.length > 1) {
              config.xaxis.crosshairs.width = 'tickWidth';
            }
          }
        }
        if (config.chart.type === 'candlestick' || config.chart.type === 'boxPlot') {
          if (config.yaxis[0].reversed) {
            console.warn("Reversed y-axis in ".concat(config.chart.type, " chart is not supported."));
            config.yaxis[0].reversed = false;
          }
        }
        return config;
      }
    }]);
    return Config;
  }();

  var Globals = /*#__PURE__*/function () {
    function Globals() {
      _classCallCheck(this, Globals);
    }
    _createClass(Globals, [{
      key: "initGlobalVars",
      value: function initGlobalVars(gl) {
        gl.series = []; // the MAIN series array (y values)
        gl.seriesCandleO = [];
        gl.seriesCandleH = [];
        gl.seriesCandleM = [];
        gl.seriesCandleL = [];
        gl.seriesCandleC = [];
        gl.seriesRangeStart = [];
        gl.seriesRangeEnd = [];
        gl.seriesRange = [];
        gl.seriesPercent = [];
        gl.seriesGoals = [];
        gl.seriesX = [];
        gl.seriesZ = [];
        gl.seriesNames = [];
        gl.seriesTotals = [];
        gl.seriesLog = [];
        gl.seriesColors = [];
        gl.stackedSeriesTotals = [];
        gl.seriesXvalues = []; // we will need this in tooltip (it's x position) when we will have unequal x values, we will need some way to get x value depending on mouse pointer
        gl.seriesYvalues = []; // we will need this when deciding which series user hovered on
        gl.dataWasParsed = false;
        gl.originalSeries = null;
        gl.labels = [];
        gl.hasXaxisGroups = false;
        gl.groups = [];
        gl.barGroups = [];
        gl.lineGroups = [];
        gl.areaGroups = [];
        gl.hasSeriesGroups = false;
        gl.seriesGroups = [];
        gl.categoryLabels = [];
        gl.timescaleLabels = [];
        gl.noLabelsProvided = false;
        gl.resizeTimer = null;
        gl.selectionResizeTimer = null;
        gl.lastWheelExecution = 0;
        gl.delayedElements = [];
        gl.pointsArray = [];
        gl.dataLabelsRects = [];
        gl.isXNumeric = false;
        gl.skipLastTimelinelabel = false;
        gl.skipFirstTimelinelabel = false;
        gl.isDataXYZ = false;
        gl.isMultiLineX = false;
        gl.isMultipleYAxis = false;
        gl.maxY = -Number.MAX_VALUE;
        gl.minY = Number.MIN_VALUE;
        gl.minYArr = [];
        gl.maxYArr = [];
        gl.maxX = -Number.MAX_VALUE;
        gl.minX = Number.MAX_VALUE;
        gl.initialMaxX = -Number.MAX_VALUE;
        gl.initialMinX = Number.MAX_VALUE;
        gl.maxDate = 0;
        gl.minDate = Number.MAX_VALUE;
        gl.minZ = Number.MAX_VALUE;
        gl.maxZ = -Number.MAX_VALUE;
        gl.minXDiff = Number.MAX_VALUE;
        gl.yAxisScale = [];
        gl.xAxisScale = null;
        gl.xAxisTicksPositions = [];
        gl.yLabelsCoords = [];
        gl.yTitleCoords = [];
        gl.barPadForNumericAxis = 0;
        gl.padHorizontal = 0;
        gl.xRange = 0;
        gl.yRange = [];
        gl.zRange = 0;
        gl.dataPoints = 0;
        gl.xTickAmount = 0;
        gl.multiAxisTickAmount = 0;
      }
    }, {
      key: "globalVars",
      value: function globalVars(config) {
        return {
          chartID: null,
          // chart ID - apexcharts-cuid
          cuid: null,
          // chart ID - random numbers excluding "apexcharts" part
          events: {
            beforeMount: [],
            mounted: [],
            updated: [],
            clicked: [],
            selection: [],
            dataPointSelection: [],
            zoomed: [],
            scrolled: []
          },
          colors: [],
          clientX: null,
          clientY: null,
          fill: {
            colors: []
          },
          stroke: {
            colors: []
          },
          dataLabels: {
            style: {
              colors: []
            }
          },
          radarPolygons: {
            fill: {
              colors: []
            }
          },
          markers: {
            colors: [],
            size: config.markers.size,
            largestSize: 0
          },
          animationEnded: false,
          isTouchDevice: 'ontouchstart' in window || navigator.msMaxTouchPoints,
          isDirty: false,
          // chart has been updated after the initial render. This is different than dataChanged property. isDirty means user manually called some method to update
          isExecCalled: false,
          // whether user updated the chart through the exec method
          initialConfig: null,
          // we will store the first config user has set to go back when user finishes interactions like zooming and come out of it
          initialSeries: [],
          lastXAxis: [],
          lastYAxis: [],
          columnSeries: null,
          labels: [],
          // store the text to draw on x axis
          // Don't mutate the labels, many things including tooltips depends on it!
          timescaleLabels: [],
          // store the timescaleLabels Labels in another variable
          noLabelsProvided: false,
          // if user didn't provide any categories/labels or x values, fallback to 1,2,3,4...
          allSeriesCollapsed: false,
          collapsedSeries: [],
          // when user collapses a series, it goes into this array
          collapsedSeriesIndices: [],
          // this stores the index of the collapsedSeries instead of whole object for quick access
          ancillaryCollapsedSeries: [],
          // when user collapses an "alwaysVisible" series, it goes into this array
          ancillaryCollapsedSeriesIndices: [],
          // this stores the index of the ancillaryCollapsedSeries whose y-axis is always visible
          risingSeries: [],
          // when user re-opens a collapsed series, it goes here
          dataFormatXNumeric: false,
          // boolean value to indicate user has passed numeric x values
          capturedSeriesIndex: -1,
          capturedDataPointIndex: -1,
          selectedDataPoints: [],
          invalidLogScale: false,
          // if a user enabled log scale but the data provided is not valid to generate a log scale, turn on this flag
          ignoreYAxisIndexes: [],
          // when series are being collapsed in multiple y axes, ignore certain index
          maxValsInArrayIndex: 0,
          radialSize: 0,
          selection: undefined,
          zoomEnabled: config.chart.toolbar.autoSelected === 'zoom' && config.chart.toolbar.tools.zoom && config.chart.zoom.enabled,
          panEnabled: config.chart.toolbar.autoSelected === 'pan' && config.chart.toolbar.tools.pan,
          selectionEnabled: config.chart.toolbar.autoSelected === 'selection' && config.chart.toolbar.tools.selection,
          yaxis: null,
          mousedown: false,
          lastClientPosition: {},
          // don't reset this variable this the chart is destroyed. It is used to detect right or left mousemove in panning
          visibleXRange: undefined,
          yValueDecimal: 0,
          // are there floating numbers in the series. If yes, this represent the len of the decimals
          total: 0,
          SVGNS: 'http://www.w3.org/2000/svg',
          // svg namespace
          svgWidth: 0,
          // the whole svg width
          svgHeight: 0,
          // the whole svg height
          noData: false,
          // whether there is any data to display or not
          locale: {},
          // the current locale values will be preserved here for global access
          dom: {},
          // for storing all dom nodes in this particular property
          memory: {
            methodsToExec: []
          },
          shouldAnimate: true,
          skipLastTimelinelabel: false,
          // when last label is cropped, skip drawing it
          skipFirstTimelinelabel: false,
          // when first label is cropped, skip drawing it
          delayedElements: [],
          // element which appear after animation has finished
          axisCharts: true,
          // chart type = line or area or bar
          // (refer them also as plot charts in the code)
          isDataXYZ: false,
          // bool: data was provided in a {[x,y,z]} pattern
          isSlopeChart: config.plotOptions.line.isSlopeChart,
          resized: false,
          // bool: user has resized
          resizeTimer: null,
          // timeout function to make a small delay before
          // drawing when user resized
          comboCharts: false,
          // bool: whether it's a combination of line/column
          dataChanged: false,
          // bool: has data changed dynamically
          previousPaths: [],
          // array: when data is changed, it will animate from
          // previous paths
          allSeriesHasEqualX: true,
          pointsArray: [],
          // store the points positions here to draw later on hover
          // format is - [[x,y],[x,y]... [x,y]]
          dataLabelsRects: [],
          // store the positions of datalabels to prevent collision
          lastDrawnDataLabelsIndexes: [],
          hasNullValues: false,
          // bool: whether series contains null values
          zoomed: false,
          // whether user has zoomed or not
          gridWidth: 0,
          // drawable width of actual graphs (series paths)
          gridHeight: 0,
          // drawable height of actual graphs (series paths)
          rotateXLabels: false,
          defaultLabels: false,
          xLabelFormatter: undefined,
          // formatter for x axis labels
          yLabelFormatters: [],
          xaxisTooltipFormatter: undefined,
          // formatter for x axis tooltip
          ttKeyFormatter: undefined,
          ttVal: undefined,
          ttZFormatter: undefined,
          LINE_HEIGHT_RATIO: 1.618,
          xAxisLabelsHeight: 0,
          xAxisGroupLabelsHeight: 0,
          xAxisLabelsWidth: 0,
          yAxisLabelsWidth: 0,
          scaleX: 1,
          scaleY: 1,
          translateX: 0,
          translateY: 0,
          translateYAxisX: [],
          yAxisWidths: [],
          translateXAxisY: 0,
          translateXAxisX: 0,
          tooltip: null,
          // Rules for niceScaleAllowedMagMsd:
          // 1) An array of two arrays only ([[],[]]):
          //    * array[0][]: influences labelling of data series that contain only integers
          //       - must contain only integers (or expect ugly ticks)
          //    * array[1][]: influences labelling of data series that contain at least one float
          //       - may contain floats
          //    * both arrays:
          //       - each array[][i] ideally satisfy: 10 mod array[][i] == 0 (or expect ugly ticks)
          //       - to avoid clipping data point keep each array[][i] >= i
          // 2) each array[i][] contains 11 values, for all possible index values 0..10.
          //    array[][0] should not be needed (not proven) but ensures non-zero is returned.
          //
          // Users can effectively force their preferred "magMsd" through stepSize and
          // forceNiceScale. With forceNiceScale: true, stepSize becomes normalizable to the
          // axis's min..max range, which allows users to set stepSize to an integer 1..10, for
          // example, stepSize: 3. This value will be preferred to the value determined through
          // this array. The range-normalized value is checked for consistency with other
          // user defined options and will be ignored if inconsistent.
          niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]],
          // Default ticks based on SVG size. These values have high numbers
          // of divisors. The array is indexed using a calculated maxTicks value
          // divided by 2 simply to halve the array size. See Scales.niceScale().
          niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24],
          seriesYAxisMap: [],
          // Given yAxis index, return all series indices belonging to it. Multiple series can be referenced to each yAxis.
          seriesYAxisReverseMap: [] // Given a Series index, return its yAxis index.
        };
      }
    }, {
      key: "init",
      value: function init(config) {
        var globals = this.globalVars(config);
        this.initGlobalVars(globals);
        globals.initialConfig = Utils$1.extend({}, config);
        globals.initialSeries = Utils$1.clone(config.series);
        globals.lastXAxis = Utils$1.clone(globals.initialConfig.xaxis);
        globals.lastYAxis = Utils$1.clone(globals.initialConfig.yaxis);
        return globals;
      }
    }]);
    return Globals;
  }();

  /**
   * ApexCharts Base Class for extending user options with pre-defined ApexCharts config.
   *
   * @module Base
   **/
  var Base = /*#__PURE__*/function () {
    function Base(opts) {
      _classCallCheck(this, Base);
      this.opts = opts;
    }
    _createClass(Base, [{
      key: "init",
      value: function init() {
        var config = new Config(this.opts).init({
          responsiveOverride: false
        });
        var globals = new Globals().init(config);
        var w = {
          config: config,
          globals: globals
        };
        return w;
      }
    }]);
    return Base;
  }();

  /**
   * ApexCharts Fill Class for setting fill options of the paths.
   *
   * @module Fill
   **/
  var Fill = /*#__PURE__*/function () {
    function Fill(ctx) {
      _classCallCheck(this, Fill);
      this.ctx = ctx;
      this.w = ctx.w;
      this.opts = null;
      this.seriesIndex = 0;
      this.patternIDs = [];
    }
    _createClass(Fill, [{
      key: "clippedImgArea",
      value: function clippedImgArea(params) {
        var w = this.w;
        var cnf = w.config;
        var svgW = parseInt(w.globals.gridWidth, 10);
        var svgH = parseInt(w.globals.gridHeight, 10);
        var size = svgW > svgH ? svgW : svgH;
        var fillImg = params.image;
        var imgWidth = 0;
        var imgHeight = 0;
        if (typeof params.width === 'undefined' && typeof params.height === 'undefined') {
          if (cnf.fill.image.width !== undefined && cnf.fill.image.height !== undefined) {
            imgWidth = cnf.fill.image.width + 1;
            imgHeight = cnf.fill.image.height;
          } else {
            imgWidth = size + 1;
            imgHeight = size;
          }
        } else {
          imgWidth = params.width;
          imgHeight = params.height;
        }
        var elPattern = document.createElementNS(w.globals.SVGNS, 'pattern');
        Graphics.setAttrs(elPattern, {
          id: params.patternID,
          patternUnits: params.patternUnits ? params.patternUnits : 'userSpaceOnUse',
          width: imgWidth + 'px',
          height: imgHeight + 'px'
        });
        var elImage = document.createElementNS(w.globals.SVGNS, 'image');
        elPattern.appendChild(elImage);
        elImage.setAttributeNS(window.SVG.xlink, 'href', fillImg);
        Graphics.setAttrs(elImage, {
          x: 0,
          y: 0,
          preserveAspectRatio: 'none',
          width: imgWidth + 'px',
          height: imgHeight + 'px'
        });
        elImage.style.opacity = params.opacity;
        w.globals.dom.elDefs.node.appendChild(elPattern);
      }
    }, {
      key: "getSeriesIndex",
      value: function getSeriesIndex(opts) {
        var w = this.w;
        var cType = w.config.chart.type;
        if ((cType === 'bar' || cType === 'rangeBar') && w.config.plotOptions.bar.distributed || cType === 'heatmap' || cType === 'treemap') {
          this.seriesIndex = opts.seriesNumber;
        } else {
          this.seriesIndex = opts.seriesNumber % w.globals.series.length;
        }
        return this.seriesIndex;
      }
    }, {
      key: "computeColorStops",
      value: function computeColorStops(data, multiColorConfig) {
        var w = this.w;
        var maxPositive = null;
        var minNegative = null;
        var _iterator = _createForOfIteratorHelper(data),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var value = _step.value;
            if (value >= multiColorConfig.threshold) {
              if (maxPositive === null || value > maxPositive) {
                maxPositive = value;
              }
            } else {
              if (minNegative === null || value < minNegative) {
                minNegative = value;
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        if (maxPositive === null) {
          maxPositive = multiColorConfig.threshold;
        }
        if (minNegative === null) {
          minNegative = multiColorConfig.threshold;
        }
        var totalRange = maxPositive - multiColorConfig.threshold + (multiColorConfig.threshold - minNegative);
        if (totalRange === 0) {
          totalRange = 1;
        }
        var negativePercentage = (multiColorConfig.threshold - minNegative) / totalRange * 100;
        var offset = 100 - negativePercentage;
        offset = Math.max(0, Math.min(offset, 100));
        return [{
          offset: offset,
          color: multiColorConfig.colorAboveThreshold,
          opacity: w.config.fill.opacity
        }, {
          offset: 0,
          color: multiColorConfig.colorBelowThreshold,
          opacity: w.config.fill.opacity
        }];
      }
    }, {
      key: "fillPath",
      value: function fillPath(opts) {
        var _w$config$series$this, _w$config$series$this2, _w$config$series$this3;
        var w = this.w;
        this.opts = opts;
        var cnf = this.w.config;
        var pathFill;
        var patternFill, gradientFill;
        this.seriesIndex = this.getSeriesIndex(opts);
        var drawMultiColorLine = cnf.plotOptions.line.colors.colorAboveThreshold && cnf.plotOptions.line.colors.colorBelowThreshold;
        var fillColors = this.getFillColors();
        var fillColor = fillColors[this.seriesIndex];

        //override fillcolor if user inputted color with data
        if (w.globals.seriesColors[this.seriesIndex] !== undefined) {
          fillColor = w.globals.seriesColors[this.seriesIndex];
        }
        if (typeof fillColor === 'function') {
          fillColor = fillColor({
            seriesIndex: this.seriesIndex,
            dataPointIndex: opts.dataPointIndex,
            value: opts.value,
            w: w
          });
        }
        var fillType = opts.fillType ? opts.fillType : this.getFillType(this.seriesIndex);
        var fillOpacity = Array.isArray(cnf.fill.opacity) ? cnf.fill.opacity[this.seriesIndex] : cnf.fill.opacity;

        // when line colors needs to be different based on values, we use gradient config to achieve this
        var useGradient = fillType === 'gradient' || drawMultiColorLine;
        if (opts.color) {
          fillColor = opts.color;
        }
        if ((_w$config$series$this = w.config.series[this.seriesIndex]) !== null && _w$config$series$this !== void 0 && (_w$config$series$this2 = _w$config$series$this.data) !== null && _w$config$series$this2 !== void 0 && (_w$config$series$this3 = _w$config$series$this2[opts.dataPointIndex]) !== null && _w$config$series$this3 !== void 0 && _w$config$series$this3.fillColor) {
          var _w$config$series$this4, _w$config$series$this5, _w$config$series$this6;
          fillColor = (_w$config$series$this4 = w.config.series[this.seriesIndex]) === null || _w$config$series$this4 === void 0 ? void 0 : (_w$config$series$this5 = _w$config$series$this4.data) === null || _w$config$series$this5 === void 0 ? void 0 : (_w$config$series$this6 = _w$config$series$this5[opts.dataPointIndex]) === null || _w$config$series$this6 === void 0 ? void 0 : _w$config$series$this6.fillColor;
        }

        // in case a color is undefined, fallback to white color to prevent runtime error
        if (!fillColor) {
          fillColor = '#fff';
          console.warn('undefined color - ApexCharts');
        }
        var defaultColor = fillColor;
        if (fillColor.indexOf('rgb') === -1) {
          if (fillColor.indexOf('#') === -1) {
            defaultColor = fillColor;
          } else if (fillColor.length < 9) {
            // if the hex contains alpha and is of 9 digit, skip the opacity
            defaultColor = Utils$1.hexToRgba(fillColor, fillOpacity);
          }
        } else {
          if (fillColor.indexOf('rgba') > -1) {
            fillOpacity = Utils$1.getOpacityFromRGBA(fillColor);
          } else {
            defaultColor = Utils$1.hexToRgba(Utils$1.rgb2hex(fillColor), fillOpacity);
          }
        }
        if (opts.opacity) fillOpacity = opts.opacity;
        if (fillType === 'pattern') {
          patternFill = this.handlePatternFill({
            fillConfig: opts.fillConfig,
            patternFill: patternFill,
            fillColor: fillColor,
            fillOpacity: fillOpacity,
            defaultColor: defaultColor
          });
        }
        if (useGradient) {
          var colorStops = _toConsumableArray(cnf.fill.gradient.colorStops) || [];
          var type = cnf.fill.gradient.type;
          if (drawMultiColorLine) {
            colorStops[this.seriesIndex] = this.computeColorStops(w.globals.series[this.seriesIndex], cnf.plotOptions.line.colors);
            type = 'vertical';
          }
          gradientFill = this.handleGradientFill({
            type: type,
            fillConfig: opts.fillConfig,
            fillColor: fillColor,
            fillOpacity: fillOpacity,
            colorStops: colorStops,
            i: this.seriesIndex
          });
        }
        if (fillType === 'image') {
          var imgSrc = cnf.fill.image.src;
          var patternID = opts.patternID ? opts.patternID : '';
          var patternKey = "pattern".concat(w.globals.cuid).concat(opts.seriesNumber + 1).concat(patternID);
          if (this.patternIDs.indexOf(patternKey) === -1) {
            this.clippedImgArea({
              opacity: fillOpacity,
              image: Array.isArray(imgSrc) ? opts.seriesNumber < imgSrc.length ? imgSrc[opts.seriesNumber] : imgSrc[0] : imgSrc,
              width: opts.width ? opts.width : undefined,
              height: opts.height ? opts.height : undefined,
              patternUnits: opts.patternUnits,
              patternID: patternKey
            });
            this.patternIDs.push(patternKey);
          }
          pathFill = "url(#".concat(patternKey, ")");
        } else if (useGradient) {
          pathFill = gradientFill;
        } else if (fillType === 'pattern') {
          pathFill = patternFill;
        } else {
          pathFill = defaultColor;
        }

        // override pattern/gradient if opts.solid is true
        if (opts.solid) {
          pathFill = defaultColor;
        }
        return pathFill;
      }
    }, {
      key: "getFillType",
      value: function getFillType(seriesIndex) {
        var w = this.w;
        if (Array.isArray(w.config.fill.type)) {
          return w.config.fill.type[seriesIndex];
        } else {
          return w.config.fill.type;
        }
      }
    }, {
      key: "getFillColors",
      value: function getFillColors() {
        var w = this.w;
        var cnf = w.config;
        var opts = this.opts;
        var fillColors = [];
        if (w.globals.comboCharts) {
          if (w.config.series[this.seriesIndex].type === 'line') {
            if (Array.isArray(w.globals.stroke.colors)) {
              fillColors = w.globals.stroke.colors;
            } else {
              fillColors.push(w.globals.stroke.colors);
            }
          } else {
            if (Array.isArray(w.globals.fill.colors)) {
              fillColors = w.globals.fill.colors;
            } else {
              fillColors.push(w.globals.fill.colors);
            }
          }
        } else {
          if (cnf.chart.type === 'line') {
            if (Array.isArray(w.globals.stroke.colors)) {
              fillColors = w.globals.stroke.colors;
            } else {
              fillColors.push(w.globals.stroke.colors);
            }
          } else {
            if (Array.isArray(w.globals.fill.colors)) {
              fillColors = w.globals.fill.colors;
            } else {
              fillColors.push(w.globals.fill.colors);
            }
          }
        }

        // colors passed in arguments
        if (typeof opts.fillColors !== 'undefined') {
          fillColors = [];
          if (Array.isArray(opts.fillColors)) {
            fillColors = opts.fillColors.slice();
          } else {
            fillColors.push(opts.fillColors);
          }
        }
        return fillColors;
      }
    }, {
      key: "handlePatternFill",
      value: function handlePatternFill(_ref) {
        var fillConfig = _ref.fillConfig,
          patternFill = _ref.patternFill,
          fillColor = _ref.fillColor,
          fillOpacity = _ref.fillOpacity,
          defaultColor = _ref.defaultColor;
        var fillCnf = this.w.config.fill;
        if (fillConfig) {
          fillCnf = fillConfig;
        }
        var opts = this.opts;
        var graphics = new Graphics(this.ctx);
        var patternStrokeWidth = Array.isArray(fillCnf.pattern.strokeWidth) ? fillCnf.pattern.strokeWidth[this.seriesIndex] : fillCnf.pattern.strokeWidth;
        var patternLineColor = fillColor;
        if (Array.isArray(fillCnf.pattern.style)) {
          if (typeof fillCnf.pattern.style[opts.seriesNumber] !== 'undefined') {
            var pf = graphics.drawPattern(fillCnf.pattern.style[opts.seriesNumber], fillCnf.pattern.width, fillCnf.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);
            patternFill = pf;
          } else {
            patternFill = defaultColor;
          }
        } else {
          patternFill = graphics.drawPattern(fillCnf.pattern.style, fillCnf.pattern.width, fillCnf.pattern.height, patternLineColor, patternStrokeWidth, fillOpacity);
        }
        return patternFill;
      }
    }, {
      key: "handleGradientFill",
      value: function handleGradientFill(_ref2) {
        var type = _ref2.type,
          fillColor = _ref2.fillColor,
          fillOpacity = _ref2.fillOpacity,
          fillConfig = _ref2.fillConfig,
          colorStops = _ref2.colorStops,
          i = _ref2.i;
        var fillCnf = this.w.config.fill;
        if (fillConfig) {
          fillCnf = _objectSpread2(_objectSpread2({}, fillCnf), fillConfig);
        }
        var opts = this.opts;
        var graphics = new Graphics(this.ctx);
        var utils = new Utils$1();
        type = type || fillCnf.gradient.type;
        var gradientFrom = fillColor;
        var gradientTo;
        var opacityFrom = fillCnf.gradient.opacityFrom === undefined ? fillOpacity : Array.isArray(fillCnf.gradient.opacityFrom) ? fillCnf.gradient.opacityFrom[i] : fillCnf.gradient.opacityFrom;
        if (gradientFrom.indexOf('rgba') > -1) {
          opacityFrom = Utils$1.getOpacityFromRGBA(gradientFrom);
        }
        var opacityTo = fillCnf.gradient.opacityTo === undefined ? fillOpacity : Array.isArray(fillCnf.gradient.opacityTo) ? fillCnf.gradient.opacityTo[i] : fillCnf.gradient.opacityTo;
        if (fillCnf.gradient.gradientToColors === undefined || fillCnf.gradient.gradientToColors.length === 0) {
          if (fillCnf.gradient.shade === 'dark') {
            gradientTo = utils.shadeColor(parseFloat(fillCnf.gradient.shadeIntensity) * -1, fillColor.indexOf('rgb') > -1 ? Utils$1.rgb2hex(fillColor) : fillColor);
          } else {
            gradientTo = utils.shadeColor(parseFloat(fillCnf.gradient.shadeIntensity), fillColor.indexOf('rgb') > -1 ? Utils$1.rgb2hex(fillColor) : fillColor);
          }
        } else {
          if (fillCnf.gradient.gradientToColors[opts.seriesNumber]) {
            var gToColor = fillCnf.gradient.gradientToColors[opts.seriesNumber];
            gradientTo = gToColor;
            if (gToColor.indexOf('rgba') > -1) {
              opacityTo = Utils$1.getOpacityFromRGBA(gToColor);
            }
          } else {
            gradientTo = fillColor;
          }
        }
        if (fillCnf.gradient.gradientFrom) {
          gradientFrom = fillCnf.gradient.gradientFrom;
        }
        if (fillCnf.gradient.gradientTo) {
          gradientTo = fillCnf.gradient.gradientTo;
        }
        if (fillCnf.gradient.inverseColors) {
          var t = gradientFrom;
          gradientFrom = gradientTo;
          gradientTo = t;
        }
        if (gradientFrom.indexOf('rgb') > -1) {
          gradientFrom = Utils$1.rgb2hex(gradientFrom);
        }
        if (gradientTo.indexOf('rgb') > -1) {
          gradientTo = Utils$1.rgb2hex(gradientTo);
        }
        return graphics.drawGradient(type, gradientFrom, gradientTo, opacityFrom, opacityTo, opts.size, fillCnf.gradient.stops, colorStops, i);
      }
    }]);
    return Fill;
  }();

  /**
   * ApexCharts Markers Class for drawing markers on y values in axes charts.
   *
   * @module Markers
   **/
  var Markers = /*#__PURE__*/function () {
    function Markers(ctx, opts) {
      _classCallCheck(this, Markers);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(Markers, [{
      key: "setGlobalMarkerSize",
      value: function setGlobalMarkerSize() {
        var w = this.w;
        w.globals.markers.size = Array.isArray(w.config.markers.size) ? w.config.markers.size : [w.config.markers.size];
        if (w.globals.markers.size.length > 0) {
          if (w.globals.markers.size.length < w.globals.series.length + 1) {
            for (var i = 0; i <= w.globals.series.length; i++) {
              if (typeof w.globals.markers.size[i] === 'undefined') {
                w.globals.markers.size.push(w.globals.markers.size[0]);
              }
            }
          }
        } else {
          w.globals.markers.size = w.config.series.map(function (s) {
            return w.config.markers.size;
          });
        }
      }
    }, {
      key: "plotChartMarkers",
      value: function plotChartMarkers(_ref) {
        var pointsPos = _ref.pointsPos,
          seriesIndex = _ref.seriesIndex,
          j = _ref.j,
          pSize = _ref.pSize,
          _ref$alwaysDrawMarker = _ref.alwaysDrawMarker,
          alwaysDrawMarker = _ref$alwaysDrawMarker === void 0 ? false : _ref$alwaysDrawMarker,
          _ref$isVirtualPoint = _ref.isVirtualPoint,
          isVirtualPoint = _ref$isVirtualPoint === void 0 ? false : _ref$isVirtualPoint;
        var w = this.w;
        var i = seriesIndex;
        var p = pointsPos;
        var elMarkersWrap = null;
        var graphics = new Graphics(this.ctx);
        var hasDiscreteMarkers = w.config.markers.discrete && w.config.markers.discrete.length;
        if (Array.isArray(p.x)) {
          for (var q = 0; q < p.x.length; q++) {
            var markerElement = void 0;
            var dataPointIndex = j;
            var invalidMarker = !Utils$1.isNumber(p.y[q]);
            if (w.globals.markers.largestSize === 0 && w.globals.hasNullValues && w.globals.series[i][j + 1] !== null && !isVirtualPoint) {
              invalidMarker = true;
            }

            // a small hack as we have 2 points for the first val to connect it
            if (j === 1 && q === 0) dataPointIndex = 0;
            if (j === 1 && q === 1) dataPointIndex = 1;
            var markerClasses = 'apexcharts-marker';
            if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {
              markerClasses += ' no-pointer-events';
            }
            var shouldMarkerDraw = Array.isArray(w.config.markers.size) ? w.globals.markers.size[seriesIndex] > 0 : w.config.markers.size > 0;
            if (shouldMarkerDraw || alwaysDrawMarker || hasDiscreteMarkers) {
              if (!invalidMarker) {
                markerClasses += " w".concat(Utils$1.randomId());
              }
              var opts = this.getMarkerConfig({
                cssClass: markerClasses,
                seriesIndex: seriesIndex,
                dataPointIndex: dataPointIndex
              });
              if (w.config.series[i].data[dataPointIndex]) {
                if (w.config.series[i].data[dataPointIndex].fillColor) {
                  opts.pointFillColor = w.config.series[i].data[dataPointIndex].fillColor;
                }
                if (w.config.series[i].data[dataPointIndex].strokeColor) {
                  opts.pointStrokeColor = w.config.series[i].data[dataPointIndex].strokeColor;
                }
              }
              if (typeof pSize !== 'undefined') {
                opts.pSize = pSize;
              }
              if (p.x[q] < -w.globals.markers.largestSize || p.x[q] > w.globals.gridWidth + w.globals.markers.largestSize || p.y[q] < -w.globals.markers.largestSize || p.y[q] > w.globals.gridHeight + w.globals.markers.largestSize) {
                opts.pSize = 0;
              }
              if (!invalidMarker) {
                var shouldCreateMarkerWrap = w.globals.markers.size[seriesIndex] > 0 || alwaysDrawMarker || hasDiscreteMarkers;
                if (shouldCreateMarkerWrap && !elMarkersWrap) {
                  elMarkersWrap = graphics.group({
                    class: alwaysDrawMarker || hasDiscreteMarkers ? '' : 'apexcharts-series-markers'
                  });
                  elMarkersWrap.attr('clip-path', "url(#gridRectMarkerMask".concat(w.globals.cuid, ")"));
                }
                markerElement = graphics.drawMarker(p.x[q], p.y[q], opts);
                markerElement.attr('rel', dataPointIndex);
                markerElement.attr('j', dataPointIndex);
                markerElement.attr('index', seriesIndex);
                markerElement.node.setAttribute('default-marker-size', opts.pSize);
                var filters = new Filters(this.ctx);
                filters.setSelectionFilter(markerElement, seriesIndex, dataPointIndex);
                this.addEvents(markerElement);
                if (elMarkersWrap) {
                  elMarkersWrap.add(markerElement);
                }
              }
            } else {
              // dynamic array creation - multidimensional
              if (typeof w.globals.pointsArray[seriesIndex] === 'undefined') w.globals.pointsArray[seriesIndex] = [];
              w.globals.pointsArray[seriesIndex].push([p.x[q], p.y[q]]);
            }
          }
        }
        return elMarkersWrap;
      }
    }, {
      key: "getMarkerConfig",
      value: function getMarkerConfig(_ref2) {
        var cssClass = _ref2.cssClass,
          seriesIndex = _ref2.seriesIndex,
          _ref2$dataPointIndex = _ref2.dataPointIndex,
          dataPointIndex = _ref2$dataPointIndex === void 0 ? null : _ref2$dataPointIndex,
          _ref2$radius = _ref2.radius,
          radius = _ref2$radius === void 0 ? null : _ref2$radius,
          _ref2$size = _ref2.size,
          size = _ref2$size === void 0 ? null : _ref2$size,
          _ref2$strokeWidth = _ref2.strokeWidth,
          strokeWidth = _ref2$strokeWidth === void 0 ? null : _ref2$strokeWidth;
        var w = this.w;
        var pStyle = this.getMarkerStyle(seriesIndex);
        var pSize = size === null ? w.globals.markers.size[seriesIndex] : size;
        var m = w.config.markers;

        // discrete markers is an option where user can specify a particular marker with different shape, size and color

        if (dataPointIndex !== null && m.discrete.length) {
          m.discrete.map(function (marker) {
            if (marker.seriesIndex === seriesIndex && marker.dataPointIndex === dataPointIndex) {
              pStyle.pointStrokeColor = marker.strokeColor;
              pStyle.pointFillColor = marker.fillColor;
              pSize = marker.size;
              pStyle.pointShape = marker.shape;
            }
          });
        }
        return {
          pSize: radius === null ? pSize : radius,
          pRadius: radius !== null ? radius : m.radius,
          pointStrokeWidth: strokeWidth !== null ? strokeWidth : Array.isArray(m.strokeWidth) ? m.strokeWidth[seriesIndex] : m.strokeWidth,
          pointStrokeColor: pStyle.pointStrokeColor,
          pointFillColor: pStyle.pointFillColor,
          shape: pStyle.pointShape || (Array.isArray(m.shape) ? m.shape[seriesIndex] : m.shape),
          class: cssClass,
          pointStrokeOpacity: Array.isArray(m.strokeOpacity) ? m.strokeOpacity[seriesIndex] : m.strokeOpacity,
          pointStrokeDashArray: Array.isArray(m.strokeDashArray) ? m.strokeDashArray[seriesIndex] : m.strokeDashArray,
          pointFillOpacity: Array.isArray(m.fillOpacity) ? m.fillOpacity[seriesIndex] : m.fillOpacity,
          seriesIndex: seriesIndex
        };
      }
    }, {
      key: "addEvents",
      value: function addEvents(marker) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        marker.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this.ctx, marker));
        marker.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this.ctx, marker));
        marker.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this.ctx, marker));
        marker.node.addEventListener('click', w.config.markers.onClick);
        marker.node.addEventListener('dblclick', w.config.markers.onDblClick);
        marker.node.addEventListener('touchstart', graphics.pathMouseDown.bind(this.ctx, marker), {
          passive: true
        });
      }
    }, {
      key: "getMarkerStyle",
      value: function getMarkerStyle(seriesIndex) {
        var w = this.w;
        var colors = w.globals.markers.colors;
        var strokeColors = w.config.markers.strokeColor || w.config.markers.strokeColors;
        var pointStrokeColor = Array.isArray(strokeColors) ? strokeColors[seriesIndex] : strokeColors;
        var pointFillColor = Array.isArray(colors) ? colors[seriesIndex] : colors;
        return {
          pointStrokeColor: pointStrokeColor,
          pointFillColor: pointFillColor
        };
      }
    }]);
    return Markers;
  }();

  /**
   * ApexCharts Scatter Class.
   * This Class also handles bubbles chart as currently there is no major difference in drawing them,
   * @module Scatter
   **/
  var Scatter = /*#__PURE__*/function () {
    function Scatter(ctx) {
      _classCallCheck(this, Scatter);
      this.ctx = ctx;
      this.w = ctx.w;
      this.initialAnim = this.w.config.chart.animations.enabled;
    }
    _createClass(Scatter, [{
      key: "draw",
      value: function draw(elSeries, j, opts) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var realIndex = opts.realIndex;
        var pointsPos = opts.pointsPos;
        var zRatio = opts.zRatio;
        var elPointsMain = opts.elParent;
        var elPointsWrap = graphics.group({
          class: "apexcharts-series-markers apexcharts-series-".concat(w.config.chart.type)
        });
        elPointsWrap.attr('clip-path', "url(#gridRectMarkerMask".concat(w.globals.cuid, ")"));
        if (Array.isArray(pointsPos.x)) {
          for (var q = 0; q < pointsPos.x.length; q++) {
            var dataPointIndex = j + 1;
            var shouldDraw = true;

            // a small hack as we have 2 points for the first val to connect it
            if (j === 0 && q === 0) dataPointIndex = 0;
            if (j === 0 && q === 1) dataPointIndex = 1;
            var radius = w.globals.markers.size[realIndex];
            if (zRatio !== Infinity) {
              // means we have a bubble
              var bubble = w.config.plotOptions.bubble;
              radius = w.globals.seriesZ[realIndex][dataPointIndex];
              if (bubble.zScaling) {
                radius /= zRatio;
              }
              if (bubble.minBubbleRadius && radius < bubble.minBubbleRadius) {
                radius = bubble.minBubbleRadius;
              }
              if (bubble.maxBubbleRadius && radius > bubble.maxBubbleRadius) {
                radius = bubble.maxBubbleRadius;
              }
            }
            var x = pointsPos.x[q];
            var y = pointsPos.y[q];
            radius = radius || 0;
            if (y === null || typeof w.globals.series[realIndex][dataPointIndex] === 'undefined') {
              shouldDraw = false;
            }
            if (shouldDraw) {
              var point = this.drawPoint(x, y, radius, realIndex, dataPointIndex, j);
              elPointsWrap.add(point);
            }
            elPointsMain.add(elPointsWrap);
          }
        }
      }
    }, {
      key: "drawPoint",
      value: function drawPoint(x, y, radius, realIndex, dataPointIndex, j) {
        var w = this.w;
        var i = realIndex;
        var anim = new Animations(this.ctx);
        var filters = new Filters(this.ctx);
        var fill = new Fill(this.ctx);
        var markers = new Markers(this.ctx);
        var graphics = new Graphics(this.ctx);
        var markerConfig = markers.getMarkerConfig({
          cssClass: 'apexcharts-marker',
          seriesIndex: i,
          dataPointIndex: dataPointIndex,
          radius: w.config.chart.type === 'bubble' || w.globals.comboCharts && w.config.series[realIndex] && w.config.series[realIndex].type === 'bubble' ? radius : null
        });
        var pathFillCircle = fill.fillPath({
          seriesNumber: realIndex,
          dataPointIndex: dataPointIndex,
          color: markerConfig.pointFillColor,
          patternUnits: 'objectBoundingBox',
          value: w.globals.series[realIndex][j]
        });
        var el = graphics.drawMarker(x, y, markerConfig);
        if (w.config.series[i].data[dataPointIndex]) {
          if (w.config.series[i].data[dataPointIndex].fillColor) {
            pathFillCircle = w.config.series[i].data[dataPointIndex].fillColor;
          }
        }
        el.attr({
          fill: pathFillCircle
        });
        if (w.config.chart.dropShadow.enabled) {
          var dropShadow = w.config.chart.dropShadow;
          filters.dropShadow(el, dropShadow, realIndex);
        }
        if (this.initialAnim && !w.globals.dataChanged && !w.globals.resized) {
          var speed = w.config.chart.animations.speed;
          anim.animateMarker(el, speed, w.globals.easing, function () {
            window.setTimeout(function () {
              anim.animationCompleted(el);
            }, 100);
          });
        } else {
          w.globals.animationEnded = true;
        }
        el.attr({
          rel: dataPointIndex,
          j: dataPointIndex,
          index: realIndex,
          'default-marker-size': markerConfig.pSize
        });
        filters.setSelectionFilter(el, realIndex, dataPointIndex);
        markers.addEvents(el);
        el.node.classList.add('apexcharts-marker');
        return el;
      }
    }, {
      key: "centerTextInBubble",
      value: function centerTextInBubble(y) {
        var w = this.w;
        y = y + parseInt(w.config.dataLabels.style.fontSize, 10) / 4;
        return {
          y: y
        };
      }
    }]);
    return Scatter;
  }();

  /**
   * ApexCharts DataLabels Class for drawing dataLabels on Axes based Charts.
   *
   * @module DataLabels
   **/
  var DataLabels = /*#__PURE__*/function () {
    function DataLabels(ctx) {
      _classCallCheck(this, DataLabels);
      this.ctx = ctx;
      this.w = ctx.w;
    }

    // When there are many datalabels to be printed, and some of them overlaps each other in the same series, this method will take care of that
    // Also, when datalabels exceeds the drawable area and get clipped off, we need to adjust and move some pixels to make them visible again
    _createClass(DataLabels, [{
      key: "dataLabelsCorrection",
      value: function dataLabelsCorrection(x, y, val, i, dataPointIndex, alwaysDrawDataLabel, fontSize) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var drawnextLabel = false; //

        var textRects = graphics.getTextRects(val, fontSize);
        var width = textRects.width;
        var height = textRects.height;
        if (y < 0) y = 0;
        if (y > w.globals.gridHeight + height) y = w.globals.gridHeight + height / 2;

        // first value in series, so push an empty array
        if (typeof w.globals.dataLabelsRects[i] === 'undefined') w.globals.dataLabelsRects[i] = [];

        // then start pushing actual rects in that sub-array
        w.globals.dataLabelsRects[i].push({
          x: x,
          y: y,
          width: width,
          height: height
        });
        var len = w.globals.dataLabelsRects[i].length - 2;
        var lastDrawnIndex = typeof w.globals.lastDrawnDataLabelsIndexes[i] !== 'undefined' ? w.globals.lastDrawnDataLabelsIndexes[i][w.globals.lastDrawnDataLabelsIndexes[i].length - 1] : 0;
        if (typeof w.globals.dataLabelsRects[i][len] !== 'undefined') {
          var lastDataLabelRect = w.globals.dataLabelsRects[i][lastDrawnIndex];
          if (
          // next label forward and x not intersecting
          x > lastDataLabelRect.x + lastDataLabelRect.width || y > lastDataLabelRect.y + lastDataLabelRect.height || y + height < lastDataLabelRect.y || x + width < lastDataLabelRect.x // next label is going to be drawn backwards
          ) {
            // the 2 indexes don't override, so OK to draw next label
            drawnextLabel = true;
          }
        }
        if (dataPointIndex === 0 || alwaysDrawDataLabel) {
          drawnextLabel = true;
        }
        return {
          x: x,
          y: y,
          textRects: textRects,
          drawnextLabel: drawnextLabel
        };
      }
    }, {
      key: "drawDataLabel",
      value: function drawDataLabel(_ref) {
        var _this = this;
        var type = _ref.type,
          pos = _ref.pos,
          i = _ref.i,
          j = _ref.j,
          isRangeStart = _ref.isRangeStart,
          _ref$strokeWidth = _ref.strokeWidth,
          strokeWidth = _ref$strokeWidth === void 0 ? 2 : _ref$strokeWidth;
        // this method handles line, area, bubble, scatter charts as those charts contains markers/points which have pre-defined x/y positions
        // all other charts like radar / bars / heatmaps will define their own drawDataLabel routine
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var dataLabelsConfig = w.config.dataLabels;
        var x = 0;
        var y = 0;
        var dataPointIndex = j;
        var elDataLabelsWrap = null;
        var seriesCollapsed = w.globals.collapsedSeriesIndices.indexOf(i) !== -1;
        if (seriesCollapsed || !dataLabelsConfig.enabled || !Array.isArray(pos.x)) {
          return elDataLabelsWrap;
        }
        elDataLabelsWrap = graphics.group({
          class: 'apexcharts-data-labels'
        });
        for (var q = 0; q < pos.x.length; q++) {
          x = pos.x[q] + dataLabelsConfig.offsetX;
          y = pos.y[q] + dataLabelsConfig.offsetY + strokeWidth;
          if (!isNaN(x)) {
            // a small hack as we have 2 points for the first val to connect it
            if (j === 1 && q === 0) dataPointIndex = 0;
            if (j === 1 && q === 1) dataPointIndex = 1;
            var val = w.globals.series[i][dataPointIndex];
            if (type === 'rangeArea') {
              if (isRangeStart) {
                val = w.globals.seriesRangeStart[i][dataPointIndex];
              } else {
                val = w.globals.seriesRangeEnd[i][dataPointIndex];
              }
            }
            var text = '';
            var getText = function getText(v) {
              return w.config.dataLabels.formatter(v, {
                ctx: _this.ctx,
                seriesIndex: i,
                dataPointIndex: dataPointIndex,
                w: w
              });
            };
            if (w.config.chart.type === 'bubble') {
              val = w.globals.seriesZ[i][dataPointIndex];
              text = getText(val);
              y = pos.y[q];
              var scatter = new Scatter(this.ctx);
              var centerTextInBubbleCoords = scatter.centerTextInBubble(y, i, dataPointIndex);
              y = centerTextInBubbleCoords.y;
            } else {
              if (typeof val !== 'undefined') {
                text = getText(val);
              }
            }
            var textAnchor = w.config.dataLabels.textAnchor;
            if (w.globals.isSlopeChart) {
              if (dataPointIndex === 0) {
                textAnchor = 'end';
              } else if (dataPointIndex === w.config.series[i].data.length - 1) {
                textAnchor = 'start';
              } else {
                textAnchor = 'middle';
              }
            }
            this.plotDataLabelsText({
              x: x,
              y: y,
              text: text,
              i: i,
              j: dataPointIndex,
              parent: elDataLabelsWrap,
              offsetCorrection: true,
              dataLabelsConfig: w.config.dataLabels,
              textAnchor: textAnchor
            });
          }
        }
        return elDataLabelsWrap;
      }
    }, {
      key: "plotDataLabelsText",
      value: function plotDataLabelsText(opts) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var x = opts.x,
          y = opts.y,
          i = opts.i,
          j = opts.j,
          text = opts.text,
          textAnchor = opts.textAnchor,
          fontSize = opts.fontSize,
          parent = opts.parent,
          dataLabelsConfig = opts.dataLabelsConfig,
          color = opts.color,
          alwaysDrawDataLabel = opts.alwaysDrawDataLabel,
          offsetCorrection = opts.offsetCorrection,
          className = opts.className;
        var dataLabelText = null;
        if (Array.isArray(w.config.dataLabels.enabledOnSeries)) {
          if (w.config.dataLabels.enabledOnSeries.indexOf(i) < 0) {
            return dataLabelText;
          }
        }
        var correctedLabels = {
          x: x,
          y: y,
          drawnextLabel: true,
          textRects: null
        };
        if (offsetCorrection) {
          correctedLabels = this.dataLabelsCorrection(x, y, text, i, j, alwaysDrawDataLabel, parseInt(dataLabelsConfig.style.fontSize, 10));
        }

        // when zoomed, we don't need to correct labels offsets,
        // but if normally, labels get cropped, correct them
        if (!w.globals.zoomed) {
          x = correctedLabels.x;
          y = correctedLabels.y;
        }
        if (correctedLabels.textRects) {
          // fixes #2264
          if (x < -20 - correctedLabels.textRects.width || x > w.globals.gridWidth + correctedLabels.textRects.width + 30) {
            // datalabels fall outside drawing area, so draw a blank label
            text = '';
          }
        }
        var dataLabelColor = w.globals.dataLabels.style.colors[i];
        if ((w.config.chart.type === 'bar' || w.config.chart.type === 'rangeBar') && w.config.plotOptions.bar.distributed || w.config.dataLabels.distributed) {
          dataLabelColor = w.globals.dataLabels.style.colors[j];
        }
        if (typeof dataLabelColor === 'function') {
          dataLabelColor = dataLabelColor({
            series: w.globals.series,
            seriesIndex: i,
            dataPointIndex: j,
            w: w
          });
        }
        if (color) {
          dataLabelColor = color;
        }
        var offX = dataLabelsConfig.offsetX;
        var offY = dataLabelsConfig.offsetY;
        if (w.config.chart.type === 'bar' || w.config.chart.type === 'rangeBar') {
          // for certain chart types, we handle offsets while calculating datalabels pos
          // why? because bars/column may have negative values and based on that
          // offsets becomes reversed
          offX = 0;
          offY = 0;
        }
        if (w.globals.isSlopeChart) {
          if (j !== 0) {
            offX = dataLabelsConfig.offsetX * -2 + 5;
          }
          if (j !== 0 && j !== w.config.series[i].data.length - 1) {
            offX = 0;
          }
        }
        if (correctedLabels.drawnextLabel) {
          if (textAnchor === 'middle') {
            if (x === w.globals.gridWidth) {
              // last label - might get cropped
              // fixes https://github.com/apexcharts/apexcharts.js/issues/5036
              textAnchor = 'end';
            }
          }
          dataLabelText = graphics.drawText({
            width: 100,
            height: parseInt(dataLabelsConfig.style.fontSize, 10),
            x: x + offX,
            y: y + offY,
            foreColor: dataLabelColor,
            textAnchor: textAnchor || dataLabelsConfig.textAnchor,
            text: text,
            fontSize: fontSize || dataLabelsConfig.style.fontSize,
            fontFamily: dataLabelsConfig.style.fontFamily,
            fontWeight: dataLabelsConfig.style.fontWeight || 'normal'
          });
          dataLabelText.attr({
            class: className || 'apexcharts-datalabel',
            cx: x,
            cy: y
          });
          if (dataLabelsConfig.dropShadow.enabled) {
            var textShadow = dataLabelsConfig.dropShadow;
            var filters = new Filters(this.ctx);
            filters.dropShadow(dataLabelText, textShadow);
          }
          parent.add(dataLabelText);
          if (typeof w.globals.lastDrawnDataLabelsIndexes[i] === 'undefined') {
            w.globals.lastDrawnDataLabelsIndexes[i] = [];
          }
          w.globals.lastDrawnDataLabelsIndexes[i].push(j);
        }
        return dataLabelText;
      }
    }, {
      key: "addBackgroundToDataLabel",
      value: function addBackgroundToDataLabel(el, coords) {
        var w = this.w;
        var bCnf = w.config.dataLabels.background;
        var paddingH = bCnf.padding;
        var paddingV = bCnf.padding / 2;
        var width = coords.width;
        var height = coords.height;
        var graphics = new Graphics(this.ctx);
        var elRect = graphics.drawRect(coords.x - paddingH, coords.y - paddingV / 2, width + paddingH * 2, height + paddingV, bCnf.borderRadius, w.config.chart.background === 'transparent' || !w.config.chart.background ? '#fff' : w.config.chart.background, bCnf.opacity, bCnf.borderWidth, bCnf.borderColor);
        if (bCnf.dropShadow.enabled) {
          var filters = new Filters(this.ctx);
          filters.dropShadow(elRect, bCnf.dropShadow);
        }
        return elRect;
      }
    }, {
      key: "dataLabelsBackground",
      value: function dataLabelsBackground() {
        var w = this.w;
        if (w.config.chart.type === 'bubble') return;
        var elDataLabels = w.globals.dom.baseEl.querySelectorAll('.apexcharts-datalabels text');
        for (var i = 0; i < elDataLabels.length; i++) {
          var el = elDataLabels[i];
          var coords = el.getBBox();
          var elRect = null;
          if (coords.width && coords.height) {
            elRect = this.addBackgroundToDataLabel(el, coords);
          }
          if (elRect) {
            el.parentNode.insertBefore(elRect.node, el);
            var background = w.config.dataLabels.background.backgroundColor || el.getAttribute('fill');
            var shouldAnim = w.config.chart.animations.enabled && !w.globals.resized && !w.globals.dataChanged;
            if (shouldAnim) {
              elRect.animate().attr({
                fill: background
              });
            } else {
              elRect.attr({
                fill: background
              });
            }
            el.setAttribute('fill', w.config.dataLabels.background.foreColor);
          }
        }
      }
    }, {
      key: "bringForward",
      value: function bringForward() {
        var w = this.w;
        var elDataLabelsNodes = w.globals.dom.baseEl.querySelectorAll('.apexcharts-datalabels');
        var elSeries = w.globals.dom.baseEl.querySelector('.apexcharts-plot-series:last-child');
        for (var i = 0; i < elDataLabelsNodes.length; i++) {
          if (elSeries) {
            elSeries.insertBefore(elDataLabelsNodes[i], elSeries.nextSibling);
          }
        }
      }
    }]);
    return DataLabels;
  }();

  var css_248z$1 = ".apexcharts-flip-y {\n  transform: scaleY(-1) translateY(-100%);\n  transform-origin: top;\n  transform-box: fill-box;\n}\n.apexcharts-flip-x {\n  transform: scaleX(-1);\n  transform-origin: center;\n  transform-box: fill-box;\n}\n.apexcharts-legend {\n  display: flex;\n  overflow: auto;\n  padding: 0 10px;\n}\n.apexcharts-legend.apexcharts-legend-group-horizontal {\n  flex-direction: column;\n}\n.apexcharts-legend-group {\n  display: flex;\n}\n.apexcharts-legend-group-vertical {\n  flex-direction: column-reverse;\n}\n.apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n  flex-wrap: wrap\n}\n.apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n  flex-direction: column;\n  bottom: 0;\n}\n.apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n  justify-content: flex-start;\n  align-items: flex-start;\n}\n.apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n  justify-content: center;\n  align-items: center;\n}\n.apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n  justify-content: flex-end;\n  align-items: flex-end;\n}\n.apexcharts-legend-series {\n  cursor: pointer;\n  line-height: normal;\n  display: flex;\n  align-items: center;\n}\n.apexcharts-legend-text {\n  position: relative;\n  font-size: 14px;\n}\n.apexcharts-legend-text *, .apexcharts-legend-marker * {\n  pointer-events: none;\n}\n.apexcharts-legend-marker {\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  margin-right: 1px;\n}\n\n.apexcharts-legend-series.apexcharts-no-click {\n  cursor: auto;\n}\n.apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n  display: none !important;\n}\n.apexcharts-inactive-legend {\n  opacity: 0.45;\n} ";

  /**
   * ApexCharts Series Class for interaction with the Series of the chart.
   *
   * @module Series
   **/
  var Series = /*#__PURE__*/function () {
    function Series(ctx) {
      _classCallCheck(this, Series);
      this.ctx = ctx;
      this.w = ctx.w;
      this.legendInactiveClass = 'legend-mouseover-inactive';
    }
    _createClass(Series, [{
      key: "getAllSeriesEls",
      value: function getAllSeriesEls() {
        return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
      }
    }, {
      key: "getSeriesByName",
      value: function getSeriesByName(seriesName) {
        return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(Utils$1.escapeString(seriesName), "']"));
      }
    }, {
      key: "isSeriesHidden",
      value: function isSeriesHidden(seriesName) {
        var targetElement = this.getSeriesByName(seriesName);
        var realIndex = parseInt(targetElement.getAttribute('data:realIndex'), 10);
        var isHidden = targetElement.classList.contains('apexcharts-series-collapsed');
        return {
          isHidden: isHidden,
          realIndex: realIndex
        };
      }
    }, {
      key: "addCollapsedClassToSeries",
      value: function addCollapsedClassToSeries(elSeries, index) {
        var w = this.w;
        function iterateOnAllCollapsedSeries(series) {
          for (var cs = 0; cs < series.length; cs++) {
            if (series[cs].index === index) {
              elSeries.node.classList.add('apexcharts-series-collapsed');
            }
          }
        }
        iterateOnAllCollapsedSeries(w.globals.collapsedSeries);
        iterateOnAllCollapsedSeries(w.globals.ancillaryCollapsedSeries);
      }
    }, {
      key: "toggleSeries",
      value: function toggleSeries(seriesName) {
        var isSeriesHidden = this.isSeriesHidden(seriesName);
        this.ctx.legend.legendHelpers.toggleDataSeries(isSeriesHidden.realIndex, isSeriesHidden.isHidden);
        return isSeriesHidden.isHidden;
      }
    }, {
      key: "showSeries",
      value: function showSeries(seriesName) {
        var isSeriesHidden = this.isSeriesHidden(seriesName);
        if (isSeriesHidden.isHidden) {
          this.ctx.legend.legendHelpers.toggleDataSeries(isSeriesHidden.realIndex, true);
        }
      }
    }, {
      key: "hideSeries",
      value: function hideSeries(seriesName) {
        var isSeriesHidden = this.isSeriesHidden(seriesName);
        if (!isSeriesHidden.isHidden) {
          this.ctx.legend.legendHelpers.toggleDataSeries(isSeriesHidden.realIndex, false);
        }
      }
    }, {
      key: "resetSeries",
      value: function resetSeries() {
        var shouldUpdateChart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var shouldResetZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var shouldResetCollapsed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var w = this.w;
        var series = Utils$1.clone(w.globals.initialSeries);
        w.globals.previousPaths = [];
        if (shouldResetCollapsed) {
          w.globals.collapsedSeries = [];
          w.globals.ancillaryCollapsedSeries = [];
          w.globals.collapsedSeriesIndices = [];
          w.globals.ancillaryCollapsedSeriesIndices = [];
        } else {
          series = this.emptyCollapsedSeries(series);
        }
        w.config.series = series;
        if (shouldUpdateChart) {
          if (shouldResetZoom) {
            w.globals.zoomed = false;
            this.ctx.updateHelpers.revertDefaultAxisMinMax();
          }
          this.ctx.updateHelpers._updateSeries(series, w.config.chart.animations.dynamicAnimation.enabled);
        }
      }
    }, {
      key: "emptyCollapsedSeries",
      value: function emptyCollapsedSeries(series) {
        var w = this.w;
        for (var i = 0; i < series.length; i++) {
          if (w.globals.collapsedSeriesIndices.indexOf(i) > -1) {
            series[i].data = [];
          }
        }
        return series;
      }
    }, {
      key: "highlightSeries",
      value: function highlightSeries(seriesName) {
        var w = this.w;
        var targetElement = this.getSeriesByName(seriesName);
        var realIndex = parseInt(targetElement === null || targetElement === void 0 ? void 0 : targetElement.getAttribute('data:realIndex'), 10);
        var allSeriesEls = w.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
        var seriesEl = null;
        var dataLabelEl = null;
        var yaxisEl = null;
        if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {
          if (w.globals.axisCharts) {
            seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(realIndex, "']"));
            dataLabelEl = w.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(realIndex, "']"));
            var yaxisIndex = w.globals.seriesYAxisReverseMap[realIndex];
            yaxisEl = w.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(yaxisIndex, "']"));
          } else {
            seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(realIndex + 1, "']"));
          }
        } else {
          seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(realIndex + 1, "'] path"));
        }
        for (var se = 0; se < allSeriesEls.length; se++) {
          allSeriesEls[se].classList.add(this.legendInactiveClass);
        }
        if (seriesEl) {
          if (!w.globals.axisCharts) {
            seriesEl.parentNode.classList.remove(this.legendInactiveClass);
          }
          seriesEl.classList.remove(this.legendInactiveClass);
          if (dataLabelEl !== null) {
            dataLabelEl.classList.remove(this.legendInactiveClass);
          }
          if (yaxisEl !== null) {
            yaxisEl.classList.remove(this.legendInactiveClass);
          }
        } else {
          for (var _se = 0; _se < allSeriesEls.length; _se++) {
            allSeriesEls[_se].classList.remove(this.legendInactiveClass);
          }
        }
      }
    }, {
      key: "toggleSeriesOnHover",
      value: function toggleSeriesOnHover(e, targetElement) {
        var w = this.w;
        if (!targetElement) targetElement = e.target;
        var allSeriesEls = w.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
        if (e.type === 'mousemove') {
          var realIndex = parseInt(targetElement.getAttribute('rel'), 10) - 1;
          this.highlightSeries(w.globals.seriesNames[realIndex]);
        } else if (e.type === 'mouseout') {
          for (var se = 0; se < allSeriesEls.length; se++) {
            allSeriesEls[se].classList.remove(this.legendInactiveClass);
          }
        }
      }
    }, {
      key: "highlightRangeInSeries",
      value: function highlightRangeInSeries(e, targetElement) {
        var _this = this;
        var w = this.w;
        var allHeatMapElements = w.globals.dom.baseEl.getElementsByClassName('apexcharts-heatmap-rect');
        var activeInactive = function activeInactive(action) {
          for (var i = 0; i < allHeatMapElements.length; i++) {
            allHeatMapElements[i].classList[action](_this.legendInactiveClass);
          }
        };
        var removeInactiveClassFromHoveredRange = function removeInactiveClassFromHoveredRange(range, rangeMax) {
          for (var i = 0; i < allHeatMapElements.length; i++) {
            var val = Number(allHeatMapElements[i].getAttribute('val'));
            if (val >= range.from && (val < range.to || range.to === rangeMax && val === rangeMax)) {
              allHeatMapElements[i].classList.remove(_this.legendInactiveClass);
            }
          }
        };
        if (e.type === 'mousemove') {
          var seriesCnt = parseInt(targetElement.getAttribute('rel'), 10) - 1;
          activeInactive('add');
          var ranges = w.config.plotOptions.heatmap.colorScale.ranges;
          var range = ranges[seriesCnt];
          var rangeMax = ranges.reduce(function (acc, cur) {
            return Math.max(acc, cur.to);
          }, 0);
          removeInactiveClassFromHoveredRange(range, rangeMax);
        } else if (e.type === 'mouseout') {
          activeInactive('remove');
        }
      }
    }, {
      key: "getActiveConfigSeriesIndex",
      value: function getActiveConfigSeriesIndex() {
        var order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'asc';
        var chartTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var w = this.w;
        var activeIndex = 0;
        if (w.config.series.length > 1) {
          // active series flag is required to know if user has not deactivated via legend click
          var activeSeriesIndex = w.config.series.map(function (s, index) {
            var checkChartType = function checkChartType() {
              if (w.globals.comboCharts) {
                return chartTypes.length === 0 || chartTypes.length && chartTypes.indexOf(w.config.series[index].type) > -1;
              }
              return true;
            };
            var hasData = s.data && s.data.length > 0 && w.globals.collapsedSeriesIndices.indexOf(index) === -1;
            return hasData && checkChartType() ? index : -1;
          });
          for (var a = order === 'asc' ? 0 : activeSeriesIndex.length - 1; order === 'asc' ? a < activeSeriesIndex.length : a >= 0; order === 'asc' ? a++ : a--) {
            if (activeSeriesIndex[a] !== -1) {
              activeIndex = activeSeriesIndex[a];
              break;
            }
          }
        }
        return activeIndex;
      }
    }, {
      key: "getBarSeriesIndices",
      value: function getBarSeriesIndices() {
        var w = this.w;
        if (w.globals.comboCharts) {
          return this.w.config.series.map(function (s, i) {
            return s.type === 'bar' || s.type === 'column' ? i : -1;
          }).filter(function (i) {
            return i !== -1;
          });
        }
        return this.w.config.series.map(function (s, i) {
          return i;
        });
      }
    }, {
      key: "getPreviousPaths",
      value: function getPreviousPaths() {
        var w = this.w;
        w.globals.previousPaths = [];
        function pushPaths(seriesEls, i, type) {
          var paths = seriesEls[i].childNodes;
          var dArr = {
            type: type,
            paths: [],
            realIndex: seriesEls[i].getAttribute('data:realIndex')
          };
          for (var j = 0; j < paths.length; j++) {
            if (paths[j].hasAttribute('pathTo')) {
              var d = paths[j].getAttribute('pathTo');
              dArr.paths.push({
                d: d
              });
            }
          }
          w.globals.previousPaths.push(dArr);
        }
        var getPaths = function getPaths(chartType) {
          return w.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(chartType, "-series .apexcharts-series"));
        };
        var chartTypes = ['line', 'area', 'bar', 'rangebar', 'rangeArea', 'candlestick', 'radar'];
        chartTypes.forEach(function (type) {
          var paths = getPaths(type);
          for (var p = 0; p < paths.length; p++) {
            pushPaths(paths, p, type);
          }
        });
        var heatTreeSeries = w.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(w.config.chart.type, " .apexcharts-series"));
        if (heatTreeSeries.length > 0) {
          var _loop = function _loop(h) {
            var seriesEls = w.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(w.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(h, "'] rect"));
            var dArr = [];
            var _loop2 = function _loop2(i) {
              var getAttr = function getAttr(x) {
                return seriesEls[i].getAttribute(x);
              };
              var rect = {
                x: parseFloat(getAttr('x')),
                y: parseFloat(getAttr('y')),
                width: parseFloat(getAttr('width')),
                height: parseFloat(getAttr('height'))
              };
              dArr.push({
                rect: rect,
                color: seriesEls[i].getAttribute('color')
              });
            };
            for (var i = 0; i < seriesEls.length; i++) {
              _loop2(i);
            }
            w.globals.previousPaths.push(dArr);
          };
          for (var h = 0; h < heatTreeSeries.length; h++) {
            _loop(h);
          }
        }
        if (!w.globals.axisCharts) {
          // for non-axis charts (i.e., circular charts, pathFrom is not usable. We need whole series)
          w.globals.previousPaths = w.globals.series;
        }
      }
    }, {
      key: "clearPreviousPaths",
      value: function clearPreviousPaths() {
        var w = this.w;
        w.globals.previousPaths = [];
        w.globals.allSeriesCollapsed = false;
      }
    }, {
      key: "handleNoData",
      value: function handleNoData() {
        var w = this.w;
        var me = this;
        var noDataOpts = w.config.noData;
        var graphics = new Graphics(me.ctx);
        var x = w.globals.svgWidth / 2;
        var y = w.globals.svgHeight / 2;
        var textAnchor = 'middle';
        w.globals.noData = true;
        w.globals.animationEnded = true;
        if (noDataOpts.align === 'left') {
          x = 10;
          textAnchor = 'start';
        } else if (noDataOpts.align === 'right') {
          x = w.globals.svgWidth - 10;
          textAnchor = 'end';
        }
        if (noDataOpts.verticalAlign === 'top') {
          y = 50;
        } else if (noDataOpts.verticalAlign === 'bottom') {
          y = w.globals.svgHeight - 50;
        }
        x = x + noDataOpts.offsetX;
        y = y + parseInt(noDataOpts.style.fontSize, 10) + 2 + noDataOpts.offsetY;
        if (noDataOpts.text !== undefined && noDataOpts.text !== '') {
          var titleText = graphics.drawText({
            x: x,
            y: y,
            text: noDataOpts.text,
            textAnchor: textAnchor,
            fontSize: noDataOpts.style.fontSize,
            fontFamily: noDataOpts.style.fontFamily,
            foreColor: noDataOpts.style.color,
            opacity: 1,
            class: 'apexcharts-text-nodata'
          });
          w.globals.dom.Paper.add(titleText);
        }
      }

      // When user clicks on legends, the collapsed series is filled with [0,0,0,...,0]
      // This is because we don't want to alter the series' length as it is used at many places
    }, {
      key: "setNullSeriesToZeroValues",
      value: function setNullSeriesToZeroValues(series) {
        var w = this.w;
        for (var sl = 0; sl < series.length; sl++) {
          if (series[sl].length === 0) {
            for (var j = 0; j < series[w.globals.maxValsInArrayIndex].length; j++) {
              series[sl].push(0);
            }
          }
        }
        return series;
      }
    }, {
      key: "hasAllSeriesEqualX",
      value: function hasAllSeriesEqualX() {
        var equalLen = true;
        var w = this.w;
        var filteredSerX = this.filteredSeriesX();
        for (var i = 0; i < filteredSerX.length - 1; i++) {
          if (filteredSerX[i][0] !== filteredSerX[i + 1][0]) {
            equalLen = false;
            break;
          }
        }
        w.globals.allSeriesHasEqualX = equalLen;
        return equalLen;
      }
    }, {
      key: "filteredSeriesX",
      value: function filteredSeriesX() {
        var w = this.w;
        var filteredSeriesX = w.globals.seriesX.map(function (ser) {
          return ser.length > 0 ? ser : [];
        });
        return filteredSeriesX;
      }
    }]);
    return Series;
  }();

  var Data = /*#__PURE__*/function () {
    function Data(ctx) {
      _classCallCheck(this, Data);
      this.ctx = ctx;
      this.w = ctx.w;
      this.twoDSeries = [];
      this.threeDSeries = [];
      this.twoDSeriesX = [];
      this.seriesGoals = [];
      this.coreUtils = new CoreUtils(this.ctx);
    }
    _createClass(Data, [{
      key: "isMultiFormat",
      value: function isMultiFormat() {
        return this.isFormatXY() || this.isFormat2DArray();
      }

      // given format is [{x, y}, {x, y}]
    }, {
      key: "isFormatXY",
      value: function isFormatXY() {
        var series = this.w.config.series.slice();
        var sr = new Series(this.ctx);
        this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();
        if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && series[this.activeSeriesIndex].data[0] !== null && typeof series[this.activeSeriesIndex].data[0].x !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null) {
          return true;
        }
      }

      // given format is [[x, y], [x, y]]
    }, {
      key: "isFormat2DArray",
      value: function isFormat2DArray() {
        var series = this.w.config.series.slice();
        var sr = new Series(this.ctx);
        this.activeSeriesIndex = sr.getActiveConfigSeriesIndex();
        if (typeof series[this.activeSeriesIndex].data !== 'undefined' && series[this.activeSeriesIndex].data.length > 0 && typeof series[this.activeSeriesIndex].data[0] !== 'undefined' && series[this.activeSeriesIndex].data[0] !== null && series[this.activeSeriesIndex].data[0].constructor === Array) {
          return true;
        }
      }
    }, {
      key: "handleFormat2DArray",
      value: function handleFormat2DArray(ser, i) {
        var cnf = this.w.config;
        var gl = this.w.globals;
        var isBoxPlot = cnf.chart.type === 'boxPlot' || cnf.series[i].type === 'boxPlot';
        for (var j = 0; j < ser[i].data.length; j++) {
          if (typeof ser[i].data[j][1] !== 'undefined') {
            if (Array.isArray(ser[i].data[j][1]) && ser[i].data[j][1].length === 4 && !isBoxPlot) {
              // candlestick nested ohlc format
              this.twoDSeries.push(Utils$1.parseNumber(ser[i].data[j][1][3]));
            } else if (ser[i].data[j].length >= 5) {
              // candlestick non-nested ohlc format
              this.twoDSeries.push(Utils$1.parseNumber(ser[i].data[j][4]));
            } else {
              this.twoDSeries.push(Utils$1.parseNumber(ser[i].data[j][1]));
            }
            gl.dataFormatXNumeric = true;
          }
          if (cnf.xaxis.type === 'datetime') {
            // if timestamps are provided and xaxis type is datetime,

            var ts = new Date(ser[i].data[j][0]);
            ts = new Date(ts).getTime();
            this.twoDSeriesX.push(ts);
          } else {
            this.twoDSeriesX.push(ser[i].data[j][0]);
          }
        }
        for (var _j = 0; _j < ser[i].data.length; _j++) {
          if (typeof ser[i].data[_j][2] !== 'undefined') {
            this.threeDSeries.push(ser[i].data[_j][2]);
            gl.isDataXYZ = true;
          }
        }
      }
    }, {
      key: "handleFormatXY",
      value: function handleFormatXY(ser, i) {
        var cnf = this.w.config;
        var gl = this.w.globals;
        var dt = new DateTime(this.ctx);
        var activeI = i;
        if (gl.collapsedSeriesIndices.indexOf(i) > -1) {
          // fix #368
          activeI = this.activeSeriesIndex;
        }

        // get series
        for (var j = 0; j < ser[i].data.length; j++) {
          if (typeof ser[i].data[j].y !== 'undefined') {
            if (Array.isArray(ser[i].data[j].y)) {
              this.twoDSeries.push(Utils$1.parseNumber(ser[i].data[j].y[ser[i].data[j].y.length - 1]));
            } else {
              this.twoDSeries.push(Utils$1.parseNumber(ser[i].data[j].y));
            }
          }
          if (typeof ser[i].data[j].goals !== 'undefined' && Array.isArray(ser[i].data[j].goals)) {
            if (typeof this.seriesGoals[i] === 'undefined') {
              this.seriesGoals[i] = [];
            }
            this.seriesGoals[i].push(ser[i].data[j].goals);
          } else {
            if (typeof this.seriesGoals[i] === 'undefined') {
              this.seriesGoals[i] = [];
            }
            this.seriesGoals[i].push(null);
          }
        }

        // get seriesX
        for (var _j2 = 0; _j2 < ser[activeI].data.length; _j2++) {
          var isXString = typeof ser[activeI].data[_j2].x === 'string';
          var isXArr = Array.isArray(ser[activeI].data[_j2].x);
          var isXDate = !isXArr && !!dt.isValidDate(ser[activeI].data[_j2].x);
          if (isXString || isXDate) {
            // user supplied '01/01/2017' or a date string (a JS date object is not supported)
            if (isXString || cnf.xaxis.convertedCatToNumeric) {
              var isRangeColumn = gl.isBarHorizontal && gl.isRangeData;
              if (cnf.xaxis.type === 'datetime' && !isRangeColumn) {
                this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x));
              } else {
                // a category and not a numeric x value
                this.fallbackToCategory = true;
                this.twoDSeriesX.push(ser[activeI].data[_j2].x);
                if (!isNaN(ser[activeI].data[_j2].x) && this.w.config.xaxis.type !== 'category' && typeof ser[activeI].data[_j2].x !== 'string') {
                  gl.isXNumeric = true;
                }
              }
            } else {
              if (cnf.xaxis.type === 'datetime') {
                this.twoDSeriesX.push(dt.parseDate(ser[activeI].data[_j2].x.toString()));
              } else {
                gl.dataFormatXNumeric = true;
                gl.isXNumeric = true;
                this.twoDSeriesX.push(parseFloat(ser[activeI].data[_j2].x));
              }
            }
          } else if (isXArr) {
            // a multiline label described in array format
            this.fallbackToCategory = true;
            this.twoDSeriesX.push(ser[activeI].data[_j2].x);
          } else {
            // a numeric value in x property
            gl.isXNumeric = true;
            gl.dataFormatXNumeric = true;
            this.twoDSeriesX.push(ser[activeI].data[_j2].x);
          }
        }
        if (ser[i].data[0] && typeof ser[i].data[0].z !== 'undefined') {
          for (var t = 0; t < ser[i].data.length; t++) {
            this.threeDSeries.push(ser[i].data[t].z);
          }
          gl.isDataXYZ = true;
        }
      }
    }, {
      key: "handleRangeData",
      value: function handleRangeData(ser, i) {
        var gl = this.w.globals;
        var range = {};
        if (this.isFormat2DArray()) {
          range = this.handleRangeDataFormat('array', ser, i);
        } else if (this.isFormatXY()) {
          range = this.handleRangeDataFormat('xy', ser, i);
        }

        // Fix: RangeArea Chart: hide all series results in a crash #3984
        gl.seriesRangeStart[i] = range.start === undefined ? [] : range.start;
        gl.seriesRangeEnd[i] = range.end === undefined ? [] : range.end;
        gl.seriesRange[i] = range.rangeUniques;

        // check for overlaps to avoid clashes in a timeline chart
        gl.seriesRange.forEach(function (sr, si) {
          if (sr) {
            sr.forEach(function (sarr, sarri) {
              sarr.y.forEach(function (arr, arri) {
                for (var sri = 0; sri < sarr.y.length; sri++) {
                  if (arri !== sri) {
                    var range1y1 = arr.y1;
                    var range1y2 = arr.y2;
                    var range2y1 = sarr.y[sri].y1;
                    var range2y2 = sarr.y[sri].y2;
                    if (range1y1 <= range2y2 && range2y1 <= range1y2) {
                      if (sarr.overlaps.indexOf(arr.rangeName) < 0) {
                        sarr.overlaps.push(arr.rangeName);
                      }
                      if (sarr.overlaps.indexOf(sarr.y[sri].rangeName) < 0) {
                        sarr.overlaps.push(sarr.y[sri].rangeName);
                      }
                    }
                  }
                }
              });
            });
          }
        });
        return range;
      }
    }, {
      key: "handleCandleStickBoxData",
      value: function handleCandleStickBoxData(ser, i) {
        var gl = this.w.globals;
        var ohlc = {};
        if (this.isFormat2DArray()) {
          ohlc = this.handleCandleStickBoxDataFormat('array', ser, i);
        } else if (this.isFormatXY()) {
          ohlc = this.handleCandleStickBoxDataFormat('xy', ser, i);
        }
        gl.seriesCandleO[i] = ohlc.o;
        gl.seriesCandleH[i] = ohlc.h;
        gl.seriesCandleM[i] = ohlc.m;
        gl.seriesCandleL[i] = ohlc.l;
        gl.seriesCandleC[i] = ohlc.c;
        return ohlc;
      }
    }, {
      key: "handleRangeDataFormat",
      value: function handleRangeDataFormat(format, ser, i) {
        var rangeStart = [];
        var rangeEnd = [];
        var uniqueKeys = ser[i].data.filter(function (thing, index, self) {
          return index === self.findIndex(function (t) {
            return t.x === thing.x;
          });
        }).map(function (r, index) {
          return {
            x: r.x,
            overlaps: [],
            y: []
          };
        });
        if (format === 'array') {
          for (var j = 0; j < ser[i].data.length; j++) {
            if (Array.isArray(ser[i].data[j])) {
              rangeStart.push(ser[i].data[j][1][0]);
              rangeEnd.push(ser[i].data[j][1][1]);
            } else {
              rangeStart.push(ser[i].data[j]);
              rangeEnd.push(ser[i].data[j]);
            }
          }
        } else if (format === 'xy') {
          var _loop = function _loop(_j3) {
            var isDataPoint2D = Array.isArray(ser[i].data[_j3].y);
            var id = Utils$1.randomId();
            var x = ser[i].data[_j3].x;
            var y = {
              y1: isDataPoint2D ? ser[i].data[_j3].y[0] : ser[i].data[_j3].y,
              y2: isDataPoint2D ? ser[i].data[_j3].y[1] : ser[i].data[_j3].y,
              rangeName: id
            };

            // CAUTION: mutating config object by adding a new property
            // TODO: As this is specifically for timeline rangebar charts, update the docs mentioning the series only supports xy format
            ser[i].data[_j3].rangeName = id;
            var uI = uniqueKeys.findIndex(function (t) {
              return t.x === x;
            });
            uniqueKeys[uI].y.push(y);
            rangeStart.push(y.y1);
            rangeEnd.push(y.y2);
          };
          for (var _j3 = 0; _j3 < ser[i].data.length; _j3++) {
            _loop(_j3);
          }
        }
        return {
          start: rangeStart,
          end: rangeEnd,
          rangeUniques: uniqueKeys
        };
      }
    }, {
      key: "handleCandleStickBoxDataFormat",
      value: function handleCandleStickBoxDataFormat(format, ser, i) {
        var w = this.w;
        var isBoxPlot = w.config.chart.type === 'boxPlot' || w.config.series[i].type === 'boxPlot';
        var serO = [];
        var serH = [];
        var serM = [];
        var serL = [];
        var serC = [];
        if (format === 'array') {
          if (isBoxPlot && ser[i].data[0].length === 6 || !isBoxPlot && ser[i].data[0].length === 5) {
            for (var j = 0; j < ser[i].data.length; j++) {
              serO.push(ser[i].data[j][1]);
              serH.push(ser[i].data[j][2]);
              if (isBoxPlot) {
                serM.push(ser[i].data[j][3]);
                serL.push(ser[i].data[j][4]);
                serC.push(ser[i].data[j][5]);
              } else {
                serL.push(ser[i].data[j][3]);
                serC.push(ser[i].data[j][4]);
              }
            }
          } else {
            for (var _j4 = 0; _j4 < ser[i].data.length; _j4++) {
              if (Array.isArray(ser[i].data[_j4][1])) {
                serO.push(ser[i].data[_j4][1][0]);
                serH.push(ser[i].data[_j4][1][1]);
                if (isBoxPlot) {
                  serM.push(ser[i].data[_j4][1][2]);
                  serL.push(ser[i].data[_j4][1][3]);
                  serC.push(ser[i].data[_j4][1][4]);
                } else {
                  serL.push(ser[i].data[_j4][1][2]);
                  serC.push(ser[i].data[_j4][1][3]);
                }
              }
            }
          }
        } else if (format === 'xy') {
          for (var _j5 = 0; _j5 < ser[i].data.length; _j5++) {
            if (Array.isArray(ser[i].data[_j5].y)) {
              serO.push(ser[i].data[_j5].y[0]);
              serH.push(ser[i].data[_j5].y[1]);
              if (isBoxPlot) {
                serM.push(ser[i].data[_j5].y[2]);
                serL.push(ser[i].data[_j5].y[3]);
                serC.push(ser[i].data[_j5].y[4]);
              } else {
                serL.push(ser[i].data[_j5].y[2]);
                serC.push(ser[i].data[_j5].y[3]);
              }
            }
          }
        }
        return {
          o: serO,
          h: serH,
          m: serM,
          l: serL,
          c: serC
        };
      }
    }, {
      key: "parseDataAxisCharts",
      value: function parseDataAxisCharts(ser) {
        var _this = this;
        var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.ctx;
        var cnf = this.w.config;
        var gl = this.w.globals;
        var dt = new DateTime(ctx);
        var xlabels = cnf.labels.length > 0 ? cnf.labels.slice() : cnf.xaxis.categories.slice();
        gl.isRangeBar = cnf.chart.type === 'rangeBar' && gl.isBarHorizontal;
        gl.hasXaxisGroups = cnf.xaxis.type === 'category' && cnf.xaxis.group.groups.length > 0;
        if (gl.hasXaxisGroups) {
          gl.groups = cnf.xaxis.group.groups;
        }
        ser.forEach(function (s, i) {
          if (s.name !== undefined) {
            gl.seriesNames.push(s.name);
          } else {
            gl.seriesNames.push('series-' + parseInt(i + 1, 10));
          }
        });
        this.coreUtils.setSeriesYAxisMappings();
        // At this point, every series that didn't have a user defined group name
        // has been given a name according to the yaxis the series is referenced by.
        // This fits the existing behaviour where all series associated with an axis
        // are defacto presented as a single group. It is now formalised.
        var buckets = [];
        var groups = _toConsumableArray(new Set(cnf.series.map(function (s) {
          return s.group;
        })));
        cnf.series.forEach(function (s, i) {
          var index = groups.indexOf(s.group);
          if (!buckets[index]) buckets[index] = [];
          buckets[index].push(gl.seriesNames[i]);
        });
        gl.seriesGroups = buckets;
        var handleDates = function handleDates() {
          for (var j = 0; j < xlabels.length; j++) {
            if (typeof xlabels[j] === 'string') {
              // user provided date strings
              var isDate = dt.isValidDate(xlabels[j]);
              if (isDate) {
                _this.twoDSeriesX.push(dt.parseDate(xlabels[j]));
              } else {
                throw new Error('You have provided invalid Date format. Please provide a valid JavaScript Date');
              }
            } else {
              // user provided timestamps
              _this.twoDSeriesX.push(xlabels[j]);
            }
          }
        };
        for (var i = 0; i < ser.length; i++) {
          this.twoDSeries = [];
          this.twoDSeriesX = [];
          this.threeDSeries = [];
          if (typeof ser[i].data === 'undefined') {
            console.error("It is a possibility that you may have not included 'data' property in series.");
            return;
          }
          if (cnf.chart.type === 'rangeBar' || cnf.chart.type === 'rangeArea' || ser[i].type === 'rangeBar' || ser[i].type === 'rangeArea') {
            gl.isRangeData = true;
            this.handleRangeData(ser, i);
          }
          if (this.isMultiFormat()) {
            if (this.isFormat2DArray()) {
              this.handleFormat2DArray(ser, i);
            } else if (this.isFormatXY()) {
              this.handleFormatXY(ser, i);
            }
            if (cnf.chart.type === 'candlestick' || ser[i].type === 'candlestick' || cnf.chart.type === 'boxPlot' || ser[i].type === 'boxPlot') {
              this.handleCandleStickBoxData(ser, i);
            }
            gl.series.push(this.twoDSeries);
            gl.labels.push(this.twoDSeriesX);
            gl.seriesX.push(this.twoDSeriesX);
            gl.seriesGoals = this.seriesGoals;
            if (i === this.activeSeriesIndex && !this.fallbackToCategory) {
              gl.isXNumeric = true;
            }
          } else {
            if (cnf.xaxis.type === 'datetime') {
              // user didn't supplied [{x,y}] or [[x,y]], but single array in data.
              // Also labels/categories were supplied differently
              gl.isXNumeric = true;
              handleDates();
              gl.seriesX.push(this.twoDSeriesX);
            } else if (cnf.xaxis.type === 'numeric') {
              gl.isXNumeric = true;
              if (xlabels.length > 0) {
                this.twoDSeriesX = xlabels;
                gl.seriesX.push(this.twoDSeriesX);
              }
            }
            gl.labels.push(this.twoDSeriesX);
            var singleArray = ser[i].data.map(function (d) {
              return Utils$1.parseNumber(d);
            });
            gl.series.push(singleArray);
          }
          gl.seriesZ.push(this.threeDSeries);

          // overrided default color if user inputs color with series data
          if (ser[i].color !== undefined) {
            gl.seriesColors.push(ser[i].color);
          } else {
            gl.seriesColors.push(undefined);
          }
        }
        return this.w;
      }
    }, {
      key: "parseDataNonAxisCharts",
      value: function parseDataNonAxisCharts(ser) {
        var gl = this.w.globals;
        var cnf = this.w.config;

        // Check if we have both old format (numeric series + labels) and new format
        var hasOldFormat = Array.isArray(ser) && ser.every(function (s) {
          return typeof s === 'number';
        }) && cnf.labels.length > 0;
        var hasNewFormat = Array.isArray(ser) && ser.some(function (s) {
          return s && _typeof(s) === 'object' && s.data || s && _typeof(s) === 'object' && s.parsing;
        });
        if (hasOldFormat && hasNewFormat) {
          console.warn('ApexCharts: Both old format (numeric series + labels) and new format (series objects with data/parsing) detected. Using old format for backward compatibility.');
        }

        // If old format exists, use it (backward compatibility priority)
        if (hasOldFormat) {
          gl.series = ser.slice();
          gl.seriesNames = cnf.labels.slice();
          for (var i = 0; i < gl.series.length; i++) {
            if (gl.seriesNames[i] === undefined) {
              gl.seriesNames.push('series-' + (i + 1));
            }
          }
          return this.w;
        }

        // Check if it's just a plain numeric array without labels (radialBar common case)
        if (Array.isArray(ser) && ser.every(function (s) {
          return typeof s === 'number';
        })) {
          gl.series = ser.slice();
          gl.seriesNames = [];
          for (var _i = 0; _i < gl.series.length; _i++) {
            gl.seriesNames.push(cnf.labels[_i] || "series-".concat(_i + 1));
          }
          return this.w;
        }
        var processedData = this.extractPieDataFromSeries(ser);
        gl.series = processedData.values;
        gl.seriesNames = processedData.labels;

        // Special handling for radialBar - ensure percentages are valid
        if (cnf.chart.type === 'radialBar') {
          gl.series = gl.series.map(function (val) {
            var numVal = Utils$1.parseNumber(val);
            if (numVal > 100) {
              console.warn("ApexCharts: RadialBar value ".concat(numVal, " > 100, consider using percentage values (0-100)"));
            }
            return numVal;
          });
        }

        // Ensure we have proper fallback names
        for (var _i2 = 0; _i2 < gl.series.length; _i2++) {
          if (gl.seriesNames[_i2] === undefined) {
            gl.seriesNames.push('series-' + (_i2 + 1));
          }
        }
        return this.w;
      }

      /**
       * Reset parsing flags to allow re-parsing of data during updates
       */
    }, {
      key: "resetParsingFlags",
      value: function resetParsingFlags() {
        var w = this.w;
        w.globals.dataWasParsed = false;
        w.globals.originalSeries = null;
        if (w.config.series) {
          w.config.series.forEach(function (serie) {
            if (serie.__apexParsed) {
              delete serie.__apexParsed;
            }
          });
        }
      }
    }, {
      key: "extractPieDataFromSeries",
      value: function extractPieDataFromSeries(ser) {
        var values = [];
        var labels = [];
        if (!Array.isArray(ser)) {
          console.warn('ApexCharts: Expected array for series data');
          return {
            values: [],
            labels: []
          };
        }
        if (ser.length === 0) {
          console.warn('ApexCharts: Empty series array');
          return {
            values: [],
            labels: []
          };
        }

        // Handle only series objects with data property
        var firstItem = ser[0];
        if (_typeof(firstItem) === 'object' && firstItem !== null && firstItem.data) {
          // Format: [{ data: [{x: 'A', y: 10}] }] or [{ data: rawData, parsing: {...} }]
          this.extractPieDataFromSeriesObjects(ser, values, labels);
        } else {
          // Unsupported format
          console.warn('ApexCharts: Unsupported series format for pie/donut/radialBar. Expected series objects with data property.');
          return {
            values: [],
            labels: []
          };
        }
        return {
          values: values,
          labels: labels
        };
      }

      // Extract data from series objects: [{ data: [...], parsing: {...} }]
    }, {
      key: "extractPieDataFromSeriesObjects",
      value: function extractPieDataFromSeriesObjects(seriesArray, values, labels) {
        seriesArray.forEach(function (serie, serieIndex) {
          if (!serie.data || !Array.isArray(serie.data)) {
            console.warn("ApexCharts: Series ".concat(serieIndex, " has no valid data array"));
            return;
          }

          // If series was already parsed by parseRawDataIfNeeded, data should be in {x, y} format
          serie.data.forEach(function (dataPoint) {
            if (_typeof(dataPoint) === 'object' && dataPoint !== null) {
              if (dataPoint.x !== undefined && dataPoint.y !== undefined) {
                labels.push(String(dataPoint.x));
                values.push(Utils$1.parseNumber(dataPoint.y));
              } else {
                console.warn('ApexCharts: Invalid data point format for pie chart. Expected {x, y} format:', dataPoint);
              }
            } else {
              console.warn('ApexCharts: Expected object data point, got:', _typeof(dataPoint));
            }
          });
        });
      }

      /** User possibly set string categories in xaxis.categories or labels prop
       * Or didn't set xaxis labels at all - in which case we manually do it.
       * If user passed series data as [[3, 2], [4, 5]] or [{ x: 3, y: 55 }],
       * this shouldn't be called
       * @param {array} ser - the series which user passed to the config
       */
    }, {
      key: "handleExternalLabelsData",
      value: function handleExternalLabelsData(ser) {
        var cnf = this.w.config;
        var gl = this.w.globals;
        if (cnf.xaxis.categories.length > 0) {
          // user provided labels in xaxis.category prop
          gl.labels = cnf.xaxis.categories;
        } else if (cnf.labels.length > 0) {
          // user provided labels in labels props
          gl.labels = cnf.labels.slice();
        } else if (this.fallbackToCategory) {
          // user provided labels in x prop in [{ x: 3, y: 55 }] data, and those labels are already stored in gl.labels[0], so just re-arrange the gl.labels array
          gl.labels = gl.labels[0];
          if (gl.seriesRange.length) {
            gl.seriesRange.map(function (srt) {
              srt.forEach(function (sr) {
                if (gl.labels.indexOf(sr.x) < 0 && sr.x) {
                  gl.labels.push(sr.x);
                }
              });
            });
            // remove duplicate x-axis labels
            gl.labels = Array.from(new Set(gl.labels.map(JSON.stringify)), JSON.parse);
          }
          if (cnf.xaxis.convertedCatToNumeric) {
            var defaults = new Defaults(cnf);
            defaults.convertCatToNumericXaxis(cnf, this.ctx, gl.seriesX[0]);
            this._generateExternalLabels(ser);
          }
        } else {
          this._generateExternalLabels(ser);
        }
      }
    }, {
      key: "_generateExternalLabels",
      value: function _generateExternalLabels(ser) {
        var gl = this.w.globals;
        var cnf = this.w.config;
        // user didn't provided any labels, fallback to 1-2-3-4-5
        var labelArr = [];
        if (gl.axisCharts) {
          if (gl.series.length > 0) {
            if (this.isFormatXY()) {
              // in case there is a combo chart (boxplot/scatter)
              // and there are duplicated x values, we need to eliminate duplicates
              var seriesDataFiltered = cnf.series.map(function (serie, s) {
                return serie.data.filter(function (v, i, a) {
                  return a.findIndex(function (t) {
                    return t.x === v.x;
                  }) === i;
                });
              });
              var len = seriesDataFiltered.reduce(function (p, c, i, a) {
                return a[p].length > c.length ? p : i;
              }, 0);
              for (var i = 0; i < seriesDataFiltered[len].length; i++) {
                labelArr.push(i + 1);
              }
            } else {
              for (var _i3 = 0; _i3 < gl.series[gl.maxValsInArrayIndex].length; _i3++) {
                labelArr.push(_i3 + 1);
              }
            }
          }
          gl.seriesX = [];
          // create gl.seriesX as it will be used in calculations of x positions
          for (var _i4 = 0; _i4 < ser.length; _i4++) {
            gl.seriesX.push(labelArr);
          }

          // turn on the isXNumeric flag to allow minX and maxX to function properly
          if (!this.w.globals.isBarHorizontal) {
            gl.isXNumeric = true;
          }
        }

        // no series to pull labels from, put a 0-10 series
        // possibly, user collapsed all series. Hence we can't work with above calc
        if (labelArr.length === 0) {
          labelArr = gl.axisCharts ? [] : gl.series.map(function (gls, glsi) {
            return glsi + 1;
          });
          for (var _i5 = 0; _i5 < ser.length; _i5++) {
            gl.seriesX.push(labelArr);
          }
        }

        // Finally, pass the labelArr in gl.labels which will be printed on x-axis
        gl.labels = labelArr;
        if (cnf.xaxis.convertedCatToNumeric) {
          gl.categoryLabels = labelArr.map(function (l) {
            return cnf.xaxis.labels.formatter(l);
          });
        }

        // Turn on this global flag to indicate no labels were provided by user
        gl.noLabelsProvided = true;
      }
    }, {
      key: "parseRawDataIfNeeded",
      value: function parseRawDataIfNeeded(series) {
        var _this2 = this;
        var cnf = this.w.config;
        var gl = this.w.globals;
        var globalParsing = cnf.parsing;

        // If data was already parsed, don't parse again
        if (gl.dataWasParsed) {
          return series;
        }

        // If no global parsing config and no series-level parsing, return as-is
        if (!globalParsing && !series.some(function (s) {
          return s.parsing;
        })) {
          return series;
        }
        var processedSeries = series.map(function (serie, index) {
          var _serie$parsing, _serie$parsing2, _serie$parsing3;
          if (!serie.data || !Array.isArray(serie.data) || serie.data.length === 0) {
            return serie;
          }

          // Resolve effective parsing config for this series
          var effectiveParsing = {
            x: ((_serie$parsing = serie.parsing) === null || _serie$parsing === void 0 ? void 0 : _serie$parsing.x) || (globalParsing === null || globalParsing === void 0 ? void 0 : globalParsing.x),
            y: ((_serie$parsing2 = serie.parsing) === null || _serie$parsing2 === void 0 ? void 0 : _serie$parsing2.y) || (globalParsing === null || globalParsing === void 0 ? void 0 : globalParsing.y),
            z: ((_serie$parsing3 = serie.parsing) === null || _serie$parsing3 === void 0 ? void 0 : _serie$parsing3.z) || (globalParsing === null || globalParsing === void 0 ? void 0 : globalParsing.z)
          };

          // If no effective parsing config, return as-is
          if (!effectiveParsing.x && !effectiveParsing.y) {
            return serie;
          }

          // Check if data is already in {x, y} format or 2D array format
          var firstDataPoint = serie.data[0];
          if (_typeof(firstDataPoint) === 'object' && firstDataPoint !== null && (firstDataPoint.hasOwnProperty('x') || firstDataPoint.hasOwnProperty('y')) || Array.isArray(firstDataPoint)) {
            return serie;
          }

          // Validate that we have both x and y parsing config
          if (!effectiveParsing.x || !effectiveParsing.y || Array.isArray(effectiveParsing.y) && effectiveParsing.y.length === 0) {
            console.warn("ApexCharts: Series ".concat(index, " has parsing config but missing x or y field specification"));
            return serie;
          }

          // Transform raw data to {x, y} format
          var transformedData = serie.data.map(function (item, itemIndex) {
            if (_typeof(item) !== 'object' || item === null) {
              console.warn("ApexCharts: Series ".concat(index, ", data point ").concat(itemIndex, " is not an object, skipping parsing"));
              return item;
            }
            var x = _this2.getNestedValue(item, effectiveParsing.x);
            var y;
            var z = undefined;
            if (Array.isArray(effectiveParsing.y)) {
              var yValues = effectiveParsing.y.map(function (fieldName) {
                return _this2.getNestedValue(item, fieldName);
              });
              if (_this2.w.config.chart.type === 'bubble' && yValues.length === 2) {
                // For bubble: [y-value, z-value]  y = yValues[0], z = yValues[1]
                y = yValues[0];
              } else {
                y = yValues;
              }
            } else {
              y = _this2.getNestedValue(item, effectiveParsing.y);
            }

            // explicit z field for bubble charts
            if (effectiveParsing.z) {
              z = _this2.getNestedValue(item, effectiveParsing.z);
            }

            // Warn if fields don't exist
            if (x === undefined) {
              console.warn("ApexCharts: Series ".concat(index, ", data point ").concat(itemIndex, " missing field '").concat(effectiveParsing.x, "'"));
            }
            if (y === undefined) {
              console.warn("ApexCharts: Series ".concat(index, ", data point ").concat(itemIndex, " missing field '").concat(effectiveParsing.y, "'"));
            }
            var result = {
              x: x,
              y: y
            };
            if (_this2.w.config.chart.type === 'bubble' && Array.isArray(effectiveParsing.y) && effectiveParsing.y.length === 2) {
              var zValue = _this2.getNestedValue(item, effectiveParsing.y[1]);
              if (zValue !== undefined) {
                result.z = zValue;
              }
            }
            if (z !== undefined) {
              result.z = z;
            }
            return result;
          });
          return _objectSpread2(_objectSpread2({}, serie), {}, {
            data: transformedData,
            __apexParsed: true
          });
        });

        // Mark that data was parsed
        gl.dataWasParsed = true;
        if (!gl.originalSeries) {
          gl.originalSeries = Utils$1.clone(series);
        }
        return processedSeries;
      }

      /**
       * Get nested object value using dot notation path
       * @param {Object} obj - The object to search in
       * @param {string} path - Dot notation path (e.g., 'user.profile.name')
       * @returns {*} The value at the path, or undefined if not found
       */
    }, {
      key: "getNestedValue",
      value: function getNestedValue(obj, path) {
        if (!obj || _typeof(obj) !== 'object' || !path) {
          return undefined;
        }

        // Handle simple property access (no dots)
        if (path.indexOf('.') === -1) {
          return obj[path];
        }

        // Handle nested property access
        var keys = path.split('.');
        var current = obj;
        for (var i = 0; i < keys.length; i++) {
          if (current === null || current === undefined || _typeof(current) !== 'object') {
            return undefined;
          }
          current = current[keys[i]];
        }
        return current;
      }

      // Segregate user provided data into appropriate vars
    }, {
      key: "parseData",
      value: function parseData(ser) {
        var w = this.w;
        var cnf = w.config;
        var gl = w.globals;
        ser = this.parseRawDataIfNeeded(ser);
        cnf.series = ser;
        gl.initialSeries = Utils$1.clone(ser);
        this.excludeCollapsedSeriesInYAxis();

        // If we detected string in X prop of series, we fallback to category x-axis
        this.fallbackToCategory = false;
        this.ctx.core.resetGlobals();
        this.ctx.core.isMultipleY();
        if (gl.axisCharts) {
          // axisCharts includes line / area / column / scatter
          this.parseDataAxisCharts(ser);
          this.coreUtils.getLargestSeries();
        } else {
          // non-axis charts are pie / donut
          this.parseDataNonAxisCharts(ser);
        }

        // set Null values to 0 in all series when user hides/shows some series
        if (cnf.chart.stacked) {
          var series = new Series(this.ctx);
          gl.series = series.setNullSeriesToZeroValues(gl.series);
        }
        this.coreUtils.getSeriesTotals();
        if (gl.axisCharts) {
          gl.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals();
          gl.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups();
        }
        this.coreUtils.getPercentSeries();
        if (!gl.dataFormatXNumeric && (!gl.isXNumeric || cnf.xaxis.type === 'numeric' && cnf.labels.length === 0 && cnf.xaxis.categories.length === 0)) {
          // x-axis labels couldn't be detected; hence try searching every option in config
          this.handleExternalLabelsData(ser);
        }

        // check for multiline xaxis
        var catLabels = this.coreUtils.getCategoryLabels(gl.labels);
        for (var l = 0; l < catLabels.length; l++) {
          if (Array.isArray(catLabels[l])) {
            gl.isMultiLineX = true;
            break;
          }
        }
      }
    }, {
      key: "excludeCollapsedSeriesInYAxis",
      value: function excludeCollapsedSeriesInYAxis() {
        var w = this.w;
        // Post revision 3.46.0 there is no longer a strict one-to-one
        // correspondence between series and Y axes.
        // An axis can be ignored only while all series referenced by it
        // are collapsed.
        var yAxisIndexes = [];
        w.globals.seriesYAxisMap.forEach(function (yAxisArr, yi) {
          var collapsedCount = 0;
          yAxisArr.forEach(function (seriesIndex) {
            if (w.globals.collapsedSeriesIndices.indexOf(seriesIndex) !== -1) {
              collapsedCount++;
            }
          });
          // It's possible to have a yaxis that doesn't reference any series yet,
          // eg, because there are no series' yet, so don't list it as ignored
          // prematurely.
          if (collapsedCount > 0 && collapsedCount == yAxisArr.length) {
            yAxisIndexes.push(yi);
          }
        });
        w.globals.ignoreYAxisIndexes = yAxisIndexes.map(function (x) {
          return x;
        });
      }
    }]);
    return Data;
  }();

  /*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
  /* vim: set ts=2: */
  /*exported XLSX */
  /*global process:false, Buffer:false, ArrayBuffer:false, DataView:false, Deno:false */
  var XLSX = {};
  XLSX.version = '0.18.5';
  var current_ansi = 1252;

  var VALID_ANSI = [ 874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 10000 ];

  var set_ansi = function(cp/*:number*/) { if(VALID_ANSI.indexOf(cp) == -1) return; current_ansi = cp; };
  function reset_ansi() { set_ansi(1252); }

  var set_cp = function(cp/*:number*/) { set_ansi(cp); };
  function reset_cp() { set_cp(1200); reset_ansi(); }
  function utf16beread(data/*:string*/)/*:string*/ {
  	var o/*:Array<string>*/ = [];
  	for(var i = 0; i < (data.length>>1); ++i) o[i] = String.fromCharCode(data.charCodeAt(2*i+1) + (data.charCodeAt(2*i)<<8));
  	return o.join("");
  }

  var _getchar = function _gc1(x/*:number*/)/*:string*/ { return String.fromCharCode(x); };
  var _getansi = function _ga1(x/*:number*/)/*:string*/ { return String.fromCharCode(x); };

  var $cptable;
  var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  function Base64_encode(input) {
    var o = "";
    var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
    for (var i = 0; i < input.length; ) {
      c1 = input.charCodeAt(i++);
      e1 = c1 >> 2;
      c2 = input.charCodeAt(i++);
      e2 = (c1 & 3) << 4 | c2 >> 4;
      c3 = input.charCodeAt(i++);
      e3 = (c2 & 15) << 2 | c3 >> 6;
      e4 = c3 & 63;
      if (isNaN(c2)) {
        e3 = e4 = 64;
      } else if (isNaN(c3)) {
        e4 = 64;
      }
      o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
    }
    return o;
  }
  function Base64_decode(input) {
    var o = "";
    var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
    input = input.replace(/[^\w\+\/\=]/g, "");
    for (var i = 0; i < input.length; ) {
      e1 = Base64_map.indexOf(input.charAt(i++));
      e2 = Base64_map.indexOf(input.charAt(i++));
      c1 = e1 << 2 | e2 >> 4;
      o += String.fromCharCode(c1);
      e3 = Base64_map.indexOf(input.charAt(i++));
      c2 = (e2 & 15) << 4 | e3 >> 2;
      if (e3 !== 64) {
        o += String.fromCharCode(c2);
      }
      e4 = Base64_map.indexOf(input.charAt(i++));
      c3 = (e3 & 3) << 6 | e4;
      if (e4 !== 64) {
        o += String.fromCharCode(c3);
      }
    }
    return o;
  }
  var has_buf = /*#__PURE__*/(function() { return typeof Buffer !== 'undefined' && typeof process !== 'undefined' && typeof process.versions !== 'undefined' && !!process.versions.node; })();

  var Buffer_from = /*#__PURE__*/(function() {
  	if(typeof Buffer !== 'undefined') {
  		var nbfs = !Buffer.from;
  		if(!nbfs) try { Buffer.from("foo", "utf8"); } catch(e) { nbfs = true; }
  		return nbfs ? function(buf, enc) { return (enc) ? new Buffer(buf, enc) : new Buffer(buf); } : Buffer.from.bind(Buffer);
  	}
  	return function() {};
  })();


  function new_raw_buf(len/*:number*/) {
  	/* jshint -W056 */
  	if(has_buf) return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);
  	return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
  	/* jshint +W056 */
  }

  function new_unsafe_buf(len/*:number*/) {
  	/* jshint -W056 */
  	if(has_buf) return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
  	return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
  	/* jshint +W056 */
  }

  var s2a = function s2a(s/*:string*/)/*:any*/ {
  	if(has_buf) return Buffer_from(s, "binary");
  	return s.split("").map(function(x/*:string*/)/*:number*/{ return x.charCodeAt(0) & 0xff; });
  };

  function s2ab(s/*:string*/)/*:any*/ {
  	if(typeof ArrayBuffer === 'undefined') return s2a(s);
  	var buf = new ArrayBuffer(s.length), view = new Uint8Array(buf);
  	for (var i=0; i!=s.length; ++i) view[i] = s.charCodeAt(i) & 0xFF;
  	return buf;
  }

  function a2s(data/*:any*/)/*:string*/ {
  	if(Array.isArray(data)) return data.map(function(c) { return String.fromCharCode(c); }).join("");
  	var o/*:Array<string>*/ = []; for(var i = 0; i < data.length; ++i) o[i] = String.fromCharCode(data[i]); return o.join("");
  }

  function a2u(data/*:Array<number>*/)/*:Uint8Array*/ {
  	if(typeof Uint8Array === 'undefined') throw new Error("Unsupported");
  	return new Uint8Array(data);
  }

  var bconcat = has_buf ? function(bufs) { return Buffer.concat(bufs.map(function(buf) { return Buffer.isBuffer(buf) ? buf : Buffer_from(buf); })); } : function(bufs) {
  	if(typeof Uint8Array !== "undefined") {
  		var i = 0, maxlen = 0;
  		for(i = 0; i < bufs.length; ++i) maxlen += bufs[i].length;
  		var o = new Uint8Array(maxlen);
  		var len = 0;
  		for(i = 0, maxlen = 0; i < bufs.length; maxlen += len, ++i) {
  			len = bufs[i].length;
  			if(bufs[i] instanceof Uint8Array) o.set(bufs[i], maxlen);
  			else if(typeof bufs[i] == "string") { throw "wtf"; }
  			else o.set(new Uint8Array(bufs[i]), maxlen);
  		}
  		return o;
  	}
  	return [].concat.apply([], bufs.map(function(buf) { return Array.isArray(buf) ? buf : [].slice.call(buf); }));
  };

  function utf8decode(content/*:string*/) {
  	var out = [], widx = 0, L = content.length + 250;
  	var o = new_raw_buf(content.length + 255);
  	for(var ridx = 0; ridx < content.length; ++ridx) {
  		var c = content.charCodeAt(ridx);
  		if(c < 0x80) o[widx++] = c;
  		else if(c < 0x800) {
  			o[widx++] = (192|((c>>6)&31));
  			o[widx++] = (128|(c&63));
  		} else if(c >= 0xD800 && c < 0xE000) {
  			c = (c&1023)+64;
  			var d = content.charCodeAt(++ridx)&1023;
  			o[widx++] = (240|((c>>8)&7));
  			o[widx++] = (128|((c>>2)&63));
  			o[widx++] = (128|((d>>6)&15)|((c&3)<<4));
  			o[widx++] = (128|(d&63));
  		} else {
  			o[widx++] = (224|((c>>12)&15));
  			o[widx++] = (128|((c>>6)&63));
  			o[widx++] = (128|(c&63));
  		}
  		if(widx > L) {
  			out.push(o.slice(0, widx));
  			widx = 0;
  			o = new_raw_buf(65535);
  			L = 65530;
  		}
  	}
  	out.push(o.slice(0, widx));
  	return bconcat(out);
  }

  var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
  /*::
  declare type Block = any;
  declare type BufArray = {
  	newblk(sz:number):Block;
  	next(sz:number):Block;
  	end():any;
  	push(buf:Block):void;
  };

  type RecordHopperCB = {(d:any, Rn:string, RT:number):?boolean;};

  type EvertType = {[string]:string};
  type EvertNumType = {[string]:number};
  type EvertArrType = {[string]:Array<string>};

  type StringConv = {(string):string};

  */
  /* ssf.js (C) 2013-present SheetJS -- http://sheetjs.com */
  /*jshint -W041 */
  function _strrev(x/*:string*/)/*:string*/ { var o = "", i = x.length-1; while(i>=0) o += x.charAt(i--); return o; }
  function pad0(v/*:any*/,d/*:number*/)/*:string*/{var t=""+v; return t.length>=d?t:fill('0',d-t.length)+t;}
  function pad_(v/*:any*/,d/*:number*/)/*:string*/{var t=""+v;return t.length>=d?t:fill(' ',d-t.length)+t;}
  function rpad_(v/*:any*/,d/*:number*/)/*:string*/{var t=""+v; return t.length>=d?t:t+fill(' ',d-t.length);}
  function pad0r1(v/*:any*/,d/*:number*/)/*:string*/{var t=""+Math.round(v); return t.length>=d?t:fill('0',d-t.length)+t;}
  function pad0r2(v/*:any*/,d/*:number*/)/*:string*/{var t=""+v; return t.length>=d?t:fill('0',d-t.length)+t;}
  var p2_32 = /*#__PURE__*/Math.pow(2,32);
  function pad0r(v/*:any*/,d/*:number*/)/*:string*/{if(v>p2_32||v<-p2_32) return pad0r1(v,d); var i = Math.round(v); return pad0r2(i,d); }
  /* yes, in 2022 this is still faster than string compare */
  function SSF_isgeneral(s/*:string*/, i/*:?number*/)/*:boolean*/ { i = i || 0; return s.length >= 7 + i && (s.charCodeAt(i)|32) === 103 && (s.charCodeAt(i+1)|32) === 101 && (s.charCodeAt(i+2)|32) === 110 && (s.charCodeAt(i+3)|32) === 101 && (s.charCodeAt(i+4)|32) === 114 && (s.charCodeAt(i+5)|32) === 97 && (s.charCodeAt(i+6)|32) === 108; }
  var days/*:Array<Array<string> >*/ = [
  	['Sun', 'Sunday'],
  	['Mon', 'Monday'],
  	['Tue', 'Tuesday'],
  	['Wed', 'Wednesday'],
  	['Thu', 'Thursday'],
  	['Fri', 'Friday'],
  	['Sat', 'Saturday']
  ];
  var months/*:Array<Array<string> >*/ = [
  	['J', 'Jan', 'January'],
  	['F', 'Feb', 'February'],
  	['M', 'Mar', 'March'],
  	['A', 'Apr', 'April'],
  	['M', 'May', 'May'],
  	['J', 'Jun', 'June'],
  	['J', 'Jul', 'July'],
  	['A', 'Aug', 'August'],
  	['S', 'Sep', 'September'],
  	['O', 'Oct', 'October'],
  	['N', 'Nov', 'November'],
  	['D', 'Dec', 'December']
  ];
  function SSF_init_table(t/*:any*/) {
  	if(!t) t = {};
  	t[0]=  'General';
  	t[1]=  '0';
  	t[2]=  '0.00';
  	t[3]=  '#,##0';
  	t[4]=  '#,##0.00';
  	t[9]=  '0%';
  	t[10]= '0.00%';
  	t[11]= '0.00E+00';
  	t[12]= '# ?/?';
  	t[13]= '# ??/??';
  	t[14]= 'm/d/yy';
  	t[15]= 'd-mmm-yy';
  	t[16]= 'd-mmm';
  	t[17]= 'mmm-yy';
  	t[18]= 'h:mm AM/PM';
  	t[19]= 'h:mm:ss AM/PM';
  	t[20]= 'h:mm';
  	t[21]= 'h:mm:ss';
  	t[22]= 'm/d/yy h:mm';
  	t[37]= '#,##0 ;(#,##0)';
  	t[38]= '#,##0 ;[Red](#,##0)';
  	t[39]= '#,##0.00;(#,##0.00)';
  	t[40]= '#,##0.00;[Red](#,##0.00)';
  	t[45]= 'mm:ss';
  	t[46]= '[h]:mm:ss';
  	t[47]= 'mmss.0';
  	t[48]= '##0.0E+0';
  	t[49]= '@';
  	t[56]= '"/ "hh""mm""ss" "';
  	return t;
  }
  /* repeated to satiate webpack */
  var table_fmt = {
  	0:  'General',
  	1:  '0',
  	2:  '0.00',
  	3:  '#,##0',
  	4:  '#,##0.00',
  	9:  '0%',
  	10: '0.00%',
  	11: '0.00E+00',
  	12: '# ?/?',
  	13: '# ??/??',
  	14: 'm/d/yy',
  	15: 'd-mmm-yy',
  	16: 'd-mmm',
  	17: 'mmm-yy',
  	18: 'h:mm AM/PM',
  	19: 'h:mm:ss AM/PM',
  	20: 'h:mm',
  	21: 'h:mm:ss',
  	22: 'm/d/yy h:mm',
  	37: '#,##0 ;(#,##0)',
  	38: '#,##0 ;[Red](#,##0)',
  	39: '#,##0.00;(#,##0.00)',
  	40: '#,##0.00;[Red](#,##0.00)',
  	45: 'mm:ss',
  	46: '[h]:mm:ss',
  	47: 'mmss.0',
  	48: '##0.0E+0',
  	49: '@',
  	56: '"/ "hh""mm""ss" "'
  };

  /* Defaults determined by systematically testing in Excel 2019 */

  /* These formats appear to default to other formats in the table */
  var SSF_default_map = {
  	5:  37, 6:  38, 7:  39, 8:  40,         //  5 -> 37 ...  8 -> 40

  	23:  0, 24:  0, 25:  0, 26:  0,         // 23 ->  0 ... 26 ->  0

  	27: 14, 28: 14, 29: 14, 30: 14, 31: 14, // 27 -> 14 ... 31 -> 14

  	50: 14, 51: 14, 52: 14, 53: 14, 54: 14, // 50 -> 14 ... 58 -> 14
  	55: 14, 56: 14, 57: 14, 58: 14,
  	59:  1, 60:  2, 61:  3, 62:  4,         // 59 ->  1 ... 62 ->  4

  	67:  9, 68: 10,                         // 67 ->  9 ... 68 -> 10
  	69: 12, 70: 13, 71: 14,                 // 69 -> 12 ... 71 -> 14
  	72: 14, 73: 15, 74: 16, 75: 17,         // 72 -> 14 ... 75 -> 17
  	76: 20, 77: 21, 78: 22,                 // 76 -> 20 ... 78 -> 22
  	79: 45, 80: 46, 81: 47,                 // 79 -> 45 ... 81 -> 47
  	82: 0                                   // 82 ->  0 ... 65536 -> 0 (omitted)
  };


  /* These formats technically refer to Accounting formats with no equivalent */
  var SSF_default_str = {
  	//  5 -- Currency,   0 decimal, black negative
  	5:  '"$"#,##0_);\\("$"#,##0\\)',
  	63: '"$"#,##0_);\\("$"#,##0\\)',

  	//  6 -- Currency,   0 decimal, red   negative
  	6:  '"$"#,##0_);[Red]\\("$"#,##0\\)',
  	64: '"$"#,##0_);[Red]\\("$"#,##0\\)',

  	//  7 -- Currency,   2 decimal, black negative
  	7:  '"$"#,##0.00_);\\("$"#,##0.00\\)',
  	65: '"$"#,##0.00_);\\("$"#,##0.00\\)',

  	//  8 -- Currency,   2 decimal, red   negative
  	8:  '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  	66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',

  	// 41 -- Accounting, 0 decimal, No Symbol
  	41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',

  	// 42 -- Accounting, 0 decimal, $  Symbol
  	42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',

  	// 43 -- Accounting, 2 decimal, No Symbol
  	43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',

  	// 44 -- Accounting, 2 decimal, $  Symbol
  	44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
  };

  function SSF_frac(x/*:number*/, D/*:number*/, mixed/*:?boolean*/)/*:Array<number>*/ {
  	var sgn = x < 0 ? -1 : 1;
  	var B = x * sgn;
  	var P_2 = 0, P_1 = 1, P = 0;
  	var Q_2 = 1, Q_1 = 0, Q = 0;
  	var A = Math.floor(B);
  	while(Q_1 < D) {
  		A = Math.floor(B);
  		P = A * P_1 + P_2;
  		Q = A * Q_1 + Q_2;
  		if((B - A) < 0.00000005) break;
  		B = 1 / (B - A);
  		P_2 = P_1; P_1 = P;
  		Q_2 = Q_1; Q_1 = Q;
  	}
  	if(Q > D) { if(Q_1 > D) { Q = Q_2; P = P_2; } else { Q = Q_1; P = P_1; } }
  	if(!mixed) return [0, sgn * P, Q];
  	var q = Math.floor(sgn * P/Q);
  	return [q, sgn*P - q*Q, Q];
  }
  function SSF_parse_date_code(v/*:number*/,opts/*:?any*/,b2/*:?boolean*/) {
  	if(v > 2958465 || v < 0) return null;
  	var date = (v|0), time = Math.floor(86400 * (v - date)), dow=0;
  	var dout=[];
  	var out={D:date, T:time, u:86400*(v-date)-time,y:0,m:0,d:0,H:0,M:0,S:0,q:0};
  	if(Math.abs(out.u) < 1e-6) out.u = 0;
  	if(opts && opts.date1904) date += 1462;
  	if(out.u > 0.9999) {
  		out.u = 0;
  		if(++time == 86400) { out.T = time = 0; ++date; ++out.D; }
  	}
  	if(date === 60) {dout = b2 ? [1317,10,29] : [1900,2,29]; dow=3;}
  	else if(date === 0) {dout = b2 ? [1317,8,29] : [1900,1,0]; dow=6;}
  	else {
  		if(date > 60) --date;
  		/* 1 = Jan 1 1900 in Gregorian */
  		var d = new Date(1900, 0, 1);
  		d.setDate(d.getDate() + date - 1);
  		dout = [d.getFullYear(), d.getMonth()+1,d.getDate()];
  		dow = d.getDay();
  		if(date < 60) dow = (dow + 6) % 7;
  		if(b2) dow = SSF_fix_hijri(d, dout);
  	}
  	out.y = dout[0]; out.m = dout[1]; out.d = dout[2];
  	out.S = time % 60; time = Math.floor(time / 60);
  	out.M = time % 60; time = Math.floor(time / 60);
  	out.H = time;
  	out.q = dow;
  	return out;
  }
  var SSFbasedate = /*#__PURE__*/new Date(1899, 11, 31, 0, 0, 0);
  var SSFdnthresh = /*#__PURE__*/SSFbasedate.getTime();
  var SSFbase1904 = /*#__PURE__*/new Date(1900, 2, 1, 0, 0, 0);
  function datenum_local(v/*:Date*/, date1904/*:?boolean*/)/*:number*/ {
  	var epoch = /*#__PURE__*/v.getTime();
  	if(date1904) epoch -= 1461*24*60*60*1000;
  	else if(v >= SSFbase1904) epoch += 24*60*60*1000;
  	return (epoch - (SSFdnthresh + (/*#__PURE__*/v.getTimezoneOffset() - /*#__PURE__*/SSFbasedate.getTimezoneOffset()) * 60000)) / (24 * 60 * 60 * 1000);
  }
  /* ECMA-376 18.8.30 numFmt*/
  /* Note: `toPrecision` uses standard form when prec > E and E >= -6 */
  /* exponent >= -9 and <= 9 */
  function SSF_strip_decimal(o/*:string*/)/*:string*/ {
  	return (o.indexOf(".") == -1) ? o : o.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
  }

  /* General Exponential always shows 2 digits exp and trims the mantissa */
  function SSF_normalize_exp(o/*:string*/)/*:string*/ {
  	if(o.indexOf("E") == -1) return o;
  	return o.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/,"$1E").replace(/(E[+-])(\d)$/,"$10$2");
  }

  /* exponent >= -9 and <= 9 */
  function SSF_small_exp(v/*:number*/)/*:string*/ {
  	var w = (v<0?12:11);
  	var o = SSF_strip_decimal(v.toFixed(12)); if(o.length <= w) return o;
  	o = v.toPrecision(10); if(o.length <= w) return o;
  	return v.toExponential(5);
  }

  /* exponent >= 11 or <= -10 likely exponential */
  function SSF_large_exp(v/*:number*/)/*:string*/ {
  	var o = SSF_strip_decimal(v.toFixed(11));
  	return (o.length > (v<0?12:11) || o === "0" || o === "-0") ? v.toPrecision(6) : o;
  }

  function SSF_general_num(v/*:number*/)/*:string*/ {
  	var V = Math.floor(Math.log(Math.abs(v))*Math.LOG10E), o;

  	if(V >= -4 && V <= -1) o = v.toPrecision(10+V);
  	else if(Math.abs(V) <= 9) o = SSF_small_exp(v);
  	else if(V === 10) o = v.toFixed(10).substr(0,12);
  	else o = SSF_large_exp(v);

  	return SSF_strip_decimal(SSF_normalize_exp(o.toUpperCase()));
  }


  /*
  	"General" rules:
  	- text is passed through ("@")
  	- booleans are rendered as TRUE/FALSE
  	- "up to 11 characters" displayed for numbers
  	- Default date format (code 14) used for Dates

  	The longest 32-bit integer text is "-2147483648", exactly 11 chars
  	TODO: technically the display depends on the width of the cell
  */
  function SSF_general(v/*:any*/, opts/*:any*/) {
  	switch(typeof v) {
  		case 'string': return v;
  		case 'boolean': return v ? "TRUE" : "FALSE";
  		case 'number': return (v|0) === v ? v.toString(10) : SSF_general_num(v);
  		case 'undefined': return "";
  		case 'object':
  			if(v == null) return "";
  			if(v instanceof Date) return SSF_format(14, datenum_local(v, opts && opts.date1904), opts);
  	}
  	throw new Error("unsupported value in General format: " + v);
  }

  function SSF_fix_hijri(date/*:Date*/, o/*:[number, number, number]*/) {
    /* TODO: properly adjust y/m/d and  */
    o[0] -= 581;
    var dow = date.getDay();
    if(date < 60) dow = (dow + 6) % 7;
    return dow;
  }
  //var THAI_DIGITS = "\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59".split("");
  function SSF_write_date(type/*:number*/, fmt/*:string*/, val, ss0/*:?number*/)/*:string*/ {
  	var o="", ss=0, tt=0, y = val.y, out, outl = 0;
  	switch(type) {
  		case 98: /* 'b' buddhist year */
  			y = val.y + 543;
  			/* falls through */
  		case 121: /* 'y' year */
  		switch(fmt.length) {
  			case 1: case 2: out = y % 100; outl = 2; break;
  			default: out = y % 10000; outl = 4; break;
  		} break;
  		case 109: /* 'm' month */
  		switch(fmt.length) {
  			case 1: case 2: out = val.m; outl = fmt.length; break;
  			case 3: return months[val.m-1][1];
  			case 5: return months[val.m-1][0];
  			default: return months[val.m-1][2];
  		} break;
  		case 100: /* 'd' day */
  		switch(fmt.length) {
  			case 1: case 2: out = val.d; outl = fmt.length; break;
  			case 3: return days[val.q][0];
  			default: return days[val.q][1];
  		} break;
  		case 104: /* 'h' 12-hour */
  		switch(fmt.length) {
  			case 1: case 2: out = 1+(val.H+11)%12; outl = fmt.length; break;
  			default: throw 'bad hour format: ' + fmt;
  		} break;
  		case 72: /* 'H' 24-hour */
  		switch(fmt.length) {
  			case 1: case 2: out = val.H; outl = fmt.length; break;
  			default: throw 'bad hour format: ' + fmt;
  		} break;
  		case 77: /* 'M' minutes */
  		switch(fmt.length) {
  			case 1: case 2: out = val.M; outl = fmt.length; break;
  			default: throw 'bad minute format: ' + fmt;
  		} break;
  		case 115: /* 's' seconds */
  			if(fmt != 's' && fmt != 'ss' && fmt != '.0' && fmt != '.00' && fmt != '.000') throw 'bad second format: ' + fmt;
  			if(val.u === 0 && (fmt == "s" || fmt == "ss")) return pad0(val.S, fmt.length);
  			/*::if(!ss0) ss0 = 0; */
  			if(ss0 >= 2) tt = ss0 === 3 ? 1000 : 100;
  			else tt = ss0 === 1 ? 10 : 1;
  			ss = Math.round((tt)*(val.S + val.u));
  			if(ss >= 60*tt) ss = 0;
  			if(fmt === 's') return ss === 0 ? "0" : ""+ss/tt;
  			o = pad0(ss,2 + ss0);
  			if(fmt === 'ss') return o.substr(0,2);
  			return "." + o.substr(2,fmt.length-1);
  		case 90: /* 'Z' absolute time */
  		switch(fmt) {
  			case '[h]': case '[hh]': out = val.D*24+val.H; break;
  			case '[m]': case '[mm]': out = (val.D*24+val.H)*60+val.M; break;
  			case '[s]': case '[ss]': out = ((val.D*24+val.H)*60+val.M)*60+Math.round(val.S+val.u); break;
  			default: throw 'bad abstime format: ' + fmt;
  		} outl = fmt.length === 3 ? 1 : 2; break;
  		case 101: /* 'e' era */
  			out = y; outl = 1; break;
  	}
  	var outstr = outl > 0 ? pad0(out, outl) : "";
  	return outstr;
  }


  /*jshint -W086 */
  /*jshint +W086 */
  function commaify(s/*:string*/)/*:string*/ {
  	var w = 3;
  	if(s.length <= w) return s;
  	var j = (s.length % w), o = s.substr(0,j);
  	for(; j!=s.length; j+=w) o+=(o.length > 0 ? "," : "") + s.substr(j,w);
  	return o;
  }
  var pct1 = /%/g;
  function write_num_pct(type/*:string*/, fmt/*:string*/, val/*:number*/)/*:string*/{
  	var sfmt = fmt.replace(pct1,""), mul = fmt.length - sfmt.length;
  	return write_num(type, sfmt, val * Math.pow(10,2*mul)) + fill("%",mul);
  }

  function write_num_cm(type/*:string*/, fmt/*:string*/, val/*:number*/)/*:string*/{
  	var idx = fmt.length - 1;
  	while(fmt.charCodeAt(idx-1) === 44) --idx;
  	return write_num(type, fmt.substr(0,idx), val / Math.pow(10,3*(fmt.length-idx)));
  }

  function write_num_exp(fmt/*:string*/, val/*:number*/)/*:string*/{
  	var o/*:string*/;
  	var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  	if(fmt.match(/^#+0.0E\+0$/)) {
  		if(val == 0) return "0.0E+0";
  		else if(val < 0) return "-" + write_num_exp(fmt, -val);
  		var period = fmt.indexOf("."); if(period === -1) period=fmt.indexOf('E');
  		var ee = Math.floor(Math.log(val)*Math.LOG10E)%period;
  		if(ee < 0) ee += period;
  		o = (val/Math.pow(10,ee)).toPrecision(idx+1+(period+ee)%period);
  		if(o.indexOf("e") === -1) {
  			var fakee = Math.floor(Math.log(val)*Math.LOG10E);
  			if(o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length+ee);
  			else o += "E+" + (fakee - ee);
  			while(o.substr(0,2) === "0.") {
  				o = o.charAt(0) + o.substr(2,period) + "." + o.substr(2+period);
  				o = o.replace(/^0+([1-9])/,"$1").replace(/^0+\./,"0.");
  			}
  			o = o.replace(/\+-/,"-");
  		}
  		o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function($$,$1,$2,$3) { return $1 + $2 + $3.substr(0,(period+ee)%period) + "." + $3.substr(ee) + "E"; });
  	} else o = val.toExponential(idx);
  	if(fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0,o.length-1) + "0" + o.charAt(o.length-1);
  	if(fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/,"e");
  	return o.replace("e","E");
  }
  var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
  function write_num_f1(r/*:Array<string>*/, aval/*:number*/, sign/*:string*/)/*:string*/ {
  	var den = parseInt(r[4],10), rr = Math.round(aval * den), base = Math.floor(rr/den);
  	var myn = (rr - base*den), myd = den;
  	return sign + (base === 0 ? "" : ""+base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn,r[1].length) + r[2] + "/" + r[3] + pad0(myd,r[4].length));
  }
  function write_num_f2(r/*:Array<string>*/, aval/*:number*/, sign/*:string*/)/*:string*/ {
  	return sign + (aval === 0 ? "" : ""+aval) + fill(" ", r[1].length + 2 + r[4].length);
  }
  var dec1 = /^#*0*\.([0#]+)/;
  var closeparen = /\).*[0#]/;
  var phone = /\(###\) ###\\?-####/;
  function hashq(str/*:string*/)/*:string*/ {
  	var o = "", cc;
  	for(var i = 0; i != str.length; ++i) switch((cc=str.charCodeAt(i))) {
  		case 35: break;
  		case 63: o+= " "; break;
  		case 48: o+= "0"; break;
  		default: o+= String.fromCharCode(cc);
  	}
  	return o;
  }
  function rnd(val/*:number*/, d/*:number*/)/*:string*/ { var dd = Math.pow(10,d); return ""+(Math.round(val * dd)/dd); }
  function dec(val/*:number*/, d/*:number*/)/*:number*/ {
  	var _frac = val - Math.floor(val), dd = Math.pow(10,d);
  	if (d < ('' + Math.round(_frac * dd)).length) return 0;
  	return Math.round(_frac * dd);
  }
  function carry(val/*:number*/, d/*:number*/)/*:number*/ {
  	if (d < ('' + Math.round((val-Math.floor(val))*Math.pow(10,d))).length) {
  		return 1;
  	}
  	return 0;
  }
  function flr(val/*:number*/)/*:string*/ {
  	if(val < 2147483647 && val > -2147483648) return ""+(val >= 0 ? (val|0) : (val-1|0));
  	return ""+Math.floor(val);
  }
  function write_num_flt(type/*:string*/, fmt/*:string*/, val/*:number*/)/*:string*/ {
  	if(type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
  		var ffmt = fmt.replace(/\( */,"").replace(/ \)/,"").replace(/\)/,"");
  		if(val >= 0) return write_num_flt('n', ffmt, val);
  		return '(' + write_num_flt('n', ffmt, -val) + ')';
  	}
  	if(fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);
  	if(fmt.indexOf('%') !== -1) return write_num_pct(type, fmt, val);
  	if(fmt.indexOf('E') !== -1) return write_num_exp(fmt, val);
  	if(fmt.charCodeAt(0) === 36) return "$"+write_num_flt(type,fmt.substr(fmt.charAt(1)==' '?2:1),val);
  	var o;
  	var r/*:?Array<string>*/, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
  	if(fmt.match(/^00+$/)) return sign + pad0r(aval,fmt.length);
  	if(fmt.match(/^[#?]+$/)) {
  		o = pad0r(val,0); if(o === "0") o = "";
  		return o.length > fmt.length ? o : hashq(fmt.substr(0,fmt.length-o.length)) + o;
  	}
  	if((r = fmt.match(frac1))) return write_num_f1(r, aval, sign);
  	if(fmt.match(/^#+0+$/)) return sign + pad0r(aval,fmt.length - fmt.indexOf("0"));
  	if((r = fmt.match(dec1))) {
  		o = rnd(val, r[1].length).replace(/^([^\.]+)$/,"$1."+hashq(r[1])).replace(/\.$/,"."+hashq(r[1])).replace(/\.(\d*)$/,function($$, $1) { return "." + $1 + fill("0", hashq(/*::(*/r/*::||[""])*/[1]).length-$1.length); });
  		return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./,".");
  	}
  	fmt = fmt.replace(/^#+([0.])/, "$1");
  	if((r = fmt.match(/^(0*)\.(#*)$/))) {
  		return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/,".$1").replace(/^(-?\d*)$/,"$1.").replace(/^0\./,r[1].length?"0.":".");
  	}
  	if((r = fmt.match(/^#{1,3},##0(\.?)$/))) return sign + commaify(pad0r(aval,0));
  	if((r = fmt.match(/^#,##0\.([#0]*0)$/))) {
  		return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(""+(Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length),r[1].length);
  	}
  	if((r = fmt.match(/^#,#*,#0/))) return write_num_flt(type,fmt.replace(/^#,#*,/,""),val);
  	if((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/))) {
  		o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g,""), val));
  		ri = 0;
  		return _strrev(_strrev(fmt.replace(/\\/g,"")).replace(/[0#]/g,function(x){return ri<o.length?o.charAt(ri++):x==='0'?'0':"";}));
  	}
  	if(fmt.match(phone)) {
  		o = write_num_flt(type, "##########", val);
  		return "(" + o.substr(0,3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
  	}
  	var oa = "";
  	if((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))) {
  		ri = Math.min(/*::String(*/r[4]/*::)*/.length,7);
  		ff = SSF_frac(aval, Math.pow(10,ri)-1, false);
  		o = "" + sign;
  		oa = write_num("n", /*::String(*/r[1]/*::)*/, ff[1]);
  		if(oa.charAt(oa.length-1) == " ") oa = oa.substr(0,oa.length-1) + "0";
  		o += oa + /*::String(*/r[2]/*::)*/ + "/" + /*::String(*/r[3]/*::)*/;
  		oa = rpad_(ff[2],ri);
  		if(oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length-oa.length)) + oa;
  		o += oa;
  		return o;
  	}
  	if((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))) {
  		ri = Math.min(Math.max(r[1].length, r[4].length),7);
  		ff = SSF_frac(aval, Math.pow(10,ri)-1, true);
  		return sign + (ff[0]||(ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1],ri) + r[2] + "/" + r[3] + rpad_(ff[2],ri): fill(" ", 2*ri+1 + r[2].length + r[3].length));
  	}
  	if((r = fmt.match(/^[#0?]+$/))) {
  		o = pad0r(val, 0);
  		if(fmt.length <= o.length) return o;
  		return hashq(fmt.substr(0,fmt.length-o.length)) + o;
  	}
  	if((r = fmt.match(/^([#0?]+)\.([#0]+)$/))) {
  		o = "" + val.toFixed(Math.min(r[2].length,10)).replace(/([^0])0+$/,"$1");
  		ri = o.indexOf(".");
  		var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
  		return hashq(fmt.substr(0,lres) + o + fmt.substr(fmt.length-rres));
  	}
  	if((r = fmt.match(/^00,000\.([#0]*0)$/))) {
  		ri = dec(val, r[1].length);
  		return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/,"0$&").replace(/^\d*$/,function($$) { return "00," + ($$.length < 3 ? pad0(0,3-$$.length) : "") + $$; }) + "." + pad0(ri,r[1].length);
  	}
  	switch(fmt) {
  		case "###,##0.00": return write_num_flt(type, "#,##0.00", val);
  		case "###,###":
  		case "##,###":
  		case "#,###": var x = commaify(pad0r(aval,0)); return x !== "0" ? sign + x : "";
  		case "###,###.00": return write_num_flt(type, "###,##0.00",val).replace(/^0\./,".");
  		case "#,###.00": return write_num_flt(type, "#,##0.00",val).replace(/^0\./,".");
  	}
  	throw new Error("unsupported format |" + fmt + "|");
  }
  function write_num_cm2(type/*:string*/, fmt/*:string*/, val/*:number*/)/*:string*/{
  	var idx = fmt.length - 1;
  	while(fmt.charCodeAt(idx-1) === 44) --idx;
  	return write_num(type, fmt.substr(0,idx), val / Math.pow(10,3*(fmt.length-idx)));
  }
  function write_num_pct2(type/*:string*/, fmt/*:string*/, val/*:number*/)/*:string*/{
  	var sfmt = fmt.replace(pct1,""), mul = fmt.length - sfmt.length;
  	return write_num(type, sfmt, val * Math.pow(10,2*mul)) + fill("%",mul);
  }
  function write_num_exp2(fmt/*:string*/, val/*:number*/)/*:string*/{
  	var o/*:string*/;
  	var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  	if(fmt.match(/^#+0.0E\+0$/)) {
  		if(val == 0) return "0.0E+0";
  		else if(val < 0) return "-" + write_num_exp2(fmt, -val);
  		var period = fmt.indexOf("."); if(period === -1) period=fmt.indexOf('E');
  		var ee = Math.floor(Math.log(val)*Math.LOG10E)%period;
  		if(ee < 0) ee += period;
  		o = (val/Math.pow(10,ee)).toPrecision(idx+1+(period+ee)%period);
  		if(!o.match(/[Ee]/)) {
  			var fakee = Math.floor(Math.log(val)*Math.LOG10E);
  			if(o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length+ee);
  			else o += "E+" + (fakee - ee);
  			o = o.replace(/\+-/,"-");
  		}
  		o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function($$,$1,$2,$3) { return $1 + $2 + $3.substr(0,(period+ee)%period) + "." + $3.substr(ee) + "E"; });
  	} else o = val.toExponential(idx);
  	if(fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0,o.length-1) + "0" + o.charAt(o.length-1);
  	if(fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/,"e");
  	return o.replace("e","E");
  }
  function write_num_int(type/*:string*/, fmt/*:string*/, val/*:number*/)/*:string*/ {
  	if(type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
  		var ffmt = fmt.replace(/\( */,"").replace(/ \)/,"").replace(/\)/,"");
  		if(val >= 0) return write_num_int('n', ffmt, val);
  		return '(' + write_num_int('n', ffmt, -val) + ')';
  	}
  	if(fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);
  	if(fmt.indexOf('%') !== -1) return write_num_pct2(type, fmt, val);
  	if(fmt.indexOf('E') !== -1) return write_num_exp2(fmt, val);
  	if(fmt.charCodeAt(0) === 36) return "$"+write_num_int(type,fmt.substr(fmt.charAt(1)==' '?2:1),val);
  	var o;
  	var r/*:?Array<string>*/, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
  	if(fmt.match(/^00+$/)) return sign + pad0(aval,fmt.length);
  	if(fmt.match(/^[#?]+$/)) {
  		o = (""+val); if(val === 0) o = "";
  		return o.length > fmt.length ? o : hashq(fmt.substr(0,fmt.length-o.length)) + o;
  	}
  	if((r = fmt.match(frac1))) return write_num_f2(r, aval, sign);
  	if(fmt.match(/^#+0+$/)) return sign + pad0(aval,fmt.length - fmt.indexOf("0"));
  	if((r = fmt.match(dec1))) {
  		/*:: if(!Array.isArray(r)) throw new Error("unreachable"); */
  		o = (""+val).replace(/^([^\.]+)$/,"$1."+hashq(r[1])).replace(/\.$/,"."+hashq(r[1]));
  		o = o.replace(/\.(\d*)$/,function($$, $1) {
  		/*:: if(!Array.isArray(r)) throw new Error("unreachable"); */
  			return "." + $1 + fill("0", hashq(r[1]).length-$1.length); });
  		return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./,".");
  	}
  	fmt = fmt.replace(/^#+([0.])/, "$1");
  	if((r = fmt.match(/^(0*)\.(#*)$/))) {
  		return sign + (""+aval).replace(/\.(\d*[1-9])0*$/,".$1").replace(/^(-?\d*)$/,"$1.").replace(/^0\./,r[1].length?"0.":".");
  	}
  	if((r = fmt.match(/^#{1,3},##0(\.?)$/))) return sign + commaify((""+aval));
  	if((r = fmt.match(/^#,##0\.([#0]*0)$/))) {
  		return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify((""+val)) + "." + fill('0',r[1].length);
  	}
  	if((r = fmt.match(/^#,#*,#0/))) return write_num_int(type,fmt.replace(/^#,#*,/,""),val);
  	if((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/))) {
  		o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g,""), val));
  		ri = 0;
  		return _strrev(_strrev(fmt.replace(/\\/g,"")).replace(/[0#]/g,function(x){return ri<o.length?o.charAt(ri++):x==='0'?'0':"";}));
  	}
  	if(fmt.match(phone)) {
  		o = write_num_int(type, "##########", val);
  		return "(" + o.substr(0,3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
  	}
  	var oa = "";
  	if((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))) {
  		ri = Math.min(/*::String(*/r[4]/*::)*/.length,7);
  		ff = SSF_frac(aval, Math.pow(10,ri)-1, false);
  		o = "" + sign;
  		oa = write_num("n", /*::String(*/r[1]/*::)*/, ff[1]);
  		if(oa.charAt(oa.length-1) == " ") oa = oa.substr(0,oa.length-1) + "0";
  		o += oa + /*::String(*/r[2]/*::)*/ + "/" + /*::String(*/r[3]/*::)*/;
  		oa = rpad_(ff[2],ri);
  		if(oa.length < r[4].length) oa = hashq(r[4].substr(r[4].length-oa.length)) + oa;
  		o += oa;
  		return o;
  	}
  	if((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))) {
  		ri = Math.min(Math.max(r[1].length, r[4].length),7);
  		ff = SSF_frac(aval, Math.pow(10,ri)-1, true);
  		return sign + (ff[0]||(ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1],ri) + r[2] + "/" + r[3] + rpad_(ff[2],ri): fill(" ", 2*ri+1 + r[2].length + r[3].length));
  	}
  	if((r = fmt.match(/^[#0?]+$/))) {
  		o = "" + val;
  		if(fmt.length <= o.length) return o;
  		return hashq(fmt.substr(0,fmt.length-o.length)) + o;
  	}
  	if((r = fmt.match(/^([#0]+)\.([#0]+)$/))) {
  		o = "" + val.toFixed(Math.min(r[2].length,10)).replace(/([^0])0+$/,"$1");
  		ri = o.indexOf(".");
  		var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
  		return hashq(fmt.substr(0,lres) + o + fmt.substr(fmt.length-rres));
  	}
  	if((r = fmt.match(/^00,000\.([#0]*0)$/))) {
  		return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify(""+val).replace(/^\d,\d{3}$/,"0$&").replace(/^\d*$/,function($$) { return "00," + ($$.length < 3 ? pad0(0,3-$$.length) : "") + $$; }) + "." + pad0(0,r[1].length);
  	}
  	switch(fmt) {
  		case "###,###":
  		case "##,###":
  		case "#,###": var x = commaify(""+aval); return x !== "0" ? sign + x : "";
  		default:
  			if(fmt.match(/\.[0#?]*$/)) return write_num_int(type, fmt.slice(0,fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
  	}
  	throw new Error("unsupported format |" + fmt + "|");
  }
  function write_num(type/*:string*/, fmt/*:string*/, val/*:number*/)/*:string*/ {
  	return (val|0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
  }
  function SSF_split_fmt(fmt/*:string*/)/*:Array<string>*/ {
  	var out/*:Array<string>*/ = [];
  	var in_str = false/*, cc*/;
  	for(var i = 0, j = 0; i < fmt.length; ++i) switch((/*cc=*/fmt.charCodeAt(i))) {
  		case 34: /* '"' */
  			in_str = !in_str; break;
  		case 95: case 42: case 92: /* '_' '*' '\\' */
  			++i; break;
  		case 59: /* ';' */
  			out[out.length] = fmt.substr(j,i-j);
  			j = i+1;
  	}
  	out[out.length] = fmt.substr(j);
  	if(in_str === true) throw new Error("Format |" + fmt + "| unterminated string ");
  	return out;
  }

  var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
  function fmt_is_date(fmt/*:string*/)/*:boolean*/ {
  	var i = 0, /*cc = 0,*/ c = "", o = "";
  	while(i < fmt.length) {
  		switch((c = fmt.charAt(i))) {
  			case 'G': if(SSF_isgeneral(fmt, i)) i+= 6; i++; break;
  			case '"': for(;(/*cc=*/fmt.charCodeAt(++i)) !== 34 && i < fmt.length;){/*empty*/} ++i; break;
  			case '\\': i+=2; break;
  			case '_': i+=2; break;
  			case '@': ++i; break;
  			case 'B': case 'b':
  				if(fmt.charAt(i+1) === "1" || fmt.charAt(i+1) === "2") return true;
  				/* falls through */
  			case 'M': case 'D': case 'Y': case 'H': case 'S': case 'E':
  				/* falls through */
  			case 'm': case 'd': case 'y': case 'h': case 's': case 'e': case 'g': return true;
  			case 'A': case 'a': case '':
  				if(fmt.substr(i, 3).toUpperCase() === "A/P") return true;
  				if(fmt.substr(i, 5).toUpperCase() === "AM/PM") return true;
  				if(fmt.substr(i, 5).toUpperCase() === "/") return true;
  				++i; break;
  			case '[':
  				o = c;
  				while(fmt.charAt(i++) !== ']' && i < fmt.length) o += fmt.charAt(i);
  				if(o.match(SSF_abstime)) return true;
  				break;
  			case '.':
  				/* falls through */
  			case '0': case '#':
  				while(i < fmt.length && ("0#?.,E+-%".indexOf(c=fmt.charAt(++i)) > -1 || (c=='\\' && fmt.charAt(i+1) == "-" && "0#".indexOf(fmt.charAt(i+2))>-1))){/* empty */}
  				break;
  			case '?': while(fmt.charAt(++i) === c){/* empty */} break;
  			case '*': ++i; if(fmt.charAt(i) == ' ' || fmt.charAt(i) == '*') ++i; break;
  			case '(': case ')': ++i; break;
  			case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
  				while(i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1){/* empty */} break;
  			case ' ': ++i; break;
  			default: ++i; break;
  		}
  	}
  	return false;
  }

  function eval_fmt(fmt/*:string*/, v/*:any*/, opts/*:any*/, flen/*:number*/) {
  	var out = [], o = "", i = 0, c = "", lst='t', dt, j, cc;
  	var hr='H';
  	/* Tokenize */
  	while(i < fmt.length) {
  		switch((c = fmt.charAt(i))) {
  			case 'G': /* General */
  				if(!SSF_isgeneral(fmt, i)) throw new Error('unrecognized character ' + c + ' in ' +fmt);
  				out[out.length] = {t:'G', v:'General'}; i+=7; break;
  			case '"': /* Literal text */
  				for(o="";(cc=fmt.charCodeAt(++i)) !== 34 && i < fmt.length;) o += String.fromCharCode(cc);
  				out[out.length] = {t:'t', v:o}; ++i; break;
  			case '\\': var w = fmt.charAt(++i), t = (w === "(" || w === ")") ? w : 't';
  				out[out.length] = {t:t, v:w}; ++i; break;
  			case '_': out[out.length] = {t:'t', v:" "}; i+=2; break;
  			case '@': /* Text Placeholder */
  				out[out.length] = {t:'T', v:v}; ++i; break;
  			case 'B': case 'b':
  				if(fmt.charAt(i+1) === "1" || fmt.charAt(i+1) === "2") {
  					if(dt==null) { dt=SSF_parse_date_code(v, opts, fmt.charAt(i+1) === "2"); if(dt==null) return ""; }
  					out[out.length] = {t:'X', v:fmt.substr(i,2)}; lst = c; i+=2; break;
  				}
  				/* falls through */
  			case 'M': case 'D': case 'Y': case 'H': case 'S': case 'E':
  				c = c.toLowerCase();
  				/* falls through */
  			case 'm': case 'd': case 'y': case 'h': case 's': case 'e': case 'g':
  				if(v < 0) return "";
  				if(dt==null) { dt=SSF_parse_date_code(v, opts); if(dt==null) return ""; }
  				o = c; while(++i < fmt.length && fmt.charAt(i).toLowerCase() === c) o+=c;
  				if(c === 'm' && lst.toLowerCase() === 'h') c = 'M';
  				if(c === 'h') c = hr;
  				out[out.length] = {t:c, v:o}; lst = c; break;
  			case 'A': case 'a': case '':
  				var q={t:c, v:c};
  				if(dt==null) dt=SSF_parse_date_code(v, opts);
  				if(fmt.substr(i, 3).toUpperCase() === "A/P") { if(dt!=null) q.v = dt.H >= 12 ? "P" : "A"; q.t = 'T'; hr='h';i+=3;}
  				else if(fmt.substr(i,5).toUpperCase() === "AM/PM") { if(dt!=null) q.v = dt.H >= 12 ? "PM" : "AM"; q.t = 'T'; i+=5; hr='h'; }
  				else if(fmt.substr(i,5).toUpperCase() === "/") { if(dt!=null) q.v = dt.H >= 12 ? "" : ""; q.t = 'T'; i+=5; hr='h'; }
  				else { q.t = "t"; ++i; }
  				if(dt==null && q.t === 'T') return "";
  				out[out.length] = q; lst = c; break;
  			case '[':
  				o = c;
  				while(fmt.charAt(i++) !== ']' && i < fmt.length) o += fmt.charAt(i);
  				if(o.slice(-1) !== ']') throw 'unterminated "[" block: |' + o + '|';
  				if(o.match(SSF_abstime)) {
  					if(dt==null) { dt=SSF_parse_date_code(v, opts); if(dt==null) return ""; }
  					out[out.length] = {t:'Z', v:o.toLowerCase()};
  					lst = o.charAt(1);
  				} else if(o.indexOf("$") > -1) {
  					o = (o.match(/\$([^-\[\]]*)/)||[])[1]||"$";
  					if(!fmt_is_date(fmt)) out[out.length] = {t:'t',v:o};
  				}
  				break;
  			/* Numbers */
  			case '.':
  				if(dt != null) {
  					o = c; while(++i < fmt.length && (c=fmt.charAt(i)) === "0") o += c;
  					out[out.length] = {t:'s', v:o}; break;
  				}
  				/* falls through */
  			case '0': case '#':
  				o = c; while(++i < fmt.length && "0#?.,E+-%".indexOf(c=fmt.charAt(i)) > -1) o += c;
  				out[out.length] = {t:'n', v:o}; break;
  			case '?':
  				o = c; while(fmt.charAt(++i) === c) o+=c;
  				out[out.length] = {t:c, v:o}; lst = c; break;
  			case '*': ++i; if(fmt.charAt(i) == ' ' || fmt.charAt(i) == '*') ++i; break; // **
  			case '(': case ')': out[out.length] = {t:(flen===1?'t':c), v:c}; ++i; break;
  			case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
  				o = c; while(i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) o+=fmt.charAt(i);
  				out[out.length] = {t:'D', v:o}; break;
  			case ' ': out[out.length] = {t:c, v:c}; ++i; break;
  			case '$': out[out.length] = {t:'t', v:'$'}; ++i; break;
  			default:
  				if(",$-+/():!^&'~{}<>=acfijklopqrtuvwxzP".indexOf(c) === -1) throw new Error('unrecognized character ' + c + ' in ' + fmt);
  				out[out.length] = {t:'t', v:c}; ++i; break;
  		}
  	}

  	/* Scan for date/time parts */
  	var bt = 0, ss0 = 0, ssm;
  	for(i=out.length-1, lst='t'; i >= 0; --i) {
  		switch(out[i].t) {
  			case 'h': case 'H': out[i].t = hr; lst='h'; if(bt < 1) bt = 1; break;
  			case 's':
  				if((ssm=out[i].v.match(/\.0+$/))) ss0=Math.max(ss0,ssm[0].length-1);
  				if(bt < 3) bt = 3;
  			/* falls through */
  			case 'd': case 'y': case 'M': case 'e': lst=out[i].t; break;
  			case 'm': if(lst === 's') { out[i].t = 'M'; if(bt < 2) bt = 2; } break;
  			case 'X': /*if(out[i].v === "B2");*/
  				break;
  			case 'Z':
  				if(bt < 1 && out[i].v.match(/[Hh]/)) bt = 1;
  				if(bt < 2 && out[i].v.match(/[Mm]/)) bt = 2;
  				if(bt < 3 && out[i].v.match(/[Ss]/)) bt = 3;
  		}
  	}
  	/* time rounding depends on presence of minute / second / usec fields */
  	switch(bt) {
  		case 0: break;
  		case 1:
  			/*::if(!dt) break;*/
  			if(dt.u >= 0.5) { dt.u = 0; ++dt.S; }
  			if(dt.S >=  60) { dt.S = 0; ++dt.M; }
  			if(dt.M >=  60) { dt.M = 0; ++dt.H; }
  			break;
  		case 2:
  			/*::if(!dt) break;*/
  			if(dt.u >= 0.5) { dt.u = 0; ++dt.S; }
  			if(dt.S >=  60) { dt.S = 0; ++dt.M; }
  			break;
  	}

  	/* replace fields */
  	var nstr = "", jj;
  	for(i=0; i < out.length; ++i) {
  		switch(out[i].t) {
  			case 't': case 'T': case ' ': case 'D': break;
  			case 'X': out[i].v = ""; out[i].t = ";"; break;
  			case 'd': case 'm': case 'y': case 'h': case 'H': case 'M': case 's': case 'e': case 'b': case 'Z':
  				/*::if(!dt) throw "unreachable"; */
  				out[i].v = SSF_write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
  				out[i].t = 't'; break;
  			case 'n': case '?':
  				jj = i+1;
  				while(out[jj] != null && (
  					(c=out[jj].t) === "?" || c === "D" ||
  					((c === " " || c === "t") && out[jj+1] != null && (out[jj+1].t === '?' || out[jj+1].t === "t" && out[jj+1].v === '/')) ||
  					(out[i].t === '(' && (c === ' ' || c === 'n' || c === ')')) ||
  					(c === 't' && (out[jj].v === '/' || out[jj].v === ' ' && out[jj+1] != null && out[jj+1].t == '?'))
  				)) {
  					out[i].v += out[jj].v;
  					out[jj] = {v:"", t:";"}; ++jj;
  				}
  				nstr += out[i].v;
  				i = jj-1; break;
  			case 'G': out[i].t = 't'; out[i].v = SSF_general(v,opts); break;
  		}
  	}
  	var vv = "", myv, ostr;
  	if(nstr.length > 0) {
  		if(nstr.charCodeAt(0) == 40) /* '(' */ {
  			myv = (v<0&&nstr.charCodeAt(0) === 45 ? -v : v);
  			ostr = write_num('n', nstr, myv);
  		} else {
  			myv = (v<0 && flen > 1 ? -v : v);
  			ostr = write_num('n', nstr, myv);
  			if(myv < 0 && out[0] && out[0].t == 't') {
  				ostr = ostr.substr(1);
  				out[0].v = "-" + out[0].v;
  			}
  		}
  		jj=ostr.length-1;
  		var decpt = out.length;
  		for(i=0; i < out.length; ++i) if(out[i] != null && out[i].t != 't' && out[i].v.indexOf(".") > -1) { decpt = i; break; }
  		var lasti=out.length;
  		if(decpt === out.length && ostr.indexOf("E") === -1) {
  			for(i=out.length-1; i>= 0;--i) {
  				if(out[i] == null || 'n?'.indexOf(out[i].t) === -1) continue;
  				if(jj>=out[i].v.length-1) { jj -= out[i].v.length; out[i].v = ostr.substr(jj+1, out[i].v.length); }
  				else if(jj < 0) out[i].v = "";
  				else { out[i].v = ostr.substr(0, jj+1); jj = -1; }
  				out[i].t = 't';
  				lasti = i;
  			}
  			if(jj>=0 && lasti<out.length) out[lasti].v = ostr.substr(0,jj+1) + out[lasti].v;
  		}
  		else if(decpt !== out.length && ostr.indexOf("E") === -1) {
  			jj = ostr.indexOf(".")-1;
  			for(i=decpt; i>= 0; --i) {
  				if(out[i] == null || 'n?'.indexOf(out[i].t) === -1) continue;
  				j=out[i].v.indexOf(".")>-1&&i===decpt?out[i].v.indexOf(".")-1:out[i].v.length-1;
  				vv = out[i].v.substr(j+1);
  				for(; j>=0; --j) {
  					if(jj>=0 && (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#")) vv = ostr.charAt(jj--) + vv;
  				}
  				out[i].v = vv;
  				out[i].t = 't';
  				lasti = i;
  			}
  			if(jj>=0 && lasti<out.length) out[lasti].v = ostr.substr(0,jj+1) + out[lasti].v;
  			jj = ostr.indexOf(".")+1;
  			for(i=decpt; i<out.length; ++i) {
  				if(out[i] == null || ('n?('.indexOf(out[i].t) === -1 && i !== decpt)) continue;
  				j=out[i].v.indexOf(".")>-1&&i===decpt?out[i].v.indexOf(".")+1:0;
  				vv = out[i].v.substr(0,j);
  				for(; j<out[i].v.length; ++j) {
  					if(jj<ostr.length) vv += ostr.charAt(jj++);
  				}
  				out[i].v = vv;
  				out[i].t = 't';
  				lasti = i;
  			}
  		}
  	}
  	for(i=0; i<out.length; ++i) if(out[i] != null && 'n?'.indexOf(out[i].t)>-1) {
  		myv = (flen >1 && v < 0 && i>0 && out[i-1].v === "-" ? -v:v);
  		out[i].v = write_num(out[i].t, out[i].v, myv);
  		out[i].t = 't';
  	}
  	var retval = "";
  	for(i=0; i !== out.length; ++i) if(out[i] != null) retval += out[i].v;
  	return retval;
  }

  var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
  function chkcond(v, rr) {
  	if(rr == null) return false;
  	var thresh = parseFloat(rr[2]);
  	switch(rr[1]) {
  		case "=":  if(v == thresh) return true; break;
  		case ">":  if(v >  thresh) return true; break;
  		case "<":  if(v <  thresh) return true; break;
  		case "<>": if(v != thresh) return true; break;
  		case ">=": if(v >= thresh) return true; break;
  		case "<=": if(v <= thresh) return true; break;
  	}
  	return false;
  }
  function choose_fmt(f/*:string*/, v/*:any*/) {
  	var fmt = SSF_split_fmt(f);
  	var l = fmt.length, lat = fmt[l-1].indexOf("@");
  	if(l<4 && lat>-1) --l;
  	if(fmt.length > 4) throw new Error("cannot find right format for |" + fmt.join("|") + "|");
  	if(typeof v !== "number") return [4, fmt.length === 4 || lat>-1?fmt[fmt.length-1]:"@"];
  	switch(fmt.length) {
  		case 1: fmt = lat>-1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"]; break;
  		case 2: fmt = lat>-1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"]; break;
  		case 3: fmt = lat>-1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"]; break;
  	}
  	var ff = v > 0 ? fmt[0] : v < 0 ? fmt[1] : fmt[2];
  	if(fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1) return [l, ff];
  	if(fmt[0].match(/\[[=<>]/) != null || fmt[1].match(/\[[=<>]/) != null) {
  		var m1 = fmt[0].match(cfregex2);
  		var m2 = fmt[1].match(cfregex2);
  		return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null && m2 != null ? 2 : 1]];
  	}
  	return [l, ff];
  }
  function SSF_format(fmt/*:string|number*/,v/*:any*/,o/*:?any*/) {
  	if(o == null) o = {};
  	var sfmt = "";
  	switch(typeof fmt) {
  		case "string":
  			if(fmt == "m/d/yy" && o.dateNF) sfmt = o.dateNF;
  			else sfmt = fmt;
  			break;
  		case "number":
  			if(fmt == 14 && o.dateNF) sfmt = o.dateNF;
  			else sfmt = (o.table != null ? (o.table/*:any*/) : table_fmt)[fmt];
  			if(sfmt == null) sfmt = (o.table && o.table[SSF_default_map[fmt]]) || table_fmt[SSF_default_map[fmt]];
  			if(sfmt == null) sfmt = SSF_default_str[fmt] || "General";
  			break;
  	}
  	if(SSF_isgeneral(sfmt,0)) return SSF_general(v, o);
  	if(v instanceof Date) v = datenum_local(v, o.date1904);
  	var f = choose_fmt(sfmt, v);
  	if(SSF_isgeneral(f[1])) return SSF_general(v, o);
  	if(v === true) v = "TRUE"; else if(v === false) v = "FALSE";
  	else if(v === "" || v == null) return "";
  	return eval_fmt(f[1], v, o, f[0]);
  }
  function SSF_load(fmt/*:string*/, idx/*:?number*/)/*:number*/ {
  	if(typeof idx != 'number') {
  		idx = +idx || -1;
  /*::if(typeof idx != 'number') return 0x188; */
  		for(var i = 0; i < 0x0188; ++i) {
  /*::if(typeof idx != 'number') return 0x188; */
  			if(table_fmt[i] == undefined) { if(idx < 0) idx = i; continue; }
  			if(table_fmt[i] == fmt) { idx = i; break; }
  		}
  /*::if(typeof idx != 'number') return 0x188; */
  		if(idx < 0) idx = 0x187;
  	}
  /*::if(typeof idx != 'number') return 0x188; */
  	table_fmt[idx] = fmt;
  	return idx;
  }
  function SSF_load_table(tbl/*:SSFTable*/)/*:void*/ {
  	for(var i=0; i!=0x0188; ++i)
  		if(tbl[i] !== undefined) SSF_load(tbl[i], i);
  }

  function make_ssf() {
  	table_fmt = SSF_init_table();
  }

  /* dateNF parse TODO: move to SSF */
  var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
  function dateNF_regex(dateNF/*:string|number*/)/*:RegExp*/ {
  	var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;
  	fmt = fmt.replace(dateNFregex, "(\\d+)");
  	return new RegExp("^" + fmt + "$");
  }
  function dateNF_fix(str/*:string*/, dateNF/*:string*/, match/*:Array<string>*/)/*:string*/ {
  	var Y = -1, m = -1, d = -1, H = -1, M = -1, S = -1;
  	(dateNF.match(dateNFregex)||[]).forEach(function(n, i) {
  		var v = parseInt(match[i+1], 10);
  		switch(n.toLowerCase().charAt(0)) {
  			case 'y': Y = v; break; case 'd': d = v; break;
  			case 'h': H = v; break; case 's': S = v; break;
  			case 'm': if(H >= 0) M = v; else m = v; break;
  		}
  	});
  	if(S >= 0 && M == -1 && m >= 0) { M = m; m = -1; }
  	var datestr = (("" + (Y>=0?Y: new Date().getFullYear())).slice(-4) + "-" + ("00" + (m>=1?m:1)).slice(-2) + "-" + ("00" + (d>=1?d:1)).slice(-2));
  	if(datestr.length == 7) datestr = "0" + datestr;
  	if(datestr.length == 8) datestr = "20" + datestr;
  	var timestr = (("00" + (H>=0?H:0)).slice(-2) + ":" + ("00" + (M>=0?M:0)).slice(-2) + ":" + ("00" + (S>=0?S:0)).slice(-2));
  	if(H == -1 && M == -1 && S == -1) return datestr;
  	if(Y == -1 && m == -1 && d == -1) return timestr;
  	return datestr + "T" + timestr;
  }

  /*::
  declare var ReadShift:any;
  declare var CheckField:any;
  declare var prep_blob:any;
  declare var __readUInt32LE:any;
  declare var __readInt32LE:any;
  declare var __toBuffer:any;
  declare var __utf16le:any;
  declare var bconcat:any;
  declare var s2a:any;
  declare var chr0:any;
  declare var chr1:any;
  declare var has_buf:boolean;
  declare var new_buf:any;
  declare var new_raw_buf:any;
  declare var new_unsafe_buf:any;
  declare var Buffer_from:any;
  */
  /* cfb.js (C) 2013-present SheetJS -- http://sheetjs.com */
  /* vim: set ts=2: */
  /*jshint eqnull:true */
  /*exported CFB */
  /*global Uint8Array:false, Uint16Array:false */

  /*::
  type SectorEntry = {
  	name?:string;
  	nodes?:Array<number>;
  	data:RawBytes;
  };
  type SectorList = {
  	[k:string|number]:SectorEntry;
  	name:?string;
  	fat_addrs:Array<number>;
  	ssz:number;
  }
  type CFBFiles = {[n:string]:CFBEntry};
  */
  /* crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
  /* vim: set ts=2: */
  /*exported CRC32 */
  var CRC32 = /*#__PURE__*/(function() {
  var CRC32 = {};
  CRC32.version = '1.2.0';
  /* see perf/crc32table.js */
  /*global Int32Array */
  function signed_crc_table()/*:any*/ {
  	var c = 0, table/*:Array<number>*/ = new Array(256);

  	for(var n =0; n != 256; ++n){
  		c = n;
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
  		table[n] = c;
  	}

  	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
  }

  var T0 = signed_crc_table();
  function slice_by_16_tables(T) {
  	var c = 0, v = 0, n = 0, table/*:Array<number>*/ = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096) ;

  	for(n = 0; n != 256; ++n) table[n] = T[n];
  	for(n = 0; n != 256; ++n) {
  		v = T[n];
  		for(c = 256 + n; c < 4096; c += 256) v = table[c] = (v >>> 8) ^ T[v & 0xFF];
  	}
  	var out = [];
  	for(n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
  	return out;
  }
  var TT = slice_by_16_tables(T0);
  var T1 = TT[0],  T2 = TT[1],  T3 = TT[2],  T4 = TT[3],  T5 = TT[4];
  var T6 = TT[5],  T7 = TT[6],  T8 = TT[7],  T9 = TT[8],  Ta = TT[9];
  var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
  function crc32_bstr(bstr/*:string*/, seed/*:number*/)/*:number*/ {
  	var C = seed/*:: ? 0 : 0 */ ^ -1;
  	for(var i = 0, L = bstr.length; i < L;) C = (C>>>8) ^ T0[(C^bstr.charCodeAt(i++))&0xFF];
  	return ~C;
  }

  function crc32_buf(B/*:Uint8Array|Array<number>*/, seed/*:number*/)/*:number*/ {
  	var C = seed/*:: ? 0 : 0 */ ^ -1, L = B.length - 15, i = 0;
  	for(; i < L;) C =
  		Tf[B[i++] ^ (C & 255)] ^
  		Te[B[i++] ^ ((C >> 8) & 255)] ^
  		Td[B[i++] ^ ((C >> 16) & 255)] ^
  		Tc[B[i++] ^ (C >>> 24)] ^
  		Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^
  		T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^
  		T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
  	L += 15;
  	while(i < L) C = (C>>>8) ^ T0[(C^B[i++])&0xFF];
  	return ~C;
  }

  function crc32_str(str/*:string*/, seed/*:number*/)/*:number*/ {
  	var C = seed ^ -1;
  	for(var i = 0, L = str.length, c = 0, d = 0; i < L;) {
  		c = str.charCodeAt(i++);
  		if(c < 0x80) {
  			C = (C>>>8) ^ T0[(C^c)&0xFF];
  		} else if(c < 0x800) {
  			C = (C>>>8) ^ T0[(C ^ (192|((c>>6)&31)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
  		} else if(c >= 0xD800 && c < 0xE000) {
  			c = (c&1023)+64; d = str.charCodeAt(i++)&1023;
  			C = (C>>>8) ^ T0[(C ^ (240|((c>>8)&7)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|((c>>2)&63)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|(d&63)))&0xFF];
  		} else {
  			C = (C>>>8) ^ T0[(C ^ (224|((c>>12)&15)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|((c>>6)&63)))&0xFF];
  			C = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];
  		}
  	}
  	return ~C;
  }
  CRC32.table = T0;
  CRC32.bstr = crc32_bstr;
  CRC32.buf = crc32_buf;
  CRC32.str = crc32_str;
  return CRC32;
  })();
  /* [MS-CFB] v20171201 */
  var CFB = /*#__PURE__*/(function _CFB(){
  var exports = {};
  exports.version = '1.2.1';
  /* [MS-CFB] 2.6.4 */
  function namecmp(l/*:string*/, r/*:string*/)/*:number*/ {
  	var L = l.split("/"), R = r.split("/");
  	for(var i = 0, c = 0, Z = Math.min(L.length, R.length); i < Z; ++i) {
  		if((c = L[i].length - R[i].length)) return c;
  		if(L[i] != R[i]) return L[i] < R[i] ? -1 : 1;
  	}
  	return L.length - R.length;
  }
  function dirname(p/*:string*/)/*:string*/ {
  	if(p.charAt(p.length - 1) == "/") return (p.slice(0,-1).indexOf("/") === -1) ? p : dirname(p.slice(0, -1));
  	var c = p.lastIndexOf("/");
  	return (c === -1) ? p : p.slice(0, c+1);
  }

  function filename(p/*:string*/)/*:string*/ {
  	if(p.charAt(p.length - 1) == "/") return filename(p.slice(0, -1));
  	var c = p.lastIndexOf("/");
  	return (c === -1) ? p : p.slice(c+1);
  }
  /* -------------------------------------------------------------------------- */
  /* DOS Date format:
     high|YYYYYYYm.mmmddddd.HHHHHMMM.MMMSSSSS|low
     add 1980 to stored year
     stored second should be doubled
  */

  /* write JS date to buf as a DOS date */
  function write_dos_date(buf/*:CFBlob*/, date/*:Date|string*/) {
  	if(typeof date === "string") date = new Date(date);
  	var hms/*:number*/ = date.getHours();
  	hms = hms << 6 | date.getMinutes();
  	hms = hms << 5 | (date.getSeconds()>>>1);
  	buf.write_shift(2, hms);
  	var ymd/*:number*/ = (date.getFullYear() - 1980);
  	ymd = ymd << 4 | (date.getMonth()+1);
  	ymd = ymd << 5 | date.getDate();
  	buf.write_shift(2, ymd);
  }

  /* read four bytes from buf and interpret as a DOS date */
  function parse_dos_date(buf/*:CFBlob*/)/*:Date*/ {
  	var hms = buf.read_shift(2) & 0xFFFF;
  	var ymd = buf.read_shift(2) & 0xFFFF;
  	var val = new Date();
  	var d = ymd & 0x1F; ymd >>>= 5;
  	var m = ymd & 0x0F; ymd >>>= 4;
  	val.setMilliseconds(0);
  	val.setFullYear(ymd + 1980);
  	val.setMonth(m-1);
  	val.setDate(d);
  	var S = hms & 0x1F; hms >>>= 5;
  	var M = hms & 0x3F; hms >>>= 6;
  	val.setHours(hms);
  	val.setMinutes(M);
  	val.setSeconds(S<<1);
  	return val;
  }
  function parse_extra_field(blob/*:CFBlob*/)/*:any*/ {
  	prep_blob(blob, 0);
  	var o = /*::(*/{}/*:: :any)*/;
  	var flags = 0;
  	while(blob.l <= blob.length - 4) {
  		var type = blob.read_shift(2);
  		var sz = blob.read_shift(2), tgt = blob.l + sz;
  		var p = {};
  		switch(type) {
  			/* UNIX-style Timestamps */
  			case 0x5455: {
  				flags = blob.read_shift(1);
  				if(flags & 1) p.mtime = blob.read_shift(4);
  				/* for some reason, CD flag corresponds to LFH */
  				if(sz > 5) {
  					if(flags & 2) p.atime = blob.read_shift(4);
  					if(flags & 4) p.ctime = blob.read_shift(4);
  				}
  				if(p.mtime) p.mt = new Date(p.mtime*1000);
  			}
  			break;
  		}
  		blob.l = tgt;
  		o[type] = p;
  	}
  	return o;
  }
  var fs/*:: = require('fs'); */;
  function get_fs() { return fs || (fs = {}); }
  function parse(file/*:RawBytes*/, options/*:CFBReadOpts*/)/*:CFBContainer*/ {
  if(file[0] == 0x50 && file[1] == 0x4b) return parse_zip(file, options);
  if((file[0] | 0x20) == 0x6d && (file[1]|0x20) == 0x69) return parse_mad(file, options);
  if(file.length < 512) throw new Error("CFB file size " + file.length + " < 512");
  var mver = 3;
  var ssz = 512;
  var nmfs = 0; // number of mini FAT sectors
  var difat_sec_cnt = 0;
  var dir_start = 0;
  var minifat_start = 0;
  var difat_start = 0;

  var fat_addrs/*:Array<number>*/ = []; // locations of FAT sectors

  /* [MS-CFB] 2.2 Compound File Header */
  var blob/*:CFBlob*/ = /*::(*/file.slice(0,512)/*:: :any)*/;
  prep_blob(blob, 0);

  /* major version */
  var mv = check_get_mver(blob);
  mver = mv[0];
  switch(mver) {
  	case 3: ssz = 512; break; case 4: ssz = 4096; break;
  	case 0: if(mv[1] == 0) return parse_zip(file, options);
  	/* falls through */
  	default: throw new Error("Major Version: Expected 3 or 4 saw " + mver);
  }

  /* reprocess header */
  if(ssz !== 512) { blob = /*::(*/file.slice(0,ssz)/*:: :any)*/; prep_blob(blob, 28 /* blob.l */); }
  /* Save header for final object */
  var header/*:RawBytes*/ = file.slice(0,ssz);

  check_shifts(blob, mver);

  // Number of Directory Sectors
  var dir_cnt/*:number*/ = blob.read_shift(4, 'i');
  if(mver === 3 && dir_cnt !== 0) throw new Error('# Directory Sectors: Expected 0 saw ' + dir_cnt);

  // Number of FAT Sectors
  blob.l += 4;

  // First Directory Sector Location
  dir_start = blob.read_shift(4, 'i');

  // Transaction Signature
  blob.l += 4;

  // Mini Stream Cutoff Size
  blob.chk('00100000', 'Mini Stream Cutoff Size: ');

  // First Mini FAT Sector Location
  minifat_start = blob.read_shift(4, 'i');

  // Number of Mini FAT Sectors
  nmfs = blob.read_shift(4, 'i');

  // First DIFAT sector location
  difat_start = blob.read_shift(4, 'i');

  // Number of DIFAT Sectors
  difat_sec_cnt = blob.read_shift(4, 'i');

  // Grab FAT Sector Locations
  for(var q = -1, j = 0; j < 109; ++j) { /* 109 = (512 - blob.l)>>>2; */
  	q = blob.read_shift(4, 'i');
  	if(q<0) break;
  	fat_addrs[j] = q;
  }

  /** Break the file up into sectors */
  var sectors/*:Array<RawBytes>*/ = sectorify(file, ssz);

  sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);

  /** Chains */
  var sector_list/*:SectorList*/ = make_sector_list(sectors, dir_start, fat_addrs, ssz);

  sector_list[dir_start].name = "!Directory";
  if(nmfs > 0 && minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";
  sector_list[fat_addrs[0]].name = "!FAT";
  sector_list.fat_addrs = fat_addrs;
  sector_list.ssz = ssz;

  /* [MS-CFB] 2.6.1 Compound File Directory Entry */
  var files/*:CFBFiles*/ = {}, Paths/*:Array<string>*/ = [], FileIndex/*:CFBFileIndex*/ = [], FullPaths/*:Array<string>*/ = [];
  read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);

  build_full_paths(FileIndex, FullPaths, Paths);
  Paths.shift();

  var o = {
  	FileIndex: FileIndex,
  	FullPaths: FullPaths
  };

  // $FlowIgnore
  if(options && options.raw) o.raw = {header: header, sectors: sectors};
  return o;
  } // parse

  /* [MS-CFB] 2.2 Compound File Header -- read up to major version */
  function check_get_mver(blob/*:CFBlob*/)/*:[number, number]*/ {
  	if(blob[blob.l] == 0x50 && blob[blob.l + 1] == 0x4b) return [0, 0];
  	// header signature 8
  	blob.chk(HEADER_SIGNATURE, 'Header Signature: ');

  	// clsid 16
  	//blob.chk(HEADER_CLSID, 'CLSID: ');
  	blob.l += 16;

  	// minor version 2
  	var mver/*:number*/ = blob.read_shift(2, 'u');

  	return [blob.read_shift(2,'u'), mver];
  }
  function check_shifts(blob/*:CFBlob*/, mver/*:number*/)/*:void*/ {
  	var shift = 0x09;

  	// Byte Order
  	//blob.chk('feff', 'Byte Order: '); // note: some writers put 0xffff
  	blob.l += 2;

  	// Sector Shift
  	switch((shift = blob.read_shift(2))) {
  		case 0x09: if(mver != 3) throw new Error('Sector Shift: Expected 9 saw ' + shift); break;
  		case 0x0c: if(mver != 4) throw new Error('Sector Shift: Expected 12 saw ' + shift); break;
  		default: throw new Error('Sector Shift: Expected 9 or 12 saw ' + shift);
  	}

  	// Mini Sector Shift
  	blob.chk('0600', 'Mini Sector Shift: ');

  	// Reserved
  	blob.chk('000000000000', 'Reserved: ');
  }

  /** Break the file up into sectors */
  function sectorify(file/*:RawBytes*/, ssz/*:number*/)/*:Array<RawBytes>*/ {
  	var nsectors = Math.ceil(file.length/ssz)-1;
  	var sectors/*:Array<RawBytes>*/ = [];
  	for(var i=1; i < nsectors; ++i) sectors[i-1] = file.slice(i*ssz,(i+1)*ssz);
  	sectors[nsectors-1] = file.slice(nsectors*ssz);
  	return sectors;
  }

  /* [MS-CFB] 2.6.4 Red-Black Tree */
  function build_full_paths(FI/*:CFBFileIndex*/, FP/*:Array<string>*/, Paths/*:Array<string>*/)/*:void*/ {
  	var i = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;
  	var dad/*:Array<number>*/ = [], q/*:Array<number>*/ = [];

  	for(; i < pl; ++i) { dad[i]=q[i]=i; FP[i]=Paths[i]; }

  	for(; j < q.length; ++j) {
  		i = q[j];
  		L = FI[i].L; R = FI[i].R; C = FI[i].C;
  		if(dad[i] === i) {
  			if(L !== -1 /*NOSTREAM*/ && dad[L] !== L) dad[i] = dad[L];
  			if(R !== -1 && dad[R] !== R) dad[i] = dad[R];
  		}
  		if(C !== -1 /*NOSTREAM*/) dad[C] = i;
  		if(L !== -1 && i != dad[i]) { dad[L] = dad[i]; if(q.lastIndexOf(L) < j) q.push(L); }
  		if(R !== -1 && i != dad[i]) { dad[R] = dad[i]; if(q.lastIndexOf(R) < j) q.push(R); }
  	}
  	for(i=1; i < pl; ++i) if(dad[i] === i) {
  		if(R !== -1 /*NOSTREAM*/ && dad[R] !== R) dad[i] = dad[R];
  		else if(L !== -1 && dad[L] !== L) dad[i] = dad[L];
  	}

  	for(i=1; i < pl; ++i) {
  		if(FI[i].type === 0 /* unknown */) continue;
  		j = i;
  		if(j != dad[j]) do {
  			j = dad[j];
  			FP[i] = FP[j] + "/" + FP[i];
  		} while (j !== 0 && -1 !== dad[j] && j != dad[j]);
  		dad[i] = -1;
  	}

  	FP[0] += "/";
  	for(i=1; i < pl; ++i) {
  		if(FI[i].type !== 2 /* stream */) FP[i] += "/";
  	}
  }

  function get_mfat_entry(entry/*:CFBEntry*/, payload/*:RawBytes*/, mini/*:?RawBytes*/)/*:CFBlob*/ {
  	var start = entry.start, size = entry.size;
  	//return (payload.slice(start*MSSZ, start*MSSZ + size)/*:any*/);
  	var o = [];
  	var idx = start;
  	while(mini && size > 0 && idx >= 0) {
  		o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
  		size -= MSSZ;
  		idx = __readInt32LE(mini, idx * 4);
  	}
  	if(o.length === 0) return (new_buf(0)/*:any*/);
  	return (bconcat(o).slice(0, entry.size)/*:any*/);
  }

  /** Chase down the rest of the DIFAT chain to build a comprehensive list
      DIFAT chains by storing the next sector number as the last 32 bits */
  function sleuth_fat(idx/*:number*/, cnt/*:number*/, sectors/*:Array<RawBytes>*/, ssz/*:number*/, fat_addrs)/*:void*/ {
  	var q/*:number*/ = ENDOFCHAIN;
  	if(idx === ENDOFCHAIN) {
  		if(cnt !== 0) throw new Error("DIFAT chain shorter than expected");
  	} else if(idx !== -1 /*FREESECT*/) {
  		var sector = sectors[idx], m = (ssz>>>2)-1;
  		if(!sector) return;
  		for(var i = 0; i < m; ++i) {
  			if((q = __readInt32LE(sector,i*4)) === ENDOFCHAIN) break;
  			fat_addrs.push(q);
  		}
  		sleuth_fat(__readInt32LE(sector,ssz-4),cnt - 1, sectors, ssz, fat_addrs);
  	}
  }

  /** Follow the linked list of sectors for a given starting point */
  function get_sector_list(sectors/*:Array<RawBytes>*/, start/*:number*/, fat_addrs/*:Array<number>*/, ssz/*:number*/, chkd/*:?Array<boolean>*/)/*:SectorEntry*/ {
  	var buf/*:Array<number>*/ = [], buf_chain/*:Array<any>*/ = [];
  	if(!chkd) chkd = [];
  	var modulus = ssz - 1, j = 0, jj = 0;
  	for(j=start; j>=0;) {
  		chkd[j] = true;
  		buf[buf.length] = j;
  		buf_chain.push(sectors[j]);
  		var addr = fat_addrs[Math.floor(j*4/ssz)];
  		jj = ((j*4) & modulus);
  		if(ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 "+ssz);
  		if(!sectors[addr]) break;
  		j = __readInt32LE(sectors[addr], jj);
  	}
  	return {nodes: buf, data:__toBuffer([buf_chain])};
  }

  /** Chase down the sector linked lists */
  function make_sector_list(sectors/*:Array<RawBytes>*/, dir_start/*:number*/, fat_addrs/*:Array<number>*/, ssz/*:number*/)/*:SectorList*/ {
  	var sl = sectors.length, sector_list/*:SectorList*/ = ([]/*:any*/);
  	var chkd/*:Array<boolean>*/ = [], buf/*:Array<number>*/ = [], buf_chain/*:Array<RawBytes>*/ = [];
  	var modulus = ssz - 1, i=0, j=0, k=0, jj=0;
  	for(i=0; i < sl; ++i) {
  		buf = ([]/*:Array<number>*/);
  		k = (i + dir_start); if(k >= sl) k-=sl;
  		if(chkd[k]) continue;
  		buf_chain = [];
  		var seen = [];
  		for(j=k; j>=0;) {
  			seen[j] = true;
  			chkd[j] = true;
  			buf[buf.length] = j;
  			buf_chain.push(sectors[j]);
  			var addr/*:number*/ = fat_addrs[Math.floor(j*4/ssz)];
  			jj = ((j*4) & modulus);
  			if(ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 "+ssz);
  			if(!sectors[addr]) break;
  			j = __readInt32LE(sectors[addr], jj);
  			if(seen[j]) break;
  		}
  		sector_list[k] = ({nodes: buf, data:__toBuffer([buf_chain])}/*:SectorEntry*/);
  	}
  	return sector_list;
  }

  /* [MS-CFB] 2.6.1 Compound File Directory Entry */
  function read_directory(dir_start/*:number*/, sector_list/*:SectorList*/, sectors/*:Array<RawBytes>*/, Paths/*:Array<string>*/, nmfs, files, FileIndex, mini) {
  	var minifat_store = 0, pl = (Paths.length?2:0);
  	var sector = sector_list[dir_start].data;
  	var i = 0, namelen = 0, name;
  	for(; i < sector.length; i+= 128) {
  		var blob/*:CFBlob*/ = /*::(*/sector.slice(i, i+128)/*:: :any)*/;
  		prep_blob(blob, 64);
  		namelen = blob.read_shift(2);
  		name = __utf16le(blob,0,namelen-pl);
  		Paths.push(name);
  		var o/*:CFBEntry*/ = ({
  			name:  name,
  			type:  blob.read_shift(1),
  			color: blob.read_shift(1),
  			L:     blob.read_shift(4, 'i'),
  			R:     blob.read_shift(4, 'i'),
  			C:     blob.read_shift(4, 'i'),
  			clsid: blob.read_shift(16),
  			state: blob.read_shift(4, 'i'),
  			start: 0,
  			size: 0
  		});
  		var ctime/*:number*/ = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
  		if(ctime !== 0) o.ct = read_date(blob, blob.l-8);
  		var mtime/*:number*/ = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
  		if(mtime !== 0) o.mt = read_date(blob, blob.l-8);
  		o.start = blob.read_shift(4, 'i');
  		o.size = blob.read_shift(4, 'i');
  		if(o.size < 0 && o.start < 0) { o.size = o.type = 0; o.start = ENDOFCHAIN; o.name = ""; }
  		if(o.type === 5) { /* root */
  			minifat_store = o.start;
  			if(nmfs > 0 && minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";
  			/*minifat_size = o.size;*/
  		} else if(o.size >= 4096 /* MSCSZ */) {
  			o.storage = 'fat';
  			if(sector_list[o.start] === undefined) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
  			sector_list[o.start].name = o.name;
  			o.content = (sector_list[o.start].data.slice(0,o.size)/*:any*/);
  		} else {
  			o.storage = 'minifat';
  			if(o.size < 0) o.size = 0;
  			else if(minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
  				o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini]||{}).data);
  			}
  		}
  		if(o.content) prep_blob(o.content, 0);
  		files[name] = o;
  		FileIndex.push(o);
  	}
  }

  function read_date(blob/*:RawBytes|CFBlob*/, offset/*:number*/)/*:Date*/ {
  	return new Date(( ( (__readUInt32LE(blob,offset+4)/1e7)*Math.pow(2,32)+__readUInt32LE(blob,offset)/1e7 ) - 11644473600)*1000);
  }

  function read_file(filename/*:string*/, options/*:CFBReadOpts*/) {
  	get_fs();
  	return parse(fs.readFileSync(filename), options);
  }

  function read(blob/*:RawBytes|string*/, options/*:CFBReadOpts*/) {
  	var type = options && options.type;
  	if(!type) {
  		if(has_buf && Buffer.isBuffer(blob)) type = "buffer";
  	}
  	switch(type || "base64") {
  		case "file": /*:: if(typeof blob !== 'string') throw "Must pass a filename when type='file'"; */return read_file(blob, options);
  		case "base64": /*:: if(typeof blob !== 'string') throw "Must pass a base64-encoded binary string when type='file'"; */return parse(s2a(Base64_decode(blob)), options);
  		case "binary": /*:: if(typeof blob !== 'string') throw "Must pass a binary string when type='file'"; */return parse(s2a(blob), options);
  	}
  	return parse(/*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */blob, options);
  }

  function init_cfb(cfb/*:CFBContainer*/, opts/*:?any*/)/*:void*/ {
  	var o = opts || {}, root = o.root || "Root Entry";
  	if(!cfb.FullPaths) cfb.FullPaths = [];
  	if(!cfb.FileIndex) cfb.FileIndex = [];
  	if(cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error("inconsistent CFB structure");
  	if(cfb.FullPaths.length === 0) {
  		cfb.FullPaths[0] = root + "/";
  		cfb.FileIndex[0] = ({ name: root, type: 5 }/*:any*/);
  	}
  	if(o.CLSID) cfb.FileIndex[0].clsid = o.CLSID;
  	seed_cfb(cfb);
  }
  function seed_cfb(cfb/*:CFBContainer*/)/*:void*/ {
  	var nm = "\u0001Sh33tJ5";
  	if(CFB.find(cfb, "/" + nm)) return;
  	var p = new_buf(4); p[0] = 55; p[1] = p[3] = 50; p[2] = 54;
  	cfb.FileIndex.push(({ name: nm, type: 2, content:p, size:4, L:69, R:69, C:69 }/*:any*/));
  	cfb.FullPaths.push(cfb.FullPaths[0] + nm);
  	rebuild_cfb(cfb);
  }
  function rebuild_cfb(cfb/*:CFBContainer*/, f/*:?boolean*/)/*:void*/ {
  	init_cfb(cfb);
  	var gc = false, s = false;
  	for(var i = cfb.FullPaths.length - 1; i >= 0; --i) {
  		var _file = cfb.FileIndex[i];
  		switch(_file.type) {
  			case 0:
  				if(s) gc = true;
  				else { cfb.FileIndex.pop(); cfb.FullPaths.pop(); }
  				break;
  			case 1: case 2: case 5:
  				s = true;
  				if(isNaN(_file.R * _file.L * _file.C)) gc = true;
  				if(_file.R > -1 && _file.L > -1 && _file.R == _file.L) gc = true;
  				break;
  			default: gc = true; break;
  		}
  	}
  	if(!gc && !f) return;

  	var now = new Date(1987, 1, 19), j = 0;
  	// Track which names exist
  	var fullPaths = Object.create ? Object.create(null) : {};
  	var data/*:Array<[string, CFBEntry]>*/ = [];
  	for(i = 0; i < cfb.FullPaths.length; ++i) {
  		fullPaths[cfb.FullPaths[i]] = true;
  		if(cfb.FileIndex[i].type === 0) continue;
  		data.push([cfb.FullPaths[i], cfb.FileIndex[i]]);
  	}
  	for(i = 0; i < data.length; ++i) {
  		var dad = dirname(data[i][0]);
  		s = fullPaths[dad];
  		if(!s) {
  			data.push([dad, ({
  				name: filename(dad).replace("/",""),
  				type: 1,
  				clsid: HEADER_CLSID,
  				ct: now, mt: now,
  				content: null
  			}/*:any*/)]);
  			// Add name to set
  			fullPaths[dad] = true;
  		}
  	}

  	data.sort(function(x,y) { return namecmp(x[0], y[0]); });
  	cfb.FullPaths = []; cfb.FileIndex = [];
  	for(i = 0; i < data.length; ++i) { cfb.FullPaths[i] = data[i][0]; cfb.FileIndex[i] = data[i][1]; }
  	for(i = 0; i < data.length; ++i) {
  		var elt = cfb.FileIndex[i];
  		var nm = cfb.FullPaths[i];

  		elt.name =  filename(nm).replace("/","");
  		elt.L = elt.R = elt.C = -(elt.color = 1);
  		elt.size = elt.content ? elt.content.length : 0;
  		elt.start = 0;
  		elt.clsid = (elt.clsid || HEADER_CLSID);
  		if(i === 0) {
  			elt.C = data.length > 1 ? 1 : -1;
  			elt.size = 0;
  			elt.type = 5;
  		} else if(nm.slice(-1) == "/") {
  			for(j=i+1;j < data.length; ++j) if(dirname(cfb.FullPaths[j])==nm) break;
  			elt.C = j >= data.length ? -1 : j;
  			for(j=i+1;j < data.length; ++j) if(dirname(cfb.FullPaths[j])==dirname(nm)) break;
  			elt.R = j >= data.length ? -1 : j;
  			elt.type = 1;
  		} else {
  			if(dirname(cfb.FullPaths[i+1]||"") == dirname(nm)) elt.R = i + 1;
  			elt.type = 2;
  		}
  	}

  }

  function _write(cfb/*:CFBContainer*/, options/*:CFBWriteOpts*/)/*:RawBytes|string*/ {
  	var _opts = options || {};
  	/* MAD is order-sensitive, skip rebuild and sort */
  	if(_opts.fileType == 'mad') return write_mad(cfb, _opts);
  	rebuild_cfb(cfb);
  	switch(_opts.fileType) {
  		case 'zip': return write_zip(cfb, _opts);
  		//case 'mad': return write_mad(cfb, _opts);
  	}
  	var L = (function(cfb/*:CFBContainer*/)/*:Array<number>*/{
  		var mini_size = 0, fat_size = 0;
  		for(var i = 0; i < cfb.FileIndex.length; ++i) {
  			var file = cfb.FileIndex[i];
  			if(!file.content) continue;
  			/*:: if(file.content == null) throw new Error("unreachable"); */
  			var flen = file.content.length;
  			if(flen > 0){
  				if(flen < 0x1000) mini_size += (flen + 0x3F) >> 6;
  				else fat_size += (flen + 0x01FF) >> 9;
  			}
  		}
  		var dir_cnt = (cfb.FullPaths.length +3) >> 2;
  		var mini_cnt = (mini_size + 7) >> 3;
  		var mfat_cnt = (mini_size + 0x7F) >> 7;
  		var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
  		var fat_cnt = (fat_base + 0x7F) >> 7;
  		var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt-109)/0x7F);
  		while(((fat_base + fat_cnt + difat_cnt + 0x7F) >> 7) > fat_cnt) difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt-109)/0x7F);
  		var L =  [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
  		cfb.FileIndex[0].size = mini_size << 6;
  		L[7] = (cfb.FileIndex[0].start=L[0]+L[1]+L[2]+L[3]+L[4]+L[5])+((L[6]+7) >> 3);
  		return L;
  	})(cfb);
  	var o = new_buf(L[7] << 9);
  	var i = 0, T = 0;
  	{
  		for(i = 0; i < 8; ++i) o.write_shift(1, HEADER_SIG[i]);
  		for(i = 0; i < 8; ++i) o.write_shift(2, 0);
  		o.write_shift(2, 0x003E);
  		o.write_shift(2, 0x0003);
  		o.write_shift(2, 0xFFFE);
  		o.write_shift(2, 0x0009);
  		o.write_shift(2, 0x0006);
  		for(i = 0; i < 3; ++i) o.write_shift(2, 0);
  		o.write_shift(4, 0);
  		o.write_shift(4, L[2]);
  		o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
  		o.write_shift(4, 0);
  		o.write_shift(4, 1<<12);
  		o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1: ENDOFCHAIN);
  		o.write_shift(4, L[3]);
  		o.write_shift(-4, L[1] ? L[0] - 1: ENDOFCHAIN);
  		o.write_shift(4, L[1]);
  		for(i = 0; i < 109; ++i) o.write_shift(-4, i < L[2] ? L[1] + i : -1);
  	}
  	if(L[1]) {
  		for(T = 0; T < L[1]; ++T) {
  			for(; i < 236 + T * 127; ++i) o.write_shift(-4, i < L[2] ? L[1] + i : -1);
  			o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
  		}
  	}
  	var chainit = function(w/*:number*/)/*:void*/ {
  		for(T += w; i<T-1; ++i) o.write_shift(-4, i+1);
  		if(w) { ++i; o.write_shift(-4, ENDOFCHAIN); }
  	};
  	T = i = 0;
  	for(T+=L[1]; i<T; ++i) o.write_shift(-4, consts.DIFSECT);
  	for(T+=L[2]; i<T; ++i) o.write_shift(-4, consts.FATSECT);
  	chainit(L[3]);
  	chainit(L[4]);
  	var j/*:number*/ = 0, flen/*:number*/ = 0;
  	var file/*:CFBEntry*/ = cfb.FileIndex[0];
  	for(; j < cfb.FileIndex.length; ++j) {
  		file = cfb.FileIndex[j];
  		if(!file.content) continue;
  		/*:: if(file.content == null) throw new Error("unreachable"); */
  		flen = file.content.length;
  		if(flen < 0x1000) continue;
  		file.start = T;
  		chainit((flen + 0x01FF) >> 9);
  	}
  	chainit((L[6] + 7) >> 3);
  	while(o.l & 0x1FF) o.write_shift(-4, consts.ENDOFCHAIN);
  	T = i = 0;
  	for(j = 0; j < cfb.FileIndex.length; ++j) {
  		file = cfb.FileIndex[j];
  		if(!file.content) continue;
  		/*:: if(file.content == null) throw new Error("unreachable"); */
  		flen = file.content.length;
  		if(!flen || flen >= 0x1000) continue;
  		file.start = T;
  		chainit((flen + 0x3F) >> 6);
  	}
  	while(o.l & 0x1FF) o.write_shift(-4, consts.ENDOFCHAIN);
  	for(i = 0; i < L[4]<<2; ++i) {
  		var nm = cfb.FullPaths[i];
  		if(!nm || nm.length === 0) {
  			for(j = 0; j < 17; ++j) o.write_shift(4, 0);
  			for(j = 0; j < 3; ++j) o.write_shift(4, -1);
  			for(j = 0; j < 12; ++j) o.write_shift(4, 0);
  			continue;
  		}
  		file = cfb.FileIndex[i];
  		if(i === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;
  		var _nm/*:string*/ = (i === 0 && _opts.root) || file.name;
  		flen = 2*(_nm.length+1);
  		o.write_shift(64, _nm, "utf16le");
  		o.write_shift(2, flen);
  		o.write_shift(1, file.type);
  		o.write_shift(1, file.color);
  		o.write_shift(-4, file.L);
  		o.write_shift(-4, file.R);
  		o.write_shift(-4, file.C);
  		if(!file.clsid) for(j = 0; j < 4; ++j) o.write_shift(4, 0);
  		else o.write_shift(16, file.clsid, "hex");
  		o.write_shift(4, file.state || 0);
  		o.write_shift(4, 0); o.write_shift(4, 0);
  		o.write_shift(4, 0); o.write_shift(4, 0);
  		o.write_shift(4, file.start);
  		o.write_shift(4, file.size); o.write_shift(4, 0);
  	}
  	for(i = 1; i < cfb.FileIndex.length; ++i) {
  		file = cfb.FileIndex[i];
  		/*:: if(!file.content) throw new Error("unreachable"); */
  		if(file.size >= 0x1000) {
  			o.l = (file.start+1) << 9;
  			if (has_buf && Buffer.isBuffer(file.content)) {
  				file.content.copy(o, o.l, 0, file.size);
  				// o is a 0-filled Buffer so just set next offset
  				o.l += (file.size + 511) & -512;
  			} else {
  				for(j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
  				for(; j & 0x1FF; ++j) o.write_shift(1, 0);
  			}
  		}
  	}
  	for(i = 1; i < cfb.FileIndex.length; ++i) {
  		file = cfb.FileIndex[i];
  		/*:: if(!file.content) throw new Error("unreachable"); */
  		if(file.size > 0 && file.size < 0x1000) {
  			if (has_buf && Buffer.isBuffer(file.content)) {
  				file.content.copy(o, o.l, 0, file.size);
  				// o is a 0-filled Buffer so just set next offset
  				o.l += (file.size + 63) & -64;
  			} else {
  				for(j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
  				for(; j & 0x3F; ++j) o.write_shift(1, 0);
  			}
  		}
  	}
  	if (has_buf) {
  		o.l = o.length;
  	} else {
  		// When using Buffer, already 0-filled
  		while(o.l < o.length) o.write_shift(1, 0);
  	}
  	return o;
  }
  /* [MS-CFB] 2.6.4 (Unicode 3.0.1 case conversion) */
  function find(cfb/*:CFBContainer*/, path/*:string*/)/*:?CFBEntry*/ {
  	var UCFullPaths/*:Array<string>*/ = cfb.FullPaths.map(function(x) { return x.toUpperCase(); });
  	var UCPaths/*:Array<string>*/ = UCFullPaths.map(function(x) { var y = x.split("/"); return y[y.length - (x.slice(-1) == "/" ? 2 : 1)]; });
  	var k/*:boolean*/ = false;
  	if(path.charCodeAt(0) === 47 /* "/" */) { k = true; path = UCFullPaths[0].slice(0, -1) + path; }
  	else k = path.indexOf("/") !== -1;
  	var UCPath/*:string*/ = path.toUpperCase();
  	var w/*:number*/ = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
  	if(w !== -1) return cfb.FileIndex[w];

  	var m = !UCPath.match(chr1);
  	UCPath = UCPath.replace(chr0,'');
  	if(m) UCPath = UCPath.replace(chr1,'!');
  	for(w = 0; w < UCFullPaths.length; ++w) {
  		if((m ? UCFullPaths[w].replace(chr1,'!') : UCFullPaths[w]).replace(chr0,'') == UCPath) return cfb.FileIndex[w];
  		if((m ? UCPaths[w].replace(chr1,'!') : UCPaths[w]).replace(chr0,'') == UCPath) return cfb.FileIndex[w];
  	}
  	return null;
  }
  /** CFB Constants */
  var MSSZ = 64; /* Mini Sector Size = 1<<6 */
  //var MSCSZ = 4096; /* Mini Stream Cutoff Size */
  /* 2.1 Compound File Sector Numbers and Types */
  var ENDOFCHAIN = -2;
  /* 2.2 Compound File Header */
  var HEADER_SIGNATURE = 'd0cf11e0a1b11ae1';
  var HEADER_SIG = [0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1];
  var HEADER_CLSID = '00000000000000000000000000000000';
  var consts = {
  	/* 2.1 Compund File Sector Numbers and Types */
  	MAXREGSECT: -6,
  	DIFSECT: -4,
  	FATSECT: -3,
  	ENDOFCHAIN: ENDOFCHAIN,
  	FREESECT: -1,
  	/* 2.2 Compound File Header */
  	HEADER_SIGNATURE: HEADER_SIGNATURE,
  	HEADER_MINOR_VERSION: '3e00',
  	MAXREGSID: -6,
  	NOSTREAM: -1,
  	HEADER_CLSID: HEADER_CLSID,
  	/* 2.6.1 Compound File Directory Entry */
  	EntryTypes: ['unknown','storage','stream','lockbytes','property','root']
  };

  function write_file(cfb/*:CFBContainer*/, filename/*:string*/, options/*:CFBWriteOpts*/)/*:void*/ {
  	get_fs();
  	var o = _write(cfb, options);
  	/*:: if(typeof Buffer == 'undefined' || !Buffer.isBuffer(o) || !(o instanceof Buffer)) throw new Error("unreachable"); */
  	fs.writeFileSync(filename, o);
  }

  function a2s(o/*:RawBytes*/)/*:string*/ {
  	var out = new Array(o.length);
  	for(var i = 0; i < o.length; ++i) out[i] = String.fromCharCode(o[i]);
  	return out.join("");
  }

  function write(cfb/*:CFBContainer*/, options/*:CFBWriteOpts*/)/*:RawBytes|string*/ {
  	var o = _write(cfb, options);
  	switch(options && options.type || "buffer") {
  		case "file": get_fs(); fs.writeFileSync(options.filename, (o/*:any*/)); return o;
  		case "binary": return typeof o == "string" ? o : a2s(o);
  		case "base64": return Base64_encode(typeof o == "string" ? o : a2s(o));
  		case "buffer": if(has_buf) return Buffer.isBuffer(o) ? o : Buffer_from(o);
  			/* falls through */
  		case "array": return typeof o == "string" ? s2a(o) : o;
  	}
  	return o;
  }
  /* node < 8.1 zlib does not expose bytesRead, so default to pure JS */
  var _zlib;
  function use_zlib(zlib) { try {
  	var InflateRaw = zlib.InflateRaw;
  	var InflRaw = new InflateRaw();
  	InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
  	if(InflRaw.bytesRead) _zlib = zlib;
  	else throw new Error("zlib does not expose bytesRead");
  } catch(e) {console.error("cannot use native zlib: " + (e.message || e)); } }

  function _inflateRawSync(payload, usz) {
  	if(!_zlib) return _inflate(payload, usz);
  	var InflateRaw = _zlib.InflateRaw;
  	var InflRaw = new InflateRaw();
  	var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
  	payload.l += InflRaw.bytesRead;
  	return out;
  }

  function _deflateRawSync(payload) {
  	return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
  }
  var CLEN_ORDER = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];

  /*  LEN_ID = [ 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285 ]; */
  var LEN_LN = [   3,   4,   5,   6,   7,   8,   9,  10,  11,  13 , 15,  17,  19,  23,  27,  31,  35,  43,  51,  59,  67,  83,  99, 115, 131, 163, 195, 227, 258 ];

  /*  DST_ID = [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,  14,  15,  16,  17,  18,  19,   20,   21,   22,   23,   24,   25,   26,    27,    28,    29 ]; */
  var DST_LN = [  1,  2,  3,  4,  5,  7,  9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];

  function bit_swap_8(n) { var t = (((((n<<1)|(n<<11)) & 0x22110) | (((n<<5)|(n<<15)) & 0x88440))); return ((t>>16) | (t>>8) |t)&0xFF; }

  var use_typed_arrays = typeof Uint8Array !== 'undefined';

  var bitswap8 = use_typed_arrays ? new Uint8Array(1<<8) : [];
  for(var q = 0; q < (1<<8); ++q) bitswap8[q] = bit_swap_8(q);

  function bit_swap_n(n, b) {
  	var rev = bitswap8[n & 0xFF];
  	if(b <= 8) return rev >>> (8-b);
  	rev = (rev << 8) | bitswap8[(n>>8)&0xFF];
  	if(b <= 16) return rev >>> (16-b);
  	rev = (rev << 8) | bitswap8[(n>>16)&0xFF];
  	return rev >>> (24-b);
  }

  /* helpers for unaligned bit reads */
  function read_bits_2(buf, bl) { var w = (bl&7), h = (bl>>>3); return ((buf[h]|(w <= 6 ? 0 : buf[h+1]<<8))>>>w)& 0x03; }
  function read_bits_3(buf, bl) { var w = (bl&7), h = (bl>>>3); return ((buf[h]|(w <= 5 ? 0 : buf[h+1]<<8))>>>w)& 0x07; }
  function read_bits_4(buf, bl) { var w = (bl&7), h = (bl>>>3); return ((buf[h]|(w <= 4 ? 0 : buf[h+1]<<8))>>>w)& 0x0F; }
  function read_bits_5(buf, bl) { var w = (bl&7), h = (bl>>>3); return ((buf[h]|(w <= 3 ? 0 : buf[h+1]<<8))>>>w)& 0x1F; }
  function read_bits_7(buf, bl) { var w = (bl&7), h = (bl>>>3); return ((buf[h]|(w <= 1 ? 0 : buf[h+1]<<8))>>>w)& 0x7F; }

  /* works up to n = 3 * 8 + 1 = 25 */
  function read_bits_n(buf, bl, n) {
  	var w = (bl&7), h = (bl>>>3), f = ((1<<n)-1);
  	var v = buf[h] >>> w;
  	if(n < 8 - w) return v & f;
  	v |= buf[h+1]<<(8-w);
  	if(n < 16 - w) return v & f;
  	v |= buf[h+2]<<(16-w);
  	if(n < 24 - w) return v & f;
  	v |= buf[h+3]<<(24-w);
  	return v & f;
  }

  /* helpers for unaligned bit writes */
  function write_bits_3(buf, bl, v) { var w = bl & 7, h = bl >>> 3;
  	if(w <= 5) buf[h] |= (v & 7) << w;
  	else {
  		buf[h] |= (v << w) & 0xFF;
  		buf[h+1] = (v&7) >> (8-w);
  	}
  	return bl + 3;
  }

  function write_bits_1(buf, bl, v) {
  	var w = bl & 7, h = bl >>> 3;
  	v = (v&1) << w;
  	buf[h] |= v;
  	return bl + 1;
  }
  function write_bits_8(buf, bl, v) {
  	var w = bl & 7, h = bl >>> 3;
  	v <<= w;
  	buf[h] |=  v & 0xFF; v >>>= 8;
  	buf[h+1] = v;
  	return bl + 8;
  }
  function write_bits_16(buf, bl, v) {
  	var w = bl & 7, h = bl >>> 3;
  	v <<= w;
  	buf[h] |=  v & 0xFF; v >>>= 8;
  	buf[h+1] = v & 0xFF;
  	buf[h+2] = v >>> 8;
  	return bl + 16;
  }

  /* until ArrayBuffer#realloc is a thing, fake a realloc */
  function realloc(b, sz/*:number*/) {
  	var L = b.length, M = 2*L > sz ? 2*L : sz + 5, i = 0;
  	if(L >= sz) return b;
  	if(has_buf) {
  		var o = new_unsafe_buf(M);
  		// $FlowIgnore
  		if(b.copy) b.copy(o);
  		else for(; i < b.length; ++i) o[i] = b[i];
  		return o;
  	} else if(use_typed_arrays) {
  		var a = new Uint8Array(M);
  		if(a.set) a.set(b);
  		else for(; i < L; ++i) a[i] = b[i];
  		return a;
  	}
  	b.length = M;
  	return b;
  }

  /* zero-filled arrays for older browsers */
  function zero_fill_array(n) {
  	var o = new Array(n);
  	for(var i = 0; i < n; ++i) o[i] = 0;
  	return o;
  }

  /* build tree (used for literals and lengths) */
  function build_tree(clens, cmap, MAX/*:number*/)/*:number*/ {
  	var maxlen = 1, w = 0, i = 0, j = 0, ccode = 0, L = clens.length;

  	var bl_count  = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
  	for(i = 0; i < 32; ++i) bl_count[i] = 0;

  	for(i = L; i < MAX; ++i) clens[i] = 0;
  	L = clens.length;

  	var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L); // []

  	/* build code tree */
  	for(i = 0; i < L; ++i) {
  		bl_count[(w = clens[i])]++;
  		if(maxlen < w) maxlen = w;
  		ctree[i] = 0;
  	}
  	bl_count[0] = 0;
  	for(i = 1; i <= maxlen; ++i) bl_count[i+16] = (ccode = (ccode + bl_count[i-1])<<1);
  	for(i = 0; i < L; ++i) {
  		ccode = clens[i];
  		if(ccode != 0) ctree[i] = bl_count[ccode+16]++;
  	}

  	/* cmap[maxlen + 4 bits] = (off&15) + (lit<<4) reverse mapping */
  	var cleni = 0;
  	for(i = 0; i < L; ++i) {
  		cleni = clens[i];
  		if(cleni != 0) {
  			ccode = bit_swap_n(ctree[i], maxlen)>>(maxlen-cleni);
  			for(j = (1<<(maxlen + 4 - cleni)) - 1; j>=0; --j)
  				cmap[ccode|(j<<cleni)] = (cleni&15) | (i<<4);
  		}
  	}
  	return maxlen;
  }

  /* Fixed Huffman */
  var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
  var fix_dmap = use_typed_arrays ? new Uint16Array(32)  : zero_fill_array(32);
  if(!use_typed_arrays) {
  	for(var i = 0; i < 512; ++i) fix_lmap[i] = 0;
  	for(i = 0; i < 32; ++i) fix_dmap[i] = 0;
  }
  (function() {
  	var dlens/*:Array<number>*/ = [];
  	var i = 0;
  	for(;i<32; i++) dlens.push(5);
  	build_tree(dlens, fix_dmap, 32);

  	var clens/*:Array<number>*/ = [];
  	i = 0;
  	for(; i<=143; i++) clens.push(8);
  	for(; i<=255; i++) clens.push(9);
  	for(; i<=279; i++) clens.push(7);
  	for(; i<=287; i++) clens.push(8);
  	build_tree(clens, fix_lmap, 288);
  })();var _deflateRaw = /*#__PURE__*/(function _deflateRawIIFE() {
  	var DST_LN_RE = use_typed_arrays ? new Uint8Array(0x8000) : [];
  	var j = 0, k = 0;
  	for(; j < DST_LN.length - 1; ++j) {
  		for(; k < DST_LN[j+1]; ++k) DST_LN_RE[k] = j;
  	}
  	for(;k < 32768; ++k) DST_LN_RE[k] = 29;

  	var LEN_LN_RE = use_typed_arrays ? new Uint8Array(0x103) : [];
  	for(j = 0, k = 0; j < LEN_LN.length - 1; ++j) {
  		for(; k < LEN_LN[j+1]; ++k) LEN_LN_RE[k] = j;
  	}

  	function write_stored(data, out) {
  		var boff = 0;
  		while(boff < data.length) {
  			var L = Math.min(0xFFFF, data.length - boff);
  			var h = boff + L == data.length;
  			out.write_shift(1, +h);
  			out.write_shift(2, L);
  			out.write_shift(2, (~L) & 0xFFFF);
  			while(L-- > 0) out[out.l++] = data[boff++];
  		}
  		return out.l;
  	}

  	/* Fixed Huffman */
  	function write_huff_fixed(data, out) {
  		var bl = 0;
  		var boff = 0;
  		var addrs = use_typed_arrays ? new Uint16Array(0x8000) : [];
  		while(boff < data.length) {
  			var L = /* data.length - boff; */ Math.min(0xFFFF, data.length - boff);

  			/* write a stored block for short data */
  			if(L < 10) {
  				bl = write_bits_3(out, bl, +!!(boff + L == data.length)); // jshint ignore:line
  				if(bl & 7) bl += 8 - (bl & 7);
  				out.l = (bl / 8) | 0;
  				out.write_shift(2, L);
  				out.write_shift(2, (~L) & 0xFFFF);
  				while(L-- > 0) out[out.l++] = data[boff++];
  				bl = out.l * 8;
  				continue;
  			}

  			bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2); // jshint ignore:line
  			var hash = 0;
  			while(L-- > 0) {
  				var d = data[boff];
  				hash = ((hash << 5) ^ d) & 0x7FFF;

  				var match = -1, mlen = 0;

  				if((match = addrs[hash])) {
  					match |= boff & ~0x7FFF;
  					if(match > boff) match -= 0x8000;
  					if(match < boff) while(data[match + mlen] == data[boff + mlen] && mlen < 250) ++mlen;
  				}

  				if(mlen > 2) {
  					/* Copy Token  */
  					d = LEN_LN_RE[mlen];
  					if(d <= 22) bl = write_bits_8(out, bl, bitswap8[d+1]>>1) - 1;
  					else {
  						write_bits_8(out, bl, 3);
  						bl += 5;
  						write_bits_8(out, bl, bitswap8[d-23]>>5);
  						bl += 3;
  					}
  					var len_eb = (d < 8) ? 0 : ((d - 4)>>2);
  					if(len_eb > 0) {
  						write_bits_16(out, bl, mlen - LEN_LN[d]);
  						bl += len_eb;
  					}

  					d = DST_LN_RE[boff - match];
  					bl = write_bits_8(out, bl, bitswap8[d]>>3);
  					bl -= 3;

  					var dst_eb = d < 4 ? 0 : (d-2)>>1;
  					if(dst_eb > 0) {
  						write_bits_16(out, bl, boff - match - DST_LN[d]);
  						bl += dst_eb;
  					}
  					for(var q = 0; q < mlen; ++q) {
  						addrs[hash] = boff & 0x7FFF;
  						hash = ((hash << 5) ^ data[boff]) & 0x7FFF;
  						++boff;
  					}
  					L-= mlen - 1;
  				} else {
  					/* Literal Token */
  					if(d <= 143) d = d + 48;
  					else bl = write_bits_1(out, bl, 1);
  					bl = write_bits_8(out, bl, bitswap8[d]);
  					addrs[hash] = boff & 0x7FFF;
  					++boff;
  				}
  			}

  			bl = write_bits_8(out, bl, 0) - 1;
  		}
  		out.l = ((bl + 7)/8)|0;
  		return out.l;
  	}
  	return function _deflateRaw(data, out) {
  		if(data.length < 8) return write_stored(data, out);
  		return write_huff_fixed(data, out);
  	};
  })();

  function _deflate(data) {
  	var buf = new_buf(50+Math.floor(data.length*1.1));
  	var off = _deflateRaw(data, buf);
  	return buf.slice(0, off);
  }
  /* modified inflate function also moves original read head */

  var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_cmap = use_typed_arrays ? new Uint16Array(128)   : zero_fill_array(128);
  var dyn_len_1 = 1, dyn_len_2 = 1;

  /* 5.5.3 Expanding Huffman Codes */
  function dyn(data, boff/*:number*/) {
  	/* nomenclature from RFC1951 refers to bit values; these are offset by the implicit constant */
  	var _HLIT = read_bits_5(data, boff) + 257; boff += 5;
  	var _HDIST = read_bits_5(data, boff) + 1; boff += 5;
  	var _HCLEN = read_bits_4(data, boff) + 4; boff += 4;
  	var w = 0;

  	/* grab and store code lengths */
  	var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
  	var ctree = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
  	var maxlen = 1;
  	var bl_count =  use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
  	var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
  	var L = clens.length; /* 19 */
  	for(var i = 0; i < _HCLEN; ++i) {
  		clens[CLEN_ORDER[i]] = w = read_bits_3(data, boff);
  		if(maxlen < w) maxlen = w;
  		bl_count[w]++;
  		boff += 3;
  	}

  	/* build code tree */
  	var ccode = 0;
  	bl_count[0] = 0;
  	for(i = 1; i <= maxlen; ++i) next_code[i] = ccode = (ccode + bl_count[i-1])<<1;
  	for(i = 0; i < L; ++i) if((ccode = clens[i]) != 0) ctree[i] = next_code[ccode]++;
  	/* cmap[7 bits from stream] = (off&7) + (lit<<3) */
  	var cleni = 0;
  	for(i = 0; i < L; ++i) {
  		cleni = clens[i];
  		if(cleni != 0) {
  			ccode = bitswap8[ctree[i]]>>(8-cleni);
  			for(var j = (1<<(7-cleni))-1; j>=0; --j) dyn_cmap[ccode|(j<<cleni)] = (cleni&7) | (i<<3);
  		}
  	}

  	/* read literal and dist codes at once */
  	var hcodes/*:Array<number>*/ = [];
  	maxlen = 1;
  	for(; hcodes.length < _HLIT + _HDIST;) {
  		ccode = dyn_cmap[read_bits_7(data, boff)];
  		boff += ccode & 7;
  		switch((ccode >>>= 3)) {
  			case 16:
  				w = 3 + read_bits_2(data, boff); boff += 2;
  				ccode = hcodes[hcodes.length - 1];
  				while(w-- > 0) hcodes.push(ccode);
  				break;
  			case 17:
  				w = 3 + read_bits_3(data, boff); boff += 3;
  				while(w-- > 0) hcodes.push(0);
  				break;
  			case 18:
  				w = 11 + read_bits_7(data, boff); boff += 7;
  				while(w -- > 0) hcodes.push(0);
  				break;
  			default:
  				hcodes.push(ccode);
  				if(maxlen < ccode) maxlen = ccode;
  				break;
  		}
  	}

  	/* build literal / length trees */
  	var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);
  	for(i = _HLIT; i < 286; ++i) h1[i] = 0;
  	for(i = _HDIST; i < 30; ++i) h2[i] = 0;
  	dyn_len_1 = build_tree(h1, dyn_lmap, 286);
  	dyn_len_2 = build_tree(h2, dyn_dmap, 30);
  	return boff;
  }

  /* return [ data, bytesRead ] */
  function inflate(data, usz/*:number*/) {
  	/* shortcircuit for empty buffer [0x03, 0x00] */
  	if(data[0] == 3 && !(data[1] & 0x3)) { return [new_raw_buf(usz), 2]; }

  	/* bit offset */
  	var boff = 0;

  	/* header includes final bit and type bits */
  	var header = 0;

  	var outbuf = new_unsafe_buf(usz ? usz : (1<<18));
  	var woff = 0;
  	var OL = outbuf.length>>>0;
  	var max_len_1 = 0, max_len_2 = 0;

  	while((header&1) == 0) {
  		header = read_bits_3(data, boff); boff += 3;
  		if((header >>> 1) == 0) {
  			/* Stored block */
  			if(boff & 7) boff += 8 - (boff&7);
  			/* 2 bytes sz, 2 bytes bit inverse */
  			var sz = data[boff>>>3] | data[(boff>>>3)+1]<<8;
  			boff += 32;
  			/* push sz bytes */
  			if(sz > 0) {
  				if(!usz && OL < woff + sz) { outbuf = realloc(outbuf, woff + sz); OL = outbuf.length; }
  				while(sz-- > 0) { outbuf[woff++] = data[boff>>>3]; boff += 8; }
  			}
  			continue;
  		} else if((header >> 1) == 1) {
  			/* Fixed Huffman */
  			max_len_1 = 9; max_len_2 = 5;
  		} else {
  			/* Dynamic Huffman */
  			boff = dyn(data, boff);
  			max_len_1 = dyn_len_1; max_len_2 = dyn_len_2;
  		}
  		for(;;) { // while(true) is apparently out of vogue in modern JS circles
  			if(!usz && (OL < woff + 32767)) { outbuf = realloc(outbuf, woff + 32767); OL = outbuf.length; }
  			/* ingest code and move read head */
  			var bits = read_bits_n(data, boff, max_len_1);
  			var code = (header>>>1) == 1 ? fix_lmap[bits] : dyn_lmap[bits];
  			boff += code & 15; code >>>= 4;
  			/* 0-255 are literals, 256 is end of block token, 257+ are copy tokens */
  			if(((code>>>8)&0xFF) === 0) outbuf[woff++] = code;
  			else if(code == 256) break;
  			else {
  				code -= 257;
  				var len_eb = (code < 8) ? 0 : ((code-4)>>2); if(len_eb > 5) len_eb = 0;
  				var tgt = woff + LEN_LN[code];
  				/* length extra bits */
  				if(len_eb > 0) {
  					tgt += read_bits_n(data, boff, len_eb);
  					boff += len_eb;
  				}

  				/* dist code */
  				bits = read_bits_n(data, boff, max_len_2);
  				code = (header>>>1) == 1 ? fix_dmap[bits] : dyn_dmap[bits];
  				boff += code & 15; code >>>= 4;
  				var dst_eb = (code < 4 ? 0 : (code-2)>>1);
  				var dst = DST_LN[code];
  				/* dist extra bits */
  				if(dst_eb > 0) {
  					dst += read_bits_n(data, boff, dst_eb);
  					boff += dst_eb;
  				}

  				/* in the common case, manual byte copy is faster than TA set / Buffer copy */
  				if(!usz && OL < tgt) { outbuf = realloc(outbuf, tgt + 100); OL = outbuf.length; }
  				while(woff < tgt) { outbuf[woff] = outbuf[woff - dst]; ++woff; }
  			}
  		}
  	}
  	if(usz) return [outbuf, (boff+7)>>>3];
  	return [outbuf.slice(0, woff), (boff+7)>>>3];
  }

  function _inflate(payload, usz) {
  	var data = payload.slice(payload.l||0);
  	var out = inflate(data, usz);
  	payload.l += out[1];
  	return out[0];
  }

  function warn_or_throw(wrn, msg) {
  	if(wrn) { if(typeof console !== 'undefined') console.error(msg); }
  	else throw new Error(msg);
  }

  function parse_zip(file/*:RawBytes*/, options/*:CFBReadOpts*/)/*:CFBContainer*/ {
  	var blob/*:CFBlob*/ = /*::(*/file/*:: :any)*/;
  	prep_blob(blob, 0);

  	var FileIndex/*:CFBFileIndex*/ = [], FullPaths/*:Array<string>*/ = [];
  	var o = {
  		FileIndex: FileIndex,
  		FullPaths: FullPaths
  	};
  	init_cfb(o, { root: options.root });

  	/* find end of central directory, start just after signature */
  	var i = blob.length - 4;
  	while((blob[i] != 0x50 || blob[i+1] != 0x4b || blob[i+2] != 0x05 || blob[i+3] != 0x06) && i >= 0) --i;
  	blob.l = i + 4;

  	/* parse end of central directory */
  	blob.l += 4;
  	var fcnt = blob.read_shift(2);
  	blob.l += 6;
  	var start_cd = blob.read_shift(4);

  	/* parse central directory */
  	blob.l = start_cd;

  	for(i = 0; i < fcnt; ++i) {
  		/* trust local file header instead of CD entry */
  		blob.l += 20;
  		var csz = blob.read_shift(4);
  		var usz = blob.read_shift(4);
  		var namelen = blob.read_shift(2);
  		var efsz = blob.read_shift(2);
  		var fcsz = blob.read_shift(2);
  		blob.l += 8;
  		var offset = blob.read_shift(4);
  		var EF = parse_extra_field(/*::(*/blob.slice(blob.l+namelen, blob.l+namelen+efsz)/*:: :any)*/);
  		blob.l += namelen + efsz + fcsz;

  		var L = blob.l;
  		blob.l = offset + 4;
  		parse_local_file(blob, csz, usz, o, EF);
  		blob.l = L;
  	}
  	return o;
  }


  /* head starts just after local file header signature */
  function parse_local_file(blob/*:CFBlob*/, csz/*:number*/, usz/*:number*/, o/*:CFBContainer*/, EF) {
  	/* [local file header] */
  	blob.l += 2;
  	var flags = blob.read_shift(2);
  	var meth = blob.read_shift(2);
  	var date = parse_dos_date(blob);

  	if(flags & 0x2041) throw new Error("Unsupported ZIP encryption");
  	var crc32 = blob.read_shift(4);
  	var _csz = blob.read_shift(4);
  	var _usz = blob.read_shift(4);

  	var namelen = blob.read_shift(2);
  	var efsz = blob.read_shift(2);

  	// TODO: flags & (1<<11) // UTF8
  	var name = ""; for(var i = 0; i < namelen; ++i) name += String.fromCharCode(blob[blob.l++]);
  	if(efsz) {
  		var ef = parse_extra_field(/*::(*/blob.slice(blob.l, blob.l + efsz)/*:: :any)*/);
  		if((ef[0x5455]||{}).mt) date = ef[0x5455].mt;
  		if(((EF||{})[0x5455]||{}).mt) date = EF[0x5455].mt;
  	}
  	blob.l += efsz;

  	/* [encryption header] */

  	/* [file data] */
  	var data = blob.slice(blob.l, blob.l + _csz);
  	switch(meth) {
  		case 8: data = _inflateRawSync(blob, _usz); break;
  		case 0: break; // TODO: scan for magic number
  		default: throw new Error("Unsupported ZIP Compression method " + meth);
  	}

  	/* [data descriptor] */
  	var wrn = false;
  	if(flags & 8) {
  		crc32 = blob.read_shift(4);
  		if(crc32 == 0x08074b50) { crc32 = blob.read_shift(4); wrn = true; }
  		_csz = blob.read_shift(4);
  		_usz = blob.read_shift(4);
  	}

  	if(_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
  	if(_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
  	//var _crc32 = CRC32.buf(data, 0);
  	//if((crc32>>0) != (_crc32>>0)) warn_or_throw(wrn, "Bad CRC32 checksum: " + crc32 + " != " + _crc32);
  	cfb_add(o, name, data, {unsafe: true, mt: date});
  }
  function write_zip(cfb/*:CFBContainer*/, options/*:CFBWriteOpts*/)/*:RawBytes*/ {
  	var _opts = options || {};
  	var out = [], cdirs = [];
  	var o/*:CFBlob*/ = new_buf(1);
  	var method = (_opts.compression ? 8 : 0), flags = 0;
  	var i = 0, j = 0;

  	var start_cd = 0, fcnt = 0;
  	var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
  	var crcs = [];
  	var sz_cd = 0;

  	for(i = 1; i < cfb.FullPaths.length; ++i) {
  		fp = cfb.FullPaths[i].slice(root.length); fi = cfb.FileIndex[i];
  		if(!fi.size || !fi.content || fp == "\u0001Sh33tJ5") continue;
  		var start = start_cd;

  		/* TODO: CP437 filename */
  		var namebuf = new_buf(fp.length);
  		for(j = 0; j < fp.length; ++j) namebuf.write_shift(1, fp.charCodeAt(j) & 0x7F);
  		namebuf = namebuf.slice(0, namebuf.l);
  		crcs[fcnt] = CRC32.buf(/*::((*/fi.content/*::||[]):any)*/, 0);

  		var outbuf = fi.content/*::||[]*/;
  		if(method == 8) outbuf = _deflateRawSync(outbuf);

  		/* local file header */
  		o = new_buf(30);
  		o.write_shift(4, 0x04034b50);
  		o.write_shift(2, 20);
  		o.write_shift(2, flags);
  		o.write_shift(2, method);
  		/* TODO: last mod file time/date */
  		if(fi.mt) write_dos_date(o, fi.mt);
  		else o.write_shift(4, 0);
  		o.write_shift(-4, crcs[fcnt]);
  		o.write_shift(4,  outbuf.length);
  		o.write_shift(4,  /*::(*/fi.content/*::||[])*/.length);
  		o.write_shift(2, namebuf.length);
  		o.write_shift(2, 0);

  		start_cd += o.length;
  		out.push(o);
  		start_cd += namebuf.length;
  		out.push(namebuf);

  		/* TODO: extra fields? */

  		/* TODO: encryption header ? */

  		start_cd += outbuf.length;
  		out.push(outbuf);

  		/* central directory */
  		o = new_buf(46);
  		o.write_shift(4, 0x02014b50);
  		o.write_shift(2, 0);
  		o.write_shift(2, 20);
  		o.write_shift(2, flags);
  		o.write_shift(2, method);
  		o.write_shift(4, 0); /* TODO: last mod file time/date */
  		o.write_shift(-4, crcs[fcnt]);

  		o.write_shift(4, outbuf.length);
  		o.write_shift(4, /*::(*/fi.content/*::||[])*/.length);
  		o.write_shift(2, namebuf.length);
  		o.write_shift(2, 0);
  		o.write_shift(2, 0);
  		o.write_shift(2, 0);
  		o.write_shift(2, 0);
  		o.write_shift(4, 0);
  		o.write_shift(4, start);

  		sz_cd += o.l;
  		cdirs.push(o);
  		sz_cd += namebuf.length;
  		cdirs.push(namebuf);
  		++fcnt;
  	}

  	/* end of central directory */
  	o = new_buf(22);
  	o.write_shift(4, 0x06054b50);
  	o.write_shift(2, 0);
  	o.write_shift(2, 0);
  	o.write_shift(2, fcnt);
  	o.write_shift(2, fcnt);
  	o.write_shift(4, sz_cd);
  	o.write_shift(4, start_cd);
  	o.write_shift(2, 0);

  	return bconcat(([bconcat((out/*:any*/)), bconcat(cdirs), o]/*:any*/));
  }
  var ContentTypeMap = ({
  	"htm": "text/html",
  	"xml": "text/xml",

  	"gif": "image/gif",
  	"jpg": "image/jpeg",
  	"png": "image/png",

  	"mso": "application/x-mso",
  	"thmx": "application/vnd.ms-officetheme",
  	"sh33tj5": "application/octet-stream"
  }/*:any*/);

  function get_content_type(fi/*:CFBEntry*/, fp/*:string*/)/*:string*/ {
  	if(fi.ctype) return fi.ctype;

  	var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);
  	if(m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];

  	if(fp) {
  		m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
  		if(m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
  	}

  	return "application/octet-stream";
  }

  /* 76 character chunks TODO: intertwine encoding */
  function write_base64_76(bstr/*:string*/)/*:string*/ {
  	var data = Base64_encode(bstr);
  	var o = [];
  	for(var i = 0; i < data.length; i+= 76) o.push(data.slice(i, i+76));
  	return o.join("\r\n") + "\r\n";
  }

  /*
  Rules for QP:
  	- escape =## applies for all non-display characters and literal "="
  	- space or tab at end of line must be encoded
  	- \r\n newlines can be preserved, but bare \r and \n must be escaped
  	- lines must not exceed 76 characters, use soft breaks =\r\n

  TODO: Some files from word appear to write line extensions with bare equals:

  ```
  <table class=3DMsoTableGrid border=3D1 cellspacing=3D0 cellpadding=3D0 width=
  ="70%"
  ```
  */
  function write_quoted_printable(text/*:string*/)/*:string*/ {
  	var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c) {
  		var w = c.charCodeAt(0).toString(16).toUpperCase();
  		return "=" + (w.length == 1 ? "0" + w : w);
  	});

  	encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");

  	if(encoded.charAt(0) == "\n") encoded = "=0D" + encoded.slice(1);
  	encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");

  	var o/*:Array<string>*/ = [], split = encoded.split("\r\n");
  	for(var si = 0; si < split.length; ++si) {
  		var str = split[si];
  		if(str.length == 0) { o.push(""); continue; }
  		for(var i = 0; i < str.length;) {
  			var end = 76;
  			var tmp = str.slice(i, i + end);
  			if(tmp.charAt(end - 1) == "=") end --;
  			else if(tmp.charAt(end - 2) == "=") end -= 2;
  			else if(tmp.charAt(end - 3) == "=") end -= 3;
  			tmp = str.slice(i, i + end);
  			i += end;
  			if(i < str.length) tmp += "=";
  			o.push(tmp);
  		}
  	}

  	return o.join("\r\n");
  }
  function parse_quoted_printable(data/*:Array<string>*/)/*:RawBytes*/ {
  	var o = [];

  	/* unify long lines */
  	for(var di = 0; di < data.length; ++di) {
  		var line = data[di];
  		while(di <= data.length && line.charAt(line.length - 1) == "=") line = line.slice(0, line.length - 1) + data[++di];
  		o.push(line);
  	}

  	/* decode */
  	for(var oi = 0; oi < o.length; ++oi) o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) { return String.fromCharCode(parseInt($$.slice(1), 16)); });
  	return s2a(o.join("\r\n"));
  }


  function parse_mime(cfb/*:CFBContainer*/, data/*:Array<string>*/, root/*:string*/)/*:void*/ {
  	var fname = "", cte = "", ctype = "", fdata;
  	var di = 0;
  	for(;di < 10; ++di) {
  		var line = data[di];
  		if(!line || line.match(/^\s*$/)) break;
  		var m = line.match(/^(.*?):\s*([^\s].*)$/);
  		if(m) switch(m[1].toLowerCase()) {
  			case "content-location": fname = m[2].trim(); break;
  			case "content-type": ctype = m[2].trim(); break;
  			case "content-transfer-encoding": cte = m[2].trim(); break;
  		}
  	}
  	++di;
  	switch(cte.toLowerCase()) {
  		case 'base64': fdata = s2a(Base64_decode(data.slice(di).join(""))); break;
  		case 'quoted-printable': fdata = parse_quoted_printable(data.slice(di)); break;
  		default: throw new Error("Unsupported Content-Transfer-Encoding " + cte);
  	}
  	var file = cfb_add(cfb, fname.slice(root.length), fdata, {unsafe: true});
  	if(ctype) file.ctype = ctype;
  }

  function parse_mad(file/*:RawBytes*/, options/*:CFBReadOpts*/)/*:CFBContainer*/ {
  	if(a2s(file.slice(0,13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
  	var root = (options && options.root || "");
  	// $FlowIgnore
  	var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s(file)).split("\r\n");
  	var di = 0, row = "";

  	/* if root is not specified, scan for the common prefix */
  	for(di = 0; di < data.length; ++di) {
  		row = data[di];
  		if(!/^Content-Location:/i.test(row)) continue;
  		row = row.slice(row.indexOf("file"));
  		if(!root) root = row.slice(0, row.lastIndexOf("/") + 1);
  		if(row.slice(0, root.length) == root) continue;
  		while(root.length > 0) {
  			root = root.slice(0, root.length - 1);
  			root = root.slice(0, root.lastIndexOf("/") + 1);
  			if(row.slice(0,root.length) == root) break;
  		}
  	}

  	var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
  	if(!mboundary) throw new Error("MAD cannot find boundary");
  	var boundary = "--" + (mboundary[1] || "");

  	var FileIndex/*:CFBFileIndex*/ = [], FullPaths/*:Array<string>*/ = [];
  	var o = {
  		FileIndex: FileIndex,
  		FullPaths: FullPaths
  	};
  	init_cfb(o);
  	var start_di, fcnt = 0;
  	for(di = 0; di < data.length; ++di) {
  		var line = data[di];
  		if(line !== boundary && line !== boundary + "--") continue;
  		if(fcnt++) parse_mime(o, data.slice(start_di, di), root);
  		start_di = di;
  	}
  	return o;
  }

  function write_mad(cfb/*:CFBContainer*/, options/*:CFBWriteOpts*/)/*:string*/ {
  	var opts = options || {};
  	var boundary = opts.boundary || "SheetJS";
  	boundary = '------=' + boundary;

  	var out = [
  		'MIME-Version: 1.0',
  		'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
  		'',
  		'',
  		''
  	];

  	var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
  	for(var i = 1; i < cfb.FullPaths.length; ++i) {
  		fp = cfb.FullPaths[i].slice(root.length);
  		fi = cfb.FileIndex[i];
  		if(!fi.size || !fi.content || fp == "\u0001Sh33tJ5") continue;

  		/* Normalize filename */
  		fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c) {
  			return "_x" + c.charCodeAt(0).toString(16) + "_";
  		}).replace(/[\u0080-\uFFFF]/g, function(u) {
  			return "_u" + u.charCodeAt(0).toString(16) + "_";
  		});

  		/* Extract content as binary string */
  		var ca = fi.content;
  		// $FlowIgnore
  		var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s(ca);

  		/* 4/5 of first 1024 chars ascii -> quoted printable, else base64 */
  		var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;
  		for(var csl = 0; csl <= L; ++csl) if((cc=cstr.charCodeAt(csl)) >= 0x20 && cc < 0x80) ++dispcnt;
  		var qp = dispcnt >= L * 4 / 5;

  		out.push(boundary);
  		out.push('Content-Location: ' + (opts.root || 'file:///C:/SheetJS/') + fp);
  		out.push('Content-Transfer-Encoding: ' + (qp ? 'quoted-printable' : 'base64'));
  		out.push('Content-Type: ' + get_content_type(fi, fp));
  		out.push('');

  		out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
  	}
  	out.push(boundary + '--\r\n');
  	return out.join("\r\n");
  }
  function cfb_new(opts/*:?any*/)/*:CFBContainer*/ {
  	var o/*:CFBContainer*/ = ({}/*:any*/);
  	init_cfb(o, opts);
  	return o;
  }

  function cfb_add(cfb/*:CFBContainer*/, name/*:string*/, content/*:?RawBytes*/, opts/*:?any*/)/*:CFBEntry*/ {
  	var unsafe = opts && opts.unsafe;
  	if(!unsafe) init_cfb(cfb);
  	var file = !unsafe && CFB.find(cfb, name);
  	if(!file) {
  		var fpath/*:string*/ = cfb.FullPaths[0];
  		if(name.slice(0, fpath.length) == fpath) fpath = name;
  		else {
  			if(fpath.slice(-1) != "/") fpath += "/";
  			fpath = (fpath + name).replace("//","/");
  		}
  		file = ({name: filename(name), type: 2}/*:any*/);
  		cfb.FileIndex.push(file);
  		cfb.FullPaths.push(fpath);
  		if(!unsafe) CFB.utils.cfb_gc(cfb);
  	}
  	/*:: if(!file) throw new Error("unreachable"); */
  	file.content = (content/*:any*/);
  	file.size = content ? content.length : 0;
  	if(opts) {
  		if(opts.CLSID) file.clsid = opts.CLSID;
  		if(opts.mt) file.mt = opts.mt;
  		if(opts.ct) file.ct = opts.ct;
  	}
  	return file;
  }

  function cfb_del(cfb/*:CFBContainer*/, name/*:string*/)/*:boolean*/ {
  	init_cfb(cfb);
  	var file = CFB.find(cfb, name);
  	if(file) for(var j = 0; j < cfb.FileIndex.length; ++j) if(cfb.FileIndex[j] == file) {
  		cfb.FileIndex.splice(j, 1);
  		cfb.FullPaths.splice(j, 1);
  		return true;
  	}
  	return false;
  }

  function cfb_mov(cfb/*:CFBContainer*/, old_name/*:string*/, new_name/*:string*/)/*:boolean*/ {
  	init_cfb(cfb);
  	var file = CFB.find(cfb, old_name);
  	if(file) for(var j = 0; j < cfb.FileIndex.length; ++j) if(cfb.FileIndex[j] == file) {
  		cfb.FileIndex[j].name = filename(new_name);
  		cfb.FullPaths[j] = new_name;
  		return true;
  	}
  	return false;
  }

  function cfb_gc(cfb/*:CFBContainer*/)/*:void*/ { rebuild_cfb(cfb, true); }

  exports.find = find;
  exports.read = read;
  exports.parse = parse;
  exports.write = write;
  exports.writeFile = write_file;
  exports.utils = {
  	cfb_new: cfb_new,
  	cfb_add: cfb_add,
  	cfb_del: cfb_del,
  	cfb_mov: cfb_mov,
  	cfb_gc: cfb_gc,
  	ReadShift: ReadShift,
  	CheckField: CheckField,
  	prep_blob: prep_blob,
  	bconcat: bconcat,
  	use_zlib: use_zlib,
  	_deflateRaw: _deflate,
  	_inflateRaw: _inflate,
  	consts: consts
  };

  return exports;
  })();

  /* normalize data for blob ctor */
  function blobify(data) {
  	if(typeof data === "string") return s2ab(data);
  	if(Array.isArray(data)) return a2u(data);
  	return data;
  }
  /* write or download file */
  function write_dl(fname/*:string*/, payload/*:any*/, enc/*:?string*/) {
  	if(typeof Deno !== 'undefined') {
  		/* in this spot, it's safe to assume typed arrays and TextEncoder/TextDecoder exist */
  		if(enc && typeof payload == "string") switch(enc) {
  			case "utf8": payload = new TextEncoder(enc).encode(payload); break;
  			case "binary": payload = s2ab(payload); break;
  			/* TODO: binary equivalent */
  			default: throw new Error("Unsupported encoding " + enc);
  		}
  		return Deno.writeFileSync(fname, payload);
  	}
  	var data = (enc == "utf8") ? utf8write(payload) : payload;
  	/*:: declare var IE_SaveFile: any; */
  	if(typeof IE_SaveFile !== 'undefined') return IE_SaveFile(data, fname);
  	if(typeof Blob !== 'undefined') {
  		var blob = new Blob([blobify(data)], {type:"application/octet-stream"});
  		/*:: declare var navigator: any; */
  		if(typeof navigator !== 'undefined' && navigator.msSaveBlob) return navigator.msSaveBlob(blob, fname);
  		/*:: declare var saveAs: any; */
  		if(typeof saveAs !== 'undefined') return saveAs(blob, fname);
  		if(typeof URL !== 'undefined' && typeof document !== 'undefined' && document.createElement && URL.createObjectURL) {
  			var url = URL.createObjectURL(blob);
  			/*:: declare var chrome: any; */
  			if(typeof chrome === 'object' && typeof (chrome.downloads||{}).download == "function") {
  				if(URL.revokeObjectURL && typeof setTimeout !== 'undefined') setTimeout(function() { URL.revokeObjectURL(url); }, 60000);
  				return chrome.downloads.download({ url: url, filename: fname, saveAs: true});
  			}
  			var a = document.createElement("a");
  			if(a.download != null) {
  				/*:: if(document.body == null) throw new Error("unreachable"); */
  				a.download = fname; a.href = url; document.body.appendChild(a); a.click();
  				/*:: if(document.body == null) throw new Error("unreachable"); */ document.body.removeChild(a);
  				if(URL.revokeObjectURL && typeof setTimeout !== 'undefined') setTimeout(function() { URL.revokeObjectURL(url); }, 60000);
  				return url;
  			}
  		}
  	}
  	// $FlowIgnore
  	if(typeof $ !== 'undefined' && typeof File !== 'undefined' && typeof Folder !== 'undefined') try { // extendscript
  		// $FlowIgnore
  		var out = File(fname); out.open("w"); out.encoding = "binary";
  		if(Array.isArray(payload)) payload = a2s(payload);
  		out.write(payload); out.close(); return payload;
  	} catch(e) { if(!e.message || !e.message.match(/onstruct/)) throw e; }
  	throw new Error("cannot save file " + fname);
  }
  function keys(o/*:any*/)/*:Array<any>*/ {
  	var ks = Object.keys(o), o2 = [];
  	for(var i = 0; i < ks.length; ++i) if(Object.prototype.hasOwnProperty.call(o, ks[i])) o2.push(ks[i]);
  	return o2;
  }

  function evert_key(obj/*:any*/, key/*:string*/)/*:EvertType*/ {
  	var o = ([]/*:any*/), K = keys(obj);
  	for(var i = 0; i !== K.length; ++i) if(o[obj[K[i]][key]] == null) o[obj[K[i]][key]] = K[i];
  	return o;
  }

  function evert(obj/*:any*/)/*:EvertType*/ {
  	var o = ([]/*:any*/), K = keys(obj);
  	for(var i = 0; i !== K.length; ++i) o[obj[K[i]]] = K[i];
  	return o;
  }

  function evert_num(obj/*:any*/)/*:EvertNumType*/ {
  	var o = ([]/*:any*/), K = keys(obj);
  	for(var i = 0; i !== K.length; ++i) o[obj[K[i]]] = parseInt(K[i],10);
  	return o;
  }

  function evert_arr(obj/*:any*/)/*:EvertArrType*/ {
  	var o/*:EvertArrType*/ = ([]/*:any*/), K = keys(obj);
  	for(var i = 0; i !== K.length; ++i) {
  		if(o[obj[K[i]]] == null) o[obj[K[i]]] = [];
  		o[obj[K[i]]].push(K[i]);
  	}
  	return o;
  }

  var basedate = /*#__PURE__*/new Date(1899, 11, 30, 0, 0, 0); // 2209161600000
  function datenum(v/*:Date*/, date1904/*:?boolean*/)/*:number*/ {
  	var epoch = /*#__PURE__*/v.getTime();
  	if(date1904) epoch -= 1462*24*60*60*1000;
  	var dnthresh = /*#__PURE__*/basedate.getTime() + (/*#__PURE__*/v.getTimezoneOffset() - /*#__PURE__*/basedate.getTimezoneOffset()) * 60000;
  	return (epoch - dnthresh) / (24 * 60 * 60 * 1000);
  }
  var refdate = /*#__PURE__*/new Date();
  var dnthresh = /*#__PURE__*/basedate.getTime() + (/*#__PURE__*/refdate.getTimezoneOffset() - /*#__PURE__*/basedate.getTimezoneOffset()) * 60000;
  var refoffset = /*#__PURE__*/refdate.getTimezoneOffset();
  function numdate(v/*:number*/)/*:Date*/ {
  	var out = new Date();
  	out.setTime(v * 24 * 60 * 60 * 1000 + dnthresh);
  	if (out.getTimezoneOffset() !== refoffset) {
  		out.setTime(out.getTime() + (out.getTimezoneOffset() - refoffset) * 60000);
  	}
  	return out;
  }

  var good_pd_date_1 = /*#__PURE__*/new Date('2017-02-19T19:06:09.000Z');
  var good_pd_date = /*#__PURE__*/isNaN(/*#__PURE__*/good_pd_date_1.getFullYear()) ? /*#__PURE__*/new Date('2/19/17') : good_pd_date_1;
  var good_pd = /*#__PURE__*/good_pd_date.getFullYear() == 2017;
  /* parses a date as a local date */
  function parseDate(str/*:string|Date*/, fixdate/*:?number*/)/*:Date*/ {
  	var d = new Date(str);
  	if(good_pd) {
  		/*:: if(fixdate == null) fixdate = 0; */
  		if(fixdate > 0) d.setTime(d.getTime() + d.getTimezoneOffset() * 60 * 1000);
  		else if(fixdate < 0) d.setTime(d.getTime() - d.getTimezoneOffset() * 60 * 1000);
  		return d;
  	}
  	if(str instanceof Date) return str;
  	if(good_pd_date.getFullYear() == 1917 && !isNaN(d.getFullYear())) {
  		var s = d.getFullYear();
  		if(str.indexOf("" + s) > -1) return d;
  		d.setFullYear(d.getFullYear() + 100); return d;
  	}
  	var n = str.match(/\d+/g)||["2017","2","19","0","0","0"];
  	var out = new Date(+n[0], +n[1] - 1, +n[2], (+n[3]||0), (+n[4]||0), (+n[5]||0));
  	if(str.indexOf("Z") > -1) out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1000);
  	return out;
  }

  function cc2str(arr/*:Array<number>*/, debomit)/*:string*/ {
  	if(has_buf && Buffer.isBuffer(arr)) {
  		if(debomit) {
  			if(arr[0] == 0xFF && arr[1] == 0xFE) return utf8write(arr.slice(2).toString("utf16le"));
  			if(arr[1] == 0xFE && arr[2] == 0xFF) return utf8write(utf16beread(arr.slice(2).toString("binary")));
  		}
  		return arr.toString("binary");
  	}

  	if(typeof TextDecoder !== "undefined") try {
  		if(debomit) {
  			if(arr[0] == 0xFF && arr[1] == 0xFE) return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));
  			if(arr[0] == 0xFE && arr[1] == 0xFF) return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));
  		}
  		var rev = {
  			"\u20ac": "\x80", "\u201a": "\x82", "\u0192": "\x83", "\u201e": "\x84",
  			"\u2026": "\x85", "\u2020": "\x86", "\u2021": "\x87", "\u02c6": "\x88",
  			"\u2030": "\x89", "\u0160": "\x8a", "\u2039": "\x8b", "\u0152": "\x8c",
  			"\u017d": "\x8e", "\u2018": "\x91", "\u2019": "\x92", "\u201c": "\x93",
  			"\u201d": "\x94", "\u2022": "\x95", "\u2013": "\x96", "\u2014": "\x97",
  			"\u02dc": "\x98", "\u2122": "\x99", "\u0161": "\x9a", "\u203a": "\x9b",
  			"\u0153": "\x9c", "\u017e": "\x9e", "\u0178": "\x9f"
  		};
  		if(Array.isArray(arr)) arr = new Uint8Array(arr);
  		return new TextDecoder("latin1").decode(arr).replace(/[]/g, function(c) { return rev[c] || c; });
  	} catch(e) {}

  	var o = [];
  	for(var i = 0; i != arr.length; ++i) o.push(String.fromCharCode(arr[i]));
  	return o.join("");
  }

  function dup(o/*:any*/)/*:any*/ {
  	if(typeof JSON != 'undefined' && !Array.isArray(o)) return JSON.parse(JSON.stringify(o));
  	if(typeof o != 'object' || o == null) return o;
  	if(o instanceof Date) return new Date(o.getTime());
  	var out = {};
  	for(var k in o) if(Object.prototype.hasOwnProperty.call(o, k)) out[k] = dup(o[k]);
  	return out;
  }

  function fill(c/*:string*/,l/*:number*/)/*:string*/ { var o = ""; while(o.length < l) o+=c; return o; }

  /* TODO: stress test */
  function fuzzynum(s/*:string*/)/*:number*/ {
  	var v/*:number*/ = Number(s);
  	if(!isNaN(v)) return isFinite(v) ? v : NaN;
  	if(!/\d/.test(s)) return v;
  	var wt = 1;
  	var ss = s.replace(/([\d]),([\d])/g,"$1$2").replace(/[$]/g,"").replace(/[%]/g, function() { wt *= 100; return "";});
  	if(!isNaN(v = Number(ss))) return v / wt;
  	ss = ss.replace(/[(](.*)[)]/,function($$, $1) { wt = -wt; return $1;});
  	if(!isNaN(v = Number(ss))) return v / wt;
  	return v;
  }
  var lower_months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
  function fuzzydate(s/*:string*/)/*:Date*/ {
  	var o = new Date(s), n = new Date(NaN);
  	var y = o.getYear(), m = o.getMonth(), d = o.getDate();
  	if(isNaN(d)) return n;
  	var lower = s.toLowerCase();
  	if(lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
  		lower = lower.replace(/[^a-z]/g,"").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/,"");
  		if(lower.length > 3 && lower_months.indexOf(lower) == -1) return n;
  	} else if(lower.match(/[a-z]/)) return n;
  	if(y < 0 || y > 8099) return n;
  	if((m > 0 || d > 1) && y != 101) return o;
  	if(s.match(/[^-0-9:,\/\\]/)) return n;
  	return o;
  }

  function zip_add_file(zip, path, content) {
  	if(zip.FullPaths) {
  		if(typeof content == "string") {
  			var res;
  			if(has_buf) res = Buffer_from(content);
  			/* TODO: investigate performance in Edge 13 */
  			//else if(typeof TextEncoder !== "undefined") res = new TextEncoder().encode(content);
  			else res = utf8decode(content);
  			return CFB.utils.cfb_add(zip, path, res);
  		}
  		CFB.utils.cfb_add(zip, path, content);
  	}
  	else zip.file(path, content);
  }

  function zip_new() { return CFB.utils.cfb_new(); }
  var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';

  var encodings = {
  	'&quot;': '"',
  	'&apos;': "'",
  	'&gt;': '>',
  	'&lt;': '<',
  	'&amp;': '&'
  };
  var rencoding = /*#__PURE__*/evert(encodings);

  var decregex=/[&<>'"]/g, charegex = /[\u0000-\u0008\u000b-\u001f]/g;
  function escapexml(text/*:string*/)/*:string*/{
  	var s = text + '';
  	return s.replace(decregex, function(y) { return rencoding[y]; }).replace(charegex,function(s) { return "_x" + ("000"+s.charCodeAt(0).toString(16)).slice(-4) + "_";});
  }
  function escapexmltag(text/*:string*/)/*:string*/{ return escapexml(text).replace(/ /g,"_x0020_"); }

  var htmlcharegex = /[\u0000-\u001f]/g;
  function escapehtml(text/*:string*/)/*:string*/{
  	var s = text + '';
  	return s.replace(decregex, function(y) { return rencoding[y]; }).replace(/\n/g, "<br/>").replace(htmlcharegex,function(s) { return "&#x" + ("000"+s.charCodeAt(0).toString(16)).slice(-4) + ";"; });
  }

  function escapexlml(text/*:string*/)/*:string*/{
  	var s = text + '';
  	return s.replace(decregex, function(y) { return rencoding[y]; }).replace(htmlcharegex,function(s) { return "&#x" + (s.charCodeAt(0).toString(16)).toUpperCase() + ";"; });
  }
  function xlml_unfixstr(str/*:string*/)/*:string*/ { return str.replace(/(\r\n|[\r\n])/g,"\&#10;"); }

  function parsexmlbool(value/*:any*/)/*:boolean*/ {
  	switch(value) {
  		case 1: case true: case '1': case 'true': case 'TRUE': return true;
  		/* case '0': case 'false': case 'FALSE':*/
  		default: return false;
  	}
  }

  function utf8reada(orig/*:string*/)/*:string*/ {
  	var out = "", i = 0, c = 0, d = 0, e = 0, f = 0, w = 0;
  	while (i < orig.length) {
  		c = orig.charCodeAt(i++);
  		if (c < 128) { out += String.fromCharCode(c); continue; }
  		d = orig.charCodeAt(i++);
  		if (c>191 && c<224) { f = ((c & 31) << 6); f |= (d & 63); out += String.fromCharCode(f); continue; }
  		e = orig.charCodeAt(i++);
  		if (c < 240) { out += String.fromCharCode(((c & 15) << 12) | ((d & 63) << 6) | (e & 63)); continue; }
  		f = orig.charCodeAt(i++);
  		w = (((c & 7) << 18) | ((d & 63) << 12) | ((e & 63) << 6) | (f & 63))-65536;
  		out += String.fromCharCode(0xD800 + ((w>>>10)&1023));
  		out += String.fromCharCode(0xDC00 + (w&1023));
  	}
  	return out;
  }

  function utf8readb(data) {
  	var out = new_raw_buf(2*data.length), w, i, j = 1, k = 0, ww=0, c;
  	for(i = 0; i < data.length; i+=j) {
  		j = 1;
  		if((c=data.charCodeAt(i)) < 128) w = c;
  		else if(c < 224) { w = (c&31)*64+(data.charCodeAt(i+1)&63); j=2; }
  		else if(c < 240) { w=(c&15)*4096+(data.charCodeAt(i+1)&63)*64+(data.charCodeAt(i+2)&63); j=3; }
  		else { j = 4;
  			w = (c & 7)*262144+(data.charCodeAt(i+1)&63)*4096+(data.charCodeAt(i+2)&63)*64+(data.charCodeAt(i+3)&63);
  			w -= 65536; ww = 0xD800 + ((w>>>10)&1023); w = 0xDC00 + (w&1023);
  		}
  		if(ww !== 0) { out[k++] = ww&255; out[k++] = ww>>>8; ww = 0; }
  		out[k++] = w%256; out[k++] = w>>>8;
  	}
  	return out.slice(0,k).toString('ucs2');
  }

  function utf8readc(data) { return Buffer_from(data, 'binary').toString('utf8'); }

  var utf8corpus = "foo bar baz\u00e2\u0098\u0083\u00f0\u009f\u008d\u00a3";
  var utf8read = has_buf && (/*#__PURE__*/utf8readc(utf8corpus) == /*#__PURE__*/utf8reada(utf8corpus) && utf8readc || /*#__PURE__*/utf8readb(utf8corpus) == /*#__PURE__*/utf8reada(utf8corpus) && utf8readb) || utf8reada;

  var utf8write/*:StringConv*/ = has_buf ? function(data) { return Buffer_from(data, 'utf8').toString("binary"); } : function(orig/*:string*/)/*:string*/ {
  	var out/*:Array<string>*/ = [], i = 0, c = 0, d = 0;
  	while(i < orig.length) {
  		c = orig.charCodeAt(i++);
  		switch(true) {
  			case c < 128: out.push(String.fromCharCode(c)); break;
  			case c < 2048:
  				out.push(String.fromCharCode(192 + (c >> 6)));
  				out.push(String.fromCharCode(128 + (c & 63)));
  				break;
  			case c >= 55296 && c < 57344:
  				c -= 55296; d = orig.charCodeAt(i++) - 56320 + (c<<10);
  				out.push(String.fromCharCode(240 + ((d >>18) & 7)));
  				out.push(String.fromCharCode(144 + ((d >>12) & 63)));
  				out.push(String.fromCharCode(128 + ((d >> 6) & 63)));
  				out.push(String.fromCharCode(128 + (d & 63)));
  				break;
  			default:
  				out.push(String.fromCharCode(224 + (c >> 12)));
  				out.push(String.fromCharCode(128 + ((c >> 6) & 63)));
  				out.push(String.fromCharCode(128 + (c & 63)));
  		}
  	}
  	return out.join("");
  };

  var htmldecode/*:{(s:string):string}*/ = /*#__PURE__*/(function() {
  	var entities/*:Array<[RegExp, string]>*/ = [
  		['nbsp', ' '], ['middot', ''],
  		['quot', '"'], ['apos', "'"], ['gt',   '>'], ['lt',   '<'], ['amp',  '&']
  	].map(function(x/*:[string, string]*/) { return [new RegExp('&' + x[0] + ';', "ig"), x[1]]; });
  	return function htmldecode(str/*:string*/)/*:string*/ {
  		var o = str
  				// Remove new lines and spaces from start of content
  				.replace(/^[\t\n\r ]+/, "")
  				// Remove new lines and spaces from end of content
  				.replace(/[\t\n\r ]+$/,"")
  				// Added line which removes any white space characters after and before html tags
  				.replace(/>\s+/g,">").replace(/\s+</g,"<")
  				// Replace remaining new lines and spaces with space
  				.replace(/[\t\n\r ]+/g, " ")
  				// Replace <br> tags with new lines
  				.replace(/<\s*[bB][rR]\s*\/?>/g,"\n")
  				// Strip HTML elements
  				.replace(/<[^>]*>/g,"");
  		for(var i = 0; i < entities.length; ++i) o = o.replace(entities[i][0], entities[i][1]);
  		return o;
  	};
  })();

  var wtregex = /(^\s|\s$|\n)/;
  function writetag(f/*:string*/,g/*:string*/)/*:string*/ { return '<' + f + (g.match(wtregex)?' xml:space="preserve"' : "") + '>' + g + '</' + f + '>'; }

  function wxt_helper(h)/*:string*/ { return keys(h).map(function(k) { return " " + k + '="' + h[k] + '"';}).join(""); }
  function writextag(f/*:string*/,g/*:?string*/,h) { return '<' + f + ((h != null) ? wxt_helper(h) : "") + ((g != null) ? (g.match(wtregex)?' xml:space="preserve"' : "") + '>' + g + '</' + f : "/") + '>';}

  function write_w3cdtf(d/*:Date*/, t/*:?boolean*/)/*:string*/ { try { return d.toISOString().replace(/\.\d*/,""); } catch(e) { if(t) throw e; } return ""; }

  function write_vt(s, xlsx/*:?boolean*/)/*:string*/ {
  	switch(typeof s) {
  		case 'string':
  			var o = writextag('vt:lpwstr', escapexml(s));
  			if(xlsx) o = o.replace(/&quot;/g, "_x0022_");
  			return o;
  		case 'number': return writextag((s|0)==s?'vt:i4':'vt:r8', escapexml(String(s)));
  		case 'boolean': return writextag('vt:bool',s?'true':'false');
  	}
  	if(s instanceof Date) return writextag('vt:filetime', write_w3cdtf(s));
  	throw new Error("Unable to serialize " + s);
  }
  //var xlmlregex = /<(\/?)([a-z0-9]*:|)(\w+)[^>]*>/mg;

  var XMLNS = ({
  	CORE_PROPS: 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',
  	CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
  	EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  	CT: 'http://schemas.openxmlformats.org/package/2006/content-types',
  	RELS: 'http://schemas.openxmlformats.org/package/2006/relationships',
  	TCMNT: 'http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments',
  	'dc': 'http://purl.org/dc/elements/1.1/',
  	'dcterms': 'http://purl.org/dc/terms/',
  	'dcmitype': 'http://purl.org/dc/dcmitype/',
  	'mx': 'http://schemas.microsoft.com/office/mac/excel/2008/main',
  	'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
  	'sjs': 'http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties',
  	'vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
  	'xsi': 'http://www.w3.org/2001/XMLSchema-instance',
  	'xsd': 'http://www.w3.org/2001/XMLSchema'
  }/*:any*/);

  var XMLNS_main = [
  	'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
  	'http://purl.oclc.org/ooxml/spreadsheetml/main',
  	'http://schemas.microsoft.com/office/excel/2006/main',
  	'http://schemas.microsoft.com/office/excel/2006/2'
  ];

  var XLMLNS = ({
  	'o':    'urn:schemas-microsoft-com:office:office',
  	'x':    'urn:schemas-microsoft-com:office:excel',
  	'ss':   'urn:schemas-microsoft-com:office:spreadsheet',
  	'dt':   'uuid:C2F41010-65B3-11d1-A29F-00AA00C14882',
  	'mv':   'http://macVmlSchemaUri',
  	'v':    'urn:schemas-microsoft-com:vml',
  	'html': 'http://www.w3.org/TR/REC-html40'
  }/*:any*/);
  function read_double_le(b/*:RawBytes|CFBlob*/, idx/*:number*/)/*:number*/ {
  	var s = 1 - 2 * (b[idx + 7] >>> 7);
  	var e = ((b[idx + 7] & 0x7f) << 4) + ((b[idx + 6] >>> 4) & 0x0f);
  	var m = (b[idx+6]&0x0f);
  	for(var i = 5; i >= 0; --i) m = m * 256 + b[idx + i];
  	if(e == 0x7ff) return m == 0 ? (s * Infinity) : NaN;
  	if(e == 0) e = -1022;
  	else { e -= 1023; m += Math.pow(2,52); }
  	return s * Math.pow(2, e - 52) * m;
  }

  function write_double_le(b/*:RawBytes|CFBlob*/, v/*:number*/, idx/*:number*/) {
  	var bs = ((((v < 0) || (1/v == -Infinity)) ? 1 : 0) << 7), e = 0, m = 0;
  	var av = bs ? (-v) : v;
  	if(!isFinite(av)) { e = 0x7ff; m = isNaN(v) ? 0x6969 : 0; }
  	else if(av == 0) e = m = 0;
  	else {
  		e = Math.floor(Math.log(av) / Math.LN2);
  		m = av * Math.pow(2, 52 - e);
  		if((e <= -1023) && (!isFinite(m) || (m < Math.pow(2,52)))) { e = -1022; }
  		else { m -= Math.pow(2,52); e+=1023; }
  	}
  	for(var i = 0; i <= 5; ++i, m/=256) b[idx + i] = m & 0xff;
  	b[idx + 6] = ((e & 0x0f) << 4) | (m & 0xf);
  	b[idx + 7] = (e >> 4) | bs;
  }

  var ___toBuffer = function(bufs/*:Array<Array<RawBytes> >*/)/*:RawBytes*/ { var x=[],w=10240; for(var i=0;i<bufs[0].length;++i) if(bufs[0][i]) for(var j=0,L=bufs[0][i].length;j<L;j+=w) x.push.apply(x, bufs[0][i].slice(j,j+w)); return x; };
  var __toBuffer = has_buf ? function(bufs) { return (bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0])) ? Buffer.concat(bufs[0].map(function(x) { return Buffer.isBuffer(x) ? x : Buffer_from(x); })) : ___toBuffer(bufs);} : ___toBuffer;

  var ___utf16le = function(b/*:RawBytes|CFBlob*/,s/*:number*/,e/*:number*/)/*:string*/ { var ss/*:Array<string>*/=[]; for(var i=s; i<e; i+=2) ss.push(String.fromCharCode(__readUInt16LE(b,i))); return ss.join("").replace(chr0,''); };
  var __utf16le = has_buf ? function(b/*:RawBytes|CFBlob*/,s/*:number*/,e/*:number*/)/*:string*/ { if(!Buffer.isBuffer(b)/*:: || !(b instanceof Buffer)*/) return ___utf16le(b,s,e); return b.toString('utf16le',s,e).replace(chr0,'')/*.replace(chr1,'!')*/; } : ___utf16le;

  var ___hexlify = function(b/*:RawBytes|CFBlob*/,s/*:number*/,l/*:number*/)/*:string*/ { var ss/*:Array<string>*/=[]; for(var i=s; i<s+l; ++i) ss.push(("0" + b[i].toString(16)).slice(-2)); return ss.join(""); };
  var __hexlify = has_buf ? function(b/*:RawBytes|CFBlob*/,s/*:number*/,l/*:number*/)/*:string*/ { return Buffer.isBuffer(b)/*:: && b instanceof Buffer*/ ? b.toString('hex',s,s+l) : ___hexlify(b,s,l); } : ___hexlify;

  var ___utf8 = function(b/*:RawBytes|CFBlob*/,s/*:number*/,e/*:number*/) { var ss=[]; for(var i=s; i<e; i++) ss.push(String.fromCharCode(__readUInt8(b,i))); return ss.join(""); };
  var __utf8 = has_buf ? function utf8_b(b/*:RawBytes|CFBlob*/, s/*:number*/, e/*:number*/) { return (Buffer.isBuffer(b)/*:: && (b instanceof Buffer)*/) ? b.toString('utf8',s,e) : ___utf8(b,s,e); } : ___utf8;

  var ___lpstr = function(b/*:RawBytes|CFBlob*/,i/*:number*/) { var len = __readUInt32LE(b,i); return len > 0 ? __utf8(b, i+4,i+4+len-1) : "";};
  var __lpstr = ___lpstr;

  var ___cpstr = function(b/*:RawBytes|CFBlob*/,i/*:number*/) { var len = __readUInt32LE(b,i); return len > 0 ? __utf8(b, i+4,i+4+len-1) : "";};
  var __cpstr = ___cpstr;

  var ___lpwstr = function(b/*:RawBytes|CFBlob*/,i/*:number*/) { var len = 2*__readUInt32LE(b,i); return len > 0 ? __utf8(b, i+4,i+4+len-1) : "";};
  var __lpwstr = ___lpwstr;

  var ___lpp4 = function lpp4_(b/*:RawBytes|CFBlob*/,i/*:number*/) { var len = __readUInt32LE(b,i); return len > 0 ? __utf16le(b, i+4,i+4+len) : "";};
  var __lpp4 = ___lpp4;

  var ___8lpp4 = function(b/*:RawBytes|CFBlob*/,i/*:number*/) { var len = __readUInt32LE(b,i); return len > 0 ? __utf8(b, i+4,i+4+len) : "";};
  var __8lpp4 = ___8lpp4;

  var ___double = function(b/*:RawBytes|CFBlob*/, idx/*:number*/) { return read_double_le(b, idx);};
  var __double = ___double;

  var is_buf = function is_buf_a(a) { return Array.isArray(a) || (typeof Uint8Array !== "undefined" && a instanceof Uint8Array); };

  if(has_buf/*:: && typeof Buffer !== 'undefined'*/) {
  	__lpstr = function lpstr_b(b/*:RawBytes|CFBlob*/, i/*:number*/) { if(!Buffer.isBuffer(b)/*:: || !(b instanceof Buffer)*/) return ___lpstr(b, i); var len = b.readUInt32LE(i); return len > 0 ? b.toString('utf8',i+4,i+4+len-1) : "";};
  	__cpstr = function cpstr_b(b/*:RawBytes|CFBlob*/, i/*:number*/) { if(!Buffer.isBuffer(b)/*:: || !(b instanceof Buffer)*/) return ___cpstr(b, i); var len = b.readUInt32LE(i); return len > 0 ? b.toString('utf8',i+4,i+4+len-1) : "";};
  	__lpwstr = function lpwstr_b(b/*:RawBytes|CFBlob*/, i/*:number*/) { if(!Buffer.isBuffer(b)/*:: || !(b instanceof Buffer)*/) return ___lpwstr(b, i); var len = 2*b.readUInt32LE(i); return b.toString('utf16le',i+4,i+4+len-1);};
  	__lpp4 = function lpp4_b(b/*:RawBytes|CFBlob*/, i/*:number*/) { if(!Buffer.isBuffer(b)/*:: || !(b instanceof Buffer)*/) return ___lpp4(b, i); var len = b.readUInt32LE(i); return b.toString('utf16le',i+4,i+4+len);};
  	__8lpp4 = function lpp4_8b(b/*:RawBytes|CFBlob*/, i/*:number*/) { if(!Buffer.isBuffer(b)/*:: || !(b instanceof Buffer)*/) return ___8lpp4(b, i); var len = b.readUInt32LE(i); return b.toString('utf8',i+4,i+4+len);};
  	__double = function double_(b/*:RawBytes|CFBlob*/, i/*:number*/) { if(Buffer.isBuffer(b)/*::&& b instanceof Buffer*/) return b.readDoubleLE(i); return ___double(b,i); };
  	is_buf = function is_buf_b(a) { return Buffer.isBuffer(a) || Array.isArray(a) || (typeof Uint8Array !== "undefined" && a instanceof Uint8Array); };
  }

  var __readUInt8 = function(b/*:RawBytes|CFBlob*/, idx/*:number*/)/*:number*/ { return b[idx]; };
  var __readUInt16LE = function(b/*:RawBytes|CFBlob*/, idx/*:number*/)/*:number*/ { return (b[idx+1]*(1<<8))+b[idx]; };
  var __readInt16LE = function(b/*:RawBytes|CFBlob*/, idx/*:number*/)/*:number*/ { var u = (b[idx+1]*(1<<8))+b[idx]; return (u < 0x8000) ? u : ((0xffff - u + 1) * -1); };
  var __readUInt32LE = function(b/*:RawBytes|CFBlob*/, idx/*:number*/)/*:number*/ { return b[idx+3]*(1<<24)+(b[idx+2]<<16)+(b[idx+1]<<8)+b[idx]; };
  var __readInt32LE = function(b/*:RawBytes|CFBlob*/, idx/*:number*/)/*:number*/ { return (b[idx+3]<<24)|(b[idx+2]<<16)|(b[idx+1]<<8)|b[idx]; };
  var __readInt32BE = function(b/*:RawBytes|CFBlob*/, idx/*:number*/)/*:number*/ { return (b[idx]<<24)|(b[idx+1]<<16)|(b[idx+2]<<8)|b[idx+3]; };

  function ReadShift(size/*:number*/, t/*:?string*/)/*:number|string*/ {
  	var o="", oI/*:: :number = 0*/, oR, oo=[], w, vv, i, loc;
  	switch(t) {
  		case 'dbcs':
  			loc = this.l;
  			if(has_buf && Buffer.isBuffer(this)) o = this.slice(this.l, this.l+2*size).toString("utf16le");
  			else for(i = 0; i < size; ++i) { o+=String.fromCharCode(__readUInt16LE(this, loc)); loc+=2; }
  			size *= 2;
  			break;

  		case 'utf8': o = __utf8(this, this.l, this.l + size); break;
  		case 'utf16le': size *= 2; o = __utf16le(this, this.l, this.l + size); break;

  		case 'wstr':
  			return ReadShift.call(this, size, 'dbcs');

  		/* [MS-OLEDS] 2.1.4 LengthPrefixedAnsiString */
  		case 'lpstr-ansi': o = __lpstr(this, this.l); size = 4 + __readUInt32LE(this, this.l); break;
  		case 'lpstr-cp': o = __cpstr(this, this.l); size = 4 + __readUInt32LE(this, this.l); break;
  		/* [MS-OLEDS] 2.1.5 LengthPrefixedUnicodeString */
  		case 'lpwstr': o = __lpwstr(this, this.l); size = 4 + 2 * __readUInt32LE(this, this.l); break;
  		/* [MS-OFFCRYPTO] 2.1.2 Length-Prefixed Padded Unicode String (UNICODE-LP-P4) */
  		case 'lpp4': size = 4 +  __readUInt32LE(this, this.l); o = __lpp4(this, this.l); if(size & 0x02) size += 2; break;
  		/* [MS-OFFCRYPTO] 2.1.3 Length-Prefixed UTF-8 String (UTF-8-LP-P4) */
  		case '8lpp4': size = 4 +  __readUInt32LE(this, this.l); o = __8lpp4(this, this.l); if(size & 0x03) size += 4 - (size & 0x03); break;

  		case 'cstr': size = 0; o = "";
  			while((w=__readUInt8(this, this.l + size++))!==0) oo.push(_getchar(w));
  			o = oo.join(""); break;
  		case '_wstr': size = 0; o = "";
  			while((w=__readUInt16LE(this,this.l +size))!==0){oo.push(_getchar(w));size+=2;}
  			size+=2; o = oo.join(""); break;

  		/* sbcs and dbcs support continue records in the SST way TODO codepages */
  		case 'dbcs-cont': o = ""; loc = this.l;
  			for(i = 0; i < size; ++i) {
  				if(this.lens && this.lens.indexOf(loc) !== -1) {
  					w = __readUInt8(this, loc);
  					this.l = loc + 1;
  					vv = ReadShift.call(this, size-i, w ? 'dbcs-cont' : 'sbcs-cont');
  					return oo.join("") + vv;
  				}
  				oo.push(_getchar(__readUInt16LE(this, loc)));
  				loc+=2;
  			} o = oo.join(""); size *= 2; break;

  		case 'cpstr':
  		/* falls through */
  		case 'sbcs-cont': o = ""; loc = this.l;
  			for(i = 0; i != size; ++i) {
  				if(this.lens && this.lens.indexOf(loc) !== -1) {
  					w = __readUInt8(this, loc);
  					this.l = loc + 1;
  					vv = ReadShift.call(this, size-i, w ? 'dbcs-cont' : 'sbcs-cont');
  					return oo.join("") + vv;
  				}
  				oo.push(_getchar(__readUInt8(this, loc)));
  				loc+=1;
  			} o = oo.join(""); break;

  		default:
  	switch(size) {
  		case 1: oI = __readUInt8(this, this.l); this.l++; return oI;
  		case 2: oI = (t === 'i' ? __readInt16LE : __readUInt16LE)(this, this.l); this.l += 2; return oI;
  		case 4: case -4:
  			if(t === 'i' || ((this[this.l+3] & 0x80)===0)) { oI = ((size > 0) ? __readInt32LE : __readInt32BE)(this, this.l); this.l += 4; return oI; }
  			else { oR = __readUInt32LE(this, this.l); this.l += 4; } return oR;
  		case 8: case -8:
  			if(t === 'f') {
  				if(size == 8) oR = __double(this, this.l);
  				else oR = __double([this[this.l+7],this[this.l+6],this[this.l+5],this[this.l+4],this[this.l+3],this[this.l+2],this[this.l+1],this[this.l+0]], 0);
  				this.l += 8; return oR;
  			} else size = 8;
  		/* falls through */
  		case 16: o = __hexlify(this, this.l, size); break;
  	}}
  	this.l+=size; return o;
  }

  var __writeUInt32LE = function(b/*:RawBytes|CFBlob*/, val/*:number*/, idx/*:number*/)/*:void*/ { b[idx] = (val & 0xFF); b[idx+1] = ((val >>> 8) & 0xFF); b[idx+2] = ((val >>> 16) & 0xFF); b[idx+3] = ((val >>> 24) & 0xFF); };
  var __writeInt32LE  = function(b/*:RawBytes|CFBlob*/, val/*:number*/, idx/*:number*/)/*:void*/ { b[idx] = (val & 0xFF); b[idx+1] = ((val >> 8) & 0xFF); b[idx+2] = ((val >> 16) & 0xFF); b[idx+3] = ((val >> 24) & 0xFF); };
  var __writeUInt16LE = function(b/*:RawBytes|CFBlob*/, val/*:number*/, idx/*:number*/)/*:void*/ { b[idx] = (val & 0xFF); b[idx+1] = ((val >>> 8) & 0xFF); };

  function WriteShift(t/*:number*/, val/*:string|number*/, f/*:?string*/)/*:any*/ {
  	var size = 0, i = 0;
  	if(f === 'dbcs') {
  		/*:: if(typeof val !== 'string') throw new Error("unreachable"); */
  		for(i = 0; i != val.length; ++i) __writeUInt16LE(this, val.charCodeAt(i), this.l + 2 * i);
  		size = 2 * val.length;
  	} else if(f === 'sbcs') {
  		{
  			/*:: if(typeof val !== 'string') throw new Error("unreachable"); */
  			val = val.replace(/[^\x00-\x7F]/g, "_");
  			/*:: if(typeof val !== 'string') throw new Error("unreachable"); */
  			for(i = 0; i != val.length; ++i) this[this.l + i] = (val.charCodeAt(i) & 0xFF);
  		}
  		size = val.length;
  	} else if(f === 'hex') {
  		for(; i < t; ++i) {
  			/*:: if(typeof val !== "string") throw new Error("unreachable"); */
  			this[this.l++] = (parseInt(val.slice(2*i, 2*i+2), 16)||0);
  		} return this;
  	} else if(f === 'utf16le') {
  			/*:: if(typeof val !== "string") throw new Error("unreachable"); */
  			var end/*:number*/ = Math.min(this.l + t, this.length);
  			for(i = 0; i < Math.min(val.length, t); ++i) {
  				var cc = val.charCodeAt(i);
  				this[this.l++] = (cc & 0xff);
  				this[this.l++] = (cc >> 8);
  			}
  			while(this.l < end) this[this.l++] = 0;
  			return this;
  	} else /*:: if(typeof val === 'number') */ switch(t) {
  		case  1: size = 1; this[this.l] = val&0xFF; break;
  		case  2: size = 2; this[this.l] = val&0xFF; val >>>= 8; this[this.l+1] = val&0xFF; break;
  		case  3: size = 3; this[this.l] = val&0xFF; val >>>= 8; this[this.l+1] = val&0xFF; val >>>= 8; this[this.l+2] = val&0xFF; break;
  		case  4: size = 4; __writeUInt32LE(this, val, this.l); break;
  		case  8: size = 8; if(f === 'f') { write_double_le(this, val, this.l); break; }
  		/* falls through */
  		case 16: break;
  		case -4: size = 4; __writeInt32LE(this, val, this.l); break;
  	}
  	this.l += size; return this;
  }

  function CheckField(hexstr/*:string*/, fld/*:string*/)/*:void*/ {
  	var m = __hexlify(this,this.l,hexstr.length>>1);
  	if(m !== hexstr) throw new Error(fld + 'Expected ' + hexstr + ' saw ' + m);
  	this.l += hexstr.length>>1;
  }

  function prep_blob(blob, pos/*:number*/)/*:void*/ {
  	blob.l = pos;
  	blob.read_shift = /*::(*/ReadShift/*:: :any)*/;
  	blob.chk = CheckField;
  	blob.write_shift = WriteShift;
  }

  function parsenoop(blob, length/*:: :number, opts?:any */) { blob.l += length; }

  function new_buf(sz/*:number*/)/*:Block*/ {
  	var o = new_raw_buf(sz);
  	prep_blob(o, 0);
  	return o;
  }

  /* control buffer usage for fixed-length buffers */
  function buf_array()/*:BufArray*/ {
  	var bufs/*:Array<Block>*/ = [], blksz = has_buf ? 256 : 2048;
  	var newblk = function ba_newblk(sz/*:number*/)/*:Block*/ {
  		var o/*:Block*/ = (new_buf(sz)/*:any*/);
  		prep_blob(o, 0);
  		return o;
  	};

  	var curbuf/*:Block*/ = newblk(blksz);

  	var endbuf = function ba_endbuf() {
  		if(!curbuf) return;
  		if(curbuf.length > curbuf.l) { curbuf = curbuf.slice(0, curbuf.l); curbuf.l = curbuf.length; }
  		if(curbuf.length > 0) bufs.push(curbuf);
  		curbuf = null;
  	};

  	var next = function ba_next(sz/*:number*/)/*:Block*/ {
  		if(curbuf && (sz < (curbuf.length - curbuf.l))) return curbuf;
  		endbuf();
  		return (curbuf = newblk(Math.max(sz+1, blksz)));
  	};

  	var end = function ba_end() {
  		endbuf();
  		return bconcat(bufs);
  	};

  	var push = function ba_push(buf) { endbuf(); curbuf = buf; if(curbuf.l == null) curbuf.l = curbuf.length; next(blksz); };

  	return ({ next:next, push:push, end:end, _bufs:bufs }/*:any*/);
  }

  function write_record(ba/*:BufArray*/, type/*:number*/, payload, length/*:?number*/) {
  	var t/*:number*/ = +type, l;
  	if(isNaN(t)) return; // TODO: throw something here?
  	if(!length) length = XLSBRecordEnum[t].p || (payload||[]).length || 0;
  	l = 1 + (t >= 0x80 ? 1 : 0) + 1/* + length*/;
  	if(length >= 0x80) ++l; if(length >= 0x4000) ++l; if(length >= 0x200000) ++l;
  	var o = ba.next(l);
  	if(t <= 0x7F) o.write_shift(1, t);
  	else {
  		o.write_shift(1, (t & 0x7F) + 0x80);
  		o.write_shift(1, (t >> 7));
  	}
  	for(var i = 0; i != 4; ++i) {
  		if(length >= 0x80) { o.write_shift(1, (length & 0x7F)+0x80); length >>= 7; }
  		else { o.write_shift(1, length); break; }
  	}
  	if(/*:: length != null &&*/length > 0 && is_buf(payload)) ba.push(payload);
  }
  /* XLS ranges enforced */
  function shift_cell_xls(cell/*:CellAddress*/, tgt/*:any*/, opts/*:?any*/)/*:CellAddress*/ {
  	var out = dup(cell);
  	if(tgt.s) {
  		if(out.cRel) out.c += tgt.s.c;
  		if(out.rRel) out.r += tgt.s.r;
  	} else {
  		if(out.cRel) out.c += tgt.c;
  		if(out.rRel) out.r += tgt.r;
  	}
  	if(!opts || opts.biff < 12) {
  		while(out.c >= 0x100) out.c -= 0x100;
  		while(out.r >= 0x10000) out.r -= 0x10000;
  	}
  	return out;
  }

  function shift_range_xls(cell, range, opts) {
  	var out = dup(cell);
  	out.s = shift_cell_xls(out.s, range.s, opts);
  	out.e = shift_cell_xls(out.e, range.s, opts);
  	return out;
  }

  function encode_cell_xls(c/*:CellAddress*/, biff/*:number*/)/*:string*/ {
  	if(c.cRel && c.c < 0) { c = dup(c); while(c.c < 0) c.c += (biff > 8) ? 0x4000 : 0x100; }
  	if(c.rRel && c.r < 0) { c = dup(c); while(c.r < 0) c.r += (biff > 8) ? 0x100000 : ((biff > 5) ? 0x10000 : 0x4000); }
  	var s = encode_cell(c);
  	if(!c.cRel && c.cRel != null) s = fix_col(s);
  	if(!c.rRel && c.rRel != null) s = fix_row(s);
  	return s;
  }

  function encode_range_xls(r, opts)/*:string*/ {
  	if(r.s.r == 0 && !r.s.rRel) {
  		if(r.e.r == (opts.biff >= 12 ? 0xFFFFF : (opts.biff >= 8 ? 0x10000 : 0x4000)) && !r.e.rRel) {
  			return (r.s.cRel ? "" : "$") + encode_col(r.s.c) + ":" + (r.e.cRel ? "" : "$") + encode_col(r.e.c);
  		}
  	}
  	if(r.s.c == 0 && !r.s.cRel) {
  		if(r.e.c == (opts.biff >= 12 ? 0x3FFF : 0xFF) && !r.e.cRel) {
  			return (r.s.rRel ? "" : "$") + encode_row(r.s.r) + ":" + (r.e.rRel ? "" : "$") + encode_row(r.e.r);
  		}
  	}
  	return encode_cell_xls(r.s, opts.biff) + ":" + encode_cell_xls(r.e, opts.biff);
  }
  function decode_row(rowstr/*:string*/)/*:number*/ { return parseInt(unfix_row(rowstr),10) - 1; }
  function encode_row(row/*:number*/)/*:string*/ { return "" + (row + 1); }
  function fix_row(cstr/*:string*/)/*:string*/ { return cstr.replace(/([A-Z]|^)(\d+)$/,"$1$$$2"); }
  function unfix_row(cstr/*:string*/)/*:string*/ { return cstr.replace(/\$(\d+)$/,"$1"); }

  function decode_col(colstr/*:string*/)/*:number*/ { var c = unfix_col(colstr), d = 0, i = 0; for(; i !== c.length; ++i) d = 26*d + c.charCodeAt(i) - 64; return d - 1; }
  function encode_col(col/*:number*/)/*:string*/ { if(col < 0) throw new Error("invalid column " + col); var s=""; for(++col; col; col=Math.floor((col-1)/26)) s = String.fromCharCode(((col-1)%26) + 65) + s; return s; }
  function fix_col(cstr/*:string*/)/*:string*/ { return cstr.replace(/^([A-Z])/,"$$$1"); }
  function unfix_col(cstr/*:string*/)/*:string*/ { return cstr.replace(/^\$([A-Z])/,"$1"); }

  function split_cell(cstr/*:string*/)/*:Array<string>*/ { return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/,"$1,$2").split(","); }
  //function decode_cell(cstr/*:string*/)/*:CellAddress*/ { var splt = split_cell(cstr); return { c:decode_col(splt[0]), r:decode_row(splt[1]) }; }
  function decode_cell(cstr/*:string*/)/*:CellAddress*/ {
  	var R = 0, C = 0;
  	for(var i = 0; i < cstr.length; ++i) {
  		var cc = cstr.charCodeAt(i);
  		if(cc >= 48 && cc <= 57) R = 10 * R + (cc - 48);
  		else if(cc >= 65 && cc <= 90) C = 26 * C + (cc - 64);
  	}
  	return { c: C - 1, r:R - 1 };
  }
  //function encode_cell(cell/*:CellAddress*/)/*:string*/ { return encode_col(cell.c) + encode_row(cell.r); }
  function encode_cell(cell/*:CellAddress*/)/*:string*/ {
  	var col = cell.c + 1;
  	var s="";
  	for(; col; col=((col-1)/26)|0) s = String.fromCharCode(((col-1)%26) + 65) + s;
  	return s + (cell.r + 1);
  }
  function decode_range(range/*:string*/)/*:Range*/ {
  	var idx = range.indexOf(":");
  	if(idx == -1) return { s: decode_cell(range), e: decode_cell(range) };
  	return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };
  }
  /*# if only one arg, it is assumed to be a Range.  If 2 args, both are cell addresses */
  function encode_range(cs/*:CellAddrSpec|Range*/,ce/*:?CellAddrSpec*/)/*:string*/ {
  	if(typeof ce === 'undefined' || typeof ce === 'number') {
  /*:: if(!(cs instanceof Range)) throw "unreachable"; */
  		return encode_range(cs.s, cs.e);
  	}
  /*:: if((cs instanceof Range)) throw "unreachable"; */
  	if(typeof cs !== 'string') cs = encode_cell((cs/*:any*/));
  	if(typeof ce !== 'string') ce = encode_cell((ce/*:any*/));
  /*:: if(typeof cs !== 'string') throw "unreachable"; */
  /*:: if(typeof ce !== 'string') throw "unreachable"; */
  	return cs == ce ? cs : cs + ":" + ce;
  }

  function safe_decode_range(range/*:string*/)/*:Range*/ {
  	var o = {s:{c:0,r:0},e:{c:0,r:0}};
  	var idx = 0, i = 0, cc = 0;
  	var len = range.length;
  	for(idx = 0; i < len; ++i) {
  		if((cc=range.charCodeAt(i)-64) < 1 || cc > 26) break;
  		idx = 26*idx + cc;
  	}
  	o.s.c = --idx;

  	for(idx = 0; i < len; ++i) {
  		if((cc=range.charCodeAt(i)-48) < 0 || cc > 9) break;
  		idx = 10*idx + cc;
  	}
  	o.s.r = --idx;

  	if(i === len || cc != 10) { o.e.c=o.s.c; o.e.r=o.s.r; return o; }
  	++i;

  	for(idx = 0; i != len; ++i) {
  		if((cc=range.charCodeAt(i)-64) < 1 || cc > 26) break;
  		idx = 26*idx + cc;
  	}
  	o.e.c = --idx;

  	for(idx = 0; i != len; ++i) {
  		if((cc=range.charCodeAt(i)-48) < 0 || cc > 9) break;
  		idx = 10*idx + cc;
  	}
  	o.e.r = --idx;
  	return o;
  }

  function safe_format_cell(cell/*:Cell*/, v/*:any*/) {
  	var q = (cell.t == 'd' && v instanceof Date);
  	if(cell.z != null) try { return (cell.w = SSF_format(cell.z, q ? datenum(v) : v)); } catch(e) { }
  	try { return (cell.w = SSF_format((cell.XF||{}).numFmtId||(q ? 14 : 0),  q ? datenum(v) : v)); } catch(e) { return ''+v; }
  }

  function format_cell(cell/*:Cell*/, v/*:any*/, o/*:any*/) {
  	if(cell == null || cell.t == null || cell.t == 'z') return "";
  	if(cell.w !== undefined) return cell.w;
  	if(cell.t == 'd' && !cell.z && o && o.dateNF) cell.z = o.dateNF;
  	if(cell.t == "e") return BErr[cell.v] || cell.v;
  	if(v == undefined) return safe_format_cell(cell, cell.v);
  	return safe_format_cell(cell, v);
  }

  function sheet_to_workbook(sheet/*:Worksheet*/, opts)/*:Workbook*/ {
  	var n = opts && opts.sheet ? opts.sheet : "Sheet1";
  	var sheets = {}; sheets[n] = sheet;
  	return { SheetNames: [n], Sheets: sheets };
  }

  function sheet_add_aoa(_ws/*:?Worksheet*/, data/*:AOA*/, opts/*:?any*/)/*:Worksheet*/ {
  	var o = opts || {};
  	var dense = _ws ? Array.isArray(_ws) : o.dense;
  	var ws/*:Worksheet*/ = _ws || (dense ? ([]/*:any*/) : ({}/*:any*/));
  	var _R = 0, _C = 0;
  	if(ws && o.origin != null) {
  		if(typeof o.origin == 'number') _R = o.origin;
  		else {
  			var _origin/*:CellAddress*/ = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
  			_R = _origin.r; _C = _origin.c;
  		}
  		if(!ws["!ref"]) ws["!ref"] = "A1:A1";
  	}
  	var range/*:Range*/ = ({s: {c:10000000, r:10000000}, e: {c:0, r:0}}/*:any*/);
  	if(ws['!ref']) {
  		var _range = safe_decode_range(ws['!ref']);
  		range.s.c = _range.s.c;
  		range.s.r = _range.s.r;
  		range.e.c = Math.max(range.e.c, _range.e.c);
  		range.e.r = Math.max(range.e.r, _range.e.r);
  		if(_R == -1) range.e.r = _R = _range.e.r + 1;
  	}
  	for(var R = 0; R != data.length; ++R) {
  		if(!data[R]) continue;
  		if(!Array.isArray(data[R])) throw new Error("aoa_to_sheet expects an array of arrays");
  		for(var C = 0; C != data[R].length; ++C) {
  			if(typeof data[R][C] === 'undefined') continue;
  			var cell/*:Cell*/ = ({v: data[R][C] }/*:any*/);
  			var __R = _R + R, __C = _C + C;
  			if(range.s.r > __R) range.s.r = __R;
  			if(range.s.c > __C) range.s.c = __C;
  			if(range.e.r < __R) range.e.r = __R;
  			if(range.e.c < __C) range.e.c = __C;
  			if(data[R][C] && typeof data[R][C] === 'object' && !Array.isArray(data[R][C]) && !(data[R][C] instanceof Date)) cell = data[R][C];
  			else {
  				if(Array.isArray(cell.v)) { cell.f = data[R][C][1]; cell.v = cell.v[0]; }
  				if(cell.v === null) {
  					if(cell.f) cell.t = 'n';
  					else if(o.nullError) { cell.t = 'e'; cell.v = 0; }
  					else if(!o.sheetStubs) continue;
  					else cell.t = 'z';
  				}
  				else if(typeof cell.v === 'number') cell.t = 'n';
  				else if(typeof cell.v === 'boolean') cell.t = 'b';
  				else if(cell.v instanceof Date) {
  					cell.z = o.dateNF || table_fmt[14];
  					if(o.cellDates) { cell.t = 'd'; cell.w = SSF_format(cell.z, datenum(cell.v)); }
  					else { cell.t = 'n'; cell.v = datenum(cell.v); cell.w = SSF_format(cell.z, cell.v); }
  				}
  				else cell.t = 's';
  			}
  			if(dense) {
  				if(!ws[__R]) ws[__R] = [];
  				if(ws[__R][__C] && ws[__R][__C].z) cell.z = ws[__R][__C].z;
  				ws[__R][__C] = cell;
  			} else {
  				var cell_ref = encode_cell(({c:__C,r:__R}/*:any*/));
  				if(ws[cell_ref] && ws[cell_ref].z) cell.z = ws[cell_ref].z;
  				ws[cell_ref] = cell;
  			}
  		}
  	}
  	if(range.s.c < 10000000) ws['!ref'] = encode_range(range);
  	return ws;
  }
  function aoa_to_sheet(data/*:AOA*/, opts/*:?any*/)/*:Worksheet*/ { return sheet_add_aoa(null, data, opts); }

  function parse_Int32LE(data) {
  	return data.read_shift(4, 'i');
  }
  function write_UInt32LE(x/*:number*/, o) {
  	if (!o) o = new_buf(4);
  	o.write_shift(4, x);
  	return o;
  }

  /* [MS-XLSB] 2.5.168 */
  function parse_XLWideString(data/*::, length*/)/*:string*/ {
  	var cchCharacters = data.read_shift(4);
  	return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, 'dbcs');
  }
  function write_XLWideString(data/*:string*/, o) {
  	var _null = false; if (o == null) { _null = true; o = new_buf(4 + 2 * data.length); }
  	o.write_shift(4, data.length);
  	if (data.length > 0) o.write_shift(0, data, 'dbcs');
  	return _null ? o.slice(0, o.l) : o;
  }

  /* [MS-XLSB] 2.5.91 */
  //function parse_LPWideString(data/*::, length*/)/*:string*/ {
  //	var cchCharacters = data.read_shift(2);
  //	return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "utf16le");
  //}

  /* [MS-XLSB] 2.5.143 */
  function parse_StrRun(data) {
  	return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
  }
  function write_StrRun(run, o) {
  	if (!o) o = new_buf(4);
  	o.write_shift(2, run.ich || 0);
  	o.write_shift(2, run.ifnt || 0);
  	return o;
  }

  /* [MS-XLSB] 2.5.121 */
  function parse_RichStr(data, length/*:number*/)/*:XLString*/ {
  	var start = data.l;
  	var flags = data.read_shift(1);
  	var str = parse_XLWideString(data);
  	var rgsStrRun = [];
  	var z = ({ t: str, h: str }/*:any*/);
  	if ((flags & 1) !== 0) { /* fRichStr */
  		/* TODO: formatted string */
  		var dwSizeStrRun = data.read_shift(4);
  		for (var i = 0; i != dwSizeStrRun; ++i) rgsStrRun.push(parse_StrRun(data));
  		z.r = rgsStrRun;
  	}
  	else z.r = [{ ich: 0, ifnt: 0 }];
  	//if((flags & 2) !== 0) { /* fExtStr */
  	//	/* TODO: phonetic string */
  	//}
  	data.l = start + length;
  	return z;
  }
  function write_RichStr(str/*:XLString*/, o/*:?Block*/)/*:Block*/ {
  	/* TODO: formatted string */
  	var _null = false; if (o == null) { _null = true; o = new_buf(15 + 4 * str.t.length); }
  	o.write_shift(1, 0);
  	write_XLWideString(str.t, o);
  	return _null ? o.slice(0, o.l) : o;
  }
  /* [MS-XLSB] 2.4.328 BrtCommentText (RichStr w/1 run) */
  var parse_BrtCommentText = parse_RichStr;
  function write_BrtCommentText(str/*:XLString*/, o/*:?Block*/)/*:Block*/ {
  	/* TODO: formatted string */
  	var _null = false; if (o == null) { _null = true; o = new_buf(23 + 4 * str.t.length); }
  	o.write_shift(1, 1);
  	write_XLWideString(str.t, o);
  	o.write_shift(4, 1);
  	write_StrRun({ ich: 0, ifnt: 0 }, o);
  	return _null ? o.slice(0, o.l) : o;
  }

  /* [MS-XLSB] 2.5.9 */
  function parse_XLSBCell(data)/*:any*/ {
  	var col = data.read_shift(4);
  	var iStyleRef = data.read_shift(2);
  	iStyleRef += data.read_shift(1) << 16;
  	data.l++; //var fPhShow = data.read_shift(1);
  	return { c: col, iStyleRef: iStyleRef };
  }
  function write_XLSBCell(cell/*:any*/, o/*:?Block*/) {
  	if (o == null) o = new_buf(8);
  	o.write_shift(-4, cell.c);
  	o.write_shift(3, cell.iStyleRef || cell.s);
  	o.write_shift(1, 0); /* fPhShow */
  	return o;
  }

  /* Short XLSB Cell does not include column */
  function parse_XLSBShortCell(data)/*:any*/ {
  	var iStyleRef = data.read_shift(2);
  	iStyleRef += data.read_shift(1) <<16;
  	data.l++; //var fPhShow = data.read_shift(1);
  	return { c:-1, iStyleRef: iStyleRef };
  }
  function write_XLSBShortCell(cell/*:any*/, o/*:?Block*/) {
  	if(o == null) o = new_buf(4);
  	o.write_shift(3, cell.iStyleRef || cell.s);
  	o.write_shift(1, 0); /* fPhShow */
  	return o;
  }

  /* [MS-XLSB] 2.5.21 */
  var parse_XLSBCodeName = parse_XLWideString;
  var write_XLSBCodeName = write_XLWideString;

  /* [MS-XLSB] 2.5.166 */
  function parse_XLNullableWideString(data/*::, length*/)/*:string*/ {
  	var cchCharacters = data.read_shift(4);
  	return cchCharacters === 0 || cchCharacters === 0xFFFFFFFF ? "" : data.read_shift(cchCharacters, 'dbcs');
  }
  function write_XLNullableWideString(data/*:string*/, o) {
  	var _null = false; if (o == null) { _null = true; o = new_buf(127); }
  	o.write_shift(4, data.length > 0 ? data.length : 0xFFFFFFFF);
  	if (data.length > 0) o.write_shift(0, data, 'dbcs');
  	return _null ? o.slice(0, o.l) : o;
  }

  /* [MS-XLSB] 2.5.165 */
  var parse_XLNameWideString = parse_XLWideString;
  //var write_XLNameWideString = write_XLWideString;

  /* [MS-XLSB] 2.5.114 */
  var parse_RelID = parse_XLNullableWideString;
  var write_RelID = write_XLNullableWideString;


  /* [MS-XLS] 2.5.217 ; [MS-XLSB] 2.5.122 */
  function parse_RkNumber(data)/*:number*/ {
  	var b = data.slice(data.l, data.l + 4);
  	var fX100 = (b[0] & 1), fInt = (b[0] & 2);
  	data.l += 4;
  	var RK = fInt === 0 ? __double([0, 0, 0, 0, (b[0] & 0xFC), b[1], b[2], b[3]], 0) : __readInt32LE(b, 0) >> 2;
  	return fX100 ? (RK / 100) : RK;
  }
  function write_RkNumber(data/*:number*/, o) {
  	if (o == null) o = new_buf(4);
  	var fX100 = 0, fInt = 0, d100 = data * 100;
  	if ((data == (data | 0)) && (data >= -(1 << 29)) && (data < (1 << 29))) { fInt = 1; }
  	else if ((d100 == (d100 | 0)) && (d100 >= -(1 << 29)) && (d100 < (1 << 29))) { fInt = 1; fX100 = 1; }
  	if (fInt) o.write_shift(-4, ((fX100 ? d100 : data) << 2) + (fX100 + 2));
  	else throw new Error("unsupported RkNumber " + data); // TODO
  }


  /* [MS-XLSB] 2.5.117 RfX */
  function parse_RfX(data /*::, length*/)/*:Range*/ {
  	var cell/*:Range*/ = ({ s: {}, e: {} }/*:any*/);
  	cell.s.r = data.read_shift(4);
  	cell.e.r = data.read_shift(4);
  	cell.s.c = data.read_shift(4);
  	cell.e.c = data.read_shift(4);
  	return cell;
  }
  function write_RfX(r/*:Range*/, o) {
  	if (!o) o = new_buf(16);
  	o.write_shift(4, r.s.r);
  	o.write_shift(4, r.e.r);
  	o.write_shift(4, r.s.c);
  	o.write_shift(4, r.e.c);
  	return o;
  }

  /* [MS-XLSB] 2.5.153 UncheckedRfX */
  var parse_UncheckedRfX = parse_RfX;
  var write_UncheckedRfX = write_RfX;

  /* [MS-XLSB] 2.5.155 UncheckedSqRfX */
  //function parse_UncheckedSqRfX(data) {
  //	var cnt = data.read_shift(4);
  //	var out = [];
  //	for(var i = 0; i < cnt; ++i) {
  //		var rng = parse_UncheckedRfX(data);
  //		out.push(encode_range(rng));
  //	}
  //	return out.join(",");
  //}
  //function write_UncheckedSqRfX(sqrfx/*:string*/) {
  //	var parts = sqrfx.split(/\s*,\s*/);
  //	var o = new_buf(4); o.write_shift(4, parts.length);
  //	var out = [o];
  //	parts.forEach(function(rng) {
  //		out.push(write_UncheckedRfX(safe_decode_range(rng)));
  //	});
  //	return bconcat(out);
  //}

  /* [MS-XLS] 2.5.342 ; [MS-XLSB] 2.5.171 */
  /* TODO: error checking, NaN and Infinity values are not valid Xnum */
  function parse_Xnum(data/*::, length*/) {
  	if(data.length - data.l < 8) throw "XLS Xnum Buffer underflow";
  	return data.read_shift(8, 'f');
  }
  function write_Xnum(data, o) { return (o || new_buf(8)).write_shift(8, data, 'f'); }

  /* [MS-XLSB] 2.4.324 BrtColor */
  function parse_BrtColor(data/*::, length*/) {
  	var out = {};
  	var d = data.read_shift(1);

  	//var fValidRGB = d & 1;
  	var xColorType = d >>> 1;

  	var index = data.read_shift(1);
  	var nTS = data.read_shift(2, 'i');
  	var bR = data.read_shift(1);
  	var bG = data.read_shift(1);
  	var bB = data.read_shift(1);
  	data.l++; //var bAlpha = data.read_shift(1);

  	switch (xColorType) {
  		case 0: out.auto = 1; break;
  		case 1:
  			out.index = index;
  			var icv = XLSIcv[index];
  			/* automatic pseudo index 81 */
  			if (icv) out.rgb = rgb2Hex(icv);
  			break;
  		case 2:
  			/* if(!fValidRGB) throw new Error("invalid"); */
  			out.rgb = rgb2Hex([bR, bG, bB]);
  			break;
  		case 3: out.theme = index; break;
  	}
  	if (nTS != 0) out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;

  	return out;
  }
  function write_BrtColor(color, o) {
  	if (!o) o = new_buf(8);
  	if (!color || color.auto) { o.write_shift(4, 0); o.write_shift(4, 0); return o; }
  	if (color.index != null) {
  		o.write_shift(1, 0x02);
  		o.write_shift(1, color.index);
  	} else if (color.theme != null) {
  		o.write_shift(1, 0x06);
  		o.write_shift(1, color.theme);
  	} else {
  		o.write_shift(1, 0x05);
  		o.write_shift(1, 0);
  	}
  	var nTS = color.tint || 0;
  	if (nTS > 0) nTS *= 32767;
  	else if (nTS < 0) nTS *= 32768;
  	o.write_shift(2, nTS);
  	if (!color.rgb || color.theme != null) {
  		o.write_shift(2, 0);
  		o.write_shift(1, 0);
  		o.write_shift(1, 0);
  	} else {
  		var rgb = (color.rgb || 'FFFFFF');
  		if (typeof rgb == 'number') rgb = ("000000" + rgb.toString(16)).slice(-6);
  		o.write_shift(1, parseInt(rgb.slice(0, 2), 16));
  		o.write_shift(1, parseInt(rgb.slice(2, 4), 16));
  		o.write_shift(1, parseInt(rgb.slice(4, 6), 16));
  		o.write_shift(1, 0xFF);
  	}
  	return o;
  }

  /* [MS-XLSB] 2.5.52 */
  function parse_FontFlags(data/*::, length, opts*/) {
  	var d = data.read_shift(1);
  	data.l++;
  	var out = {
  		fBold: d & 0x01,
  		fItalic: d & 0x02,
  		fUnderline: d & 0x04,
  		fStrikeout: d & 0x08,
  		fOutline: d & 0x10,
  		fShadow: d & 0x20,
  		fCondense: d & 0x40,
  		fExtend: d & 0x80
  	};
  	return out;
  }
  function write_FontFlags(font, o) {
  	if (!o) o = new_buf(2);
  	var grbit =
  		(font.italic ? 0x02 : 0) |
  		(font.strike ? 0x08 : 0) |
  		(font.outline ? 0x10 : 0) |
  		(font.shadow ? 0x20 : 0) |
  		(font.condense ? 0x40 : 0) |
  		(font.extend ? 0x80 : 0);
  	o.write_shift(1, grbit);
  	o.write_shift(1, 0);
  	return o;
  }

  /* [MS-OLEPS] 2.2 PropertyType */
  // Note: some tree shakers cannot handle VT_VECTOR | $CONST, hence extra vars
  //var VT_EMPTY    = 0x0000;
  //var VT_NULL     = 0x0001;
  var VT_I2       = 0x0002;
  var VT_I4       = 0x0003;
  //var VT_R4       = 0x0004;
  //var VT_R8       = 0x0005;
  //var VT_CY       = 0x0006;
  //var VT_DATE     = 0x0007;
  //var VT_BSTR     = 0x0008;
  //var VT_ERROR    = 0x000A;
  var VT_BOOL     = 0x000B;
  //var VT_DECIMAL  = 0x000E;
  //var VT_I1       = 0x0010;
  //var VT_UI1      = 0x0011;
  //var VT_UI2      = 0x0012;
  var VT_UI4      = 0x0013;
  //var VT_LPWSTR   = 0x001F;
  var VT_FILETIME = 0x0040;
  var VT_BLOB     = 0x0041;
  //var VT_STREAM   = 0x0042;
  //var VT_STORAGE  = 0x0043;
  //var VT_STREAMED_Object  = 0x0044;
  //var VT_STORED_Object    = 0x0045;
  //var VT_BLOB_Object      = 0x0046;
  var VT_CF       = 0x0047;
  var VT_VECTOR_VARIANT = 0x100C;
  var VT_VECTOR_LPSTR   = 0x101E;
  //var VT_ARRAY    = 0x2000;

  var VT_STRING   = 0x0050; // 2.3.3.1.11 VtString

  /* [MS-OSHARED] 2.3.3.2.2.1 Document Summary Information PIDDSI */
  var DocSummaryPIDDSI = {
  	/*::[*/0x01/*::]*/: { n: 'CodePage', t: VT_I2 },
  	/*::[*/0x02/*::]*/: { n: 'Category', t: VT_STRING },
  	/*::[*/0x03/*::]*/: { n: 'PresentationFormat', t: VT_STRING },
  	/*::[*/0x04/*::]*/: { n: 'ByteCount', t: VT_I4 },
  	/*::[*/0x05/*::]*/: { n: 'LineCount', t: VT_I4 },
  	/*::[*/0x06/*::]*/: { n: 'ParagraphCount', t: VT_I4 },
  	/*::[*/0x07/*::]*/: { n: 'SlideCount', t: VT_I4 },
  	/*::[*/0x08/*::]*/: { n: 'NoteCount', t: VT_I4 },
  	/*::[*/0x09/*::]*/: { n: 'HiddenCount', t: VT_I4 },
  	/*::[*/0x0a/*::]*/: { n: 'MultimediaClipCount', t: VT_I4 },
  	/*::[*/0x0b/*::]*/: { n: 'ScaleCrop', t: VT_BOOL },
  	/*::[*/0x0c/*::]*/: { n: 'HeadingPairs', t: VT_VECTOR_VARIANT /* VT_VECTOR | VT_VARIANT */ },
  	/*::[*/0x0d/*::]*/: { n: 'TitlesOfParts', t: VT_VECTOR_LPSTR /* VT_VECTOR | VT_LPSTR */ },
  	/*::[*/0x0e/*::]*/: { n: 'Manager', t: VT_STRING },
  	/*::[*/0x0f/*::]*/: { n: 'Company', t: VT_STRING },
  	/*::[*/0x10/*::]*/: { n: 'LinksUpToDate', t: VT_BOOL },
  	/*::[*/0x11/*::]*/: { n: 'CharacterCount', t: VT_I4 },
  	/*::[*/0x13/*::]*/: { n: 'SharedDoc', t: VT_BOOL },
  	/*::[*/0x16/*::]*/: { n: 'HyperlinksChanged', t: VT_BOOL },
  	/*::[*/0x17/*::]*/: { n: 'AppVersion', t: VT_I4, p: 'version' },
  	/*::[*/0x18/*::]*/: { n: 'DigSig', t: VT_BLOB },
  	/*::[*/0x1A/*::]*/: { n: 'ContentType', t: VT_STRING },
  	/*::[*/0x1B/*::]*/: { n: 'ContentStatus', t: VT_STRING },
  	/*::[*/0x1C/*::]*/: { n: 'Language', t: VT_STRING },
  	/*::[*/0x1D/*::]*/: { n: 'Version', t: VT_STRING },
  	/*::[*/0xFF/*::]*/: {},
  	/* [MS-OLEPS] 2.18 */
  	/*::[*/0x80000000/*::]*/: { n: 'Locale', t: VT_UI4 },
  	/*::[*/0x80000003/*::]*/: { n: 'Behavior', t: VT_UI4 },
  	/*::[*/0x72627262/*::]*/: {}
  };

  /* [MS-OSHARED] 2.3.3.2.1.1 Summary Information Property Set PIDSI */
  var SummaryPIDSI = {
  	/*::[*/0x01/*::]*/: { n: 'CodePage', t: VT_I2 },
  	/*::[*/0x02/*::]*/: { n: 'Title', t: VT_STRING },
  	/*::[*/0x03/*::]*/: { n: 'Subject', t: VT_STRING },
  	/*::[*/0x04/*::]*/: { n: 'Author', t: VT_STRING },
  	/*::[*/0x05/*::]*/: { n: 'Keywords', t: VT_STRING },
  	/*::[*/0x06/*::]*/: { n: 'Comments', t: VT_STRING },
  	/*::[*/0x07/*::]*/: { n: 'Template', t: VT_STRING },
  	/*::[*/0x08/*::]*/: { n: 'LastAuthor', t: VT_STRING },
  	/*::[*/0x09/*::]*/: { n: 'RevNumber', t: VT_STRING },
  	/*::[*/0x0A/*::]*/: { n: 'EditTime', t: VT_FILETIME },
  	/*::[*/0x0B/*::]*/: { n: 'LastPrinted', t: VT_FILETIME },
  	/*::[*/0x0C/*::]*/: { n: 'CreatedDate', t: VT_FILETIME },
  	/*::[*/0x0D/*::]*/: { n: 'ModifiedDate', t: VT_FILETIME },
  	/*::[*/0x0E/*::]*/: { n: 'PageCount', t: VT_I4 },
  	/*::[*/0x0F/*::]*/: { n: 'WordCount', t: VT_I4 },
  	/*::[*/0x10/*::]*/: { n: 'CharCount', t: VT_I4 },
  	/*::[*/0x11/*::]*/: { n: 'Thumbnail', t: VT_CF },
  	/*::[*/0x12/*::]*/: { n: 'Application', t: VT_STRING },
  	/*::[*/0x13/*::]*/: { n: 'DocSecurity', t: VT_I4 },
  	/*::[*/0xFF/*::]*/: {},
  	/* [MS-OLEPS] 2.18 */
  	/*::[*/0x80000000/*::]*/: { n: 'Locale', t: VT_UI4 },
  	/*::[*/0x80000003/*::]*/: { n: 'Behavior', t: VT_UI4 },
  	/*::[*/0x72627262/*::]*/: {}
  };

  function rgbify(arr/*:Array<number>*/)/*:Array<[number, number, number]>*/ { return arr.map(function(x) { return [(x>>16)&255,(x>>8)&255,x&255]; }); }

  /* [MS-XLS] 2.5.161 */
  /* [MS-XLSB] 2.5.75 Icv */
  var _XLSIcv = /*#__PURE__*/ rgbify([
  	/* Color Constants */
  	0x000000,
  	0xFFFFFF,
  	0xFF0000,
  	0x00FF00,
  	0x0000FF,
  	0xFFFF00,
  	0xFF00FF,
  	0x00FFFF,

  	/* Overridable Defaults */
  	0x000000,
  	0xFFFFFF,
  	0xFF0000,
  	0x00FF00,
  	0x0000FF,
  	0xFFFF00,
  	0xFF00FF,
  	0x00FFFF,

  	0x800000,
  	0x008000,
  	0x000080,
  	0x808000,
  	0x800080,
  	0x008080,
  	0xC0C0C0,
  	0x808080,
  	0x9999FF,
  	0x993366,
  	0xFFFFCC,
  	0xCCFFFF,
  	0x660066,
  	0xFF8080,
  	0x0066CC,
  	0xCCCCFF,

  	0x000080,
  	0xFF00FF,
  	0xFFFF00,
  	0x00FFFF,
  	0x800080,
  	0x800000,
  	0x008080,
  	0x0000FF,
  	0x00CCFF,
  	0xCCFFFF,
  	0xCCFFCC,
  	0xFFFF99,
  	0x99CCFF,
  	0xFF99CC,
  	0xCC99FF,
  	0xFFCC99,

  	0x3366FF,
  	0x33CCCC,
  	0x99CC00,
  	0xFFCC00,
  	0xFF9900,
  	0xFF6600,
  	0x666699,
  	0x969696,
  	0x003366,
  	0x339966,
  	0x003300,
  	0x333300,
  	0x993300,
  	0x993366,
  	0x333399,
  	0x333333,

  	/* Other entries to appease BIFF8/12 */
  	0xFFFFFF, /* 0x40 icvForeground ?? */
  	0x000000, /* 0x41 icvBackground ?? */
  	0x000000, /* 0x42 icvFrame ?? */
  	0x000000, /* 0x43 icv3D ?? */
  	0x000000, /* 0x44 icv3DText ?? */
  	0x000000, /* 0x45 icv3DHilite ?? */
  	0x000000, /* 0x46 icv3DShadow ?? */
  	0x000000, /* 0x47 icvHilite ?? */
  	0x000000, /* 0x48 icvCtlText ?? */
  	0x000000, /* 0x49 icvCtlScrl ?? */
  	0x000000, /* 0x4A icvCtlInv ?? */
  	0x000000, /* 0x4B icvCtlBody ?? */
  	0x000000, /* 0x4C icvCtlFrame ?? */
  	0x000000, /* 0x4D icvCtlFore ?? */
  	0x000000, /* 0x4E icvCtlBack ?? */
  	0x000000, /* 0x4F icvCtlNeutral */
  	0x000000, /* 0x50 icvInfoBk ?? */
  	0x000000 /* 0x51 icvInfoText ?? */
  ]);
  var XLSIcv = /*#__PURE__*/dup(_XLSIcv);

  /* [MS-XLSB] 2.5.97.2 */
  var BErr = {
  	/*::[*/0x00/*::]*/: "#NULL!",
  	/*::[*/0x07/*::]*/: "#DIV/0!",
  	/*::[*/0x0F/*::]*/: "#VALUE!",
  	/*::[*/0x17/*::]*/: "#REF!",
  	/*::[*/0x1D/*::]*/: "#NAME?",
  	/*::[*/0x24/*::]*/: "#NUM!",
  	/*::[*/0x2A/*::]*/: "#N/A",
  	/*::[*/0x2B/*::]*/: "#GETTING_DATA",
  	/*::[*/0xFF/*::]*/: "#WTF?"
  };

  /* Parts enumerated in OPC spec, MS-XLSB and MS-XLSX */
  /* 12.3 Part Summary <SpreadsheetML> */
  /* 14.2 Part Summary <DrawingML> */
  /* [MS-XLSX] 2.1 Part Enumerations ; [MS-XLSB] 2.1.7 Part Enumeration */
  var ct2type/*{[string]:string}*/ = ({
  	/* Workbook */
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  	"application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  	"application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  	"application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",

  	/* Worksheet */
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  	"application/vnd.ms-excel.worksheet": "sheets",
  	"application/vnd.ms-excel.binIndexWs": "TODO", /* Binary Index */

  	/* Chartsheet */
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  	"application/vnd.ms-excel.chartsheet": "charts",

  	/* Macrosheet */
  	"application/vnd.ms-excel.macrosheet+xml": "macros",
  	"application/vnd.ms-excel.macrosheet": "macros",
  	"application/vnd.ms-excel.intlmacrosheet": "TODO",
  	"application/vnd.ms-excel.binIndexMs": "TODO", /* Binary Index */

  	/* Dialogsheet */
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  	"application/vnd.ms-excel.dialogsheet": "dialogs",

  	/* Shared Strings */
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  	"application/vnd.ms-excel.sharedStrings": "strs",

  	/* Styles */
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  	"application/vnd.ms-excel.styles": "styles",

  	/* File Properties */
  	"application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  	"application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  	"application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",

  	/* Custom Data Properties */
  	"application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",

  	/* Comments */
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  	"application/vnd.ms-excel.comments": "comments",
  	"application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  	"application/vnd.ms-excel.person+xml": "people",

  	/* Metadata (Stock/Geography and Dynamic Array) */
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  	"application/vnd.ms-excel.sheetMetadata": "metadata",

  	/* PivotTable */
  	"application/vnd.ms-excel.pivotTable": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",

  	/* Chart Objects */
  	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",

  	/* Chart Colors */
  	"application/vnd.ms-office.chartcolorstyle+xml": "TODO",

  	/* Chart Style */
  	"application/vnd.ms-office.chartstyle+xml": "TODO",

  	/* Chart Advanced */
  	"application/vnd.ms-office.chartex+xml": "TODO",

  	/* Calculation Chain */
  	"application/vnd.ms-excel.calcChain": "calcchains",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",

  	/* Printer Settings */
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",

  	/* ActiveX */
  	"application/vnd.ms-office.activeX": "TODO",
  	"application/vnd.ms-office.activeX+xml": "TODO",

  	/* Custom Toolbars */
  	"application/vnd.ms-excel.attachedToolbars": "TODO",

  	/* External Data Connections */
  	"application/vnd.ms-excel.connections": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",

  	/* External Links */
  	"application/vnd.ms-excel.externalLink": "links",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",

  	/* PivotCache */
  	"application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  	"application/vnd.ms-excel.pivotCacheRecords": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",

  	/* Query Table */
  	"application/vnd.ms-excel.queryTable": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",

  	/* Shared Workbook */
  	"application/vnd.ms-excel.userNames": "TODO",
  	"application/vnd.ms-excel.revisionHeaders": "TODO",
  	"application/vnd.ms-excel.revisionLog": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",

  	/* Single Cell Table */
  	"application/vnd.ms-excel.tableSingleCells": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",

  	/* Slicer */
  	"application/vnd.ms-excel.slicer": "TODO",
  	"application/vnd.ms-excel.slicerCache": "TODO",
  	"application/vnd.ms-excel.slicer+xml": "TODO",
  	"application/vnd.ms-excel.slicerCache+xml": "TODO",

  	/* Sort Map */
  	"application/vnd.ms-excel.wsSortMap": "TODO",

  	/* Table */
  	"application/vnd.ms-excel.table": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",

  	/* Themes */
  	"application/vnd.openxmlformats-officedocument.theme+xml": "themes",

  	/* Theme Override */
  	"application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",

  	/* Timeline */
  	"application/vnd.ms-excel.Timeline+xml": "TODO", /* verify */
  	"application/vnd.ms-excel.TimelineCache+xml": "TODO", /* verify */

  	/* VBA */
  	"application/vnd.ms-office.vbaProject": "vba",
  	"application/vnd.ms-office.vbaProjectSignature": "TODO",

  	/* Volatile Dependencies */
  	"application/vnd.ms-office.volatileDependencies": "TODO",
  	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",

  	/* Control Properties */
  	"application/vnd.ms-excel.controlproperties+xml": "TODO",

  	/* Data Model */
  	"application/vnd.openxmlformats-officedocument.model+data": "TODO",

  	/* Survey */
  	"application/vnd.ms-excel.Survey+xml": "TODO",

  	/* Drawing */
  	"application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  	"application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  	"application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  	"application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  	"application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",

  	/* VML */
  	"application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",

  	"application/vnd.openxmlformats-package.relationships+xml": "rels",
  	"application/vnd.openxmlformats-officedocument.oleObject": "TODO",

  	/* Image */
  	"image/png": "TODO",

  	"sheet": "js"
  }/*:any*/);

  var CT_LIST = {
  		workbooks: {
  			xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
  			xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
  			xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
  			xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
  			xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
  		},
  		strs: { /* Shared Strings */
  			xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
  			xlsb: "application/vnd.ms-excel.sharedStrings"
  		},
  		comments: { /* Comments */
  			xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
  			xlsb: "application/vnd.ms-excel.comments"
  		},
  		sheets: { /* Worksheet */
  			xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
  			xlsb: "application/vnd.ms-excel.worksheet"
  		},
  		charts: { /* Chartsheet */
  			xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
  			xlsb: "application/vnd.ms-excel.chartsheet"
  		},
  		dialogs: { /* Dialogsheet */
  			xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
  			xlsb: "application/vnd.ms-excel.dialogsheet"
  		},
  		macros: { /* Macrosheet (Excel 4.0 Macros) */
  			xlsx: "application/vnd.ms-excel.macrosheet+xml",
  			xlsb: "application/vnd.ms-excel.macrosheet"
  		},
  		metadata: { /* Metadata (Stock/Geography and Dynamic Array) */
  			xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
  			xlsb: "application/vnd.ms-excel.sheetMetadata"
  		},
  		styles: { /* Styles */
  			xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
  			xlsb: "application/vnd.ms-excel.styles"
  		}
  };

  function new_ct()/*:any*/ {
  	return ({
  		workbooks:[], sheets:[], charts:[], dialogs:[], macros:[],
  		rels:[], strs:[], comments:[], threadedcomments:[], links:[],
  		coreprops:[], extprops:[], custprops:[], themes:[], styles:[],
  		calcchains:[], vba: [], drawings: [], metadata: [], people:[],
  		TODO:[], xmlns: "" }/*:any*/);
  }

  function write_ct(ct, opts)/*:string*/ {
  	var type2ct/*{[string]:Array<string>}*/ = evert_arr(ct2type);

  	var o/*:Array<string>*/ = [], v;
  	o[o.length] = (XML_HEADER);
  	o[o.length] = writextag('Types', null, {
  		'xmlns': XMLNS.CT,
  		'xmlns:xsd': XMLNS.xsd,
  		'xmlns:xsi': XMLNS.xsi
  	});

  	o = o.concat([
  		['xml', 'application/xml'],
  		['bin', 'application/vnd.ms-excel.sheet.binary.macroEnabled.main'],
  		['vml', 'application/vnd.openxmlformats-officedocument.vmlDrawing'],
  		['data', 'application/vnd.openxmlformats-officedocument.model+data'],
  		/* from test files */
  		['bmp', 'image/bmp'],
  		['png', 'image/png'],
  		['gif', 'image/gif'],
  		['emf', 'image/x-emf'],
  		['wmf', 'image/x-wmf'],
  		['jpg', 'image/jpeg'], ['jpeg', 'image/jpeg'],
  		['tif', 'image/tiff'], ['tiff', 'image/tiff'],
  		['pdf', 'application/pdf'],
  		['rels', 'application/vnd.openxmlformats-package.relationships+xml']
  	].map(function(x) {
  		return writextag('Default', null, {'Extension':x[0], 'ContentType': x[1]});
  	}));

  	/* only write first instance */
  	var f1 = function(w) {
  		if(ct[w] && ct[w].length > 0) {
  			v = ct[w][0];
  			o[o.length] = (writextag('Override', null, {
  				'PartName': (v[0] == '/' ? "":"/") + v,
  				'ContentType': CT_LIST[w][opts.bookType] || CT_LIST[w]['xlsx']
  			}));
  		}
  	};

  	/* book type-specific */
  	var f2 = function(w) {
  		(ct[w]||[]).forEach(function(v) {
  			o[o.length] = (writextag('Override', null, {
  				'PartName': (v[0] == '/' ? "":"/") + v,
  				'ContentType': CT_LIST[w][opts.bookType] || CT_LIST[w]['xlsx']
  			}));
  		});
  	};

  	/* standard type */
  	var f3 = function(t) {
  		(ct[t]||[]).forEach(function(v) {
  			o[o.length] = (writextag('Override', null, {
  				'PartName': (v[0] == '/' ? "":"/") + v,
  				'ContentType': type2ct[t][0]
  			}));
  		});
  	};

  	f1('workbooks');
  	f2('sheets');
  	f2('charts');
  	f3('themes');
  	['strs', 'styles'].forEach(f1);
  	['coreprops', 'extprops', 'custprops'].forEach(f3);
  	f3('vba');
  	f3('comments');
  	f3('threadedcomments');
  	f3('drawings');
  	f2('metadata');
  	f3('people');
  	if(o.length>2){ o[o.length] = ('</Types>'); o[1]=o[1].replace("/>",">"); }
  	return o.join("");
  }
  /* 9.3 Relationships */
  var RELS = ({
  	WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  	SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  	HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  	VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  	XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  	XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  	XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  	CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  	CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  	CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  	CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  	EXT_PROPS: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties',
  	CUST_PROPS: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties',
  	SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  	STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  	THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  	CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  	CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  	CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  	WS: [
  		"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
  		"http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  	],
  	DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  	MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  	IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  	DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  	XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  	TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  	PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  	VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
  }/*:any*/);


  /* 9.3.3 Representing Relationships */
  function get_rels_path(file/*:string*/)/*:string*/ {
  	var n = file.lastIndexOf("/");
  	return file.slice(0,n+1) + '_rels/' + file.slice(n+1) + ".rels";
  }


  /* TODO */
  function write_rels(rels)/*:string*/ {
  	var o = [XML_HEADER, writextag('Relationships', null, {
  		//'xmlns:ns0': XMLNS.RELS,
  		'xmlns': XMLNS.RELS
  	})];
  	keys(rels['!id']).forEach(function(rid) {
  		o[o.length] = (writextag('Relationship', null, rels['!id'][rid]));
  	});
  	if(o.length>2){ o[o.length] = ('</Relationships>'); o[1]=o[1].replace("/>",">"); }
  	return o.join("");
  }

  function add_rels(rels, rId/*:number*/, f, type, relobj, targetmode/*:?string*/)/*:number*/ {
  	if(!relobj) relobj = {};
  	if(!rels['!id']) rels['!id'] = {};
  	if(!rels['!idx']) rels['!idx'] = 1;
  	if(rId < 0) for(rId = rels['!idx']; rels['!id']['rId' + rId]; ++rId){/* empty */}
  	rels['!idx'] = rId + 1;
  	relobj.Id = 'rId' + rId;
  	relobj.Type = type;
  	relobj.Target = f;
  	if(targetmode) relobj.TargetMode = targetmode;
  	else if([RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(relobj.Type) > -1) relobj.TargetMode = "External";
  	if(rels['!id'][relobj.Id]) throw new Error("Cannot rewrite rId " + rId);
  	rels['!id'][relobj.Id] = relobj;
  	rels[('/' + relobj.Target).replace("//","/")] = relobj;
  	return rId;
  }

  function write_manifest(manifest/*:Array<Array<string> >*/)/*:string*/ {
  	var o = [XML_HEADER];
  	o.push('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">\n');
  	o.push('  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>\n');
  	for(var i = 0; i < manifest.length; ++i) o.push('  <manifest:file-entry manifest:full-path="' + manifest[i][0] + '" manifest:media-type="' + manifest[i][1] + '"/>\n');
  	o.push('</manifest:manifest>');
  	return o.join("");
  }

  /* Part 3 Section 6 Metadata Manifest File */
  function write_rdf_type(file/*:string*/, res/*:string*/, tag/*:?string*/) {
  	return [
  		'  <rdf:Description rdf:about="' + file + '">\n',
  		'    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (tag || "odf") + '#' + res + '"/>\n',
  		'  </rdf:Description>\n'
  	].join("");
  }
  function write_rdf_has(base/*:string*/, file/*:string*/) {
  	return [
  		'  <rdf:Description rdf:about="' + base + '">\n',
  		'    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + file + '"/>\n',
  		'  </rdf:Description>\n'
  	].join("");
  }
  function write_rdf(rdf) {
  	var o = [XML_HEADER];
  	o.push('<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n');
  	for(var i = 0; i != rdf.length; ++i) {
  		o.push(write_rdf_type(rdf[i][0], rdf[i][1]));
  		o.push(write_rdf_has("",rdf[i][0]));
  	}
  	o.push(write_rdf_type("","Document", "pkg"));
  	o.push('</rdf:RDF>');
  	return o.join("");
  }
  /* TODO: pull properties */
  function write_meta_ods(/*:: wb: Workbook, opts: any*/)/*:string*/ {
  	return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>Sheet' + 'JS ' + XLSX.version + '</meta:generator></office:meta></office:document-meta>';
  }

  /* ECMA-376 Part II 11.1 Core Properties Part */
  /* [MS-OSHARED] 2.3.3.2.[1-2].1 (PIDSI/PIDDSI) */
  var CORE_PROPS/*:Array<Array<string> >*/ = [
  	["cp:category", "Category"],
  	["cp:contentStatus", "ContentStatus"],
  	["cp:keywords", "Keywords"],
  	["cp:lastModifiedBy", "LastAuthor"],
  	["cp:lastPrinted", "LastPrinted"],
  	["cp:revision", "RevNumber"],
  	["cp:version", "Version"],
  	["dc:creator", "Author"],
  	["dc:description", "Comments"],
  	["dc:identifier", "Identifier"],
  	["dc:language", "Language"],
  	["dc:subject", "Subject"],
  	["dc:title", "Title"],
  	["dcterms:created", "CreatedDate", 'date'],
  	["dcterms:modified", "ModifiedDate", 'date']
  ];

  function cp_doit(f, g, h, o, p) {
  	if(p[f] != null || g == null || g === "") return;
  	p[f] = g;
  	g = escapexml(g);
  	o[o.length] = (h ? writextag(f,g,h) : writetag(f,g));
  }

  function write_core_props(cp, _opts) {
  	var opts = _opts || {};
  	var o = [XML_HEADER, writextag('cp:coreProperties', null, {
  		//'xmlns': XMLNS.CORE_PROPS,
  		'xmlns:cp': XMLNS.CORE_PROPS,
  		'xmlns:dc': XMLNS.dc,
  		'xmlns:dcterms': XMLNS.dcterms,
  		'xmlns:dcmitype': XMLNS.dcmitype,
  		'xmlns:xsi': XMLNS.xsi
  	})], p = {};
  	if(!cp && !opts.Props) return o.join("");

  	if(cp) {
  		if(cp.CreatedDate != null) cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), {"xsi:type":"dcterms:W3CDTF"}, o, p);
  		if(cp.ModifiedDate != null) cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), {"xsi:type":"dcterms:W3CDTF"}, o, p);
  	}

  	for(var i = 0; i != CORE_PROPS.length; ++i) {
  		var f = CORE_PROPS[i];
  		var v = opts.Props && opts.Props[f[1]] != null ? opts.Props[f[1]] : cp ? cp[f[1]] : null;
  		if(v === true) v = "1";
  		else if(v === false) v = "0";
  		else if(typeof v == "number") v = String(v);
  		if(v != null) cp_doit(f[0], v, null, o, p);
  	}
  	if(o.length>2){ o[o.length] = ('</cp:coreProperties>'); o[1]=o[1].replace("/>",">"); }
  	return o.join("");
  }
  /* 15.2.12.3 Extended File Properties Part */
  /* [MS-OSHARED] 2.3.3.2.[1-2].1 (PIDSI/PIDDSI) */
  var EXT_PROPS/*:Array<Array<string> >*/ = [
  	["Application", "Application", "string"],
  	["AppVersion", "AppVersion", "string"],
  	["Company", "Company", "string"],
  	["DocSecurity", "DocSecurity", "string"],
  	["Manager", "Manager", "string"],
  	["HyperlinksChanged", "HyperlinksChanged", "bool"],
  	["SharedDoc", "SharedDoc", "bool"],
  	["LinksUpToDate", "LinksUpToDate", "bool"],
  	["ScaleCrop", "ScaleCrop", "bool"],
  	["HeadingPairs", "HeadingPairs", "raw"],
  	["TitlesOfParts", "TitlesOfParts", "raw"]
  ];

  var PseudoPropsPairs = [
  	"Worksheets",  "SheetNames",
  	"NamedRanges", "DefinedNames",
  	"Chartsheets", "ChartNames"
  ];

  function write_ext_props(cp/*::, opts*/)/*:string*/ {
  	var o/*:Array<string>*/ = [], W = writextag;
  	if(!cp) cp = {};
  	cp.Application = "SheetJS";
  	o[o.length] = (XML_HEADER);
  	o[o.length] = (writextag('Properties', null, {
  		'xmlns': XMLNS.EXT_PROPS,
  		'xmlns:vt': XMLNS.vt
  	}));

  	EXT_PROPS.forEach(function(f) {
  		if(cp[f[1]] === undefined) return;
  		var v;
  		switch(f[2]) {
  			case 'string': v = escapexml(String(cp[f[1]])); break;
  			case 'bool': v = cp[f[1]] ? 'true' : 'false'; break;
  		}
  		if(v !== undefined) o[o.length] = (W(f[0], v));
  	});

  	/* TODO: HeadingPairs, TitlesOfParts */
  	o[o.length] = (W('HeadingPairs', W('vt:vector', W('vt:variant', '<vt:lpstr>Worksheets</vt:lpstr>')+W('vt:variant', W('vt:i4', String(cp.Worksheets))), {size:2, baseType:"variant"})));
  	o[o.length] = (W('TitlesOfParts', W('vt:vector', cp.SheetNames.map(function(s) { return "<vt:lpstr>" + escapexml(s) + "</vt:lpstr>"; }).join(""), {size: cp.Worksheets, baseType:"lpstr"})));
  	if(o.length>2){ o[o.length] = ('</Properties>'); o[1]=o[1].replace("/>",">"); }
  	return o.join("");
  }

  function write_cust_props(cp/*::, opts*/)/*:string*/ {
  	var o = [XML_HEADER, writextag('Properties', null, {
  		'xmlns': XMLNS.CUST_PROPS,
  		'xmlns:vt': XMLNS.vt
  	})];
  	if(!cp) return o.join("");
  	var pid = 1;
  	keys(cp).forEach(function custprop(k) { ++pid;
  		o[o.length] = (writextag('property', write_vt(cp[k], true), {
  			'fmtid': '{D5CDD505-2E9C-101B-9397-08002B2CF9AE}',
  			'pid': pid,
  			'name': escapexml(k)
  		}));
  	});
  	if(o.length>2){ o[o.length] = '</Properties>'; o[1]=o[1].replace("/>",">"); }
  	return o.join("");
  }
  /* Common Name -> XLML Name */
  var XLMLDocPropsMap = {
  	Title: 'Title',
  	Subject: 'Subject',
  	Author: 'Author',
  	Keywords: 'Keywords',
  	Comments: 'Description',
  	LastAuthor: 'LastAuthor',
  	RevNumber: 'Revision',
  	Application: 'AppName',
  	/* TotalTime: 'TotalTime', */
  	LastPrinted: 'LastPrinted',
  	CreatedDate: 'Created',
  	ModifiedDate: 'LastSaved',
  	/* Pages */
  	/* Words */
  	/* Characters */
  	Category: 'Category',
  	/* PresentationFormat */
  	Manager: 'Manager',
  	Company: 'Company',
  	/* Guid */
  	/* HyperlinkBase */
  	/* Bytes */
  	/* Lines */
  	/* Paragraphs */
  	/* CharactersWithSpaces */
  	AppVersion: 'Version',

  	ContentStatus: 'ContentStatus', /* NOTE: missing from schema */
  	Identifier: 'Identifier', /* NOTE: missing from schema */
  	Language: 'Language' /* NOTE: missing from schema */
  };

  function xlml_write_docprops(Props, opts) {
  	var o/*:Array<string>*/ = [];
  	keys(XLMLDocPropsMap).map(function(m) {
  		for(var i = 0; i < CORE_PROPS.length; ++i) if(CORE_PROPS[i][1] == m) return CORE_PROPS[i];
  		for(i = 0; i < EXT_PROPS.length; ++i) if(EXT_PROPS[i][1] == m) return EXT_PROPS[i];
  		throw m;
  	}).forEach(function(p) {
  		if(Props[p[1]] == null) return;
  		var m = opts && opts.Props && opts.Props[p[1]] != null ? opts.Props[p[1]] : Props[p[1]];
  		switch(p[2]) {
  			case 'date': m = new Date(m).toISOString().replace(/\.\d*Z/,"Z"); break;
  		}
  		if(typeof m == 'number') m = String(m);
  		else if(m === true || m === false) { m = m ? "1" : "0"; }
  		else if(m instanceof Date) m = new Date(m).toISOString().replace(/\.\d*Z/,"");
  		o.push(writetag(XLMLDocPropsMap[p[1]] || p[1], m));
  	});
  	return writextag('DocumentProperties', o.join(""), {xmlns:XLMLNS.o });
  }
  function xlml_write_custprops(Props, Custprops/*::, opts*/) {
  	var BLACKLIST = ["Worksheets","SheetNames"];
  	var T = 'CustomDocumentProperties';
  	var o/*:Array<string>*/ = [];
  	if(Props) keys(Props).forEach(function(k) {
  		/*:: if(!Props) return; */
  		if(!Object.prototype.hasOwnProperty.call(Props, k)) return;
  		for(var i = 0; i < CORE_PROPS.length; ++i) if(k == CORE_PROPS[i][1]) return;
  		for(i = 0; i < EXT_PROPS.length; ++i) if(k == EXT_PROPS[i][1]) return;
  		for(i = 0; i < BLACKLIST.length; ++i) if(k == BLACKLIST[i]) return;

  		var m = Props[k];
  		var t = "string";
  		if(typeof m == 'number') { t = "float"; m = String(m); }
  		else if(m === true || m === false) { t = "boolean"; m = m ? "1" : "0"; }
  		else m = String(m);
  		o.push(writextag(escapexmltag(k), m, {"dt:dt":t}));
  	});
  	if(Custprops) keys(Custprops).forEach(function(k) {
  		/*:: if(!Custprops) return; */
  		if(!Object.prototype.hasOwnProperty.call(Custprops, k)) return;
  		if(Props && Object.prototype.hasOwnProperty.call(Props, k)) return;
  		var m = Custprops[k];
  		var t = "string";
  		if(typeof m == 'number') { t = "float"; m = String(m); }
  		else if(m === true || m === false) { t = "boolean"; m = m ? "1" : "0"; }
  		else if(m instanceof Date) { t = "dateTime.tz"; m = m.toISOString(); }
  		else m = String(m);
  		o.push(writextag(escapexmltag(k), m, {"dt:dt":t}));
  	});
  	return '<' + T + ' xmlns="' + XLMLNS.o + '">' + o.join("") + '</' + T + '>';
  }
  function write_FILETIME(time/*:string|Date*/) {
  	var date = (typeof time == "string") ? new Date(Date.parse(time)) : time;
  	var t = date.getTime() / 1000 + 11644473600;
  	var l = t % Math.pow(2,32), h = (t - l) / Math.pow(2,32);
  	l *= 1e7; h *= 1e7;
  	var w = (l / Math.pow(2,32)) | 0;
  	if(w > 0) { l = l % Math.pow(2,32); h += w; }
  	var o = new_buf(8); o.write_shift(4, l); o.write_shift(4, h); return o;
  }
  function write_TypedPropertyValue(type/*:number*/, value) {
  	var o = new_buf(4), p = new_buf(4);
  	o.write_shift(4, type == 0x50 ? 0x1F : type);
  	switch(type) {
  		case 0x03 /*VT_I4*/: p.write_shift(-4, value); break;
  		case 0x05 /*VT_I4*/: p = new_buf(8); p.write_shift(8, value, 'f'); break;
  		case 0x0B /*VT_BOOL*/: p.write_shift(4, value ? 0x01 : 0x00); break;
  		case 0x40 /*VT_FILETIME*/: /*:: if(typeof value !== "string" && !(value instanceof Date)) throw "unreachable"; */ p = write_FILETIME(value); break;
  		case 0x1F /*VT_LPWSTR*/:
  		case 0x50 /*VT_STRING*/:
  			/*:: if(typeof value !== "string") throw "unreachable"; */
  			p = new_buf(4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
  			p.write_shift(4, value.length + 1);
  			p.write_shift(0, value, "dbcs");
  			while(p.l != p.length) p.write_shift(1, 0);
  			break;
  		default: throw new Error("TypedPropertyValue unrecognized type " + type + " " + value);
  	}
  	return bconcat([o, p]);
  }
  var XLSPSSkip = [ "CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID" ]; //.concat(PseudoPropsPairs);
  function guess_property_type(val/*:any*/)/*:number*/ {
  	switch(typeof val) {
  		case "boolean": return 0x0B;
  		case "number": return ((val|0)==val) ? 0x03 : 0x05;
  		case "string": return 0x1F;
  		case "object": if(val instanceof Date) return 0x40; break;
  	}
  	return -1;
  }
  function write_PropertySet(entries, RE, PIDSI) {
  	var hdr = new_buf(8), piao = [], prop = [];
  	var sz = 8, i = 0;

  	var pr = new_buf(8), pio = new_buf(8);
  	pr.write_shift(4, 0x0002);
  	pr.write_shift(4, 0x04B0);
  	pio.write_shift(4, 0x0001);
  	prop.push(pr); piao.push(pio);
  	sz += 8 + pr.length;

  	if(!RE) {
  		pio = new_buf(8);
  		pio.write_shift(4, 0);
  		piao.unshift(pio);

  		var bufs = [new_buf(4)];
  		bufs[0].write_shift(4, entries.length);
  		for(i = 0; i < entries.length; ++i) {
  			var value = entries[i][0];
  			pr = new_buf(4 + 4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
  			pr.write_shift(4, i+2);
  			pr.write_shift(4, value.length + 1);
  			pr.write_shift(0, value, "dbcs");
  			while(pr.l != pr.length) pr.write_shift(1, 0);
  			bufs.push(pr);
  		}
  		pr = bconcat(bufs);
  		prop.unshift(pr);
  		sz += 8 + pr.length;
  	}

  	for(i = 0; i < entries.length; ++i) {
  		if(RE && !RE[entries[i][0]]) continue;
  		if(XLSPSSkip.indexOf(entries[i][0]) > -1 || PseudoPropsPairs.indexOf(entries[i][0]) > -1) continue;
  		if(entries[i][1] == null) continue;

  		var val = entries[i][1], idx = 0;
  		if(RE) {
  			idx = +RE[entries[i][0]];
  			var pinfo = (PIDSI/*:: || {}*/)[idx]/*:: || {} */;
  			if(pinfo.p == "version" && typeof val == "string") {
  				/*:: if(typeof val !== "string") throw "unreachable"; */
  				var arr = val.split(".");
  				val = ((+arr[0])<<16) + ((+arr[1])||0);
  			}
  			pr = write_TypedPropertyValue(pinfo.t, val);
  		} else {
  			var T = guess_property_type(val);
  			if(T == -1) { T = 0x1F; val = String(val); }
  			pr = write_TypedPropertyValue(T, val);
  		}
  		prop.push(pr);

  		pio = new_buf(8);
  		pio.write_shift(4, !RE ? 2+i : idx);
  		piao.push(pio);

  		sz += 8 + pr.length;
  	}

  	var w = 8 * (prop.length + 1);
  	for(i = 0; i < prop.length; ++i) { piao[i].write_shift(4, w); w += prop[i].length; }
  	hdr.write_shift(4, sz);
  	hdr.write_shift(4, prop.length);
  	return bconcat([hdr].concat(piao).concat(prop));
  }
  function write_PropertySetStream(entries, clsid, RE, PIDSI/*:{[key:string|number]:any}*/, entries2/*:?any*/, clsid2/*:?any*/) {
  	var hdr = new_buf(entries2 ? 68 : 48);
  	var bufs = [hdr];
  	hdr.write_shift(2, 0xFFFE);
  	hdr.write_shift(2, 0x0000); /* TODO: type 1 props */
  	hdr.write_shift(4, 0x32363237);
  	hdr.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex");
  	hdr.write_shift(4, (entries2 ? 2 : 1));
  	hdr.write_shift(16, clsid, "hex");
  	hdr.write_shift(4, (entries2 ? 68 : 48));
  	var ps0 = write_PropertySet(entries, RE, PIDSI);
  	bufs.push(ps0);

  	if(entries2) {
  		var ps1 = write_PropertySet(entries2, null, null);
  		hdr.write_shift(16, clsid2, "hex");
  		hdr.write_shift(4, 68 + ps0.length);
  		bufs.push(ps1);
  	}
  	return bconcat(bufs);
  }
  function writezeroes(n, o) { if(!o) o=new_buf(n); for(var j=0; j<n; ++j) o.write_shift(1, 0); return o; }

  function parsebool(blob, length/*:number*/) { return blob.read_shift(length) === 0x1; }
  function writebool(v/*:any*/, o) { if(!o) o=new_buf(2); o.write_shift(2, +!!v); return o; }

  function parseuint16(blob/*::, length:?number, opts:?any*/) { return blob.read_shift(2, 'u'); }
  function writeuint16(v/*:number*/, o) { if(!o) o=new_buf(2); o.write_shift(2, v); return o; }
  function write_Bes(v, t/*:string*/, o) {
  	if(!o) o = new_buf(2);
  	o.write_shift(1, ((t == 'e') ? +v : +!!v));
  	o.write_shift(1, ((t == 'e') ? 1 : 0));
  	return o;
  }

  /* [MS-XLS] 2.5.240 ShortXLUnicodeString */
  function parse_ShortXLUnicodeString(blob, length, opts) {
  	var cch = blob.read_shift(opts && opts.biff >= 12 ? 2 : 1);
  	var encoding = 'sbcs-cont';
  	if(opts && opts.biff >= 8) ;
  	if(!opts || opts.biff == 8 ) {
  		var fHighByte = blob.read_shift(1);
  		if(fHighByte) { encoding = 'dbcs-cont'; }
  	} else if(opts.biff == 12) {
  		encoding = 'wstr';
  	}
  	if(opts.biff >= 2 && opts.biff <= 5) encoding = 'cpstr';
  	var o = cch ? blob.read_shift(cch, encoding) : "";
  	return o;
  }
  function write_XLUnicodeRichExtendedString(xlstr/*:: :XLString, opts*/) {
  	var str = (xlstr.t||"");

  	var hdr = new_buf(3 + (0));
  	hdr.write_shift(2, str.length);
  	hdr.write_shift(1, (0x00) | 0x01);

  	var otext = new_buf(2 * str.length);
  	otext.write_shift(2 * str.length, str, 'utf16le');

  	var out = [hdr, otext];

  	return bconcat(out);
  }

  /* 2.5.296 XLUnicodeStringNoCch */
  function parse_XLUnicodeStringNoCch(blob, cch, opts) {
  	var retval;
  	if(opts) {
  		if(opts.biff >= 2 && opts.biff <= 5) return blob.read_shift(cch, 'cpstr');
  		if(opts.biff >= 12) return blob.read_shift(cch, 'dbcs-cont');
  	}
  	var fHighByte = blob.read_shift(1);
  	if(fHighByte===0) { retval = blob.read_shift(cch, 'sbcs-cont'); }
  	else { retval = blob.read_shift(cch, 'dbcs-cont'); }
  	return retval;
  }

  /* 2.5.294 XLUnicodeString */
  function parse_XLUnicodeString(blob, length, opts) {
  	var cch = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  	if(cch === 0) { blob.l++; return ""; }
  	return parse_XLUnicodeStringNoCch(blob, cch, opts);
  }
  /* BIFF5 override */
  function parse_XLUnicodeString2(blob, length, opts) {
  	if(opts.biff > 5) return parse_XLUnicodeString(blob, length, opts);
  	var cch = blob.read_shift(1);
  	if(cch === 0) { blob.l++; return ""; }
  	return blob.read_shift(cch, (opts.biff <= 4 || !blob.lens ) ? 'cpstr' : 'sbcs-cont');
  }
  /* TODO: BIFF5 and lower, codepage awareness */
  function write_XLUnicodeString(str, opts, o) {
  	if(!o) o = new_buf(3 + 2 * str.length);
  	o.write_shift(2, str.length);
  	o.write_shift(1, 1);
  	o.write_shift(31, str, 'utf16le');
  	return o;
  }
  function write_HyperlinkString(str/*:string*/, o) {
  	if(!o) o = new_buf(6 + str.length * 2);
  	o.write_shift(4, 1 + str.length);
  	for(var i = 0; i < str.length; ++i) o.write_shift(2, str.charCodeAt(i));
  	o.write_shift(2, 0);
  	return o;
  }
  function write_Hyperlink(hl) {
  	var out = new_buf(512), i = 0;
  	var Target = hl.Target;
  	if(Target.slice(0,7) == "file://") Target = Target.slice(7);
  	var hashidx = Target.indexOf("#");
  	var F = hashidx > -1 ? 0x1f : 0x17;
  	switch(Target.charAt(0)) { case "#": F=0x1c; break; case ".": F&=~2; break; }
  	out.write_shift(4,2); out.write_shift(4, F);
  	var data = [8,6815827,6619237,4849780,83]; for(i = 0; i < data.length; ++i) out.write_shift(4, data[i]);
  	if(F == 0x1C) {
  		Target = Target.slice(1);
  		write_HyperlinkString(Target, out);
  	} else if(F & 0x02) {
  		data = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
  		for(i = 0; i < data.length; ++i) out.write_shift(1, parseInt(data[i], 16));
  		var Pretarget = hashidx > -1 ? Target.slice(0, hashidx) : Target;
  		out.write_shift(4, 2*(Pretarget.length + 1));
  		for(i = 0; i < Pretarget.length; ++i) out.write_shift(2, Pretarget.charCodeAt(i));
  		out.write_shift(2, 0);
  		if(F & 0x08) write_HyperlinkString(hashidx > -1 ? Target.slice(hashidx+1): "", out);
  	} else {
  		data = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");
  		for(i = 0; i < data.length; ++i) out.write_shift(1, parseInt(data[i], 16));
  		var P = 0;
  		while(Target.slice(P*3,P*3+3)=="../"||Target.slice(P*3,P*3+3)=="..\\") ++P;
  		out.write_shift(2, P);
  		out.write_shift(4, Target.length - 3 * P + 1);
  		for(i = 0; i < Target.length - 3 * P; ++i) out.write_shift(1, Target.charCodeAt(i + 3 * P) & 0xFF);
  		out.write_shift(1, 0);
  		out.write_shift(2, 0xFFFF);
  		out.write_shift(2, 0xDEAD);
  		for(i = 0; i < 6; ++i) out.write_shift(4, 0);
  	}
  	return out.slice(0, out.l);
  }
  function write_XLSCell(R/*:number*/, C/*:number*/, ixfe/*:?number*/, o) {
  	if(!o) o = new_buf(6);
  	o.write_shift(2, R);
  	o.write_shift(2, C);
  	o.write_shift(2, ixfe||0);
  	return o;
  }

  /* [MS-XLS] 2.5.344 */
  function parse_XTI(blob, length, opts) {
  	var w = opts.biff > 8 ? 4 : 2;
  	var iSupBook = blob.read_shift(w), itabFirst = blob.read_shift(w,'i'), itabLast = blob.read_shift(w,'i');
  	return [iSupBook, itabFirst, itabLast];
  }

  /* [MS-XLS] 2.5.209 TODO: Check sizes */
  function parse_Ref8U(blob/*::, length*/) {
  	var rwFirst = blob.read_shift(2);
  	var rwLast = blob.read_shift(2);
  	var colFirst = blob.read_shift(2);
  	var colLast = blob.read_shift(2);
  	return {s:{c:colFirst, r:rwFirst}, e:{c:colLast,r:rwLast}};
  }
  function write_Ref8U(r/*:Range*/, o) {
  	if(!o) o = new_buf(8);
  	o.write_shift(2, r.s.r);
  	o.write_shift(2, r.e.r);
  	o.write_shift(2, r.s.c);
  	o.write_shift(2, r.e.c);
  	return o;
  }
  function write_BOF(wb/*:Workbook*/, t/*:number*/, o) {
  	var h = 0x0600, w = 16;
  	switch(o.bookType) {
  		case 'biff8': break;
  		case 'biff5': h = 0x0500; w = 8; break;
  		case 'biff4': h = 0x0004; w = 6; break;
  		case 'biff3': h = 0x0003; w = 6; break;
  		case 'biff2': h = 0x0002; w = 4; break;
  		case 'xla': break;
  		default: throw new Error("unsupported BIFF version");
  	}
  	var out = new_buf(w);
  	out.write_shift(2, h);
  	out.write_shift(2, t);
  	if(w > 4) out.write_shift(2, 0x7262);
  	if(w > 6) out.write_shift(2, 0x07CD);
  	if(w > 8) {
  		out.write_shift(2, 0xC009);
  		out.write_shift(2, 0x0001);
  		out.write_shift(2, 0x0706);
  		out.write_shift(2, 0x0000);
  	}
  	return out;
  }
  function write_WriteAccess(s/*:string*/, opts) {
  	var b8 = !opts || opts.biff == 8;
  	var o = new_buf(b8 ? 112 : 54);
  	o.write_shift(opts.biff == 8 ? 2 : 1, 7);
  	if(b8) o.write_shift(1, 0);
  	o.write_shift(4, 0x33336853);
  	o.write_shift(4, (0x00534A74 | (b8 ? 0 : 0x20000000)));
  	while(o.l < o.length) o.write_shift(1, (b8 ? 0 : 32));
  	return o;
  }
  function write_BoundSheet8(data, opts) {
  	var w = (!opts || opts.biff >= 8 ? 2 : 1);
  	var o = new_buf(8 + w * data.name.length);
  	o.write_shift(4, data.pos);
  	o.write_shift(1, data.hs || 0);
  	o.write_shift(1, data.dt);
  	o.write_shift(1, data.name.length);
  	if(opts.biff >= 8) o.write_shift(1, 1);
  	o.write_shift(w * data.name.length, data.name, opts.biff < 8 ? 'sbcs' : 'utf16le');
  	var out = o.slice(0, o.l);
  	out.l = o.l; return out;
  }
  function write_SST(sst, opts) {
  	var header = new_buf(8);
  	header.write_shift(4, sst.Count);
  	header.write_shift(4, sst.Unique);
  	var strs = [];
  	for(var j = 0; j < sst.length; ++j) strs[j] = write_XLUnicodeRichExtendedString(sst[j]);
  	var o = bconcat([header].concat(strs));
  	/*::(*/o/*:: :any)*/.parts = [header.length].concat(strs.map(function(str) { return str.length; }));
  	return o;
  }
  function write_Window1(/*::opts*/) {
  	var o = new_buf(18);
  	o.write_shift(2, 0);
  	o.write_shift(2, 0);
  	o.write_shift(2, 0x7260);
  	o.write_shift(2, 0x44c0);
  	o.write_shift(2, 0x38);
  	o.write_shift(2, 0);
  	o.write_shift(2, 0);
  	o.write_shift(2, 1);
  	o.write_shift(2, 0x01f4);
  	return o;
  }
  function write_Window2(view) {
  	var o = new_buf(18), f = 0x6b6;
  	if(view && view.RTL) f |= 0x40;
  	o.write_shift(2, f);
  	o.write_shift(4, 0);
  	o.write_shift(4, 64);
  	o.write_shift(4, 0);
  	o.write_shift(4, 0);
  	return o;
  }
  function write_Font(data, opts) {
  	var name = data.name || "Arial";
  	var b5 = (opts && (opts.biff == 5)), w = (b5 ? (15 + name.length) : (16 + 2 * name.length));
  	var o = new_buf(w);
  	o.write_shift(2, (data.sz || 12) * 20);
  	o.write_shift(4, 0);
  	o.write_shift(2, 400);
  	o.write_shift(4, 0);
  	o.write_shift(2, 0);
  	o.write_shift(1, name.length);
  	if(!b5) o.write_shift(1, 1);
  	o.write_shift((b5 ? 1 : 2) * name.length, name, (b5 ? "sbcs" : "utf16le"));
  	return o;
  }
  function write_LabelSst(R/*:number*/, C/*:number*/, v/*:number*/, os/*:number*/ /*::, opts*/) {
  	var o = new_buf(10);
  	write_XLSCell(R, C, os, o);
  	o.write_shift(4, v);
  	return o;
  }
  function write_Label(R/*:number*/, C/*:number*/, v/*:string*/, os/*:number*/, opts) {
  	var b8 = !opts || opts.biff == 8;
  	var o = new_buf(6 + 2 + (+b8) + (1 + b8) * v.length);
  	write_XLSCell(R, C, os, o);
  	o.write_shift(2, v.length);
  	if(b8) o.write_shift(1, 1);
  	o.write_shift((1 + b8) * v.length, v, b8 ? 'utf16le' : 'sbcs');
  	return o;
  }
  function write_Format(i/*:number*/, f/*:string*/, opts, o) {
  	var b5 = (opts && (opts.biff == 5));
  	if(!o) o = new_buf(b5 ? (3 + f.length) : (5 + 2 * f.length));
  	o.write_shift(2, i);
  	o.write_shift((b5 ? 1 : 2), f.length);
  	if(!b5) o.write_shift(1, 1);
  	o.write_shift((b5 ? 1 : 2) * f.length, f, (b5 ? 'sbcs' : 'utf16le'));
  	var out = (o.length > o.l) ? o.slice(0, o.l) : o;
  	if(out.l == null) out.l = out.length;
  	return out;
  }
  function write_Dimensions(range, opts) {
  	var w = opts.biff == 8 || !opts.biff ? 4 : 2;
  	var o = new_buf(2*w + 6);
  	o.write_shift(w, range.s.r);
  	o.write_shift(w, range.e.r + 1);
  	o.write_shift(2, range.s.c);
  	o.write_shift(2, range.e.c + 1);
  	o.write_shift(2, 0);
  	return o;
  }
  function write_XF(data, ixfeP, opts, o) {
  	var b5 = (opts && (opts.biff == 5));
  	if(!o) o = new_buf(b5 ? 16 : 20);
  	o.write_shift(2, 0);
  	if(data.style) {
  		o.write_shift(2, (data.numFmtId||0));
  		o.write_shift(2, 0xFFF4);
  	} else {
  		o.write_shift(2, (data.numFmtId||0));
  		o.write_shift(2, (ixfeP<<4));
  	}
  	var f = 0;
  	if(data.numFmtId > 0 && b5) f |= 0x0400;
  	o.write_shift(4, f);
  	o.write_shift(4, 0);
  	if(!b5) o.write_shift(4, 0);
  	o.write_shift(2, 0);
  	return o;
  }
  function write_Guts(guts/*:Array<number>*/) {
  	var o = new_buf(8);
  	o.write_shift(4, 0);
  	o.write_shift(2, guts[0] ? guts[0] + 1 : 0);
  	o.write_shift(2, guts[1] ? guts[1] + 1 : 0);
  	return o;
  }
  function write_BoolErr(R/*:number*/, C/*:number*/, v, os/*:number*/, opts, t/*:string*/) {
  	var o = new_buf(8);
  	write_XLSCell(R, C, os, o);
  	write_Bes(v, t, o);
  	return o;
  }
  function write_Number(R/*:number*/, C/*:number*/, v, os/*:: :number, opts*/) {
  	var o = new_buf(14);
  	write_XLSCell(R, C, os, o);
  	write_Xnum(v, o);
  	return o;
  }

  /* [MS-XLS] 2.4.106 TODO: verify filename encoding */
  function parse_ExternSheet(blob, length, opts) {
  	if(opts.biff < 8) return parse_BIFF5ExternSheet(blob, length, opts);
  	var o = [], target = blob.l + length, len = blob.read_shift(opts.biff > 8 ? 4 : 2);
  	while(len-- !== 0) o.push(parse_XTI(blob, opts.biff > 8 ? 12 : 6, opts));
  		// [iSupBook, itabFirst, itabLast];
  	if(blob.l != target) throw new Error("Bad ExternSheet: " + blob.l + " != " + target);
  	return o;
  }
  function parse_BIFF5ExternSheet(blob, length, opts) {
  	if(blob[blob.l + 1] == 0x03) blob[blob.l]++;
  	var o = parse_ShortXLUnicodeString(blob, length, opts);
  	return o.charCodeAt(0) == 0x03 ? o.slice(1) : o;
  }
  function write_MergeCells(merges/*:Array<Range>*/) {
  	var o = new_buf(2 + merges.length * 8);
  	o.write_shift(2, merges.length);
  	for(var i = 0; i < merges.length; ++i) write_Ref8U(merges[i], o);
  	return o;
  }
  function write_HLink(hl) {
  	var O = new_buf(24);
  	var ref = decode_cell(hl[0]);
  	O.write_shift(2, ref.r); O.write_shift(2, ref.r);
  	O.write_shift(2, ref.c); O.write_shift(2, ref.c);
  	var clsid = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
  	for(var i = 0; i < 16; ++i) O.write_shift(1, parseInt(clsid[i], 16));
  	return bconcat([O, write_Hyperlink(hl[1])]);
  }
  function write_HLinkTooltip(hl) {
  	var TT = hl[1].Tooltip;
  	var O = new_buf(10 + 2 * (TT.length + 1));
  	O.write_shift(2, 0x0800);
  	var ref = decode_cell(hl[0]);
  	O.write_shift(2, ref.r); O.write_shift(2, ref.r);
  	O.write_shift(2, ref.c); O.write_shift(2, ref.c);
  	for(var i = 0; i < TT.length; ++i) O.write_shift(2, TT.charCodeAt(i));
  	O.write_shift(2, 0);
  	return O;
  }
  function write_Country(o) {
  	if(!o) o = new_buf(4);
  	o.write_shift(2, 0x01);
  	o.write_shift(2, 0x01);
  	return o;
  }

  /* [MS-XLS] 2.4.53 TODO: parse flags */
  /* [MS-XLSB] 2.4.323 TODO: parse flags */
  function parse_ColInfo(blob, length, opts) {
  	if(!opts.cellStyles) return parsenoop(blob, length);
  	var w = opts && opts.biff >= 12 ? 4 : 2;
  	var colFirst = blob.read_shift(w);
  	var colLast = blob.read_shift(w);
  	var coldx = blob.read_shift(w);
  	var ixfe = blob.read_shift(w);
  	var flags = blob.read_shift(2);
  	if(w == 2) blob.l += 2;
  	var o = ({s:colFirst, e:colLast, w:coldx, ixfe:ixfe, flags:flags}/*:any*/);
  	if(opts.biff >= 5 || !opts.biff) o.level = (flags >> 8) & 0x7;
  	return o;
  }
  function write_ColInfo(col, idx) {
  	var o = new_buf(12);
  	o.write_shift(2, idx);
  	o.write_shift(2, idx);
  	o.write_shift(2, col.width * 256);
  	o.write_shift(2, 0);
  	var f = 0;
  	if(col.hidden) f |= 1;
  	o.write_shift(1, f);
  	f = col.level || 0;
  	o.write_shift(1, f);
  	o.write_shift(2, 0);
  	return o;
  }

  /* [MS-XLS] 2.4.241 */
  function write_RRTabId(n/*:number*/) {
  	var out = new_buf(2 * n);
  	for(var i = 0; i < n; ++i) out.write_shift(2, i+1);
  	return out;
  }
  function write_BIFF2NUM(r/*:number*/, c/*:number*/, val/*:number*/) {
  	var out = new_buf(15);
  	write_BIFF2Cell(out, r, c);
  	out.write_shift(8, val, 'f');
  	return out;
  }
  function write_BIFF2INT(r/*:number*/, c/*:number*/, val/*:number*/) {
  	var out = new_buf(9);
  	write_BIFF2Cell(out, r, c);
  	out.write_shift(2, val);
  	return out;
  }
  var DBF = /*#__PURE__*/(function() {
  var dbf_codepage_map = {
  	/* Code Pages Supported by Visual FoxPro */
  	/*::[*/0x01/*::]*/:   437,           /*::[*/0x02/*::]*/:   850,
  	/*::[*/0x03/*::]*/:  1252,           /*::[*/0x04/*::]*/: 10000,
  	/*::[*/0x64/*::]*/:   852,           /*::[*/0x65/*::]*/:   866,
  	/*::[*/0x66/*::]*/:   865,           /*::[*/0x67/*::]*/:   861,
  	/*::[*/0x68/*::]*/:   895,           /*::[*/0x69/*::]*/:   620,
  	/*::[*/0x6A/*::]*/:   737,           /*::[*/0x6B/*::]*/:   857,
  	/*::[*/0x78/*::]*/:   950,           /*::[*/0x79/*::]*/:   949,
  	/*::[*/0x7A/*::]*/:   936,           /*::[*/0x7B/*::]*/:   932,
  	/*::[*/0x7C/*::]*/:   874,           /*::[*/0x7D/*::]*/:  1255,
  	/*::[*/0x7E/*::]*/:  1256,           /*::[*/0x96/*::]*/: 10007,
  	/*::[*/0x97/*::]*/: 10029,           /*::[*/0x98/*::]*/: 10006,
  	/*::[*/0xC8/*::]*/:  1250,           /*::[*/0xC9/*::]*/:  1251,
  	/*::[*/0xCA/*::]*/:  1254,           /*::[*/0xCB/*::]*/:  1253,

  	/* shapefile DBF extension */
  	/*::[*/0x00/*::]*/: 20127,           /*::[*/0x08/*::]*/:   865,
  	/*::[*/0x09/*::]*/:   437,           /*::[*/0x0A/*::]*/:   850,
  	/*::[*/0x0B/*::]*/:   437,           /*::[*/0x0D/*::]*/:   437,
  	/*::[*/0x0E/*::]*/:   850,           /*::[*/0x0F/*::]*/:   437,
  	/*::[*/0x10/*::]*/:   850,           /*::[*/0x11/*::]*/:   437,
  	/*::[*/0x12/*::]*/:   850,           /*::[*/0x13/*::]*/:   932,
  	/*::[*/0x14/*::]*/:   850,           /*::[*/0x15/*::]*/:   437,
  	/*::[*/0x16/*::]*/:   850,           /*::[*/0x17/*::]*/:   865,
  	/*::[*/0x18/*::]*/:   437,           /*::[*/0x19/*::]*/:   437,
  	/*::[*/0x1A/*::]*/:   850,           /*::[*/0x1B/*::]*/:   437,
  	/*::[*/0x1C/*::]*/:   863,           /*::[*/0x1D/*::]*/:   850,
  	/*::[*/0x1F/*::]*/:   852,           /*::[*/0x22/*::]*/:   852,
  	/*::[*/0x23/*::]*/:   852,           /*::[*/0x24/*::]*/:   860,
  	/*::[*/0x25/*::]*/:   850,           /*::[*/0x26/*::]*/:   866,
  	/*::[*/0x37/*::]*/:   850,           /*::[*/0x40/*::]*/:   852,
  	/*::[*/0x4D/*::]*/:   936,           /*::[*/0x4E/*::]*/:   949,
  	/*::[*/0x4F/*::]*/:   950,           /*::[*/0x50/*::]*/:   874,
  	/*::[*/0x57/*::]*/:  1252,           /*::[*/0x58/*::]*/:  1252,
  	/*::[*/0x59/*::]*/:  1252,           /*::[*/0x6C/*::]*/:   863,
  	/*::[*/0x86/*::]*/:   737,           /*::[*/0x87/*::]*/:   852,
  	/*::[*/0x88/*::]*/:   857,           /*::[*/0xCC/*::]*/:  1257,

  	/*::[*/0xFF/*::]*/: 16969
  };
  var dbf_reverse_map = evert({
  	/*::[*/0x01/*::]*/:   437,           /*::[*/0x02/*::]*/:   850,
  	/*::[*/0x03/*::]*/:  1252,           /*::[*/0x04/*::]*/: 10000,
  	/*::[*/0x64/*::]*/:   852,           /*::[*/0x65/*::]*/:   866,
  	/*::[*/0x66/*::]*/:   865,           /*::[*/0x67/*::]*/:   861,
  	/*::[*/0x68/*::]*/:   895,           /*::[*/0x69/*::]*/:   620,
  	/*::[*/0x6A/*::]*/:   737,           /*::[*/0x6B/*::]*/:   857,
  	/*::[*/0x78/*::]*/:   950,           /*::[*/0x79/*::]*/:   949,
  	/*::[*/0x7A/*::]*/:   936,           /*::[*/0x7B/*::]*/:   932,
  	/*::[*/0x7C/*::]*/:   874,           /*::[*/0x7D/*::]*/:  1255,
  	/*::[*/0x7E/*::]*/:  1256,           /*::[*/0x96/*::]*/: 10007,
  	/*::[*/0x97/*::]*/: 10029,           /*::[*/0x98/*::]*/: 10006,
  	/*::[*/0xC8/*::]*/:  1250,           /*::[*/0xC9/*::]*/:  1251,
  	/*::[*/0xCA/*::]*/:  1254,           /*::[*/0xCB/*::]*/:  1253,
  	/*::[*/0x00/*::]*/: 20127
  });
  /* TODO: find an actual specification */
  function dbf_to_aoa(buf, opts)/*:AOA*/ {
  	var out/*:AOA*/ = [];
  	var d/*:Block*/ = (new_raw_buf(1)/*:any*/);
  	switch(opts.type) {
  		case 'base64': d = s2a(Base64_decode(buf)); break;
  		case 'binary': d = s2a(buf); break;
  		case 'buffer':
  		case 'array': d = buf; break;
  	}
  	prep_blob(d, 0);

  	/* header */
  	var ft = d.read_shift(1);
  	var memo = !!(ft & 0x88);
  	var vfp = false, l7 = false;
  	switch(ft) {
  		case 0x02: break; // dBASE II
  		case 0x03: break; // dBASE III
  		case 0x30: vfp = true; memo = true; break; // VFP
  		case 0x31: vfp = true; memo = true; break; // VFP with autoincrement
  		// 0x43 dBASE IV SQL table files
  		// 0x63 dBASE IV SQL system files
  		case 0x83: break; // dBASE III with memo
  		case 0x8B: break; // dBASE IV with memo
  		case 0x8C: l7 = true; break; // dBASE Level 7 with memo
  		// case 0xCB dBASE IV SQL table files with memo
  		case 0xF5: break; // FoxPro 2.x with memo
  		// case 0xFB FoxBASE
  		default: throw new Error("DBF Unsupported Version: " + ft.toString(16));
  	}

  	var nrow = 0, fpos = 0x0209;
  	if(ft == 0x02) nrow = d.read_shift(2);
  	d.l += 3; // dBASE II stores DDMMYY date, others use YYMMDD
  	if(ft != 0x02) nrow = d.read_shift(4);
  	if(nrow > 1048576) nrow = 1e6;

  	if(ft != 0x02) fpos = d.read_shift(2); // header length
  	var rlen = d.read_shift(2); // record length

  	var /*flags = 0,*/ current_cp = opts.codepage || 1252;
  	if(ft != 0x02) { // 20 reserved bytes
  		d.l+=16;
  		/*flags = */d.read_shift(1);
  		//if(memo && ((flags & 0x02) === 0)) throw new Error("DBF Flags " + flags.toString(16) + " ft " + ft.toString(16));

  		/* codepage present in FoxPro and dBASE Level 7 */
  		if(d[d.l] !== 0) current_cp = dbf_codepage_map[d[d.l]];
  		d.l+=1;

  		d.l+=2;
  	}
  	if(l7) d.l += 36; // Level 7: 32 byte "Language driver name", 4 byte reserved

  /*:: type DBFField = { name:string; len:number; type:string; } */
  	var fields/*:Array<DBFField>*/ = [], field/*:DBFField*/ = ({}/*:any*/);
  	var hend = Math.min(d.length, (ft == 0x02 ? 0x209 : (fpos - 10 - (vfp ? 264 : 0))));
  	var ww = l7 ? 32 : 11;
  	while(d.l < hend && d[d.l] != 0x0d) {
  		field = ({}/*:any*/);
  		field.name = $cptable.utils.decode(current_cp, d.slice(d.l, d.l+ww)).replace(/[\u0000\r\n].*$/g,"");
  		d.l += ww;
  		field.type = String.fromCharCode(d.read_shift(1));
  		if(ft != 0x02 && !l7) field.offset = d.read_shift(4);
  		field.len = d.read_shift(1);
  		if(ft == 0x02) field.offset = d.read_shift(2);
  		field.dec = d.read_shift(1);
  		if(field.name.length) fields.push(field);
  		if(ft != 0x02) d.l += l7 ? 13 : 14;
  		switch(field.type) {
  			case 'B': // Double (VFP) / Binary (dBASE L7)
  				if((!vfp || field.len != 8) && opts.WTF) console.log('Skipping ' + field.name + ':' + field.type);
  				break;
  			case 'G': // General (FoxPro and dBASE L7)
  			case 'P': // Picture (FoxPro and dBASE L7)
  				if(opts.WTF) console.log('Skipping ' + field.name + ':' + field.type);
  				break;
  			case '+': // Autoincrement (dBASE L7 only)
  			case '0': // _NullFlags (VFP only)
  			case '@': // Timestamp (dBASE L7 only)
  			case 'C': // Character (dBASE II)
  			case 'D': // Date (dBASE III)
  			case 'F': // Float (dBASE IV)
  			case 'I': // Long (VFP and dBASE L7)
  			case 'L': // Logical (dBASE II)
  			case 'M': // Memo (dBASE III)
  			case 'N': // Number (dBASE II)
  			case 'O': // Double (dBASE L7 only)
  			case 'T': // Datetime (VFP only)
  			case 'Y': // Currency (VFP only)
  				break;
  			default: throw new Error('Unknown Field Type: ' + field.type);
  		}
  	}

  	if(d[d.l] !== 0x0D) d.l = fpos-1;
  	if(d.read_shift(1) !== 0x0D) throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);
  	d.l = fpos;

  	/* data */
  	var R = 0, C = 0;
  	out[0] = [];
  	for(C = 0; C != fields.length; ++C) out[0][C] = fields[C].name;
  	while(nrow-- > 0) {
  		if(d[d.l] === 0x2A) {
  			// TODO: record marked as deleted -- create a hidden row?
  			d.l+=rlen;
  			continue;
  		}
  		++d.l;
  		out[++R] = []; C = 0;
  		for(C = 0; C != fields.length; ++C) {
  			var dd = d.slice(d.l, d.l+fields[C].len); d.l+=fields[C].len;
  			prep_blob(dd, 0);
  			var s = $cptable.utils.decode(current_cp, dd);
  			switch(fields[C].type) {
  				case 'C':
  					// NOTE: it is conventional to write '  /  /  ' for empty dates
  					if(s.trim().length) out[R][C] = s.replace(/\s+$/,"");
  					break;
  				case 'D':
  					if(s.length === 8) out[R][C] = new Date(+s.slice(0,4), +s.slice(4,6)-1, +s.slice(6,8));
  					else out[R][C] = s;
  					break;
  				case 'F': out[R][C] = parseFloat(s.trim()); break;
  				case '+': case 'I': out[R][C] = l7 ? dd.read_shift(-4, 'i') ^ 0x80000000 : dd.read_shift(4, 'i'); break;
  				case 'L': switch(s.trim().toUpperCase()) {
  					case 'Y': case 'T': out[R][C] = true; break;
  					case 'N': case 'F': out[R][C] = false; break;
  					case '': case '?': break;
  					default: throw new Error("DBF Unrecognized L:|" + s + "|");
  					} break;
  				case 'M': /* TODO: handle memo files */
  					if(!memo) throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));
  					out[R][C] = "##MEMO##" + (l7 ? parseInt(s.trim(), 10): dd.read_shift(4));
  					break;
  				case 'N':
  					s = s.replace(/\u0000/g,"").trim();
  					// NOTE: dBASE II interprets "  .  " as 0
  					if(s && s != ".") out[R][C] = +s || 0; break;
  				case '@':
  					// NOTE: dBASE specs appear to be incorrect
  					out[R][C] = new Date(dd.read_shift(-8, 'f') - 0x388317533400);
  					break;
  				case 'T': out[R][C] = new Date((dd.read_shift(4) - 0x253D8C) * 0x5265C00 + dd.read_shift(4)); break;
  				case 'Y': out[R][C] = dd.read_shift(4,'i')/1e4 + (dd.read_shift(4, 'i')/1e4)*Math.pow(2,32); break;
  				case 'O': out[R][C] = -dd.read_shift(-8, 'f'); break;
  				case 'B': if(vfp && fields[C].len == 8) { out[R][C] = dd.read_shift(8,'f'); break; }
  					/* falls through */
  				case 'G': case 'P': dd.l += fields[C].len; break;
  				case '0':
  					if(fields[C].name === '_NullFlags') break;
  					/* falls through */
  				default: throw new Error("DBF Unsupported data type " + fields[C].type);
  			}
  		}
  	}
  	if(ft != 0x02) if(d.l < d.length && d[d.l++] != 0x1A) throw new Error("DBF EOF Marker missing " + (d.l-1) + " of " + d.length + " " + d[d.l-1].toString(16));
  	if(opts && opts.sheetRows) out = out.slice(0, opts.sheetRows);
  	opts.DBF = fields;
  	return out;
  }

  function dbf_to_sheet(buf, opts)/*:Worksheet*/ {
  	var o = opts || {};
  	if(!o.dateNF) o.dateNF = "yyyymmdd";
  	var ws = aoa_to_sheet(dbf_to_aoa(buf, o), o);
  	ws["!cols"] = o.DBF.map(function(field) { return {
  		wch: field.len,
  		DBF: field
  	};});
  	delete o.DBF;
  	return ws;
  }

  function dbf_to_workbook(buf, opts)/*:Workbook*/ {
  	try { return sheet_to_workbook(dbf_to_sheet(buf, opts), opts); }
  	catch(e) { if(opts && opts.WTF) throw e; }
  	return ({SheetNames:[],Sheets:{}});
  }

  var _RLEN = { 'B': 8, 'C': 250, 'L': 1, 'D': 8, '?': 0, '': 0 };
  function sheet_to_dbf(ws/*:Worksheet*/, opts/*:WriteOpts*/) {
  	var o = opts || {};
  	if(+o.codepage >= 0) set_cp(+o.codepage);
  	if(o.type == "string") throw new Error("Cannot write DBF to JS string");
  	var ba = buf_array();
  	var aoa/*:AOA*/ = sheet_to_json(ws, {header:1, raw:true, cellDates:true});
  	var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];
  	var i = 0, j = 0, hcnt = 0, rlen = 1;
  	for(i = 0; i < headers.length; ++i) {
  		if(((cols[i]||{}).DBF||{}).name) { headers[i] = cols[i].DBF.name; ++hcnt; continue; }
  		if(headers[i] == null) continue;
  		++hcnt;
  		if(typeof headers[i] === 'number') headers[i] = headers[i].toString(10);
  		if(typeof headers[i] !== 'string') throw new Error("DBF Invalid column name " + headers[i] + " |" + (typeof headers[i]) + "|");
  		if(headers.indexOf(headers[i]) !== i) for(j=0; j<1024;++j)
  			if(headers.indexOf(headers[i] + "_" + j) == -1) { headers[i] += "_" + j; break; }
  	}
  	var range = safe_decode_range(ws['!ref']);
  	var coltypes/*:Array<string>*/ = [];
  	var colwidths/*:Array<number>*/ = [];
  	var coldecimals/*:Array<number>*/ = [];
  	for(i = 0; i <= range.e.c - range.s.c; ++i) {
  		var guess = '', _guess = '', maxlen = 0;
  		var col/*:Array<any>*/ = [];
  		for(j=0; j < data.length; ++j) {
  			if(data[j][i] != null) col.push(data[j][i]);
  		}
  		if(col.length == 0 || headers[i] == null) { coltypes[i] = '?'; continue; }
  		for(j = 0; j < col.length; ++j) {
  			switch(typeof col[j]) {
  				/* TODO: check if L2 compat is desired */
  				case 'number': _guess = 'B'; break;
  				case 'string': _guess = 'C'; break;
  				case 'boolean': _guess = 'L'; break;
  				case 'object': _guess = col[j] instanceof Date ? 'D' : 'C'; break;
  				default: _guess = 'C';
  			}
  			maxlen = Math.max(maxlen, String(col[j]).length);
  			guess = guess && guess != _guess ? 'C' : _guess;
  			//if(guess == 'C') break;
  		}
  		if(maxlen > 250) maxlen = 250;
  		_guess = ((cols[i]||{}).DBF||{}).type;
  		/* TODO: more fine grained control over DBF type resolution */
  		if(_guess == 'C') {
  			if(cols[i].DBF.len > maxlen) maxlen = cols[i].DBF.len;
  		}
  		if(guess == 'B' && _guess == 'N') {
  			guess = 'N';
  			coldecimals[i] = cols[i].DBF.dec;
  			maxlen = cols[i].DBF.len;
  		}
  		colwidths[i] = guess == 'C' || _guess == 'N' ? maxlen : (_RLEN[guess] || 0);
  		rlen += colwidths[i];
  		coltypes[i] = guess;
  	}

  	var h = ba.next(32);
  	h.write_shift(4, 0x13021130);
  	h.write_shift(4, data.length);
  	h.write_shift(2, 296 + 32 * hcnt);
  	h.write_shift(2, rlen);
  	for(i=0; i < 4; ++i) h.write_shift(4, 0);
  	h.write_shift(4, 0x00000000 | ((+dbf_reverse_map[/*::String(*/current_ansi/*::)*/] || 0x03)<<8));

  	for(i = 0, j = 0; i < headers.length; ++i) {
  		if(headers[i] == null) continue;
  		var hf = ba.next(32);
  		var _f = (headers[i].slice(-10) + "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00").slice(0, 11);
  		hf.write_shift(1, _f, "sbcs");
  		hf.write_shift(1, coltypes[i] == '?' ? 'C' : coltypes[i], "sbcs");
  		hf.write_shift(4, j);
  		hf.write_shift(1, colwidths[i] || _RLEN[coltypes[i]] || 0);
  		hf.write_shift(1, coldecimals[i] || 0);
  		hf.write_shift(1, 0x02);
  		hf.write_shift(4, 0);
  		hf.write_shift(1, 0);
  		hf.write_shift(4, 0);
  		hf.write_shift(4, 0);
  		j += (colwidths[i] || _RLEN[coltypes[i]] || 0);
  	}

  	var hb = ba.next(264);
  	hb.write_shift(4, 0x0000000D);
  	for(i=0; i < 65;++i) hb.write_shift(4, 0x00000000);
  	for(i=0; i < data.length; ++i) {
  		var rout = ba.next(rlen);
  		rout.write_shift(1, 0);
  		for(j=0; j<headers.length; ++j) {
  			if(headers[j] == null) continue;
  			switch(coltypes[j]) {
  				case 'L': rout.write_shift(1, data[i][j] == null ? 0x3F : data[i][j] ? 0x54 : 0x46); break;
  				case 'B': rout.write_shift(8, data[i][j]||0, 'f'); break;
  				case 'N':
  					var _n = "0";
  					if(typeof data[i][j] == "number") _n = data[i][j].toFixed(coldecimals[j]||0);
  					for(hcnt=0; hcnt < colwidths[j]-_n.length; ++hcnt) rout.write_shift(1, 0x20);
  					rout.write_shift(1, _n, "sbcs");
  					break;
  				case 'D':
  					if(!data[i][j]) rout.write_shift(8, "00000000", "sbcs");
  					else {
  						rout.write_shift(4, ("0000"+data[i][j].getFullYear()).slice(-4), "sbcs");
  						rout.write_shift(2, ("00"+(data[i][j].getMonth()+1)).slice(-2), "sbcs");
  						rout.write_shift(2, ("00"+data[i][j].getDate()).slice(-2), "sbcs");
  					} break;
  				case 'C':
  					var _s = String(data[i][j] != null ? data[i][j] : "").slice(0, colwidths[j]);
  					rout.write_shift(1, _s, "sbcs");
  					for(hcnt=0; hcnt < colwidths[j]-_s.length; ++hcnt) rout.write_shift(1, 0x20); break;
  			}
  		}
  		// data
  	}
  	ba.next(1).write_shift(1, 0x1A);
  	return ba.end();
  }
  	return {
  		to_workbook: dbf_to_workbook,
  		to_sheet: dbf_to_sheet,
  		from_sheet: sheet_to_dbf
  	};
  })();

  var SYLK = /*#__PURE__*/(function() {
  	/* TODO: stress test sequences */
  	var sylk_escapes = ({
  		AA:'', BA:'', CA:'', DA:195, HA:'', JA:197,
  		AE:'', BE:'', CE:'',         HE:'',
  		AI:'', BI:'', CI:'',         HI:'',
  		AO:'', BO:'', CO:'', DO:213, HO:'',
  		AU:'', BU:'', CU:'',         HU:'',
  		Aa:'', Ba:'', Ca:'', Da:227, Ha:'', Ja:229,
  		Ae:'', Be:'', Ce:'',         He:'',
  		Ai:'', Bi:'', Ci:'',         Hi:'',
  		Ao:'', Bo:'', Co:'', Do:245, Ho:'',
  		Au:'', Bu:'', Cu:'',         Hu:'',
  		KC:'', Kc:'', q:'',  z:'',  a:'',  j:'',
  		DN:209, Dn:241, Hy:255,
  		S:169,  c:170,  R:174,  "B ":180,
  		/*::[*/0/*::]*/:176,    /*::[*/1/*::]*/:177,  /*::[*/2/*::]*/:178,
  		/*::[*/3/*::]*/:179,    /*::[*/5/*::]*/:181,  /*::[*/6/*::]*/:182,
  		/*::[*/7/*::]*/:183,    Q:185,  k:186,  b:208,  i:216,  l:222,  s:240,  y:248,
  		"!":161, '"':162, "#":163, "(":164, "%":165, "'":167, "H ":168,
  		"+":171, ";":187, "<":188, "=":189, ">":190, "?":191, "{":223
  	}/*:any*/);
  	var sylk_char_regex = new RegExp("\u001BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g,"\\$1") + "|\\|)", "gm");
  	var sylk_char_fn = function(_, $1){ var o = sylk_escapes[$1]; return typeof o == "number" ? _getansi(o) : o; };
  	var decode_sylk_char = function($$, $1, $2) { var newcc = (($1.charCodeAt(0) - 0x20)<<4) | ($2.charCodeAt(0) - 0x30); return newcc == 59 ? $$ : _getansi(newcc); };
  	sylk_escapes["|"] = 254;
  	/* TODO: find an actual specification */
  	function sylk_to_aoa(d/*:RawData*/, opts)/*:[AOA, Worksheet]*/ {
  		switch(opts.type) {
  			case 'base64': return sylk_to_aoa_str(Base64_decode(d), opts);
  			case 'binary': return sylk_to_aoa_str(d, opts);
  			case 'buffer': return sylk_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString('binary') : a2s(d), opts);
  			case 'array': return sylk_to_aoa_str(cc2str(d), opts);
  		}
  		throw new Error("Unrecognized type " + opts.type);
  	}
  	function sylk_to_aoa_str(str/*:string*/, opts)/*:[AOA, Worksheet]*/ {
  		var records = str.split(/[\n\r]+/), R = -1, C = -1, ri = 0, rj = 0, arr/*:AOA*/ = [];
  		var formats/*:Array<string>*/ = [];
  		var next_cell_format/*:string|null*/ = null;
  		var sht = {}, rowinfo/*:Array<RowInfo>*/ = [], colinfo/*:Array<ColInfo>*/ = [], cw/*:Array<string>*/ = [];
  		var Mval = 0, j;
  		if(+opts.codepage >= 0) set_cp(+opts.codepage);
  		for (; ri !== records.length; ++ri) {
  			Mval = 0;
  			var rstr=records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);
  			var record=rstr.replace(/;;/g, "\u0000").split(";").map(function(x) { return x.replace(/\u0000/g, ";"); });
  			var RT=record[0], val;
  			if(rstr.length > 0) switch(RT) {
  			case 'ID': break; /* header */
  			case 'E': break; /* EOF */
  			case 'B': break; /* dimensions */
  			case 'O': break; /* options? */
  			case 'W': break; /* window? */
  			case 'P':
  				if(record[1].charAt(0) == 'P')
  					formats.push(rstr.slice(3).replace(/;;/g, ";"));
  				break;
  			case 'C':
  			var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1;
  			for(rj=1; rj<record.length; ++rj) switch(record[rj].charAt(0)) {
  				case 'A': break; // TODO: comment
  				case 'X': C = parseInt(record[rj].slice(1))-1; C_seen_X = true; break;
  				case 'Y':
  					R = parseInt(record[rj].slice(1))-1; if(!C_seen_X) C = 0;
  					for(j = arr.length; j <= R; ++j) arr[j] = [];
  					break;
  				case 'K':
  					val = record[rj].slice(1);
  					if(val.charAt(0) === '"') val = val.slice(1,val.length - 1);
  					else if(val === 'TRUE') val = true;
  					else if(val === 'FALSE') val = false;
  					else if(!isNaN(fuzzynum(val))) {
  						val = fuzzynum(val);
  						if(next_cell_format !== null && fmt_is_date(next_cell_format)) val = numdate(val);
  					} else if(!isNaN(fuzzydate(val).getDate())) {
  						val = parseDate(val);
  					}
  					C_seen_K = true;
  					break;
  				case 'E':
  					C_seen_E = true;
  					var formula = rc_to_a1(record[rj].slice(1), {r:R,c:C});
  					arr[R][C] = [arr[R][C], formula];
  					break;
  				case 'S':
  					C_seen_S = true;
  					arr[R][C] = [arr[R][C], "S5S"];
  					break;
  				case 'G': break; // unknown
  				case 'R': _R = parseInt(record[rj].slice(1))-1; break;
  				case 'C': _C = parseInt(record[rj].slice(1))-1; break;
  				default: if(opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
  			}
  			if(C_seen_K) {
  				if(arr[R][C] && arr[R][C].length == 2) arr[R][C][0] = val;
  				else arr[R][C] = val;
  				next_cell_format = null;
  			}
  			if(C_seen_S) {
  				if(C_seen_E) throw new Error("SYLK shared formula cannot have own formula");
  				var shrbase = _R > -1 && arr[_R][_C];
  				if(!shrbase || !shrbase[1]) throw new Error("SYLK shared formula cannot find base");
  				arr[R][C][1] = shift_formula_str(shrbase[1], {r: R - _R, c: C - _C});
  			}
  			break;
  			case 'F':
  			var F_seen = 0;
  			for(rj=1; rj<record.length; ++rj) switch(record[rj].charAt(0)) {
  				case 'X': C = parseInt(record[rj].slice(1))-1; ++F_seen; break;
  				case 'Y':
  					R = parseInt(record[rj].slice(1))-1; /*C = 0;*/
  					for(j = arr.length; j <= R; ++j) arr[j] = [];
  					break;
  				case 'M': Mval = parseInt(record[rj].slice(1)) / 20; break;
  				case 'F': break; /* ??? */
  				case 'G': break; /* hide grid */
  				case 'P':
  					next_cell_format = formats[parseInt(record[rj].slice(1))];
  					break;
  				case 'S': break; /* cell style */
  				case 'D': break; /* column */
  				case 'N': break; /* font */
  				case 'W':
  					cw = record[rj].slice(1).split(" ");
  					for(j = parseInt(cw[0], 10); j <= parseInt(cw[1], 10); ++j) {
  						Mval = parseInt(cw[2], 10);
  						colinfo[j-1] = Mval === 0 ? {hidden:true}: {wch:Mval}; process_col(colinfo[j-1]);
  					} break;
  				case 'C': /* default column format */
  					C = parseInt(record[rj].slice(1))-1;
  					if(!colinfo[C]) colinfo[C] = {};
  					break;
  				case 'R': /* row properties */
  					R = parseInt(record[rj].slice(1))-1;
  					if(!rowinfo[R]) rowinfo[R] = {};
  					if(Mval > 0) { rowinfo[R].hpt = Mval; rowinfo[R].hpx = pt2px(Mval); }
  					else if(Mval === 0) rowinfo[R].hidden = true;
  					break;
  				default: if(opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
  			}
  			if(F_seen < 1) next_cell_format = null; break;
  			default: if(opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
  			}
  		}
  		if(rowinfo.length > 0) sht['!rows'] = rowinfo;
  		if(colinfo.length > 0) sht['!cols'] = colinfo;
  		if(opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
  		return [arr, sht];
  	}

  	function sylk_to_sheet(d/*:RawData*/, opts)/*:Worksheet*/ {
  		var aoasht = sylk_to_aoa(d, opts);
  		var aoa = aoasht[0], ws = aoasht[1];
  		var o = aoa_to_sheet(aoa, opts);
  		keys(ws).forEach(function(k) { o[k] = ws[k]; });
  		return o;
  	}

  	function sylk_to_workbook(d/*:RawData*/, opts)/*:Workbook*/ { return sheet_to_workbook(sylk_to_sheet(d, opts), opts); }

  	function write_ws_cell_sylk(cell/*:Cell*/, ws/*:Worksheet*/, R/*:number*/, C/*:number*//*::, opts*/)/*:string*/ {
  		var o = "C;Y" + (R+1) + ";X" + (C+1) + ";K";
  		switch(cell.t) {
  			case 'n':
  				o += (cell.v||0);
  				if(cell.f && !cell.F) o += ";E" + a1_to_rc(cell.f, {r:R, c:C}); break;
  			case 'b': o += cell.v ? "TRUE" : "FALSE"; break;
  			case 'e': o += cell.w || cell.v; break;
  			case 'd': o += '"' + (cell.w || cell.v) + '"'; break;
  			case 's': o += '"' + cell.v.replace(/"/g,"").replace(/;/g, ";;") + '"'; break;
  		}
  		return o;
  	}

  	function write_ws_cols_sylk(out, cols) {
  		cols.forEach(function(col, i) {
  			var rec = "F;W" + (i+1) + " " + (i+1) + " ";
  			if(col.hidden) rec += "0";
  			else {
  				if(typeof col.width == 'number' && !col.wpx) col.wpx = width2px(col.width);
  				if(typeof col.wpx == 'number' && !col.wch) col.wch = px2char(col.wpx);
  				if(typeof col.wch == 'number') rec += Math.round(col.wch);
  			}
  			if(rec.charAt(rec.length - 1) != " ") out.push(rec);
  		});
  	}

  	function write_ws_rows_sylk(out/*:Array<string>*/, rows/*:Array<RowInfo>*/) {
  		rows.forEach(function(row, i) {
  			var rec = "F;";
  			if(row.hidden) rec += "M0;";
  			else if(row.hpt) rec += "M" + 20 * row.hpt + ";";
  			else if(row.hpx) rec += "M" + 20 * px2pt(row.hpx) + ";";
  			if(rec.length > 2) out.push(rec + "R" + (i+1));
  		});
  	}

  	function sheet_to_sylk(ws/*:Worksheet*/, opts/*:?any*/)/*:string*/ {
  		var preamble/*:Array<string>*/ = ["ID;PWXL;N;E"], o/*:Array<string>*/ = [];
  		var r = safe_decode_range(ws['!ref']), cell/*:Cell*/;
  		var dense = Array.isArray(ws);
  		var RS = "\r\n";

  		preamble.push("P;PGeneral");
  		preamble.push("F;P0;DG0G8;M255");
  		if(ws['!cols']) write_ws_cols_sylk(preamble, ws['!cols']);
  		if(ws['!rows']) write_ws_rows_sylk(preamble, ws['!rows']);

  		preamble.push("B;Y" + (r.e.r - r.s.r + 1) + ";X" + (r.e.c - r.s.c + 1) + ";D" + [r.s.c,r.s.r,r.e.c,r.e.r].join(" "));
  		for(var R = r.s.r; R <= r.e.r; ++R) {
  			for(var C = r.s.c; C <= r.e.c; ++C) {
  				var coord = encode_cell({r:R,c:C});
  				cell = dense ? (ws[R]||[])[C]: ws[coord];
  				if(!cell || (cell.v == null && (!cell.f || cell.F))) continue;
  				o.push(write_ws_cell_sylk(cell, ws, R, C));
  			}
  		}
  		return preamble.join(RS) + RS + o.join(RS) + RS + "E" + RS;
  	}

  	return {
  		to_workbook: sylk_to_workbook,
  		to_sheet: sylk_to_sheet,
  		from_sheet: sheet_to_sylk
  	};
  })();

  var DIF = /*#__PURE__*/(function() {
  	function dif_to_aoa(d/*:RawData*/, opts)/*:AOA*/ {
  		switch(opts.type) {
  			case 'base64': return dif_to_aoa_str(Base64_decode(d), opts);
  			case 'binary': return dif_to_aoa_str(d, opts);
  			case 'buffer': return dif_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString('binary') : a2s(d), opts);
  			case 'array': return dif_to_aoa_str(cc2str(d), opts);
  		}
  		throw new Error("Unrecognized type " + opts.type);
  	}
  	function dif_to_aoa_str(str/*:string*/, opts)/*:AOA*/ {
  		var records = str.split('\n'), R = -1, C = -1, ri = 0, arr/*:AOA*/ = [];
  		for (; ri !== records.length; ++ri) {
  			if (records[ri].trim() === 'BOT') { arr[++R] = []; C = 0; continue; }
  			if (R < 0) continue;
  			var metadata = records[ri].trim().split(",");
  			var type = metadata[0], value = metadata[1];
  			++ri;
  			var data = records[ri] || "";
  			while(((data.match(/["]/g)||[]).length & 1) && ri < records.length - 1) data += "\n" + records[++ri];
  			data = data.trim();
  			switch (+type) {
  				case -1:
  					if (data === 'BOT') { arr[++R] = []; C = 0; continue; }
  					else if (data !== 'EOD') throw new Error("Unrecognized DIF special command " + data);
  					break;
  				case 0:
  					if(data === 'TRUE') arr[R][C] = true;
  					else if(data === 'FALSE') arr[R][C] = false;
  					else if(!isNaN(fuzzynum(value))) arr[R][C] = fuzzynum(value);
  					else if(!isNaN(fuzzydate(value).getDate())) arr[R][C] = parseDate(value);
  					else arr[R][C] = value;
  					++C; break;
  				case 1:
  					data = data.slice(1,data.length-1);
  					data = data.replace(/""/g, '"');
  					if(data && data.match(/^=".*"$/)) data = data.slice(2, -1);
  					arr[R][C++] = data !== '' ? data : null;
  					break;
  			}
  			if (data === 'EOD') break;
  		}
  		if(opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
  		return arr;
  	}

  	function dif_to_sheet(str/*:string*/, opts)/*:Worksheet*/ { return aoa_to_sheet(dif_to_aoa(str, opts), opts); }
  	function dif_to_workbook(str/*:string*/, opts)/*:Workbook*/ { return sheet_to_workbook(dif_to_sheet(str, opts), opts); }

  	var sheet_to_dif = /*#__PURE__*/(function() {
  		var push_field = function pf(o/*:Array<string>*/, topic/*:string*/, v/*:number*/, n/*:number*/, s/*:string*/) {
  			o.push(topic);
  			o.push(v + "," + n);
  			o.push('"' + s.replace(/"/g,'""') + '"');
  		};
  		var push_value = function po(o/*:Array<string>*/, type/*:number*/, v/*:any*/, s/*:string*/) {
  			o.push(type + "," + v);
  			o.push(type == 1 ? '"' + s.replace(/"/g,'""') + '"' : s);
  		};
  		return function sheet_to_dif(ws/*:Worksheet*//*::, opts:?any*/)/*:string*/ {
  			var o/*:Array<string>*/ = [];
  			var r = safe_decode_range(ws['!ref']), cell/*:Cell*/;
  			var dense = Array.isArray(ws);
  			push_field(o, "TABLE", 0, 1, "sheetjs");
  			push_field(o, "VECTORS", 0, r.e.r - r.s.r + 1,"");
  			push_field(o, "TUPLES", 0, r.e.c - r.s.c + 1,"");
  			push_field(o, "DATA", 0, 0,"");
  			for(var R = r.s.r; R <= r.e.r; ++R) {
  				push_value(o, -1, 0, "BOT");
  				for(var C = r.s.c; C <= r.e.c; ++C) {
  					var coord = encode_cell({r:R,c:C});
  					cell = dense ? (ws[R]||[])[C] : ws[coord];
  					if(!cell) { push_value(o, 1, 0, ""); continue;}
  					switch(cell.t) {
  						case 'n':
  							var val = cell.w ;
  							if(!val && cell.v != null) val = cell.v;
  							if(val == null) {
  								if(cell.f && !cell.F) push_value(o, 1, 0, "=" + cell.f);
  								else push_value(o, 1, 0, "");
  							}
  							else push_value(o, 0, val, "V");
  							break;
  						case 'b':
  							push_value(o, 0, cell.v ? 1 : 0, cell.v ? "TRUE" : "FALSE");
  							break;
  						case 's':
  							push_value(o, 1, 0, (isNaN(cell.v)) ? cell.v : '="' + cell.v + '"');
  							break;
  						case 'd':
  							if(!cell.w) cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));
  							push_value(o, 0, cell.w, "V");
  							break;
  						default: push_value(o, 1, 0, "");
  					}
  				}
  			}
  			push_value(o, -1, 0, "EOD");
  			var RS = "\r\n";
  			var oo = o.join(RS);
  			//while((oo.length & 0x7F) != 0) oo += "\0";
  			return oo;
  		};
  	})();
  	return {
  		to_workbook: dif_to_workbook,
  		to_sheet: dif_to_sheet,
  		from_sheet: sheet_to_dif
  	};
  })();

  var ETH = /*#__PURE__*/(function() {
  	function decode(s/*:string*/)/*:string*/ { return s.replace(/\\b/g,"\\").replace(/\\c/g,":").replace(/\\n/g,"\n"); }
  	function encode(s/*:string*/)/*:string*/ { return s.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g,"\\n"); }

  	function eth_to_aoa(str/*:string*/, opts)/*:AOA*/ {
  		var records = str.split('\n'), R = -1, C = -1, ri = 0, arr/*:AOA*/ = [];
  		for (; ri !== records.length; ++ri) {
  			var record = records[ri].trim().split(":");
  			if(record[0] !== 'cell') continue;
  			var addr = decode_cell(record[1]);
  			if(arr.length <= addr.r) for(R = arr.length; R <= addr.r; ++R) if(!arr[R]) arr[R] = [];
  			R = addr.r; C = addr.c;
  			switch(record[2]) {
  				case 't': arr[R][C] = decode(record[3]); break;
  				case 'v': arr[R][C] = +record[3]; break;
  				case 'vtf': var _f = record[record.length - 1];
  					/* falls through */
  				case 'vtc':
  					switch(record[3]) {
  						case 'nl': arr[R][C] = +record[4] ? true : false; break;
  						default: arr[R][C] = +record[4]; break;
  					}
  					if(record[2] == 'vtf') arr[R][C] = [arr[R][C], _f];
  			}
  		}
  		if(opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
  		return arr;
  	}

  	function eth_to_sheet(d/*:string*/, opts)/*:Worksheet*/ { return aoa_to_sheet(eth_to_aoa(d, opts), opts); }
  	function eth_to_workbook(d/*:string*/, opts)/*:Workbook*/ { return sheet_to_workbook(eth_to_sheet(d, opts), opts); }

  	var header = [
  		"socialcalc:version:1.5",
  		"MIME-Version: 1.0",
  		"Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  	].join("\n");

  	var sep = [
  		"--SocialCalcSpreadsheetControlSave",
  		"Content-type: text/plain; charset=UTF-8"
  	].join("\n") + "\n";

  	/* TODO: the other parts */
  	var meta = [
  		"# SocialCalc Spreadsheet Control Save",
  		"part:sheet"
  	].join("\n");

  	var end = "--SocialCalcSpreadsheetControlSave--";

  	function sheet_to_eth_data(ws/*:Worksheet*/)/*:string*/ {
  		if(!ws || !ws['!ref']) return "";
  		var o/*:Array<string>*/ = [], oo/*:Array<string>*/ = [], cell, coord = "";
  		var r = decode_range(ws['!ref']);
  		var dense = Array.isArray(ws);
  		for(var R = r.s.r; R <= r.e.r; ++R) {
  			for(var C = r.s.c; C <= r.e.c; ++C) {
  				coord = encode_cell({r:R,c:C});
  				cell = dense ? (ws[R]||[])[C] : ws[coord];
  				if(!cell || cell.v == null || cell.t === 'z') continue;
  				oo = ["cell", coord, 't'];
  				switch(cell.t) {
  					case 's': case 'str': oo.push(encode(cell.v)); break;
  					case 'n':
  						if(!cell.f) { oo[2]='v'; oo[3]=cell.v; }
  						else { oo[2]='vtf'; oo[3]='n'; oo[4]=cell.v; oo[5]=encode(cell.f); }
  						break;
  					case 'b':
  						oo[2] = 'vt'+(cell.f?'f':'c'); oo[3]='nl'; oo[4]=cell.v?"1":"0";
  						oo[5] = encode(cell.f||(cell.v?'TRUE':'FALSE'));
  						break;
  					case 'd':
  						var t = datenum(parseDate(cell.v));
  						oo[2] = 'vtc'; oo[3] = 'nd'; oo[4] = ""+t;
  						oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t);
  						break;
  					case 'e': continue;
  				}
  				o.push(oo.join(":"));
  			}
  		}
  		o.push("sheet:c:" + (r.e.c-r.s.c+1) + ":r:" + (r.e.r-r.s.r+1) + ":tvf:1");
  		o.push("valueformat:1:text-wiki");
  		//o.push("copiedfrom:" + ws['!ref']); // clipboard only
  		return o.join("\n");
  	}

  	function sheet_to_eth(ws/*:Worksheet*//*::, opts:?any*/)/*:string*/ {
  		return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");
  		// return ["version:1.5", sheet_to_eth_data(ws)].join("\n"); // clipboard form
  	}

  	return {
  		to_workbook: eth_to_workbook,
  		to_sheet: eth_to_sheet,
  		from_sheet: sheet_to_eth
  	};
  })();

  var PRN = /*#__PURE__*/(function() {
  	function set_text_arr(data/*:string*/, arr/*:AOA*/, R/*:number*/, C/*:number*/, o/*:any*/) {
  		if(o.raw) arr[R][C] = data;
  		else if(data === "");
  		else if(data === 'TRUE') arr[R][C] = true;
  		else if(data === 'FALSE') arr[R][C] = false;
  		else if(!isNaN(fuzzynum(data))) arr[R][C] = fuzzynum(data);
  		else if(!isNaN(fuzzydate(data).getDate())) arr[R][C] = parseDate(data);
  		else arr[R][C] = data;
  	}

  	function prn_to_aoa_str(f/*:string*/, opts)/*:AOA*/ {
  		var o = opts || {};
  		var arr/*:AOA*/ = ([]/*:any*/);
  		if(!f || f.length === 0) return arr;
  		var lines = f.split(/[\r\n]/);
  		var L = lines.length - 1;
  		while(L >= 0 && lines[L].length === 0) --L;
  		var start = 10, idx = 0;
  		var R = 0;
  		for(; R <= L; ++R) {
  			idx = lines[R].indexOf(" ");
  			if(idx == -1) idx = lines[R].length; else idx++;
  			start = Math.max(start, idx);
  		}
  		for(R = 0; R <= L; ++R) {
  			arr[R] = [];
  			/* TODO: confirm that widths are always 10 */
  			var C = 0;
  			set_text_arr(lines[R].slice(0, start).trim(), arr, R, C, o);
  			for(C = 1; C <= (lines[R].length - start)/10 + 1; ++C)
  				set_text_arr(lines[R].slice(start+(C-1)*10,start+C*10).trim(),arr,R,C,o);
  		}
  		if(o.sheetRows) arr = arr.slice(0, o.sheetRows);
  		return arr;
  	}

  	// List of accepted CSV separators
  	var guess_seps = {
  		/*::[*/0x2C/*::]*/: ',',
  		/*::[*/0x09/*::]*/: "\t",
  		/*::[*/0x3B/*::]*/: ';',
  		/*::[*/0x7C/*::]*/: '|'
  	};

  	// CSV separator weights to be used in case of equal numbers
  	var guess_sep_weights = {
  		/*::[*/0x2C/*::]*/: 3,
  		/*::[*/0x09/*::]*/: 2,
  		/*::[*/0x3B/*::]*/: 1,
  		/*::[*/0x7C/*::]*/: 0
  	};

  	function guess_sep(str) {
  		var cnt = {}, instr = false, end = 0, cc = 0;
  		for(;end < str.length;++end) {
  			if((cc=str.charCodeAt(end)) == 0x22) instr = !instr;
  			else if(!instr && cc in guess_seps) cnt[cc] = (cnt[cc]||0)+1;
  		}

  		cc = [];
  		for(end in cnt) if ( Object.prototype.hasOwnProperty.call(cnt, end) ) {
  			cc.push([ cnt[end], end ]);
  		}

  		if ( !cc.length ) {
  			cnt = guess_sep_weights;
  			for(end in cnt) if ( Object.prototype.hasOwnProperty.call(cnt, end) ) {
  				cc.push([ cnt[end], end ]);
  			}
  		}

  		cc.sort(function(a, b) { return a[0] - b[0] || guess_sep_weights[a[1]] - guess_sep_weights[b[1]]; });

  		return guess_seps[cc.pop()[1]] || 0x2C;
  	}

  	function dsv_to_sheet_str(str/*:string*/, opts)/*:Worksheet*/ {
  		var o = opts || {};
  		var sep = "";
  		var ws/*:Worksheet*/ = o.dense ? ([]/*:any*/) : ({}/*:any*/);
  		var range/*:Range*/ = ({s: {c:0, r:0}, e: {c:0, r:0}}/*:any*/);

  		if(str.slice(0,4) == "sep=") {
  			// If the line ends in \r\n
  			if(str.charCodeAt(5) == 13 && str.charCodeAt(6) == 10 ) {
  				sep = str.charAt(4); str = str.slice(7);
  			}
  			// If line ends in \r OR \n
  			else if(str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10 ) {
  				sep = str.charAt(4); str = str.slice(6);
  			}
  			else sep = guess_sep(str.slice(0,1024));
  		}
  		else if(o && o.FS) sep = o.FS;
  		else sep = guess_sep(str.slice(0,1024));
  		var R = 0, C = 0, v = 0;
  		var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc=0, startcc=str.charCodeAt(0);
  		str = str.replace(/\r\n/mg, "\n");
  		var _re/*:?RegExp*/ = o.dateNF != null ? dateNF_regex(o.dateNF) : null;
  		function finish_cell() {
  			var s = str.slice(start, end);
  			var cell = ({}/*:any*/);
  			if(s.charAt(0) == '"' && s.charAt(s.length - 1) == '"') s = s.slice(1,-1).replace(/""/g,'"');
  			if(s.length === 0) cell.t = 'z';
  			else if(o.raw) { cell.t = 's'; cell.v = s; }
  			else if(s.trim().length === 0) { cell.t = 's'; cell.v = s; }
  			else if(s.charCodeAt(0) == 0x3D) {
  				if(s.charCodeAt(1) == 0x22 && s.charCodeAt(s.length - 1) == 0x22) { cell.t = 's'; cell.v = s.slice(2,-1).replace(/""/g,'"'); }
  				else if(fuzzyfmla(s)) { cell.t = 'n'; cell.f = s.slice(1); }
  				else { cell.t = 's'; cell.v = s; } }
  			else if(s == "TRUE") { cell.t = 'b'; cell.v = true; }
  			else if(s == "FALSE") { cell.t = 'b'; cell.v = false; }
  			else if(!isNaN(v = fuzzynum(s))) { cell.t = 'n'; if(o.cellText !== false) cell.w = s; cell.v = v; }
  			else if(!isNaN(fuzzydate(s).getDate()) || _re && s.match(_re)) {
  				cell.z = o.dateNF || table_fmt[14];
  				var k = 0;
  				if(_re && s.match(_re)){ s=dateNF_fix(s, o.dateNF, (s.match(_re)||[])); k=1; }
  				if(o.cellDates) { cell.t = 'd'; cell.v = parseDate(s, k); }
  				else { cell.t = 'n'; cell.v = datenum(parseDate(s, k)); }
  				if(o.cellText !== false) cell.w = SSF_format(cell.z, cell.v instanceof Date ? datenum(cell.v):cell.v);
  				if(!o.cellNF) delete cell.z;
  			} else {
  				cell.t = 's';
  				cell.v = s;
  			}
  			if(cell.t == 'z');
  			else if(o.dense) { if(!ws[R]) ws[R] = []; ws[R][C] = cell; }
  			else ws[encode_cell({c:C,r:R})] = cell;
  			start = end+1; startcc = str.charCodeAt(start);
  			if(range.e.c < C) range.e.c = C;
  			if(range.e.r < R) range.e.r = R;
  			if(cc == sepcc) ++C; else { C = 0; ++R; if(o.sheetRows && o.sheetRows <= R) return true; }
  		}
  		outer: for(;end < str.length;++end) switch((cc=str.charCodeAt(end))) {
  			case 0x22: if(startcc === 0x22) instr = !instr; break;
  			case sepcc: case 0x0a: case 0x0d: if(!instr && finish_cell()) break outer; break;
  		}
  		if(end - start > 0) finish_cell();

  		ws['!ref'] = encode_range(range);
  		return ws;
  	}

  	function prn_to_sheet_str(str/*:string*/, opts)/*:Worksheet*/ {
  		if(!(opts && opts.PRN)) return dsv_to_sheet_str(str, opts);
  		if(opts.FS) return dsv_to_sheet_str(str, opts);
  		if(str.slice(0,4) == "sep=") return dsv_to_sheet_str(str, opts);
  		if(str.indexOf("\t") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0) return dsv_to_sheet_str(str, opts);
  		return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
  	}

  	function prn_to_sheet(d/*:RawData*/, opts)/*:Worksheet*/ {
  		var str = "", bytes = opts.type == 'string' ? [0,0,0,0] : firstbyte(d, opts);
  		switch(opts.type) {
  			case 'base64': str = Base64_decode(d); break;
  			case 'binary': str = d; break;
  			case 'buffer':
  				if(opts.codepage == 65001) str = d.toString('utf8'); // TODO: test if buf
  				else if(opts.codepage && typeof $cptable !== 'undefined') str = $cptable.utils.decode(opts.codepage, d);
  				else str = has_buf && Buffer.isBuffer(d) ? d.toString('binary') : a2s(d);
  				break;
  			case 'array': str = cc2str(d); break;
  			case 'string': str = d; break;
  			default: throw new Error("Unrecognized type " + opts.type);
  		}
  		if(bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF) str = utf8read(str.slice(3));
  		else if(opts.type != 'string' && opts.type != 'buffer' && opts.codepage == 65001) str = utf8read(str);
  		else if((opts.type == 'binary') && typeof $cptable !== 'undefined' && opts.codepage)  str = $cptable.utils.decode(opts.codepage, $cptable.utils.encode(28591,str));
  		if(str.slice(0,19) == "socialcalc:version:") return ETH.to_sheet(opts.type == 'string' ? str : utf8read(str), opts);
  		return prn_to_sheet_str(str, opts);
  	}

  	function prn_to_workbook(d/*:RawData*/, opts)/*:Workbook*/ { return sheet_to_workbook(prn_to_sheet(d, opts), opts); }

  	function sheet_to_prn(ws/*:Worksheet*//*::, opts:?any*/)/*:string*/ {
  		var o/*:Array<string>*/ = [];
  		var r = safe_decode_range(ws['!ref']), cell/*:Cell*/;
  		var dense = Array.isArray(ws);
  		for(var R = r.s.r; R <= r.e.r; ++R) {
  			var oo/*:Array<string>*/ = [];
  			for(var C = r.s.c; C <= r.e.c; ++C) {
  				var coord = encode_cell({r:R,c:C});
  				cell = dense ? (ws[R]||[])[C] : ws[coord];
  				if(!cell || cell.v == null) { oo.push("          "); continue; }
  				var w = (cell.w || (format_cell(cell), cell.w) || "").slice(0,10);
  				while(w.length < 10) w += " ";
  				oo.push(w + (C === 0 ? " " : ""));
  			}
  			o.push(oo.join(""));
  		}
  		return o.join("\n");
  	}

  	return {
  		to_workbook: prn_to_workbook,
  		to_sheet: prn_to_sheet,
  		from_sheet: sheet_to_prn
  	};
  })();

  var WK_ = /*#__PURE__*/(function() {
  	function lotushopper(data, cb/*:RecordHopperCB*/, opts/*:any*/) {
  		if(!data) return;
  		prep_blob(data, data.l || 0);
  		var Enum = opts.Enum || WK1Enum;
  		while(data.l < data.length) {
  			var RT = data.read_shift(2);
  			var R = Enum[RT] || Enum[0xFFFF];
  			var length = data.read_shift(2);
  			var tgt = data.l + length;
  			var d = R.f && R.f(data, length, opts);
  			data.l = tgt;
  			if(cb(d, R, RT)) return;
  		}
  	}

  	function lotus_to_workbook(d/*:RawData*/, opts) {
  		switch(opts.type) {
  			case 'base64': return lotus_to_workbook_buf(s2a(Base64_decode(d)), opts);
  			case 'binary': return lotus_to_workbook_buf(s2a(d), opts);
  			case 'buffer':
  			case 'array': return lotus_to_workbook_buf(d, opts);
  		}
  		throw "Unsupported type " + opts.type;
  	}

  	function lotus_to_workbook_buf(d, opts)/*:Workbook*/ {
  		if(!d) return d;
  		var o = opts || {};
  		var s/*:Worksheet*/ = ((o.dense ? [] : {})/*:any*/), n = "Sheet1", next_n = "", sidx = 0;
  		var sheets = {}, snames = [], realnames = [];

  		var refguess = {s: {r:0, c:0}, e: {r:0, c:0} };
  		var sheetRows = o.sheetRows || 0;

  		if(d[2] == 0x00) {
  			if(d[3] == 0x08 || d[3] == 0x09) {
  				if(d.length >= 16 && d[14] == 0x05 && d[15] === 0x6c) throw new Error("Unsupported Works 3 for Mac file");
  			}
  		}

  		if(d[2] == 0x02) {
  			o.Enum = WK1Enum;
  			lotushopper(d, function(val, R, RT) { switch(RT) {
  				case 0x00: /* BOF */
  					o.vers = val;
  					if(val >= 0x1000) o.qpro = true;
  					break;
  				case 0x06: refguess = val; break; /* RANGE */
  				case 0xCC: if(val) next_n = val; break; /* SHEETNAMECS */
  				case 0xDE: next_n = val; break; /* SHEETNAMELP */
  				case 0x0F: /* LABEL */
  				case 0x33: /* STRING */
  					if(!o.qpro) val[1].v = val[1].v.slice(1);
  					/* falls through */
  				case 0x0D: /* INTEGER */
  				case 0x0E: /* NUMBER */
  				case 0x10: /* FORMULA */
  					/* TODO: actual translation of the format code */
  					if(RT == 0x0E && (val[2] & 0x70) == 0x70 && (val[2] & 0x0F) > 1 && (val[2] & 0x0F) < 15) {
  						val[1].z = o.dateNF || table_fmt[14];
  						if(o.cellDates) { val[1].t = 'd'; val[1].v = numdate(val[1].v); }
  					}

  					if(o.qpro) {
  						if(val[3] > sidx) {
  							s["!ref"] = encode_range(refguess);
  							sheets[n] = s;
  							snames.push(n);
  							s = (o.dense ? [] : {});
  							refguess = {s: {r:0, c:0}, e: {r:0, c:0} };
  							sidx = val[3]; n = next_n || "Sheet" + (sidx + 1); next_n = "";
  						}
  					}

  					var tmpcell = o.dense ? (s[val[0].r]||[])[val[0].c] : s[encode_cell(val[0])];
  					if(tmpcell) {
  						tmpcell.t = val[1].t; tmpcell.v = val[1].v;
  						if(val[1].z != null) tmpcell.z = val[1].z;
  						if(val[1].f != null) tmpcell.f = val[1].f;
  						break;
  					}
  					if(o.dense) {
  						if(!s[val[0].r]) s[val[0].r] = [];
  						s[val[0].r][val[0].c] = val[1];
  					} else s[encode_cell(val[0])] = val[1];
  					break;
  			}}, o);
  		} else if(d[2] == 0x1A || d[2] == 0x0E) {
  			o.Enum = WK3Enum;
  			if(d[2] == 0x0E) { o.qpro = true; d.l = 0; }
  			lotushopper(d, function(val, R, RT) { switch(RT) {
  				case 0xCC: n = val; break; /* SHEETNAMECS */
  				case 0x16: /* LABEL16 */
  					val[1].v = val[1].v.slice(1);
  					/* falls through */
  				case 0x17: /* NUMBER17 */
  				case 0x18: /* NUMBER18 */
  				case 0x19: /* FORMULA19 */
  				case 0x25: /* NUMBER25 */
  				case 0x27: /* NUMBER27 */
  				case 0x28: /* FORMULA28 */
  					if(val[3] > sidx) {
  						s["!ref"] = encode_range(refguess);
  						sheets[n] = s;
  						snames.push(n);
  						s = (o.dense ? [] : {});
  						refguess = {s: {r:0, c:0}, e: {r:0, c:0} };
  						sidx = val[3]; n = "Sheet" + (sidx + 1);
  					}
  					if(sheetRows > 0 && val[0].r >= sheetRows) break;
  					if(o.dense) {
  						if(!s[val[0].r]) s[val[0].r] = [];
  						s[val[0].r][val[0].c] = val[1];
  					} else s[encode_cell(val[0])] = val[1];
  					if(refguess.e.c < val[0].c) refguess.e.c = val[0].c;
  					if(refguess.e.r < val[0].r) refguess.e.r = val[0].r;
  					break;
  				case 0x1B: /* XFORMAT */
  					if(val[0x36b0]) realnames[val[0x36b0][0]] = val[0x36b0][1];
  					break;
  				case 0x0601: /* SHEETINFOQP */
  					realnames[val[0]] = val[1]; if(val[0] == sidx) n = val[1]; break;
  			}}, o);
  		} else throw new Error("Unrecognized LOTUS BOF " + d[2]);
  		s["!ref"] = encode_range(refguess);
  		sheets[next_n || n] = s;
  		snames.push(next_n || n);
  		if(!realnames.length) return { SheetNames: snames, Sheets: sheets };
  		var osheets = {}, rnames = [];
  		/* TODO: verify no collisions */
  		for(var i = 0; i < realnames.length; ++i) if(sheets[snames[i]]) {
  			rnames.push(realnames[i] || snames[i]);
  			osheets[realnames[i]] = sheets[realnames[i]] || sheets[snames[i]];
  		} else {
  			rnames.push(realnames[i]);
  			osheets[realnames[i]] = ({ "!ref": "A1" });
  		}
  		return { SheetNames: rnames, Sheets: osheets };
  	}

  	function sheet_to_wk1(ws/*:Worksheet*/, opts/*:WriteOpts*/) {
  		var o = opts || {};
  		if(+o.codepage >= 0) set_cp(+o.codepage);
  		if(o.type == "string") throw new Error("Cannot write WK1 to JS string");
  		var ba = buf_array();
  		var range = safe_decode_range(ws["!ref"]);
  		var dense = Array.isArray(ws);
  		var cols = [];

  		write_biff_rec(ba, 0x00, write_BOF_WK1(0x0406));
  		write_biff_rec(ba, 0x06, write_RANGE(range));
  		var max_R = Math.min(range.e.r, 8191);
  		for(var R = range.s.r; R <= max_R; ++R) {
  			var rr = encode_row(R);
  			for(var C = range.s.c; C <= range.e.c; ++C) {
  				if(R === range.s.r) cols[C] = encode_col(C);
  				var ref = cols[C] + rr;
  				var cell = dense ? (ws[R]||[])[C] : ws[ref];
  				if(!cell || cell.t == "z") continue;
  				/* TODO: formula records */
  				if(cell.t == "n") {
  					if((cell.v|0)==cell.v && cell.v >= -32768 && cell.v <= 32767) write_biff_rec(ba, 0x0d, write_INTEGER(R, C, cell.v));
  					else write_biff_rec(ba, 0x0e, write_NUMBER(R, C, cell.v));
  				} else {
  					var str = format_cell(cell);
  					write_biff_rec(ba, 0x0F, write_LABEL(R, C, str.slice(0, 239)));
  				}
  			}
  		}

  		write_biff_rec(ba, 0x01);
  		return ba.end();
  	}

  	function book_to_wk3(wb/*:Workbook*/, opts/*:WriteOpts*/) {
  		var o = opts || {};
  		if(+o.codepage >= 0) set_cp(+o.codepage);
  		if(o.type == "string") throw new Error("Cannot write WK3 to JS string");
  		var ba = buf_array();

  		write_biff_rec(ba, 0x00, write_BOF_WK3(wb));

  		for(var i = 0, cnt = 0; i < wb.SheetNames.length; ++i) if((wb.Sheets[wb.SheetNames[i]] || {})["!ref"]) write_biff_rec(ba, 0x1b, write_XFORMAT_SHEETNAME(wb.SheetNames[i], cnt++));

  		var wsidx = 0;
  		for(i = 0; i < wb.SheetNames.length; ++i) {
  			var ws = wb.Sheets[wb.SheetNames[i]];
  			if(!ws || !ws["!ref"]) continue;
  			var range = safe_decode_range(ws["!ref"]);
  			var dense = Array.isArray(ws);
  			var cols = [];
  			var max_R = Math.min(range.e.r, 8191);
  			for(var R = range.s.r; R <= max_R; ++R) {
  				var rr = encode_row(R);
  				for(var C = range.s.c; C <= range.e.c; ++C) {
  					if(R === range.s.r) cols[C] = encode_col(C);
  					var ref = cols[C] + rr;
  					var cell = dense ? (ws[R]||[])[C] : ws[ref];
  					if(!cell || cell.t == "z") continue;
  					/* TODO: FORMULA19 NUMBER18 records */
  					if(cell.t == "n") {
  						write_biff_rec(ba, 0x17, write_NUMBER_17(R, C, wsidx, cell.v));
  					} else {
  						var str = format_cell(cell);
  						/* TODO: max len? */
  						write_biff_rec(ba, 0x16, write_LABEL_16(R, C, wsidx, str.slice(0, 239)));
  					}
  				}
  			}
  			++wsidx;
  		}

  		write_biff_rec(ba, 0x01);
  		return ba.end();
  	}


  	function write_BOF_WK1(v/*:number*/) {
  		var out = new_buf(2);
  		out.write_shift(2, v);
  		return out;
  	}

  	function write_BOF_WK3(wb/*:Workbook*/) {
  		var out = new_buf(26);
  		out.write_shift(2, 0x1000);
  		out.write_shift(2, 0x0004);
  		out.write_shift(4, 0x0000);
  		var rows = 0, cols = 0, wscnt = 0;
  		for(var i = 0; i < wb.SheetNames.length; ++i) {
  			var name = wb.SheetNames[i];
  			var ws = wb.Sheets[name];
  			if(!ws || !ws["!ref"]) continue;
  			++wscnt;
  			var range = decode_range(ws["!ref"]);
  			if(rows < range.e.r) rows = range.e.r;
  			if(cols < range.e.c) cols = range.e.c;
  		}
  		if(rows > 8191) rows = 8191;
  		out.write_shift(2, rows);
  		out.write_shift(1, wscnt);
  		out.write_shift(1, cols);
  		out.write_shift(2, 0x00);
  		out.write_shift(2, 0x00);
  		out.write_shift(1, 0x01);
  		out.write_shift(1, 0x02);
  		out.write_shift(4, 0);
  		out.write_shift(4, 0);
  		return out;
  	}

  	function parse_RANGE(blob, length, opts) {
  		var o = {s:{c:0,r:0},e:{c:0,r:0}};
  		if(length == 8 && opts.qpro) {
  			o.s.c = blob.read_shift(1);
  			blob.l++;
  			o.s.r = blob.read_shift(2);
  			o.e.c = blob.read_shift(1);
  			blob.l++;
  			o.e.r = blob.read_shift(2);
  			return o;
  		}
  		o.s.c = blob.read_shift(2);
  		o.s.r = blob.read_shift(2);
  		if(length == 12 && opts.qpro) blob.l += 2;
  		o.e.c = blob.read_shift(2);
  		o.e.r = blob.read_shift(2);
  		if(length == 12 && opts.qpro) blob.l += 2;
  		if(o.s.c == 0xFFFF) o.s.c = o.e.c = o.s.r = o.e.r = 0;
  		return o;
  	}
  	function write_RANGE(range) {
  		var out = new_buf(8);
  		out.write_shift(2, range.s.c);
  		out.write_shift(2, range.s.r);
  		out.write_shift(2, range.e.c);
  		out.write_shift(2, range.e.r);
  		return out;
  	}

  	function parse_cell(blob, length, opts) {
  		var o = [{c:0,r:0}, {t:'n',v:0}, 0, 0];
  		if(opts.qpro && opts.vers != 0x5120) {
  			o[0].c = blob.read_shift(1);
  			o[3] = blob.read_shift(1);
  			o[0].r = blob.read_shift(2);
  			blob.l+=2;
  		} else {
  			o[2] = blob.read_shift(1);
  			o[0].c = blob.read_shift(2); o[0].r = blob.read_shift(2);
  		}
  		return o;
  	}

  	function parse_LABEL(blob, length, opts) {
  		var tgt = blob.l + length;
  		var o = parse_cell(blob, length, opts);
  		o[1].t = 's';
  		if(opts.vers == 0x5120) {
  			blob.l++;
  			var len = blob.read_shift(1);
  			o[1].v = blob.read_shift(len, 'utf8');
  			return o;
  		}
  		if(opts.qpro) blob.l++;
  		o[1].v = blob.read_shift(tgt - blob.l, 'cstr');
  		return o;
  	}
  	function write_LABEL(R, C, s) {
  		/* TODO: encoding */
  		var o = new_buf(7 + s.length);
  		o.write_shift(1, 0xFF);
  		o.write_shift(2, C);
  		o.write_shift(2, R);
  		o.write_shift(1, 0x27); // ??
  		for(var i = 0; i < o.length; ++i) {
  			var cc = s.charCodeAt(i);
  			o.write_shift(1, cc >= 0x80 ? 0x5F : cc);
  		}
  		o.write_shift(1, 0);
  		return o;
  	}

  	function parse_INTEGER(blob, length, opts) {
  		var o = parse_cell(blob, length, opts);
  		o[1].v = blob.read_shift(2, 'i');
  		return o;
  	}
  	function write_INTEGER(R, C, v) {
  		var o = new_buf(7);
  		o.write_shift(1, 0xFF);
  		o.write_shift(2, C);
  		o.write_shift(2, R);
  		o.write_shift(2, v, 'i');
  		return o;
  	}

  	function parse_NUMBER(blob, length, opts) {
  		var o = parse_cell(blob, length, opts);
  		o[1].v = blob.read_shift(8, 'f');
  		return o;
  	}
  	function write_NUMBER(R, C, v) {
  		var o = new_buf(13);
  		o.write_shift(1, 0xFF);
  		o.write_shift(2, C);
  		o.write_shift(2, R);
  		o.write_shift(8, v, 'f');
  		return o;
  	}

  	function parse_FORMULA(blob, length, opts) {
  		var tgt = blob.l + length;
  		var o = parse_cell(blob, length, opts);
  		/* TODO: formula */
  		o[1].v = blob.read_shift(8, 'f');
  		if(opts.qpro) blob.l = tgt;
  		else {
  			var flen = blob.read_shift(2);
  			wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o);
  			blob.l += flen;
  		}
  		return o;
  	}

  	function wk1_parse_rc(B, V, col) {
  		var rel = V & 0x8000;
  		V &= ~0x8000;
  		V = (rel ? B : 0) + ((V >= 0x2000) ? V - 0x4000 : V);
  		return (rel ? "" : "$") + (col ? encode_col(V) : encode_row(V));
  	}
  	/* var oprec = [
  		8, 8, 8, 8, 8, 8, 8, 8, 6, 4, 4, 5, 5, 7, 3, 3,
  		3, 3, 3, 3, 1, 1, 2, 6, 8, 8, 8, 8, 8, 8, 8, 8
  	]; */
  	/* TODO: flesh out */
  	var FuncTab = {
  		0x33: ["FALSE", 0],
  		0x34: ["TRUE", 0],
  		0x46: ["LEN", 1],
  		0x50: ["SUM", 69],
  		0x51: ["AVERAGEA", 69],
  		0x52: ["COUNTA", 69],
  		0x53: ["MINA", 69],
  		0x54: ["MAXA", 69],
  		0x6F: ["T", 1]
  	};
  	var BinOpTab = [
  		  "",   "",   "",   "",   "",   "",   "",   "", // eslint-disable-line no-mixed-spaces-and-tabs
  		  "",  "+",  "-",  "*",  "/",  "^",  "=", "<>", // eslint-disable-line no-mixed-spaces-and-tabs
  		"<=", ">=",  "<",  ">",   "",   "",   "",   "", // eslint-disable-line no-mixed-spaces-and-tabs
  		 "&",   "",   "",   "",   "",   "",   "",   ""  // eslint-disable-line no-mixed-spaces-and-tabs
  	];

  	function wk1_fmla_to_csf(blob, o) {
  		prep_blob(blob, 0);
  		var out = [], argc = 0, R = "", C = "", argL = "", argR = "";
  		while(blob.l < blob.length) {
  			var cc = blob[blob.l++];
  			switch(cc) {
  				case 0x00: out.push(blob.read_shift(8, 'f')); break;
  				case 0x01: {
  					C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
  					R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
  					out.push(C + R);
  				} break;
  				case 0x02: {
  					var c = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
  					var r = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
  					C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
  					R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
  					out.push(c + r + ":" + C + R);
  				} break;
  				case 0x03:
  					if(blob.l < blob.length) { console.error("WK1 premature formula end"); return; }
  					break;
  				case 0x04: out.push("(" + out.pop() + ")"); break;
  				case 0x05: out.push(blob.read_shift(2)); break;
  				case 0x06: {
  					/* TODO: text encoding */
  					var Z = ""; while((cc = blob[blob.l++])) Z += String.fromCharCode(cc);
  					out.push('"' + Z.replace(/"/g, '""') + '"');
  				} break;

  				case 0x08: out.push("-" + out.pop()); break;
  				case 0x17: out.push("+" + out.pop()); break;
  				case 0x16: out.push("NOT(" + out.pop() + ")"); break;

  				case 0x14: case 0x15: {
  					argR = out.pop(); argL = out.pop();
  					out.push(["AND", "OR"][cc - 0x14] + "(" + argL + "," + argR + ")");
  				} break;

  				default:
  					if(cc < 0x20 && BinOpTab[cc]) {
  						argR = out.pop(); argL = out.pop();
  						out.push(argL + BinOpTab[cc] + argR);
  					} else if(FuncTab[cc]) {
  						argc = FuncTab[cc][1];
  						if(argc == 69) argc = blob[blob.l++];
  						if(argc > out.length) { console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|"); return; }
  						var args = out.slice(-argc);
  						out.length -= argc;
  						out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");
  					}
  					else if(cc <= 0x07) return console.error("WK1 invalid opcode " + cc.toString(16));
  					else if(cc <= 0x18) return console.error("WK1 unsupported op " + cc.toString(16));
  					else if(cc <= 0x1E) return console.error("WK1 invalid opcode " + cc.toString(16));
  					else if(cc <= 0x73) return console.error("WK1 unsupported function opcode " + cc.toString(16));
  					// possible future functions ??
  					else return console.error("WK1 unrecognized opcode " + cc.toString(16));
  			}
  		}
  		if(out.length == 1) o[1].f = "" + out[0];
  		else console.error("WK1 bad formula parse |" + out.join("|") + "|");
  	}


  	function parse_cell_3(blob/*::, length*/) {
  		var o = [{c:0,r:0}, {t:'n',v:0}, 0];
  		o[0].r = blob.read_shift(2); o[3] = blob[blob.l++]; o[0].c = blob[blob.l++];
  		return o;
  	}

  	function parse_LABEL_16(blob, length) {
  		var o = parse_cell_3(blob);
  		o[1].t = 's';
  		o[1].v = blob.read_shift(length - 4, 'cstr');
  		return o;
  	}
  	function write_LABEL_16(R, C, wsidx, s) {
  		/* TODO: encoding */
  		var o = new_buf(6 + s.length);
  		o.write_shift(2, R);
  		o.write_shift(1, wsidx);
  		o.write_shift(1, C);
  		o.write_shift(1, 0x27);
  		for(var i = 0; i < s.length; ++i) {
  			var cc = s.charCodeAt(i);
  			o.write_shift(1, cc >= 0x80 ? 0x5F : cc);
  		}
  		o.write_shift(1, 0);
  		return o;
  	}

  	function parse_NUMBER_18(blob, length) {
  		var o = parse_cell_3(blob);
  		o[1].v = blob.read_shift(2);
  		var v = o[1].v >> 1;
  		if(o[1].v & 0x1) {
  			switch(v & 0x07) {
  				case 0: v = (v >> 3) * 5000; break;
  				case 1: v = (v >> 3) * 500; break;
  				case 2: v = (v >> 3) / 20; break;
  				case 3: v = (v >> 3) / 200; break;
  				case 4: v = (v >> 3) / 2000; break;
  				case 5: v = (v >> 3) / 20000; break;
  				case 6: v = (v >> 3) / 16; break;
  				case 7: v = (v >> 3) / 64; break;
  			}
  		}
  		o[1].v = v;
  		return o;
  	}

  	function parse_NUMBER_17(blob, length) {
  		var o = parse_cell_3(blob);
  		var v1 = blob.read_shift(4);
  		var v2 = blob.read_shift(4);
  		var e = blob.read_shift(2);
  		if(e == 0xFFFF) {
  			if(v1 === 0 && v2 === 0xC0000000) { o[1].t = "e"; o[1].v = 0x0F; } // ERR -> #VALUE!
  			else if(v1 === 0 && v2 === 0xD0000000) { o[1].t = "e"; o[1].v = 0x2A; } // NA -> #N/A
  			else o[1].v = 0;
  			return o;
  		}
  		var s = e & 0x8000; e = (e&0x7FFF) - 16446;
  		o[1].v = (1 - s*2) * (v2 * Math.pow(2, e+32) + v1 * Math.pow(2, e));
  		return o;
  	}
  	function write_NUMBER_17(R, C, wsidx, v) {
  		var o = new_buf(14);
  		o.write_shift(2, R);
  		o.write_shift(1, wsidx);
  		o.write_shift(1, C);
  		if(v == 0) {
  			o.write_shift(4, 0);
  			o.write_shift(4, 0);
  			o.write_shift(2, 0xFFFF);
  			return o;
  		}
  		var s = 0, e = 0, v1 = 0, v2 = 0;
  		if(v < 0) { s = 1; v = -v; }
  		e = Math.log2(v) | 0;
  		v /= Math.pow(2, e-31);
  		v2 = (v)>>>0;
  		if((v2&0x80000000) == 0) { v/=2; ++e; v2 = v >>> 0; }
  		v -= v2;
  		v2 |= 0x80000000;
  		v2 >>>= 0;
  		v *= Math.pow(2, 32);
  		v1 = v>>>0;
  		o.write_shift(4, v1);
  		o.write_shift(4, v2);
  		e += 0x3FFF + (s ? 0x8000 : 0);
  		o.write_shift(2, e);
  		return o;
  	}

  	function parse_FORMULA_19(blob, length) {
  		var o = parse_NUMBER_17(blob);
  		blob.l += length - 14; /* TODO: WK3 formula */
  		return o;
  	}

  	function parse_NUMBER_25(blob, length) {
  		var o = parse_cell_3(blob);
  		var v1 = blob.read_shift(4);
  		o[1].v = v1 >> 6;
  		return o;
  	}

  	function parse_NUMBER_27(blob, length) {
  		var o = parse_cell_3(blob);
  		var v1 = blob.read_shift(8,'f');
  		o[1].v = v1;
  		return o;
  	}

  	function parse_FORMULA_28(blob, length) {
  		var o = parse_NUMBER_27(blob);
  		blob.l += length - 10; /* TODO: formula */
  		return o;
  	}

  	function parse_SHEETNAMECS(blob, length) {
  		return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, 'cstr') : "";
  	}

  	function parse_SHEETNAMELP(blob, length) {
  		var len = blob[blob.l++];
  		if(len > length - 1) len = length - 1;
  		var o = ""; while(o.length < len) o += String.fromCharCode(blob[blob.l++]);
  		return o;
  	}

  	function parse_SHEETINFOQP(blob, length, opts) {
  		if(!opts.qpro || length < 21) return;
  		var id = blob.read_shift(1);
  		blob.l += 17;
  		blob.l += 1; //var len = blob.read_shift(1);
  		blob.l += 2;
  		var nm = blob.read_shift(length - 21, 'cstr');
  		return [id, nm];
  	}

  	function parse_XFORMAT(blob, length) {
  		var o = {}, tgt = blob.l + length;
  		while(blob.l < tgt) {
  			var dt = blob.read_shift(2);
  			if(dt == 0x36b0) {
  				o[dt] = [0, ""];
  				o[dt][0] = blob.read_shift(2);
  				while(blob[blob.l]) { o[dt][1] += String.fromCharCode(blob[blob.l]); blob.l++; } blob.l++;
  			}
  			// TODO: 0x3a99 ??
  		}
  		return o;
  	}
  	function write_XFORMAT_SHEETNAME(name, wsidx) {
  		var out = new_buf(5 + name.length);
  		out.write_shift(2, 0x36b0);
  		out.write_shift(2, wsidx);
  		for(var i = 0; i < name.length; ++i) {
  			var cc = name.charCodeAt(i);
  			out[out.l++] = cc > 0x7F ? 0x5F : cc;
  		}
  		out[out.l++] = 0;
  		return out;
  	}

  	var WK1Enum = {
  		/*::[*/0x0000/*::]*/: { n:"BOF", f:parseuint16 },
  		/*::[*/0x0001/*::]*/: { n:"EOF" },
  		/*::[*/0x0002/*::]*/: { n:"CALCMODE" },
  		/*::[*/0x0003/*::]*/: { n:"CALCORDER" },
  		/*::[*/0x0004/*::]*/: { n:"SPLIT" },
  		/*::[*/0x0005/*::]*/: { n:"SYNC" },
  		/*::[*/0x0006/*::]*/: { n:"RANGE", f:parse_RANGE },
  		/*::[*/0x0007/*::]*/: { n:"WINDOW1" },
  		/*::[*/0x0008/*::]*/: { n:"COLW1" },
  		/*::[*/0x0009/*::]*/: { n:"WINTWO" },
  		/*::[*/0x000A/*::]*/: { n:"COLW2" },
  		/*::[*/0x000B/*::]*/: { n:"NAME" },
  		/*::[*/0x000C/*::]*/: { n:"BLANK" },
  		/*::[*/0x000D/*::]*/: { n:"INTEGER", f:parse_INTEGER },
  		/*::[*/0x000E/*::]*/: { n:"NUMBER", f:parse_NUMBER },
  		/*::[*/0x000F/*::]*/: { n:"LABEL", f:parse_LABEL },
  		/*::[*/0x0010/*::]*/: { n:"FORMULA", f:parse_FORMULA },
  		/*::[*/0x0018/*::]*/: { n:"TABLE" },
  		/*::[*/0x0019/*::]*/: { n:"ORANGE" },
  		/*::[*/0x001A/*::]*/: { n:"PRANGE" },
  		/*::[*/0x001B/*::]*/: { n:"SRANGE" },
  		/*::[*/0x001C/*::]*/: { n:"FRANGE" },
  		/*::[*/0x001D/*::]*/: { n:"KRANGE1" },
  		/*::[*/0x0020/*::]*/: { n:"HRANGE" },
  		/*::[*/0x0023/*::]*/: { n:"KRANGE2" },
  		/*::[*/0x0024/*::]*/: { n:"PROTEC" },
  		/*::[*/0x0025/*::]*/: { n:"FOOTER" },
  		/*::[*/0x0026/*::]*/: { n:"HEADER" },
  		/*::[*/0x0027/*::]*/: { n:"SETUP" },
  		/*::[*/0x0028/*::]*/: { n:"MARGINS" },
  		/*::[*/0x0029/*::]*/: { n:"LABELFMT" },
  		/*::[*/0x002A/*::]*/: { n:"TITLES" },
  		/*::[*/0x002B/*::]*/: { n:"SHEETJS" },
  		/*::[*/0x002D/*::]*/: { n:"GRAPH" },
  		/*::[*/0x002E/*::]*/: { n:"NGRAPH" },
  		/*::[*/0x002F/*::]*/: { n:"CALCCOUNT" },
  		/*::[*/0x0030/*::]*/: { n:"UNFORMATTED" },
  		/*::[*/0x0031/*::]*/: { n:"CURSORW12" },
  		/*::[*/0x0032/*::]*/: { n:"WINDOW" },
  		/*::[*/0x0033/*::]*/: { n:"STRING", f:parse_LABEL },
  		/*::[*/0x0037/*::]*/: { n:"PASSWORD" },
  		/*::[*/0x0038/*::]*/: { n:"LOCKED" },
  		/*::[*/0x003C/*::]*/: { n:"QUERY" },
  		/*::[*/0x003D/*::]*/: { n:"QUERYNAME" },
  		/*::[*/0x003E/*::]*/: { n:"PRINT" },
  		/*::[*/0x003F/*::]*/: { n:"PRINTNAME" },
  		/*::[*/0x0040/*::]*/: { n:"GRAPH2" },
  		/*::[*/0x0041/*::]*/: { n:"GRAPHNAME" },
  		/*::[*/0x0042/*::]*/: { n:"ZOOM" },
  		/*::[*/0x0043/*::]*/: { n:"SYMSPLIT" },
  		/*::[*/0x0044/*::]*/: { n:"NSROWS" },
  		/*::[*/0x0045/*::]*/: { n:"NSCOLS" },
  		/*::[*/0x0046/*::]*/: { n:"RULER" },
  		/*::[*/0x0047/*::]*/: { n:"NNAME" },
  		/*::[*/0x0048/*::]*/: { n:"ACOMM" },
  		/*::[*/0x0049/*::]*/: { n:"AMACRO" },
  		/*::[*/0x004A/*::]*/: { n:"PARSE" },
  		/*::[*/0x0066/*::]*/: { n:"PRANGES??" },
  		/*::[*/0x0067/*::]*/: { n:"RRANGES??" },
  		/*::[*/0x0068/*::]*/: { n:"FNAME??" },
  		/*::[*/0x0069/*::]*/: { n:"MRANGES??" },
  		/*::[*/0x00CC/*::]*/: { n:"SHEETNAMECS", f:parse_SHEETNAMECS },
  		/*::[*/0x00DE/*::]*/: { n:"SHEETNAMELP", f:parse_SHEETNAMELP },
  		/*::[*/0xFFFF/*::]*/: { n:"" }
  	};

  	var WK3Enum = {
  		/*::[*/0x0000/*::]*/: { n:"BOF" },
  		/*::[*/0x0001/*::]*/: { n:"EOF" },
  		/*::[*/0x0002/*::]*/: { n:"PASSWORD" },
  		/*::[*/0x0003/*::]*/: { n:"CALCSET" },
  		/*::[*/0x0004/*::]*/: { n:"WINDOWSET" },
  		/*::[*/0x0005/*::]*/: { n:"SHEETCELLPTR" },
  		/*::[*/0x0006/*::]*/: { n:"SHEETLAYOUT" },
  		/*::[*/0x0007/*::]*/: { n:"COLUMNWIDTH" },
  		/*::[*/0x0008/*::]*/: { n:"HIDDENCOLUMN" },
  		/*::[*/0x0009/*::]*/: { n:"USERRANGE" },
  		/*::[*/0x000A/*::]*/: { n:"SYSTEMRANGE" },
  		/*::[*/0x000B/*::]*/: { n:"ZEROFORCE" },
  		/*::[*/0x000C/*::]*/: { n:"SORTKEYDIR" },
  		/*::[*/0x000D/*::]*/: { n:"FILESEAL" },
  		/*::[*/0x000E/*::]*/: { n:"DATAFILLNUMS" },
  		/*::[*/0x000F/*::]*/: { n:"PRINTMAIN" },
  		/*::[*/0x0010/*::]*/: { n:"PRINTSTRING" },
  		/*::[*/0x0011/*::]*/: { n:"GRAPHMAIN" },
  		/*::[*/0x0012/*::]*/: { n:"GRAPHSTRING" },
  		/*::[*/0x0013/*::]*/: { n:"??" },
  		/*::[*/0x0014/*::]*/: { n:"ERRCELL" },
  		/*::[*/0x0015/*::]*/: { n:"NACELL" },
  		/*::[*/0x0016/*::]*/: { n:"LABEL16", f:parse_LABEL_16},
  		/*::[*/0x0017/*::]*/: { n:"NUMBER17", f:parse_NUMBER_17 },
  		/*::[*/0x0018/*::]*/: { n:"NUMBER18", f:parse_NUMBER_18 },
  		/*::[*/0x0019/*::]*/: { n:"FORMULA19", f:parse_FORMULA_19},
  		/*::[*/0x001A/*::]*/: { n:"FORMULA1A" },
  		/*::[*/0x001B/*::]*/: { n:"XFORMAT", f:parse_XFORMAT },
  		/*::[*/0x001C/*::]*/: { n:"DTLABELMISC" },
  		/*::[*/0x001D/*::]*/: { n:"DTLABELCELL" },
  		/*::[*/0x001E/*::]*/: { n:"GRAPHWINDOW" },
  		/*::[*/0x001F/*::]*/: { n:"CPA" },
  		/*::[*/0x0020/*::]*/: { n:"LPLAUTO" },
  		/*::[*/0x0021/*::]*/: { n:"QUERY" },
  		/*::[*/0x0022/*::]*/: { n:"HIDDENSHEET" },
  		/*::[*/0x0023/*::]*/: { n:"??" },
  		/*::[*/0x0025/*::]*/: { n:"NUMBER25", f:parse_NUMBER_25 },
  		/*::[*/0x0026/*::]*/: { n:"??" },
  		/*::[*/0x0027/*::]*/: { n:"NUMBER27", f:parse_NUMBER_27 },
  		/*::[*/0x0028/*::]*/: { n:"FORMULA28", f:parse_FORMULA_28 },
  		/*::[*/0x008E/*::]*/: { n:"??" },
  		/*::[*/0x0093/*::]*/: { n:"??" },
  		/*::[*/0x0096/*::]*/: { n:"??" },
  		/*::[*/0x0097/*::]*/: { n:"??" },
  		/*::[*/0x0098/*::]*/: { n:"??" },
  		/*::[*/0x0099/*::]*/: { n:"??" },
  		/*::[*/0x009A/*::]*/: { n:"??" },
  		/*::[*/0x009B/*::]*/: { n:"??" },
  		/*::[*/0x009C/*::]*/: { n:"??" },
  		/*::[*/0x00A3/*::]*/: { n:"??" },
  		/*::[*/0x00AE/*::]*/: { n:"??" },
  		/*::[*/0x00AF/*::]*/: { n:"??" },
  		/*::[*/0x00B0/*::]*/: { n:"??" },
  		/*::[*/0x00B1/*::]*/: { n:"??" },
  		/*::[*/0x00B8/*::]*/: { n:"??" },
  		/*::[*/0x00B9/*::]*/: { n:"??" },
  		/*::[*/0x00BA/*::]*/: { n:"??" },
  		/*::[*/0x00BB/*::]*/: { n:"??" },
  		/*::[*/0x00BC/*::]*/: { n:"??" },
  		/*::[*/0x00C3/*::]*/: { n:"??" },
  		/*::[*/0x00C9/*::]*/: { n:"??" },
  		/*::[*/0x00CC/*::]*/: { n:"SHEETNAMECS", f:parse_SHEETNAMECS },
  		/*::[*/0x00CD/*::]*/: { n:"??" },
  		/*::[*/0x00CE/*::]*/: { n:"??" },
  		/*::[*/0x00CF/*::]*/: { n:"??" },
  		/*::[*/0x00D0/*::]*/: { n:"??" },
  		/*::[*/0x0100/*::]*/: { n:"??" },
  		/*::[*/0x0103/*::]*/: { n:"??" },
  		/*::[*/0x0104/*::]*/: { n:"??" },
  		/*::[*/0x0105/*::]*/: { n:"??" },
  		/*::[*/0x0106/*::]*/: { n:"??" },
  		/*::[*/0x0107/*::]*/: { n:"??" },
  		/*::[*/0x0109/*::]*/: { n:"??" },
  		/*::[*/0x010A/*::]*/: { n:"??" },
  		/*::[*/0x010B/*::]*/: { n:"??" },
  		/*::[*/0x010C/*::]*/: { n:"??" },
  		/*::[*/0x010E/*::]*/: { n:"??" },
  		/*::[*/0x010F/*::]*/: { n:"??" },
  		/*::[*/0x0180/*::]*/: { n:"??" },
  		/*::[*/0x0185/*::]*/: { n:"??" },
  		/*::[*/0x0186/*::]*/: { n:"??" },
  		/*::[*/0x0189/*::]*/: { n:"??" },
  		/*::[*/0x018C/*::]*/: { n:"??" },
  		/*::[*/0x0200/*::]*/: { n:"??" },
  		/*::[*/0x0202/*::]*/: { n:"??" },
  		/*::[*/0x0201/*::]*/: { n:"??" },
  		/*::[*/0x0204/*::]*/: { n:"??" },
  		/*::[*/0x0205/*::]*/: { n:"??" },
  		/*::[*/0x0280/*::]*/: { n:"??" },
  		/*::[*/0x0281/*::]*/: { n:"??" },
  		/*::[*/0x0282/*::]*/: { n:"??" },
  		/*::[*/0x0283/*::]*/: { n:"??" },
  		/*::[*/0x0284/*::]*/: { n:"??" },
  		/*::[*/0x0285/*::]*/: { n:"??" },
  		/*::[*/0x0286/*::]*/: { n:"??" },
  		/*::[*/0x0287/*::]*/: { n:"??" },
  		/*::[*/0x0288/*::]*/: { n:"??" },
  		/*::[*/0x0292/*::]*/: { n:"??" },
  		/*::[*/0x0293/*::]*/: { n:"??" },
  		/*::[*/0x0294/*::]*/: { n:"??" },
  		/*::[*/0x0295/*::]*/: { n:"??" },
  		/*::[*/0x0296/*::]*/: { n:"??" },
  		/*::[*/0x0299/*::]*/: { n:"??" },
  		/*::[*/0x029A/*::]*/: { n:"??" },
  		/*::[*/0x0300/*::]*/: { n:"??" },
  		/*::[*/0x0304/*::]*/: { n:"??" },
  		/*::[*/0x0601/*::]*/: { n:"SHEETINFOQP", f:parse_SHEETINFOQP },
  		/*::[*/0x0640/*::]*/: { n:"??" },
  		/*::[*/0x0642/*::]*/: { n:"??" },
  		/*::[*/0x0701/*::]*/: { n:"??" },
  		/*::[*/0x0702/*::]*/: { n:"??" },
  		/*::[*/0x0703/*::]*/: { n:"??" },
  		/*::[*/0x0704/*::]*/: { n:"??" },
  		/*::[*/0x0780/*::]*/: { n:"??" },
  		/*::[*/0x0800/*::]*/: { n:"??" },
  		/*::[*/0x0801/*::]*/: { n:"??" },
  		/*::[*/0x0804/*::]*/: { n:"??" },
  		/*::[*/0x0A80/*::]*/: { n:"??" },
  		/*::[*/0x2AF6/*::]*/: { n:"??" },
  		/*::[*/0x3231/*::]*/: { n:"??" },
  		/*::[*/0x6E49/*::]*/: { n:"??" },
  		/*::[*/0x6F44/*::]*/: { n:"??" },
  		/*::[*/0xFFFF/*::]*/: { n:"" }
  	};
  	return {
  		sheet_to_wk1: sheet_to_wk1,
  		book_to_wk3: book_to_wk3,
  		to_workbook: lotus_to_workbook
  	};
  })();

  var straywsregex = /^\s|\s$|[\t\n\r]/;
  function write_sst_xml(sst/*:SST*/, opts)/*:string*/ {
  	if(!opts.bookSST) return "";
  	var o = [XML_HEADER];
  	o[o.length] = (writextag('sst', null, {
  		xmlns: XMLNS_main[0],
  		count: sst.Count,
  		uniqueCount: sst.Unique
  	}));
  	for(var i = 0; i != sst.length; ++i) { if(sst[i] == null) continue;
  		var s/*:XLString*/ = sst[i];
  		var sitag = "<si>";
  		if(s.r) sitag += s.r;
  		else {
  			sitag += "<t";
  			if(!s.t) s.t = "";
  			if(s.t.match(straywsregex)) sitag += ' xml:space="preserve"';
  			sitag += ">" + escapexml(s.t) + "</t>";
  		}
  		sitag += "</si>";
  		o[o.length] = (sitag);
  	}
  	if(o.length>2){ o[o.length] = ('</sst>'); o[1]=o[1].replace("/>",">"); }
  	return o.join("");
  }
  /* [MS-XLSB] 2.4.221 BrtBeginSst */
  function parse_BrtBeginSst(data) {
  	return [data.read_shift(4), data.read_shift(4)];
  }

  function write_BrtBeginSst(sst, o) {
  	if(!o) o = new_buf(8);
  	o.write_shift(4, sst.Count);
  	o.write_shift(4, sst.Unique);
  	return o;
  }

  var write_BrtSSTItem = write_RichStr;

  function write_sst_bin(sst/*::, opts*/) {
  	var ba = buf_array();
  	write_record(ba, 0x009F /* BrtBeginSst */, write_BrtBeginSst(sst));
  	for(var i = 0; i < sst.length; ++i) write_record(ba, 0x0013 /* BrtSSTItem */, write_BrtSSTItem(sst[i]));
  	/* FRTSST */
  	write_record(ba, 0x00A0 /* BrtEndSst */);
  	return ba.end();
  }
  function _JS2ANSI(str/*:string*/)/*:Array<number>*/ {
  	var o/*:Array<number>*/ = [], oo = str.split("");
  	for(var i = 0; i < oo.length; ++i) o[i] = oo[i].charCodeAt(0);
  	return o;
  }

  /* [MS-OFFCRYPTO] 2.3.7.1 Binary Document Password Verifier Derivation */
  function crypto_CreatePasswordVerifier_Method1(Password/*:string*/) {
  	var Verifier = 0x0000, PasswordArray;
  	var PasswordDecoded = _JS2ANSI(Password);
  	var len = PasswordDecoded.length + 1, i, PasswordByte;
  	var Intermediate1, Intermediate2, Intermediate3;
  	PasswordArray = new_raw_buf(len);
  	PasswordArray[0] = PasswordDecoded.length;
  	for(i = 1; i != len; ++i) PasswordArray[i] = PasswordDecoded[i-1];
  	for(i = len-1; i >= 0; --i) {
  		PasswordByte = PasswordArray[i];
  		Intermediate1 = ((Verifier & 0x4000) === 0x0000) ? 0 : 1;
  		Intermediate2 = (Verifier << 1) & 0x7FFF;
  		Intermediate3 = Intermediate1 | Intermediate2;
  		Verifier = Intermediate3 ^ PasswordByte;
  	}
  	return Verifier ^ 0xCE4B;
  }


  var RTF = /*#__PURE__*/(function() {
  	function rtf_to_sheet(d/*:RawData*/, opts)/*:Worksheet*/ {
  		switch(opts.type) {
  			case 'base64': return rtf_to_sheet_str(Base64_decode(d), opts);
  			case 'binary': return rtf_to_sheet_str(d, opts);
  			case 'buffer': return rtf_to_sheet_str(has_buf && Buffer.isBuffer(d) ? d.toString('binary') : a2s(d), opts);
  			case 'array':  return rtf_to_sheet_str(cc2str(d), opts);
  		}
  		throw new Error("Unrecognized type " + opts.type);
  	}

  	/* TODO: this is a stub */
  	function rtf_to_sheet_str(str/*:string*/, opts)/*:Worksheet*/ {
  		var o = opts || {};
  		var ws/*:Worksheet*/ = o.dense ? ([]/*:any*/) : ({}/*:any*/);

  		var rows = str.match(/\\trowd.*?\\row\b/g);
  		if(!rows.length) throw new Error("RTF missing table");
  		var range/*:Range*/ = ({s: {c:0, r:0}, e: {c:0, r:rows.length - 1}}/*:any*/);
  		rows.forEach(function(rowtf, R) {
  			if(Array.isArray(ws)) ws[R] = [];
  			var rtfre = /\\\w+\b/g;
  			var last_index = 0;
  			var res;
  			var C = -1;
  			while((res = rtfre.exec(rowtf))) {
  				switch(res[0]) {
  					case "\\cell":
  						var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);
  						if(data[0] == " ") data = data.slice(1);
  						++C;
  						if(data.length) {
  							// TODO: value parsing, including codepage adjustments
  							var cell = {v: data, t:"s"};
  							if(Array.isArray(ws)) ws[R][C] = cell;
  							else ws[encode_cell({r:R, c:C})] = cell;
  						}
  						break;
  				}
  				last_index = rtfre.lastIndex;
  			}
  			if(C > range.e.c) range.e.c = C;
  		});
  		ws['!ref'] = encode_range(range);
  		return ws;
  	}

  	function rtf_to_workbook(d/*:RawData*/, opts)/*:Workbook*/ { return sheet_to_workbook(rtf_to_sheet(d, opts), opts); }

  	/* TODO: this is a stub */
  	function sheet_to_rtf(ws/*:Worksheet*//*::, opts*/)/*:string*/ {
  		var o = ["{\\rtf1\\ansi"];
  		var r = safe_decode_range(ws['!ref']), cell/*:Cell*/;
  		var dense = Array.isArray(ws);
  		for(var R = r.s.r; R <= r.e.r; ++R) {
  			o.push("\\trowd\\trautofit1");
  			for(var C = r.s.c; C <= r.e.c; ++C) o.push("\\cellx" + (C+1));
  			o.push("\\pard\\intbl");
  			for(C = r.s.c; C <= r.e.c; ++C) {
  				var coord = encode_cell({r:R,c:C});
  				cell = dense ? (ws[R]||[])[C]: ws[coord];
  				if(!cell || cell.v == null && (!cell.f || cell.F)) continue;
  				o.push(" " + (cell.w || (format_cell(cell), cell.w)));
  				o.push("\\cell");
  			}
  			o.push("\\pard\\intbl\\row");
  		}
  		return o.join("") + "}";
  	}

  	return {
  		to_workbook: rtf_to_workbook,
  		to_sheet: rtf_to_sheet,
  		from_sheet: sheet_to_rtf
  	};
  })();
  function rgb2Hex(rgb) {
  	for(var i=0,o=1; i!=3; ++i) o = o*256 + (rgb[i]>255?255:rgb[i]<0?0:rgb[i]);
  	return o.toString(16).toUpperCase().slice(1);
  }

  /* 18.3.1.13 width calculations */
  /* [MS-OI29500] 2.1.595 Column Width & Formatting */
  var DEF_MDW = 6, MDW = DEF_MDW;
  function width2px(width) { return Math.floor(( width + (Math.round(128/MDW))/256 )* MDW ); }
  function px2char(px) { return (Math.floor((px - 5)/MDW * 100 + 0.5))/100; }
  function char2width(chr) { return (Math.round((chr * MDW + 5)/MDW*256))/256; }
  /* XLML specifies width in terms of pixels */
  /*function find_mdw_wpx(wpx) {
  	var delta = Infinity, guess = 0, _MDW = MIN_MDW;
  	for(MDW=MIN_MDW; MDW<MAX_MDW; ++MDW) {
  		guess = char2width_(px2char_(wpx))*256;
  		guess = (guess) % 1;
  		if(guess > 0.5) guess--;
  		if(Math.abs(guess) < delta) { delta = Math.abs(guess); _MDW = MDW; }
  	}
  	MDW = _MDW;
  }*/

  function process_col(coll/*:ColInfo*/) {
  	if(coll.width) {
  		coll.wpx = width2px(coll.width);
  		coll.wch = px2char(coll.wpx);
  		coll.MDW = MDW;
  	} else if(coll.wpx) {
  		coll.wch = px2char(coll.wpx);
  		coll.width = char2width(coll.wch);
  		coll.MDW = MDW;
  	} else if(typeof coll.wch == 'number') {
  		coll.width = char2width(coll.wch);
  		coll.wpx = width2px(coll.width);
  		coll.MDW = MDW;
  	}
  	if(coll.customWidth) delete coll.customWidth;
  }

  var DEF_PPI = 96, PPI = DEF_PPI;
  function px2pt(px) { return px * 96 / PPI; }
  function pt2px(pt) { return pt * PPI / 96; }

  function write_numFmts(NF/*:{[n:number|string]:string}*//*::, opts*/) {
  	var o = ["<numFmts>"];
  	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {
  		for(var i = r[0]; i <= r[1]; ++i) if(NF[i] != null) o[o.length] = (writextag('numFmt',null,{numFmtId:i,formatCode:escapexml(NF[i])}));
  	});
  	if(o.length === 1) return "";
  	o[o.length] = ("</numFmts>");
  	o[0] = writextag('numFmts', null, { count:o.length-2 }).replace("/>", ">");
  	return o.join("");
  }

  function write_cellXfs(cellXfs)/*:string*/ {
  	var o/*:Array<string>*/ = [];
  	o[o.length] = (writextag('cellXfs',null));
  	cellXfs.forEach(function(c) {
  		o[o.length] = (writextag('xf', null, c));
  	});
  	o[o.length] = ("</cellXfs>");
  	if(o.length === 2) return "";
  	o[0] = writextag('cellXfs',null, {count:o.length-2}).replace("/>",">");
  	return o.join("");
  }

  function write_sty_xml(wb/*:Workbook*/, opts)/*:string*/ {
  	var o = [XML_HEADER, writextag('styleSheet', null, {
  		'xmlns': XMLNS_main[0],
  		'xmlns:vt': XMLNS.vt
  	})], w;
  	if(wb.SSF && (w = write_numFmts(wb.SSF)) != null) o[o.length] = w;
  	o[o.length] = ('<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>');
  	o[o.length] = ('<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>');
  	o[o.length] = ('<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>');
  	o[o.length] = ('<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>');
  	if((w = write_cellXfs(opts.cellXfs))) o[o.length] = (w);
  	o[o.length] = ('<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>');
  	o[o.length] = ('<dxfs count="0"/>');
  	o[o.length] = ('<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>');

  	if(o.length>2){ o[o.length] = ('</styleSheet>'); o[1]=o[1].replace("/>",">"); }
  	return o.join("");
  }
  /* [MS-XLSB] 2.4.657 BrtFmt */
  function parse_BrtFmt(data, length/*:number*/) {
  	var numFmtId = data.read_shift(2);
  	var stFmtCode = parse_XLWideString(data);
  	return [numFmtId, stFmtCode];
  }
  function write_BrtFmt(i/*:number*/, f/*:string*/, o) {
  	if(!o) o = new_buf(6 + 4 * f.length);
  	o.write_shift(2, i);
  	write_XLWideString(f, o);
  	var out = (o.length > o.l) ? o.slice(0, o.l) : o;
  	if(o.l == null) o.l = o.length;
  	return out;
  }

  /* [MS-XLSB] 2.4.659 BrtFont TODO */
  function parse_BrtFont(data, length/*:number*/, opts) {
  	var out = ({}/*:any*/);

  	out.sz = data.read_shift(2) / 20;

  	var grbit = parse_FontFlags(data);
  	if(grbit.fItalic) out.italic = 1;
  	if(grbit.fCondense) out.condense = 1;
  	if(grbit.fExtend) out.extend = 1;
  	if(grbit.fShadow) out.shadow = 1;
  	if(grbit.fOutline) out.outline = 1;
  	if(grbit.fStrikeout) out.strike = 1;

  	var bls = data.read_shift(2);
  	if(bls === 0x02BC) out.bold = 1;

  	switch(data.read_shift(2)) {
  		/* case 0: out.vertAlign = "baseline"; break; */
  		case 1: out.vertAlign = "superscript"; break;
  		case 2: out.vertAlign = "subscript"; break;
  	}

  	var underline = data.read_shift(1);
  	if(underline != 0) out.underline = underline;

  	var family = data.read_shift(1);
  	if(family > 0) out.family = family;

  	var bCharSet = data.read_shift(1);
  	if(bCharSet > 0) out.charset = bCharSet;

  	data.l++;
  	out.color = parse_BrtColor(data);

  	switch(data.read_shift(1)) {
  		/* case 0: out.scheme = "none": break; */
  		case 1: out.scheme = "major"; break;
  		case 2: out.scheme = "minor"; break;
  	}

  	out.name = parse_XLWideString(data);

  	return out;
  }
  function write_BrtFont(font/*:any*/, o) {
  	if(!o) o = new_buf(25+4*32);
  	o.write_shift(2, font.sz * 20);
  	write_FontFlags(font, o);
  	o.write_shift(2, font.bold ? 0x02BC : 0x0190);
  	var sss = 0;
  	if(font.vertAlign == "superscript") sss = 1;
  	else if(font.vertAlign == "subscript") sss = 2;
  	o.write_shift(2, sss);
  	o.write_shift(1, font.underline || 0);
  	o.write_shift(1, font.family || 0);
  	o.write_shift(1, font.charset || 0);
  	o.write_shift(1, 0);
  	write_BrtColor(font.color, o);
  	var scheme = 0;
  	if(font.scheme == "major") scheme = 1;
  	if(font.scheme == "minor") scheme = 2;
  	o.write_shift(1, scheme);
  	write_XLWideString(font.name, o);
  	return o.length > o.l ? o.slice(0, o.l) : o;
  }

  /* [MS-XLSB] 2.4.650 BrtFill */
  var XLSBFillPTNames = [
  	"none",
  	"solid",
  	"mediumGray",
  	"darkGray",
  	"lightGray",
  	"darkHorizontal",
  	"darkVertical",
  	"darkDown",
  	"darkUp",
  	"darkGrid",
  	"darkTrellis",
  	"lightHorizontal",
  	"lightVertical",
  	"lightDown",
  	"lightUp",
  	"lightGrid",
  	"lightTrellis",
  	"gray125",
  	"gray0625"
  ];
  var rev_XLSBFillPTNames/*:EvertNumType*/;
  /* TODO: gradient fill representation */
  var parse_BrtFill = parsenoop;
  function write_BrtFill(fill, o) {
  	if(!o) o = new_buf(4*3 + 8*7 + 16*1);
  	if(!rev_XLSBFillPTNames) rev_XLSBFillPTNames = (evert(XLSBFillPTNames)/*:any*/);
  	var fls/*:number*/ = rev_XLSBFillPTNames[fill.patternType];
  	if(fls == null) fls = 0x28;
  	o.write_shift(4, fls);
  	var j = 0;
  	if(fls != 0x28) {
  		/* TODO: custom FG Color */
  		write_BrtColor({auto:1}, o);
  		/* TODO: custom BG Color */
  		write_BrtColor({auto:1}, o);

  		for(; j < 12; ++j) o.write_shift(4, 0);
  	} else {
  		for(; j < 4; ++j) o.write_shift(4, 0);

  		for(; j < 12; ++j) o.write_shift(4, 0); /* TODO */
  		/* iGradientType */
  		/* xnumDegree */
  		/* xnumFillToLeft */
  		/* xnumFillToRight */
  		/* xnumFillToTop */
  		/* xnumFillToBottom */
  		/* cNumStop */
  		/* xfillGradientStop */
  	}
  	return o.length > o.l ? o.slice(0, o.l) : o;
  }

  /* [MS-XLSB] 2.4.824 BrtXF */
  function parse_BrtXF(data, length/*:number*/) {
  	var tgt = data.l + length;
  	var ixfeParent = data.read_shift(2);
  	var ifmt = data.read_shift(2);
  	data.l = tgt;
  	return {ixfe:ixfeParent, numFmtId:ifmt };
  }
  function write_BrtXF(data, ixfeP, o) {
  	if(!o) o = new_buf(16);
  	o.write_shift(2, ixfeP||0);
  	o.write_shift(2, data.numFmtId||0);
  	o.write_shift(2, 0); /* iFont */
  	o.write_shift(2, 0); /* iFill */
  	o.write_shift(2, 0); /* ixBorder */
  	o.write_shift(1, 0); /* trot */
  	o.write_shift(1, 0); /* indent */
  	var flow = 0;
  	o.write_shift(1, flow); /* flags */
  	o.write_shift(1, 0); /* flags */
  	o.write_shift(1, 0); /* xfGrbitAtr */
  	o.write_shift(1, 0);
  	return o;
  }

  /* [MS-XLSB] 2.5.4 Blxf TODO */
  function write_Blxf(data, o) {
  	if(!o) o = new_buf(10);
  	o.write_shift(1, 0); /* dg */
  	o.write_shift(1, 0);
  	o.write_shift(4, 0); /* color */
  	o.write_shift(4, 0); /* color */
  	return o;
  }
  /* [MS-XLSB] 2.4.302 BrtBorder TODO */
  var parse_BrtBorder = parsenoop;
  function write_BrtBorder(border, o) {
  	if(!o) o = new_buf(51);
  	o.write_shift(1, 0); /* diagonal */
  	write_Blxf(null, o); /* top */
  	write_Blxf(null, o); /* bottom */
  	write_Blxf(null, o); /* left */
  	write_Blxf(null, o); /* right */
  	write_Blxf(null, o); /* diag */
  	return o.length > o.l ? o.slice(0, o.l) : o;
  }

  /* [MS-XLSB] 2.4.763 BrtStyle TODO */
  function write_BrtStyle(style, o) {
  	if(!o) o = new_buf(12+4*10);
  	o.write_shift(4, style.xfId);
  	o.write_shift(2, 1);
  	o.write_shift(1, +style.builtinId);
  	o.write_shift(1, 0); /* iLevel */
  	write_XLNullableWideString(style.name || "", o);
  	return o.length > o.l ? o.slice(0, o.l) : o;
  }

  /* [MS-XLSB] 2.4.272 BrtBeginTableStyles */
  function write_BrtBeginTableStyles(cnt, defTableStyle, defPivotStyle) {
  	var o = new_buf(4+256*2*4);
  	o.write_shift(4, cnt);
  	write_XLNullableWideString(defTableStyle, o);
  	write_XLNullableWideString(defPivotStyle, o);
  	return o.length > o.l ? o.slice(0, o.l) : o;
  }

  function write_FMTS_bin(ba, NF/*:?SSFTable*/) {
  	if(!NF) return;
  	var cnt = 0;
  	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {
  		/*:: if(!NF) return; */
  		for(var i = r[0]; i <= r[1]; ++i) if(NF[i] != null) ++cnt;
  	});

  	if(cnt == 0) return;
  	write_record(ba, 0x0267 /* BrtBeginFmts */, write_UInt32LE(cnt));
  	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {
  		/*:: if(!NF) return; */
  		for(var i = r[0]; i <= r[1]; ++i) if(NF[i] != null) write_record(ba, 0x002C /* BrtFmt */, write_BrtFmt(i, NF[i]));
  	});
  	write_record(ba, 0x0268 /* BrtEndFmts */);
  }

  function write_FONTS_bin(ba/*::, data*/) {
  	var cnt = 1;
  	write_record(ba, 0x0263 /* BrtBeginFonts */, write_UInt32LE(cnt));
  	write_record(ba, 0x002B /* BrtFont */, write_BrtFont({
  		sz:12,
  		color: {theme:1},
  		name: "Calibri",
  		family: 2,
  		scheme: "minor"
  	}));
  	/* 1*65491BrtFont [ACFONTS] */
  	write_record(ba, 0x0264 /* BrtEndFonts */);
  }

  function write_FILLS_bin(ba/*::, data*/) {
  	var cnt = 2;
  	write_record(ba, 0x025B /* BrtBeginFills */, write_UInt32LE(cnt));
  	write_record(ba, 0x002D /* BrtFill */, write_BrtFill({patternType:"none"}));
  	write_record(ba, 0x002D /* BrtFill */, write_BrtFill({patternType:"gray125"}));
  	/* 1*65431BrtFill */
  	write_record(ba, 0x025C /* BrtEndFills */);
  }

  function write_BORDERS_bin(ba/*::, data*/) {
  	var cnt = 1;
  	write_record(ba, 0x0265 /* BrtBeginBorders */, write_UInt32LE(cnt));
  	write_record(ba, 0x002E /* BrtBorder */, write_BrtBorder());
  	/* 1*65430BrtBorder */
  	write_record(ba, 0x0266 /* BrtEndBorders */);
  }

  function write_CELLSTYLEXFS_bin(ba/*::, data*/) {
  	var cnt = 1;
  	write_record(ba, 0x0272 /* BrtBeginCellStyleXFs */, write_UInt32LE(cnt));
  	write_record(ba, 0x002F /* BrtXF */, write_BrtXF({
  		numFmtId: 0,
  		fontId:   0,
  		fillId:   0,
  		borderId: 0
  	}, 0xFFFF));
  	/* 1*65430(BrtXF *FRT) */
  	write_record(ba, 0x0273 /* BrtEndCellStyleXFs */);
  }

  function write_CELLXFS_bin(ba, data) {
  	write_record(ba, 0x0269 /* BrtBeginCellXFs */, write_UInt32LE(data.length));
  	data.forEach(function(c) { write_record(ba, 0x002F /* BrtXF */, write_BrtXF(c,0)); });
  	/* 1*65430(BrtXF *FRT) */
  	write_record(ba, 0x026A /* BrtEndCellXFs */);
  }

  function write_STYLES_bin(ba/*::, data*/) {
  	var cnt = 1;

  	write_record(ba, 0x026B /* BrtBeginStyles */, write_UInt32LE(cnt));
  	write_record(ba, 0x0030 /* BrtStyle */, write_BrtStyle({
  		xfId:0,
  		builtinId:0,
  		name:"Normal"
  	}));
  	/* 1*65430(BrtStyle *FRT) */
  	write_record(ba, 0x026C /* BrtEndStyles */);
  }

  function write_DXFS_bin(ba/*::, data*/) {
  	var cnt = 0;

  	write_record(ba, 0x01F9 /* BrtBeginDXFs */, write_UInt32LE(cnt));
  	/* *2147483647(BrtDXF *FRT) */
  	write_record(ba, 0x01FA /* BrtEndDXFs */);
  }

  function write_TABLESTYLES_bin(ba/*::, data*/) {
  	var cnt = 0;

  	write_record(ba, 0x01FC /* BrtBeginTableStyles */, write_BrtBeginTableStyles(cnt, "TableStyleMedium9", "PivotStyleMedium4"));
  	/* *TABLESTYLE */
  	write_record(ba, 0x01FD /* BrtEndTableStyles */);
  }

  /* [MS-XLSB] 2.1.7.50 Styles */
  function write_sty_bin(wb, opts) {
  	var ba = buf_array();
  	write_record(ba, 0x0116 /* BrtBeginStyleSheet */);
  	write_FMTS_bin(ba, wb.SSF);
  	write_FONTS_bin(ba);
  	write_FILLS_bin(ba);
  	write_BORDERS_bin(ba);
  	write_CELLSTYLEXFS_bin(ba);
  	write_CELLXFS_bin(ba, opts.cellXfs);
  	write_STYLES_bin(ba);
  	write_DXFS_bin(ba);
  	write_TABLESTYLES_bin(ba);
  	/* FRTSTYLESHEET*/
  	write_record(ba, 0x0117 /* BrtEndStyleSheet */);
  	return ba.end();
  }

  function write_theme(Themes, opts)/*:string*/ {
  	if(opts && opts.themeXLSX) return opts.themeXLSX;
  	if(Themes && typeof Themes.raw == "string") return Themes.raw;
  	var o = [XML_HEADER];
  	o[o.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
  	o[o.length] =  '<a:themeElements>';

  	o[o.length] =   '<a:clrScheme name="Office">';
  	o[o.length] =    '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
  	o[o.length] =    '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
  	o[o.length] =    '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
  	o[o.length] =    '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
  	o[o.length] =    '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
  	o[o.length] =    '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
  	o[o.length] =    '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
  	o[o.length] =    '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
  	o[o.length] =    '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
  	o[o.length] =    '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
  	o[o.length] =    '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
  	o[o.length] =    '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
  	o[o.length] =   '</a:clrScheme>';

  	o[o.length] =   '<a:fontScheme name="Office">';
  	o[o.length] =    '<a:majorFont>';
  	o[o.length] =     '<a:latin typeface="Cambria"/>';
  	o[o.length] =     '<a:ea typeface=""/>';
  	o[o.length] =     '<a:cs typeface=""/>';
  	o[o.length] =     '<a:font script="Jpan" typeface=" "/>';
  	o[o.length] =     '<a:font script="Hang" typeface=" "/>';
  	o[o.length] =     '<a:font script="Hans" typeface=""/>';
  	o[o.length] =     '<a:font script="Hant" typeface=""/>';
  	o[o.length] =     '<a:font script="Arab" typeface="Times New Roman"/>';
  	o[o.length] =     '<a:font script="Hebr" typeface="Times New Roman"/>';
  	o[o.length] =     '<a:font script="Thai" typeface="Tahoma"/>';
  	o[o.length] =     '<a:font script="Ethi" typeface="Nyala"/>';
  	o[o.length] =     '<a:font script="Beng" typeface="Vrinda"/>';
  	o[o.length] =     '<a:font script="Gujr" typeface="Shruti"/>';
  	o[o.length] =     '<a:font script="Khmr" typeface="MoolBoran"/>';
  	o[o.length] =     '<a:font script="Knda" typeface="Tunga"/>';
  	o[o.length] =     '<a:font script="Guru" typeface="Raavi"/>';
  	o[o.length] =     '<a:font script="Cans" typeface="Euphemia"/>';
  	o[o.length] =     '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  	o[o.length] =     '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  	o[o.length] =     '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  	o[o.length] =     '<a:font script="Thaa" typeface="MV Boli"/>';
  	o[o.length] =     '<a:font script="Deva" typeface="Mangal"/>';
  	o[o.length] =     '<a:font script="Telu" typeface="Gautami"/>';
  	o[o.length] =     '<a:font script="Taml" typeface="Latha"/>';
  	o[o.length] =     '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  	o[o.length] =     '<a:font script="Orya" typeface="Kalinga"/>';
  	o[o.length] =     '<a:font script="Mlym" typeface="Kartika"/>';
  	o[o.length] =     '<a:font script="Laoo" typeface="DokChampa"/>';
  	o[o.length] =     '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  	o[o.length] =     '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  	o[o.length] =     '<a:font script="Viet" typeface="Times New Roman"/>';
  	o[o.length] =     '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  	o[o.length] =     '<a:font script="Geor" typeface="Sylfaen"/>';
  	o[o.length] =    '</a:majorFont>';
  	o[o.length] =    '<a:minorFont>';
  	o[o.length] =     '<a:latin typeface="Calibri"/>';
  	o[o.length] =     '<a:ea typeface=""/>';
  	o[o.length] =     '<a:cs typeface=""/>';
  	o[o.length] =     '<a:font script="Jpan" typeface=" "/>';
  	o[o.length] =     '<a:font script="Hang" typeface=" "/>';
  	o[o.length] =     '<a:font script="Hans" typeface=""/>';
  	o[o.length] =     '<a:font script="Hant" typeface=""/>';
  	o[o.length] =     '<a:font script="Arab" typeface="Arial"/>';
  	o[o.length] =     '<a:font script="Hebr" typeface="Arial"/>';
  	o[o.length] =     '<a:font script="Thai" typeface="Tahoma"/>';
  	o[o.length] =     '<a:font script="Ethi" typeface="Nyala"/>';
  	o[o.length] =     '<a:font script="Beng" typeface="Vrinda"/>';
  	o[o.length] =     '<a:font script="Gujr" typeface="Shruti"/>';
  	o[o.length] =     '<a:font script="Khmr" typeface="DaunPenh"/>';
  	o[o.length] =     '<a:font script="Knda" typeface="Tunga"/>';
  	o[o.length] =     '<a:font script="Guru" typeface="Raavi"/>';
  	o[o.length] =     '<a:font script="Cans" typeface="Euphemia"/>';
  	o[o.length] =     '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  	o[o.length] =     '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  	o[o.length] =     '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  	o[o.length] =     '<a:font script="Thaa" typeface="MV Boli"/>';
  	o[o.length] =     '<a:font script="Deva" typeface="Mangal"/>';
  	o[o.length] =     '<a:font script="Telu" typeface="Gautami"/>';
  	o[o.length] =     '<a:font script="Taml" typeface="Latha"/>';
  	o[o.length] =     '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  	o[o.length] =     '<a:font script="Orya" typeface="Kalinga"/>';
  	o[o.length] =     '<a:font script="Mlym" typeface="Kartika"/>';
  	o[o.length] =     '<a:font script="Laoo" typeface="DokChampa"/>';
  	o[o.length] =     '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  	o[o.length] =     '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  	o[o.length] =     '<a:font script="Viet" typeface="Arial"/>';
  	o[o.length] =     '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  	o[o.length] =     '<a:font script="Geor" typeface="Sylfaen"/>';
  	o[o.length] =    '</a:minorFont>';
  	o[o.length] =   '</a:fontScheme>';

  	o[o.length] =   '<a:fmtScheme name="Office">';
  	o[o.length] =    '<a:fillStyleLst>';
  	o[o.length] =     '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  	o[o.length] =     '<a:gradFill rotWithShape="1">';
  	o[o.length] =      '<a:gsLst>';
  	o[o.length] =       '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  	o[o.length] =       '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  	o[o.length] =       '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  	o[o.length] =      '</a:gsLst>';
  	o[o.length] =      '<a:lin ang="16200000" scaled="1"/>';
  	o[o.length] =     '</a:gradFill>';
  	o[o.length] =     '<a:gradFill rotWithShape="1">';
  	o[o.length] =      '<a:gsLst>';
  	o[o.length] =       '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
  	o[o.length] =       '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  	o[o.length] =      '</a:gsLst>';
  	o[o.length] =      '<a:lin ang="16200000" scaled="0"/>';
  	o[o.length] =     '</a:gradFill>';
  	o[o.length] =    '</a:fillStyleLst>';
  	o[o.length] =    '<a:lnStyleLst>';
  	o[o.length] =     '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
  	o[o.length] =     '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  	o[o.length] =     '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  	o[o.length] =    '</a:lnStyleLst>';
  	o[o.length] =    '<a:effectStyleLst>';
  	o[o.length] =     '<a:effectStyle>';
  	o[o.length] =      '<a:effectLst>';
  	o[o.length] =       '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
  	o[o.length] =      '</a:effectLst>';
  	o[o.length] =     '</a:effectStyle>';
  	o[o.length] =     '<a:effectStyle>';
  	o[o.length] =      '<a:effectLst>';
  	o[o.length] =       '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  	o[o.length] =      '</a:effectLst>';
  	o[o.length] =     '</a:effectStyle>';
  	o[o.length] =     '<a:effectStyle>';
  	o[o.length] =      '<a:effectLst>';
  	o[o.length] =       '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  	o[o.length] =      '</a:effectLst>';
  	o[o.length] =      '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
  	o[o.length] =      '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
  	o[o.length] =     '</a:effectStyle>';
  	o[o.length] =    '</a:effectStyleLst>';
  	o[o.length] =    '<a:bgFillStyleLst>';
  	o[o.length] =     '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  	o[o.length] =     '<a:gradFill rotWithShape="1">';
  	o[o.length] =      '<a:gsLst>';
  	o[o.length] =       '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  	o[o.length] =       '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  	o[o.length] =       '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
  	o[o.length] =      '</a:gsLst>';
  	o[o.length] =      '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
  	o[o.length] =     '</a:gradFill>';
  	o[o.length] =     '<a:gradFill rotWithShape="1">';
  	o[o.length] =      '<a:gsLst>';
  	o[o.length] =       '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  	o[o.length] =       '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
  	o[o.length] =      '</a:gsLst>';
  	o[o.length] =      '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
  	o[o.length] =     '</a:gradFill>';
  	o[o.length] =    '</a:bgFillStyleLst>';
  	o[o.length] =   '</a:fmtScheme>';
  	o[o.length] =  '</a:themeElements>';

  	o[o.length] =  '<a:objectDefaults>';
  	o[o.length] =   '<a:spDef>';
  	o[o.length] =    '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
  	o[o.length] =   '</a:spDef>';
  	o[o.length] =   '<a:lnDef>';
  	o[o.length] =    '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
  	o[o.length] =   '</a:lnDef>';
  	o[o.length] =  '</a:objectDefaults>';
  	o[o.length] =  '<a:extraClrSchemeLst/>';
  	o[o.length] = '</a:theme>';
  	return o.join("");
  }

  function parse_BrtMdtinfo(data, length) {
    return {
      flags: data.read_shift(4),
      version: data.read_shift(4),
      name: parse_XLWideString(data)
    };
  }
  function write_BrtMdtinfo(data) {
    var o = new_buf(12 + 2 * data.name.length);
    o.write_shift(4, data.flags);
    o.write_shift(4, data.version);
    write_XLWideString(data.name, o);
    return o.slice(0, o.l);
  }
  function parse_BrtMdb(data) {
    var out = [];
    var cnt = data.read_shift(4);
    while (cnt-- > 0)
      out.push([data.read_shift(4), data.read_shift(4)]);
    return out;
  }
  function write_BrtMdb(mdb) {
    var o = new_buf(4 + 8 * mdb.length);
    o.write_shift(4, mdb.length);
    for (var i = 0; i < mdb.length; ++i) {
      o.write_shift(4, mdb[i][0]);
      o.write_shift(4, mdb[i][1]);
    }
    return o;
  }
  function write_BrtBeginEsfmd(cnt, name) {
    var o = new_buf(8 + 2 * name.length);
    o.write_shift(4, cnt);
    write_XLWideString(name, o);
    return o.slice(0, o.l);
  }
  function parse_BrtBeginEsmdb(data) {
    data.l += 4;
    return data.read_shift(4) != 0;
  }
  function write_BrtBeginEsmdb(cnt, cm) {
    var o = new_buf(8);
    o.write_shift(4, cnt);
    o.write_shift(4, cm ? 1 : 0);
    return o;
  }
  function write_xlmeta_bin() {
    var ba = buf_array();
    write_record(ba, 332);
    write_record(ba, 334, write_UInt32LE(1));
    write_record(ba, 335, write_BrtMdtinfo({
      name: "XLDAPR",
      version: 12e4,
      flags: 3496657072
    }));
    write_record(ba, 336);
    write_record(ba, 339, write_BrtBeginEsfmd(1, "XLDAPR"));
    write_record(ba, 52);
    write_record(ba, 35, write_UInt32LE(514));
    write_record(ba, 4096, write_UInt32LE(0));
    write_record(ba, 4097, writeuint16(1));
    write_record(ba, 36);
    write_record(ba, 53);
    write_record(ba, 340);
    write_record(ba, 337, write_BrtBeginEsmdb(1, true));
    write_record(ba, 51, write_BrtMdb([[1, 0]]));
    write_record(ba, 338);
    write_record(ba, 333);
    return ba.end();
  }
  function write_xlmeta_xml() {
    var o = [XML_HEADER];
    o.push('<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">\n  <metadataTypes count="1">\n    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>\n  </metadataTypes>\n  <futureMetadata name="XLDAPR" count="1">\n    <bk>\n      <extLst>\n        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">\n          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>\n        </ext>\n      </extLst>\n    </bk>\n  </futureMetadata>\n  <cellMetadata count="1">\n    <bk>\n      <rc t="1" v="0"/>\n    </bk>\n  </cellMetadata>\n</metadata>');
    return o.join("");
  }

  //function write_cc_xml(data, opts) { }

  /* [MS-XLSB] 2.6.4.1 */
  function parse_BrtCalcChainItem$(data) {
  	var out = {};
  	out.i = data.read_shift(4);
  	var cell = {};
  	cell.r = data.read_shift(4);
  	cell.c = data.read_shift(4);
  	out.r = encode_cell(cell);
  	var flags = data.read_shift(1);
  	if(flags & 0x2) out.l = '1';
  	if(flags & 0x8) out.a = '1';
  	return out;
  }

  /* L.5.5.2 SpreadsheetML Comments + VML Schema */
  var _shapeid = 1024;
  function write_comments_vml(rId/*:number*/, comments) {
  	var csize = [21600, 21600];
  	/* L.5.2.1.2 Path Attribute */
  	var bbox = ["m0,0l0",csize[1],csize[0],csize[1],csize[0],"0xe"].join(",");
  	var o = [
  		writextag("xml", null, { 'xmlns:v': XLMLNS.v, 'xmlns:o': XLMLNS.o, 'xmlns:x': XLMLNS.x, 'xmlns:mv': XLMLNS.mv }).replace(/\/>/,">"),
  		writextag("o:shapelayout", writextag("o:idmap", null, {'v:ext':"edit", 'data':rId}), {'v:ext':"edit"}),
  		writextag("v:shapetype", [
  			writextag("v:stroke", null, {joinstyle:"miter"}),
  			writextag("v:path", null, {gradientshapeok:"t", 'o:connecttype':"rect"})
  		].join(""), {id:"_x0000_t202", 'o:spt':202, coordsize:csize.join(","),path:bbox})
  	];
  	while(_shapeid < rId * 1000) _shapeid += 1000;

  	comments.forEach(function(x) {
  	var c = decode_cell(x[0]);
  	var fillopts = /*::(*/{'color2':"#BEFF82", 'type':"gradient"}/*:: :any)*/;
  	if(fillopts.type == "gradient") fillopts.angle = "-180";
  	var fillparm = fillopts.type == "gradient" ? writextag("o:fill", null, {type:"gradientUnscaled", 'v:ext':"view"}) : null;
  	var fillxml = writextag('v:fill', fillparm, fillopts);

  	var shadata = ({on:"t", 'obscured':"t"}/*:any*/);
  	++_shapeid;

  	o = o.concat([
  	'<v:shape' + wxt_helper({
  		id:'_x0000_s' + _shapeid,
  		type:"#_x0000_t202",
  		style:"position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (x[1].hidden ? ";visibility:hidden" : "") ,
  		fillcolor:"#ECFAD4",
  		strokecolor:"#edeaa1"
  	}) + '>',
  		fillxml,
  		writextag("v:shadow", null, shadata),
  		writextag("v:path", null, {'o:connecttype':"none"}),
  		'<v:textbox><div style="text-align:left"></div></v:textbox>',
  		'<x:ClientData ObjectType="Note">',
  			'<x:MoveWithCells/>',
  			'<x:SizeWithCells/>',
  			/* Part 4 19.4.2.3 Anchor (Anchor) */
  			writetag('x:Anchor', [c.c+1, 0, c.r+1, 0, c.c+3, 20, c.r+5, 20].join(",")),
  			writetag('x:AutoFill', "False"),
  			writetag('x:Row', String(c.r)),
  			writetag('x:Column', String(c.c)),
  			x[1].hidden ? '' : '<x:Visible/>',
  		'</x:ClientData>',
  	'</v:shape>'
  	]); });
  	o.push('</xml>');
  	return o.join("");
  }

  function write_comments_xml(data/*::, opts*/) {
  	var o = [XML_HEADER, writextag('comments', null, { 'xmlns': XMLNS_main[0] })];

  	var iauthor/*:Array<string>*/ = [];
  	o.push("<authors>");
  	data.forEach(function(x) { x[1].forEach(function(w) { var a = escapexml(w.a);
  		if(iauthor.indexOf(a) == -1) {
  			iauthor.push(a);
  			o.push("<author>" + a + "</author>");
  		}
  		if(w.T && w.ID && iauthor.indexOf("tc=" + w.ID) == -1) {
  			iauthor.push("tc=" + w.ID);
  			o.push("<author>" + "tc=" + w.ID + "</author>");
  		}
  	}); });
  	if(iauthor.length == 0) { iauthor.push("SheetJ5"); o.push("<author>SheetJ5</author>"); }
  	o.push("</authors>");
  	o.push("<commentList>");
  	data.forEach(function(d) {
  		/* 18.7.3 CT_Comment */
  		var lastauthor = 0, ts = [];
  		if(d[1][0] && d[1][0].T && d[1][0].ID) lastauthor = iauthor.indexOf("tc=" + d[1][0].ID);
  		else d[1].forEach(function(c) {
  			if(c.a) lastauthor = iauthor.indexOf(escapexml(c.a));
  			ts.push(c.t||"");
  		});
  		o.push('<comment ref="' + d[0] + '" authorId="' + lastauthor + '"><text>');
  		if(ts.length <= 1) o.push(writetag("t", escapexml(ts[0]||"")));
  		else {
  			/* based on Threaded Comments -> Comments projection */
  			var t = "Comment:\n    " + (ts[0]) + "\n";
  			for(var i = 1; i < ts.length; ++i) t += "Reply:\n    " + ts[i] + "\n";
  			o.push(writetag("t", escapexml(t)));
  		}
  		o.push('</text></comment>');
  	});
  	o.push("</commentList>");
  	if(o.length>2) { o[o.length] = ('</comments>'); o[1]=o[1].replace("/>",">"); }
  	return o.join("");
  }

  function write_tcmnt_xml(comments, people, opts) {
  	var o = [XML_HEADER, writextag('ThreadedComments', null, { 'xmlns': XMLNS.TCMNT }).replace(/[\/]>/, ">")];
  	comments.forEach(function(carr) {
  		var rootid = "";
  		(carr[1] || []).forEach(function(c, idx) {
  			if(!c.T) { delete c.ID; return; }
  			if(c.a && people.indexOf(c.a) == -1) people.push(c.a);
  			var tcopts = {
  				ref: carr[0],
  				id: "{54EE7951-7262-4200-6969-" + ("000000000000" + opts.tcid++).slice(-12) + "}"
  			};
  			if(idx == 0) rootid = tcopts.id;
  			else tcopts.parentId = rootid;
  			c.ID = tcopts.id;
  			if(c.a) tcopts.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + people.indexOf(c.a)).slice(-12) + "}";
  			o.push(writextag('threadedComment', writetag('text', c.t||""), tcopts));
  		});
  	});
  	o.push('</ThreadedComments>');
  	return o.join("");
  }
  function write_people_xml(people/*, opts*/) {
  	var o = [XML_HEADER, writextag('personList', null, {
  		'xmlns': XMLNS.TCMNT,
  		'xmlns:x': XMLNS_main[0]
  	}).replace(/[\/]>/, ">")];
  	people.forEach(function(person, idx) {
  		o.push(writextag('person', null, {
  			displayName: person,
  			id: "{54EE7950-7262-4200-6969-" + ("000000000000" + idx).slice(-12) + "}",
  			userId: person,
  			providerId: "None"
  		}));
  	});
  	o.push("</personList>");
  	return o.join("");
  }
  /* [MS-XLSB] 2.4.28 BrtBeginComment */
  function parse_BrtBeginComment(data) {
  	var out = {};
  	out.iauthor = data.read_shift(4);
  	var rfx = parse_UncheckedRfX(data);
  	out.rfx = rfx.s;
  	out.ref = encode_cell(rfx.s);
  	data.l += 16; /*var guid = parse_GUID(data); */
  	return out;
  }
  function write_BrtBeginComment(data, o) {
  	if(o == null) o = new_buf(36);
  	o.write_shift(4, data[1].iauthor);
  	write_UncheckedRfX((data[0]/*:any*/), o);
  	o.write_shift(4, 0);
  	o.write_shift(4, 0);
  	o.write_shift(4, 0);
  	o.write_shift(4, 0);
  	return o;
  }

  /* [MS-XLSB] 2.4.327 BrtCommentAuthor */
  var parse_BrtCommentAuthor = parse_XLWideString;
  function write_BrtCommentAuthor(data) { return write_XLWideString(data.slice(0, 54)); }

  function write_comments_bin(data/*::, opts*/) {
  	var ba = buf_array();
  	var iauthor/*:Array<string>*/ = [];
  	write_record(ba, 0x0274 /* BrtBeginComments */);

  	write_record(ba, 0x0276 /* BrtBeginCommentAuthors */);
  	data.forEach(function(comment) {
  		comment[1].forEach(function(c) {
  			if(iauthor.indexOf(c.a) > -1) return;
  			iauthor.push(c.a.slice(0,54));
  			write_record(ba, 0x0278 /* BrtCommentAuthor */, write_BrtCommentAuthor(c.a));
  		});
  	});
  	write_record(ba, 0x0277 /* BrtEndCommentAuthors */);

  	write_record(ba, 0x0279 /* BrtBeginCommentList */);
  	data.forEach(function(comment) {
  		comment[1].forEach(function(c) {
  			c.iauthor = iauthor.indexOf(c.a);
  			var range = {s:decode_cell(comment[0]),e:decode_cell(comment[0])};
  			write_record(ba, 0x027B /* BrtBeginComment */, write_BrtBeginComment([range, c]));
  			if(c.t && c.t.length > 0) write_record(ba, 0x027D /* BrtCommentText */, write_BrtCommentText(c));
  			write_record(ba, 0x027C /* BrtEndComment */);
  			delete c.iauthor;
  		});
  	});
  	write_record(ba, 0x027A /* BrtEndCommentList */);

  	write_record(ba, 0x0275 /* BrtEndComments */);
  	return ba.end();
  }
  function fill_vba_xls(cfb, vba) {
    vba.FullPaths.forEach(function(p, i) {
      if (i == 0)
        return;
      var newpath = p.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
      if (newpath.slice(-1) !== "/")
        CFB.utils.cfb_add(cfb, newpath, vba.FileIndex[i].content);
    });
  }
  var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
  /* TODO: it will be useful to parse the function str */
  var rc_to_a1 = /*#__PURE__*/(function(){
  	var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;
  	var rcbase/*:Cell*/ = ({r:0,c:0}/*:any*/);
  	function rcfunc($$,$1,$2,$3) {
  		var cRel = false, rRel = false;

  		if($2.length == 0) rRel = true;
  		else if($2.charAt(0) == "[") { rRel = true; $2 = $2.slice(1, -1); }

  		if($3.length == 0) cRel = true;
  		else if($3.charAt(0) == "[") { cRel = true; $3 = $3.slice(1, -1); }

  		var R = $2.length>0?parseInt($2,10)|0:0, C = $3.length>0?parseInt($3,10)|0:0;

  		if(cRel) C += rcbase.c; else --C;
  		if(rRel) R += rcbase.r; else --R;
  		return $1 + (cRel ? "" : "$") + encode_col(C) + (rRel ? "" : "$") + encode_row(R);
  	}
  	return function rc_to_a1(fstr/*:string*/, base/*:Cell*/)/*:string*/ {
  		rcbase = base;
  		return fstr.replace(rcregex, rcfunc);
  	};
  })();

  var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
  var a1_to_rc = /*#__PURE__*/(function(){
  	return function a1_to_rc(fstr/*:string*/, base/*:CellAddress*/) {
  		return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
  			var c = decode_col($3) - ($2 ? 0 : base.c);
  			var r = decode_row($5) - ($4 ? 0 : base.r);
  			var R = (r == 0 ? "" : !$4 ? "[" + r + "]" : (r+1));
  			var C = (c == 0 ? "" : !$2 ? "[" + c + "]" : (c+1));
  			return $1 + "R" + R + "C" + C;
  		});
  	};
  })();

  /* no defined name can collide with a valid cell address A1:XFD1048576 ... except LOG10! */
  function shift_formula_str(f/*:string*/, delta/*:Cell*/)/*:string*/ {
  	return f.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
  		return $1+($2=="$" ? $2+$3 : encode_col(decode_col($3)+delta.c))+($4=="$" ? $4+$5 : encode_row(decode_row($5) + delta.r));
  	});
  }

  /* TODO: parse formula */
  function fuzzyfmla(f/*:string*/)/*:boolean*/ {
  	if(f.length == 1) return false;
  	return true;
  }
  function parseread1(blob) { blob.l+=1; return; }

  /* [MS-XLS] 2.5.51 */
  function parse_ColRelU(blob, length) {
  	var c = blob.read_shift(length == 1 ? 1 : 2);
  	return [c & 0x3FFF, (c >> 14) & 1, (c >> 15) & 1];
  }

  /* [MS-XLS] 2.5.198.105 ; [MS-XLSB] 2.5.97.89 */
  function parse_RgceArea(blob, length, opts) {
  	var w = 2;
  	if(opts) {
  		if(opts.biff >= 2 && opts.biff <= 5) return parse_RgceArea_BIFF2(blob);
  		else if(opts.biff == 12) w = 4;
  	}
  	var r=blob.read_shift(w), R=blob.read_shift(w);
  	var c=parse_ColRelU(blob, 2);
  	var C=parse_ColRelU(blob, 2);
  	return { s:{r:r, c:c[0], cRel:c[1], rRel:c[2]}, e:{r:R, c:C[0], cRel:C[1], rRel:C[2]} };
  }
  /* BIFF 2-5 encodes flags in the row field */
  function parse_RgceArea_BIFF2(blob/*::, length, opts*/) {
  	var r=parse_ColRelU(blob, 2), R=parse_ColRelU(blob, 2);
  	var c=blob.read_shift(1);
  	var C=blob.read_shift(1);
  	return { s:{r:r[0], c:c, cRel:r[1], rRel:r[2]}, e:{r:R[0], c:C, cRel:R[1], rRel:R[2]} };
  }

  /* [MS-XLS] 2.5.198.105 ; [MS-XLSB] 2.5.97.90 */
  function parse_RgceAreaRel(blob, length, opts) {
  	if(opts.biff < 8) return parse_RgceArea_BIFF2(blob);
  	var r=blob.read_shift(opts.biff == 12 ? 4 : 2), R=blob.read_shift(opts.biff == 12 ? 4 : 2);
  	var c=parse_ColRelU(blob, 2);
  	var C=parse_ColRelU(blob, 2);
  	return { s:{r:r, c:c[0], cRel:c[1], rRel:c[2]}, e:{r:R, c:C[0], cRel:C[1], rRel:C[2]} };
  }

  /* [MS-XLS] 2.5.198.109 ; [MS-XLSB] 2.5.97.91 */
  function parse_RgceLoc(blob, length, opts) {
  	if(opts && opts.biff >= 2 && opts.biff <= 5) return parse_RgceLoc_BIFF2(blob);
  	var r = blob.read_shift(opts && opts.biff == 12 ? 4 : 2);
  	var c = parse_ColRelU(blob, 2);
  	return {r:r, c:c[0], cRel:c[1], rRel:c[2]};
  }
  function parse_RgceLoc_BIFF2(blob/*::, length, opts*/) {
  	var r = parse_ColRelU(blob, 2);
  	var c = blob.read_shift(1);
  	return {r:r[0], c:c, cRel:r[1], rRel:r[2]};
  }

  /* [MS-XLS] 2.5.198.107, 2.5.47 */
  function parse_RgceElfLoc(blob/*::, length, opts*/) {
  	var r = blob.read_shift(2);
  	var c = blob.read_shift(2);
  	return {r:r, c:c & 0xFF, fQuoted:!!(c & 0x4000), cRel:c>>15, rRel:c>>15 };
  }

  /* [MS-XLS] 2.5.198.111 ; [MS-XLSB] 2.5.97.92 TODO */
  function parse_RgceLocRel(blob, length, opts) {
  	var biff = opts && opts.biff ? opts.biff : 8;
  	if(biff >= 2 && biff <= 5) return parse_RgceLocRel_BIFF2(blob);
  	var r = blob.read_shift(biff >= 12 ? 4 : 2);
  	var cl = blob.read_shift(2);
  	var cRel = (cl & 0x4000) >> 14, rRel = (cl & 0x8000) >> 15;
  	cl &= 0x3FFF;
  	if(rRel == 1) while(r > 0x7FFFF) r -= 0x100000;
  	if(cRel == 1) while(cl > 0x1FFF) cl = cl - 0x4000;
  	return {r:r,c:cl,cRel:cRel,rRel:rRel};
  }
  function parse_RgceLocRel_BIFF2(blob/*::, length:number, opts*/) {
  	var rl = blob.read_shift(2);
  	var c = blob.read_shift(1);
  	var rRel = (rl & 0x8000) >> 15, cRel = (rl & 0x4000) >> 14;
  	rl &= 0x3FFF;
  	if(rRel == 1 && rl >= 0x2000) rl = rl - 0x4000;
  	if(cRel == 1 && c >= 0x80) c = c - 0x100;
  	return {r:rl,c:c,cRel:cRel,rRel:rRel};
  }

  /* [MS-XLS] 2.5.198.27 ; [MS-XLSB] 2.5.97.18 */
  function parse_PtgArea(blob, length, opts) {
  	var type = (blob[blob.l++] & 0x60) >> 5;
  	var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
  	return [type, area];
  }

  /* [MS-XLS] 2.5.198.28 ; [MS-XLSB] 2.5.97.19 */
  function parse_PtgArea3d(blob, length, opts) {
  	var type = (blob[blob.l++] & 0x60) >> 5;
  	var ixti = blob.read_shift(2, 'i');
  	var w = 8;
  	if(opts) switch(opts.biff) {
  		case 5: blob.l += 12; w = 6; break;
  		case 12: w = 12; break;
  	}
  	var area = parse_RgceArea(blob, w, opts);
  	return [type, ixti, area];
  }

  /* [MS-XLS] 2.5.198.29 ; [MS-XLSB] 2.5.97.20 */
  function parse_PtgAreaErr(blob, length, opts) {
  	var type = (blob[blob.l++] & 0x60) >> 5;
  	blob.l += opts && (opts.biff > 8) ? 12 : (opts.biff < 8 ? 6 : 8);
  	return [type];
  }
  /* [MS-XLS] 2.5.198.30 ; [MS-XLSB] 2.5.97.21 */
  function parse_PtgAreaErr3d(blob, length, opts) {
  	var type = (blob[blob.l++] & 0x60) >> 5;
  	var ixti = blob.read_shift(2);
  	var w = 8;
  	if(opts) switch(opts.biff) {
  		case 5: blob.l += 12; w = 6; break;
  		case 12: w = 12; break;
  	}
  	blob.l += w;
  	return [type, ixti];
  }

  /* [MS-XLS] 2.5.198.31 ; [MS-XLSB] 2.5.97.22 */
  function parse_PtgAreaN(blob, length, opts) {
  	var type = (blob[blob.l++] & 0x60) >> 5;
  	var area = parse_RgceAreaRel(blob, length - 1, opts);
  	return [type, area];
  }

  /* [MS-XLS] 2.5.198.32 ; [MS-XLSB] 2.5.97.23 */
  function parse_PtgArray(blob, length, opts) {
  	var type = (blob[blob.l++] & 0x60) >> 5;
  	blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
  	return [type];
  }

  /* [MS-XLS] 2.5.198.33 ; [MS-XLSB] 2.5.97.24 */
  function parse_PtgAttrBaxcel(blob) {
  	var bitSemi = blob[blob.l+1] & 0x01; /* 1 = volatile */
  	var bitBaxcel = 1;
  	blob.l += 4;
  	return [bitSemi, bitBaxcel];
  }

  /* [MS-XLS] 2.5.198.34 ; [MS-XLSB] 2.5.97.25 */
  function parse_PtgAttrChoose(blob, length, opts)/*:Array<number>*/ {
  	blob.l +=2;
  	var offset = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  	var o/*:Array<number>*/ = [];
  	/* offset is 1 less than the number of elements */
  	for(var i = 0; i <= offset; ++i) o.push(blob.read_shift(opts && opts.biff == 2 ? 1 : 2));
  	return o;
  }

  /* [MS-XLS] 2.5.198.35 ; [MS-XLSB] 2.5.97.26 */
  function parse_PtgAttrGoto(blob, length, opts) {
  	var bitGoto = (blob[blob.l+1] & 0xFF) ? 1 : 0;
  	blob.l += 2;
  	return [bitGoto, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
  }

  /* [MS-XLS] 2.5.198.36 ; [MS-XLSB] 2.5.97.27 */
  function parse_PtgAttrIf(blob, length, opts) {
  	var bitIf = (blob[blob.l+1] & 0xFF) ? 1 : 0;
  	blob.l += 2;
  	return [bitIf, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
  }

  /* [MS-XLSB] 2.5.97.28 */
  function parse_PtgAttrIfError(blob) {
  	var bitIf = (blob[blob.l+1] & 0xFF) ? 1 : 0;
  	blob.l += 2;
  	return [bitIf, blob.read_shift(2)];
  }

  /* [MS-XLS] 2.5.198.37 ; [MS-XLSB] 2.5.97.29 */
  function parse_PtgAttrSemi(blob, length, opts) {
  	var bitSemi = (blob[blob.l+1] & 0xFF) ? 1 : 0;
  	blob.l += opts && opts.biff == 2 ? 3 : 4;
  	return [bitSemi];
  }

  /* [MS-XLS] 2.5.198.40 ; [MS-XLSB] 2.5.97.32 */
  function parse_PtgAttrSpaceType(blob/*::, length*/) {
  	var type = blob.read_shift(1), cch = blob.read_shift(1);
  	return [type, cch];
  }

  /* [MS-XLS] 2.5.198.38 ; [MS-XLSB] 2.5.97.30 */
  function parse_PtgAttrSpace(blob) {
  	blob.read_shift(2);
  	return parse_PtgAttrSpaceType(blob);
  }

  /* [MS-XLS] 2.5.198.39 ; [MS-XLSB] 2.5.97.31 */
  function parse_PtgAttrSpaceSemi(blob) {
  	blob.read_shift(2);
  	return parse_PtgAttrSpaceType(blob);
  }

  /* [MS-XLS] 2.5.198.84 ; [MS-XLSB] 2.5.97.68 TODO */
  function parse_PtgRef(blob, length, opts) {
  	//var ptg = blob[blob.l] & 0x1F;
  	var type = (blob[blob.l] & 0x60)>>5;
  	blob.l += 1;
  	var loc = parse_RgceLoc(blob, 0, opts);
  	return [type, loc];
  }

  /* [MS-XLS] 2.5.198.88 ; [MS-XLSB] 2.5.97.72 TODO */
  function parse_PtgRefN(blob, length, opts) {
  	var type = (blob[blob.l] & 0x60)>>5;
  	blob.l += 1;
  	var loc = parse_RgceLocRel(blob, 0, opts);
  	return [type, loc];
  }

  /* [MS-XLS] 2.5.198.85 ; [MS-XLSB] 2.5.97.69 TODO */
  function parse_PtgRef3d(blob, length, opts) {
  	var type = (blob[blob.l] & 0x60)>>5;
  	blob.l += 1;
  	var ixti = blob.read_shift(2); // XtiIndex
  	if(opts && opts.biff == 5) blob.l += 12;
  	var loc = parse_RgceLoc(blob, 0, opts); // TODO: or RgceLocRel
  	return [type, ixti, loc];
  }


  /* [MS-XLS] 2.5.198.62 ; [MS-XLSB] 2.5.97.45 TODO */
  function parse_PtgFunc(blob, length, opts) {
  	//var ptg = blob[blob.l] & 0x1F;
  	var type = (blob[blob.l] & 0x60)>>5;
  	blob.l += 1;
  	var iftab = blob.read_shift(opts && opts.biff <= 3 ? 1 : 2);
  	return [FtabArgc[iftab], Ftab[iftab], type];
  }
  /* [MS-XLS] 2.5.198.63 ; [MS-XLSB] 2.5.97.46 TODO */
  function parse_PtgFuncVar(blob, length, opts) {
  	var type = blob[blob.l++];
  	var cparams = blob.read_shift(1), tab = opts && opts.biff <= 3 ? [(type == 0x58 ? -1 : 0), blob.read_shift(1)]: parsetab(blob);
  	return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
  }

  function parsetab(blob) {
  	return [blob[blob.l+1]>>7, blob.read_shift(2) & 0x7FFF];
  }

  /* [MS-XLS] 2.5.198.41 ; [MS-XLSB] 2.5.97.33 */
  function parse_PtgAttrSum(blob, length, opts) {
  	blob.l += opts && opts.biff == 2 ? 3 : 4; return;
  }

  /* [MS-XLS] 2.5.198.58 ; [MS-XLSB] 2.5.97.40 */
  function parse_PtgExp(blob, length, opts) {
  	blob.l++;
  	if(opts && opts.biff == 12) return [blob.read_shift(4, 'i'), 0];
  	var row = blob.read_shift(2);
  	var col = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  	return [row, col];
  }

  /* [MS-XLS] 2.5.198.57 ; [MS-XLSB] 2.5.97.39 */
  function parse_PtgErr(blob) { blob.l++; return BErr[blob.read_shift(1)]; }

  /* [MS-XLS] 2.5.198.66 ; [MS-XLSB] 2.5.97.49 */
  function parse_PtgInt(blob) { blob.l++; return blob.read_shift(2); }

  /* [MS-XLS] 2.5.198.42 ; [MS-XLSB] 2.5.97.34 */
  function parse_PtgBool(blob) { blob.l++; return blob.read_shift(1)!==0;}

  /* [MS-XLS] 2.5.198.79 ; [MS-XLSB] 2.5.97.63 */
  function parse_PtgNum(blob) { blob.l++; return parse_Xnum(blob); }

  /* [MS-XLS] 2.5.198.89 ; [MS-XLSB] 2.5.97.74 */
  function parse_PtgStr(blob, length, opts) { blob.l++; return parse_ShortXLUnicodeString(blob, length-1, opts); }

  /* [MS-XLS] 2.5.192.112 + 2.5.192.11{3,4,5,6,7} */
  /* [MS-XLSB] 2.5.97.93 + 2.5.97.9{4,5,6,7} */
  function parse_SerAr(blob, biff/*:number*/) {
  	var val = [blob.read_shift(1)];
  	if(biff == 12) switch(val[0]) {
  		case 0x02: val[0] = 0x04; break; /* SerBool */
  		case 0x04: val[0] = 0x10; break; /* SerErr */
  		case 0x00: val[0] = 0x01; break; /* SerNum */
  		case 0x01: val[0] = 0x02; break; /* SerStr */
  	}
  	switch(val[0]) {
  		case 0x04: /* SerBool -- boolean */
  			val[1] = parsebool(blob, 1) ? 'TRUE' : 'FALSE';
  			if(biff != 12) blob.l += 7; break;
  		case 0x25: /* appears to be an alias */
  		case 0x10: /* SerErr -- error */
  			val[1] = BErr[blob[blob.l]];
  			blob.l += ((biff == 12) ? 4 : 8); break;
  		case 0x00: /* SerNil -- honestly, I'm not sure how to reproduce this */
  			blob.l += 8; break;
  		case 0x01: /* SerNum -- Xnum */
  			val[1] = parse_Xnum(blob); break;
  		case 0x02: /* SerStr -- XLUnicodeString (<256 chars) */
  			val[1] = parse_XLUnicodeString2(blob, 0, {biff:biff > 0 && biff < 8 ? 2 : biff}); break;
  		default: throw new Error("Bad SerAr: " + val[0]); /* Unreachable */
  	}
  	return val;
  }

  /* [MS-XLS] 2.5.198.61 ; [MS-XLSB] 2.5.97.44 */
  function parse_PtgExtraMem(blob, cce, opts) {
  	var count = blob.read_shift((opts.biff == 12) ? 4 : 2);
  	var out/*:Array<Range>*/ = [];
  	for(var i = 0; i != count; ++i) out.push(((opts.biff == 12) ? parse_UncheckedRfX : parse_Ref8U)(blob));
  	return out;
  }

  /* [MS-XLS] 2.5.198.59 ; [MS-XLSB] 2.5.97.41 */
  function parse_PtgExtraArray(blob, length, opts) {
  	var rows = 0, cols = 0;
  	if(opts.biff == 12) {
  		rows = blob.read_shift(4); // DRw
  		cols = blob.read_shift(4); // DCol
  	} else {
  		cols = 1 + blob.read_shift(1); //DColByteU
  		rows = 1 + blob.read_shift(2); //DRw
  	}
  	if(opts.biff >= 2 && opts.biff < 8) { --rows; if(--cols == 0) cols = 0x100; }
  	// $FlowIgnore
  	for(var i = 0, o/*:Array<Array<any>>*/ = []; i != rows && (o[i] = []); ++i)
  		for(var j = 0; j != cols; ++j) o[i][j] = parse_SerAr(blob, opts.biff);
  	return o;
  }

  /* [MS-XLS] 2.5.198.76 ; [MS-XLSB] 2.5.97.60 */
  function parse_PtgName(blob, length, opts) {
  	var type = (blob.read_shift(1) >>> 5) & 0x03;
  	var w = (!opts || (opts.biff >= 8)) ? 4 : 2;
  	var nameindex = blob.read_shift(w);
  	switch(opts.biff) {
  		case 2: blob.l += 5; break;
  		case 3: case 4: blob.l += 8; break;
  		case 5: blob.l += 12; break;
  	}
  	return [type, 0, nameindex];
  }

  /* [MS-XLS] 2.5.198.77 ; [MS-XLSB] 2.5.97.61 */
  function parse_PtgNameX(blob, length, opts) {
  	if(opts.biff == 5) return parse_PtgNameX_BIFF5(blob);
  	var type = (blob.read_shift(1) >>> 5) & 0x03;
  	var ixti = blob.read_shift(2); // XtiIndex
  	var nameindex = blob.read_shift(4);
  	return [type, ixti, nameindex];
  }
  function parse_PtgNameX_BIFF5(blob/*::, length, opts*/) {
  	var type = (blob.read_shift(1) >>> 5) & 0x03;
  	var ixti = blob.read_shift(2, 'i'); // XtiIndex
  	blob.l += 8;
  	var nameindex = blob.read_shift(2);
  	blob.l += 12;
  	return [type, ixti, nameindex];
  }

  /* [MS-XLS] 2.5.198.70 ; [MS-XLSB] 2.5.97.54 */
  function parse_PtgMemArea(blob, length, opts) {
  	var type = (blob.read_shift(1) >>> 5) & 0x03;
  	blob.l += (opts && opts.biff == 2 ? 3 : 4);
  	var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  	return [type, cce];
  }

  /* [MS-XLS] 2.5.198.72 ; [MS-XLSB] 2.5.97.56 */
  function parse_PtgMemFunc(blob, length, opts) {
  	var type = (blob.read_shift(1) >>> 5) & 0x03;
  	var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  	return [type, cce];
  }


  /* [MS-XLS] 2.5.198.86 ; [MS-XLSB] 2.5.97.69 */
  function parse_PtgRefErr(blob, length, opts) {
  	var type = (blob.read_shift(1) >>> 5) & 0x03;
  	blob.l += 4;
  	if(opts.biff < 8) blob.l--;
  	if(opts.biff == 12) blob.l += 2;
  	return [type];
  }

  /* [MS-XLS] 2.5.198.87 ; [MS-XLSB] 2.5.97.71 */
  function parse_PtgRefErr3d(blob, length, opts) {
  	var type = (blob[blob.l++] & 0x60) >> 5;
  	var ixti = blob.read_shift(2);
  	var w = 4;
  	if(opts) switch(opts.biff) {
  		case 5: w = 15; break;
  		case 12: w = 6; break;
  	}
  	blob.l += w;
  	return [type, ixti];
  }

  /* [MS-XLS] 2.5.198.71 ; [MS-XLSB] 2.5.97.55 */
  var parse_PtgMemErr = parsenoop;
  /* [MS-XLS] 2.5.198.73  ; [MS-XLSB] 2.5.97.57 */
  var parse_PtgMemNoMem = parsenoop;
  /* [MS-XLS] 2.5.198.92 */
  var parse_PtgTbl = parsenoop;

  function parse_PtgElfLoc(blob, length, opts) {
  	blob.l += 2;
  	return [parse_RgceElfLoc(blob)];
  }
  function parse_PtgElfNoop(blob/*::, length, opts*/) {
  	blob.l += 6;
  	return [];
  }
  /* [MS-XLS] 2.5.198.46 */
  var parse_PtgElfCol = parse_PtgElfLoc;
  /* [MS-XLS] 2.5.198.47 */
  var parse_PtgElfColS = parse_PtgElfNoop;
  /* [MS-XLS] 2.5.198.48 */
  var parse_PtgElfColSV = parse_PtgElfNoop;
  /* [MS-XLS] 2.5.198.49 */
  var parse_PtgElfColV = parse_PtgElfLoc;
  /* [MS-XLS] 2.5.198.50 */
  function parse_PtgElfLel(blob/*::, length, opts*/) {
  	blob.l += 2;
  	return [parseuint16(blob), blob.read_shift(2) & 0x01];
  }
  /* [MS-XLS] 2.5.198.51 */
  var parse_PtgElfRadical = parse_PtgElfLoc;
  /* [MS-XLS] 2.5.198.52 */
  var parse_PtgElfRadicalLel = parse_PtgElfLel;
  /* [MS-XLS] 2.5.198.53 */
  var parse_PtgElfRadicalS = parse_PtgElfNoop;
  /* [MS-XLS] 2.5.198.54 */
  var parse_PtgElfRw = parse_PtgElfLoc;
  /* [MS-XLS] 2.5.198.55 */
  var parse_PtgElfRwV = parse_PtgElfLoc;

  /* [MS-XLSB] 2.5.97.52 TODO */
  var PtgListRT = [
  	"Data",
  	"All",
  	"Headers",
  	"??",
  	"?Data2",
  	"??",
  	"?DataHeaders",
  	"??",
  	"Totals",
  	"??",
  	"??",
  	"??",
  	"?DataTotals",
  	"??",
  	"??",
  	"??",
  	"?Current"
  ];
  function parse_PtgList(blob/*::, length, opts*/) {
  	blob.l += 2;
  	var ixti = blob.read_shift(2);
  	var flags = blob.read_shift(2);
  	var idx = blob.read_shift(4);
  	var c = blob.read_shift(2);
  	var C = blob.read_shift(2);
  	var rt = PtgListRT[(flags >> 2) & 0x1F];
  	return {ixti: ixti, coltype:(flags&0x3), rt:rt, idx:idx, c:c, C:C};
  }
  /* [MS-XLS] 2.5.198.91 ; [MS-XLSB] 2.5.97.76 */
  function parse_PtgSxName(blob/*::, length, opts*/) {
  	blob.l += 2;
  	return [blob.read_shift(4)];
  }

  /* [XLS] old spec */
  function parse_PtgSheet(blob, length, opts) {
  	blob.l += 5;
  	blob.l += 2;
  	blob.l += (opts.biff == 2 ? 1 : 4);
  	return ["PTGSHEET"];
  }
  function parse_PtgEndSheet(blob, length, opts) {
  	blob.l += (opts.biff == 2 ? 4 : 5);
  	return ["PTGENDSHEET"];
  }
  function parse_PtgMemAreaN(blob/*::, length, opts*/) {
  	var type = (blob.read_shift(1) >>> 5) & 0x03;
  	var cce = blob.read_shift(2);
  	return [type, cce];
  }
  function parse_PtgMemNoMemN(blob/*::, length, opts*/) {
  	var type = (blob.read_shift(1) >>> 5) & 0x03;
  	var cce = blob.read_shift(2);
  	return [type, cce];
  }
  function parse_PtgAttrNoop(blob/*::, length, opts*/) {
  	blob.l += 4;
  	return [0, 0];
  }

  /* [MS-XLS] 2.5.198.25 ; [MS-XLSB] 2.5.97.16 */
  var PtgTypes = {
  	/*::[*/0x01/*::]*/: { n:'PtgExp', f:parse_PtgExp },
  	/*::[*/0x02/*::]*/: { n:'PtgTbl', f:parse_PtgTbl },
  	/*::[*/0x03/*::]*/: { n:'PtgAdd', f:parseread1 },
  	/*::[*/0x04/*::]*/: { n:'PtgSub', f:parseread1 },
  	/*::[*/0x05/*::]*/: { n:'PtgMul', f:parseread1 },
  	/*::[*/0x06/*::]*/: { n:'PtgDiv', f:parseread1 },
  	/*::[*/0x07/*::]*/: { n:'PtgPower', f:parseread1 },
  	/*::[*/0x08/*::]*/: { n:'PtgConcat', f:parseread1 },
  	/*::[*/0x09/*::]*/: { n:'PtgLt', f:parseread1 },
  	/*::[*/0x0A/*::]*/: { n:'PtgLe', f:parseread1 },
  	/*::[*/0x0B/*::]*/: { n:'PtgEq', f:parseread1 },
  	/*::[*/0x0C/*::]*/: { n:'PtgGe', f:parseread1 },
  	/*::[*/0x0D/*::]*/: { n:'PtgGt', f:parseread1 },
  	/*::[*/0x0E/*::]*/: { n:'PtgNe', f:parseread1 },
  	/*::[*/0x0F/*::]*/: { n:'PtgIsect', f:parseread1 },
  	/*::[*/0x10/*::]*/: { n:'PtgUnion', f:parseread1 },
  	/*::[*/0x11/*::]*/: { n:'PtgRange', f:parseread1 },
  	/*::[*/0x12/*::]*/: { n:'PtgUplus', f:parseread1 },
  	/*::[*/0x13/*::]*/: { n:'PtgUminus', f:parseread1 },
  	/*::[*/0x14/*::]*/: { n:'PtgPercent', f:parseread1 },
  	/*::[*/0x15/*::]*/: { n:'PtgParen', f:parseread1 },
  	/*::[*/0x16/*::]*/: { n:'PtgMissArg', f:parseread1 },
  	/*::[*/0x17/*::]*/: { n:'PtgStr', f:parse_PtgStr },
  	/*::[*/0x1A/*::]*/: { n:'PtgSheet', f:parse_PtgSheet },
  	/*::[*/0x1B/*::]*/: { n:'PtgEndSheet', f:parse_PtgEndSheet },
  	/*::[*/0x1C/*::]*/: { n:'PtgErr', f:parse_PtgErr },
  	/*::[*/0x1D/*::]*/: { n:'PtgBool', f:parse_PtgBool },
  	/*::[*/0x1E/*::]*/: { n:'PtgInt', f:parse_PtgInt },
  	/*::[*/0x1F/*::]*/: { n:'PtgNum', f:parse_PtgNum },
  	/*::[*/0x20/*::]*/: { n:'PtgArray', f:parse_PtgArray },
  	/*::[*/0x21/*::]*/: { n:'PtgFunc', f:parse_PtgFunc },
  	/*::[*/0x22/*::]*/: { n:'PtgFuncVar', f:parse_PtgFuncVar },
  	/*::[*/0x23/*::]*/: { n:'PtgName', f:parse_PtgName },
  	/*::[*/0x24/*::]*/: { n:'PtgRef', f:parse_PtgRef },
  	/*::[*/0x25/*::]*/: { n:'PtgArea', f:parse_PtgArea },
  	/*::[*/0x26/*::]*/: { n:'PtgMemArea', f:parse_PtgMemArea },
  	/*::[*/0x27/*::]*/: { n:'PtgMemErr', f:parse_PtgMemErr },
  	/*::[*/0x28/*::]*/: { n:'PtgMemNoMem', f:parse_PtgMemNoMem },
  	/*::[*/0x29/*::]*/: { n:'PtgMemFunc', f:parse_PtgMemFunc },
  	/*::[*/0x2A/*::]*/: { n:'PtgRefErr', f:parse_PtgRefErr },
  	/*::[*/0x2B/*::]*/: { n:'PtgAreaErr', f:parse_PtgAreaErr },
  	/*::[*/0x2C/*::]*/: { n:'PtgRefN', f:parse_PtgRefN },
  	/*::[*/0x2D/*::]*/: { n:'PtgAreaN', f:parse_PtgAreaN },
  	/*::[*/0x2E/*::]*/: { n:'PtgMemAreaN', f:parse_PtgMemAreaN },
  	/*::[*/0x2F/*::]*/: { n:'PtgMemNoMemN', f:parse_PtgMemNoMemN },
  	/*::[*/0x39/*::]*/: { n:'PtgNameX', f:parse_PtgNameX },
  	/*::[*/0x3A/*::]*/: { n:'PtgRef3d', f:parse_PtgRef3d },
  	/*::[*/0x3B/*::]*/: { n:'PtgArea3d', f:parse_PtgArea3d },
  	/*::[*/0x3C/*::]*/: { n:'PtgRefErr3d', f:parse_PtgRefErr3d },
  	/*::[*/0x3D/*::]*/: { n:'PtgAreaErr3d', f:parse_PtgAreaErr3d },
  	/*::[*/0xFF/*::]*/: {}
  };
  /* These are duplicated in the PtgTypes table */
  var PtgDupes = {
  	/*::[*/0x40/*::]*/: 0x20, /*::[*/0x60/*::]*/: 0x20,
  	/*::[*/0x41/*::]*/: 0x21, /*::[*/0x61/*::]*/: 0x21,
  	/*::[*/0x42/*::]*/: 0x22, /*::[*/0x62/*::]*/: 0x22,
  	/*::[*/0x43/*::]*/: 0x23, /*::[*/0x63/*::]*/: 0x23,
  	/*::[*/0x44/*::]*/: 0x24, /*::[*/0x64/*::]*/: 0x24,
  	/*::[*/0x45/*::]*/: 0x25, /*::[*/0x65/*::]*/: 0x25,
  	/*::[*/0x46/*::]*/: 0x26, /*::[*/0x66/*::]*/: 0x26,
  	/*::[*/0x47/*::]*/: 0x27, /*::[*/0x67/*::]*/: 0x27,
  	/*::[*/0x48/*::]*/: 0x28, /*::[*/0x68/*::]*/: 0x28,
  	/*::[*/0x49/*::]*/: 0x29, /*::[*/0x69/*::]*/: 0x29,
  	/*::[*/0x4A/*::]*/: 0x2A, /*::[*/0x6A/*::]*/: 0x2A,
  	/*::[*/0x4B/*::]*/: 0x2B, /*::[*/0x6B/*::]*/: 0x2B,
  	/*::[*/0x4C/*::]*/: 0x2C, /*::[*/0x6C/*::]*/: 0x2C,
  	/*::[*/0x4D/*::]*/: 0x2D, /*::[*/0x6D/*::]*/: 0x2D,
  	/*::[*/0x4E/*::]*/: 0x2E, /*::[*/0x6E/*::]*/: 0x2E,
  	/*::[*/0x4F/*::]*/: 0x2F, /*::[*/0x6F/*::]*/: 0x2F,
  	/*::[*/0x58/*::]*/: 0x22, /*::[*/0x78/*::]*/: 0x22,
  	/*::[*/0x59/*::]*/: 0x39, /*::[*/0x79/*::]*/: 0x39,
  	/*::[*/0x5A/*::]*/: 0x3A, /*::[*/0x7A/*::]*/: 0x3A,
  	/*::[*/0x5B/*::]*/: 0x3B, /*::[*/0x7B/*::]*/: 0x3B,
  	/*::[*/0x5C/*::]*/: 0x3C, /*::[*/0x7C/*::]*/: 0x3C,
  	/*::[*/0x5D/*::]*/: 0x3D, /*::[*/0x7D/*::]*/: 0x3D
  };

  var Ptg18 = {
  	/*::[*/0x01/*::]*/: { n:'PtgElfLel', f:parse_PtgElfLel },
  	/*::[*/0x02/*::]*/: { n:'PtgElfRw', f:parse_PtgElfRw },
  	/*::[*/0x03/*::]*/: { n:'PtgElfCol', f:parse_PtgElfCol },
  	/*::[*/0x06/*::]*/: { n:'PtgElfRwV', f:parse_PtgElfRwV },
  	/*::[*/0x07/*::]*/: { n:'PtgElfColV', f:parse_PtgElfColV },
  	/*::[*/0x0A/*::]*/: { n:'PtgElfRadical', f:parse_PtgElfRadical },
  	/*::[*/0x0B/*::]*/: { n:'PtgElfRadicalS', f:parse_PtgElfRadicalS },
  	/*::[*/0x0D/*::]*/: { n:'PtgElfColS', f:parse_PtgElfColS },
  	/*::[*/0x0F/*::]*/: { n:'PtgElfColSV', f:parse_PtgElfColSV },
  	/*::[*/0x10/*::]*/: { n:'PtgElfRadicalLel', f:parse_PtgElfRadicalLel },
  	/*::[*/0x19/*::]*/: { n:'PtgList', f:parse_PtgList },
  	/*::[*/0x1D/*::]*/: { n:'PtgSxName', f:parse_PtgSxName },
  	/*::[*/0xFF/*::]*/: {}
  };
  var Ptg19 = {
  	/*::[*/0x00/*::]*/: { n:'PtgAttrNoop', f:parse_PtgAttrNoop },
  	/*::[*/0x01/*::]*/: { n:'PtgAttrSemi', f:parse_PtgAttrSemi },
  	/*::[*/0x02/*::]*/: { n:'PtgAttrIf', f:parse_PtgAttrIf },
  	/*::[*/0x04/*::]*/: { n:'PtgAttrChoose', f:parse_PtgAttrChoose },
  	/*::[*/0x08/*::]*/: { n:'PtgAttrGoto', f:parse_PtgAttrGoto },
  	/*::[*/0x10/*::]*/: { n:'PtgAttrSum', f:parse_PtgAttrSum },
  	/*::[*/0x20/*::]*/: { n:'PtgAttrBaxcel', f:parse_PtgAttrBaxcel },
  	/*::[*/0x21/*::]*/: { n:'PtgAttrBaxcel', f:parse_PtgAttrBaxcel },
  	/*::[*/0x40/*::]*/: { n:'PtgAttrSpace', f:parse_PtgAttrSpace },
  	/*::[*/0x41/*::]*/: { n:'PtgAttrSpaceSemi', f:parse_PtgAttrSpaceSemi },
  	/*::[*/0x80/*::]*/: { n:'PtgAttrIfError', f:parse_PtgAttrIfError },
  	/*::[*/0xFF/*::]*/: {}
  };

  /* [MS-XLS] 2.5.198.103 ; [MS-XLSB] 2.5.97.87 */
  function parse_RgbExtra(blob, length, rgce, opts) {
  	if(opts.biff < 8) return parsenoop(blob, length);
  	var target = blob.l + length;
  	var o = [];
  	for(var i = 0; i !== rgce.length; ++i) {
  		switch(rgce[i][0]) {
  			case 'PtgArray': /* PtgArray -> PtgExtraArray */
  				rgce[i][1] = parse_PtgExtraArray(blob, 0, opts);
  				o.push(rgce[i][1]);
  				break;
  			case 'PtgMemArea': /* PtgMemArea -> PtgExtraMem */
  				rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1], opts);
  				o.push(rgce[i][2]);
  				break;
  			case 'PtgExp': /* PtgExp -> PtgExtraCol */
  				if(opts && opts.biff == 12) {
  					rgce[i][1][1] = blob.read_shift(4);
  					o.push(rgce[i][1]);
  				} break;
  			case 'PtgList': /* TODO: PtgList -> PtgExtraList */
  			case 'PtgElfRadicalS': /* TODO: PtgElfRadicalS -> PtgExtraElf */
  			case 'PtgElfColS': /* TODO: PtgElfColS -> PtgExtraElf */
  			case 'PtgElfColSV': /* TODO: PtgElfColSV -> PtgExtraElf */
  				throw "Unsupported " + rgce[i][0];
  		}
  	}
  	length = target - blob.l;
  	/* note: this is technically an error but Excel disregards */
  	//if(target !== blob.l && blob.l !== target - length) throw new Error(target + " != " + blob.l);
  	if(length !== 0) o.push(parsenoop(blob, length));
  	return o;
  }

  /* [MS-XLS] 2.5.198.104 ; [MS-XLSB] 2.5.97.88 */
  function parse_Rgce(blob, length, opts) {
  	var target = blob.l + length;
  	var R, id, ptgs = [];
  	while(target != blob.l) {
  		length = target - blob.l;
  		id = blob[blob.l];
  		R = PtgTypes[id] || PtgTypes[PtgDupes[id]];
  		if(id === 0x18 || id === 0x19) R = (id === 0x18 ? Ptg18 : Ptg19)[blob[blob.l + 1]];
  		if(!R || !R.f) { /*ptgs.push*/(parsenoop(blob, length)); }
  		else { ptgs.push([R.n, R.f(blob, length, opts)]); }
  	}
  	return ptgs;
  }

  function stringify_array(f/*:Array<Array<string>>*/)/*:string*/ {
  	var o/*:Array<string>*/ = [];
  	for(var i = 0; i < f.length; ++i) {
  		var x = f[i], r/*:Array<string>*/ = [];
  		for(var j = 0; j < x.length; ++j) {
  			var y = x[j];
  			if(y) switch(y[0]) {
  				// TODO: handle embedded quotes
  				case 0x02:
  					/*:: if(typeof y[1] != 'string') throw "unreachable"; */
  					r.push('"' + y[1].replace(/"/g,'""') + '"'); break;
  				default: r.push(y[1]);
  			} else r.push("");
  		}
  		o.push(r.join(","));
  	}
  	return o.join(";");
  }

  /* [MS-XLS] 2.2.2 ; [MS-XLSB] 2.2.2 TODO */
  var PtgBinOp = {
  	PtgAdd: "+",
  	PtgConcat: "&",
  	PtgDiv: "/",
  	PtgEq: "=",
  	PtgGe: ">=",
  	PtgGt: ">",
  	PtgLe: "<=",
  	PtgLt: "<",
  	PtgMul: "*",
  	PtgNe: "<>",
  	PtgPower: "^",
  	PtgSub: "-"
  };

  // List of invalid characters needs to be tested further
  function formula_quote_sheet_name(sname/*:string*/, opts)/*:string*/ {
  	if(!sname && !(opts && opts.biff <= 5 && opts.biff >= 2)) throw new Error("empty sheet name");
  	if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname)) return "'" + sname + "'";
  	return sname;
  }
  function get_ixti_raw(supbooks, ixti/*:number*/, opts)/*:string*/ {
  	if(!supbooks) return "SH33TJSERR0";
  	if(opts.biff > 8 && (!supbooks.XTI || !supbooks.XTI[ixti])) return supbooks.SheetNames[ixti];
  	if(!supbooks.XTI) return "SH33TJSERR6";
  	var XTI = supbooks.XTI[ixti];
  	if(opts.biff < 8) {
  		if(ixti > 10000) ixti-= 65536;
  		if(ixti < 0) ixti = -ixti;
  		return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
  	}
  	if(!XTI) return "SH33TJSERR1";
  	var o = "";
  	if(opts.biff > 8) switch(supbooks[XTI[0]][0]) {
  		case 0x0165: /* 'BrtSupSelf' */
  			o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
  			return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
  		case 0x0166: /* 'BrtSupSame' */
  			if(opts.SID != null) return supbooks.SheetNames[opts.SID];
  			return "SH33TJSSAME" + supbooks[XTI[0]][0];
  		case 0x0163: /* 'BrtSupBookSrc' */
  			/* falls through */
  		default: return "SH33TJSSRC" + supbooks[XTI[0]][0];
  	}
  	switch(supbooks[XTI[0]][0][0]) {
  		case 0x0401:
  			o = XTI[1] == -1 ? "#REF" : (supbooks.SheetNames[XTI[1]] || "SH33TJSERR3");
  			return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
  		case 0x3A01: return supbooks[XTI[0]].slice(1).map(function(name) { return name.Name; }).join(";;"); //return "SH33TJSERR8";
  		default:
  			if(!supbooks[XTI[0]][0][3]) return "SH33TJSERR2";
  			o = XTI[1] == -1 ? "#REF" : (supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4");
  			return XTI[1] == XTI[2] ? o : o + ":" + supbooks[XTI[0]][0][3][XTI[2]];
  	}
  }
  function get_ixti(supbooks, ixti/*:number*/, opts)/*:string*/ {
  	var ixtiraw = get_ixti_raw(supbooks, ixti, opts);
  	return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);
  }
  function stringify_formula(formula/*Array<any>*/, range, cell/*:any*/, supbooks, opts)/*:string*/ {
  	var biff = (opts && opts.biff) || 8;
  	var _range = /*range != null ? range :*/ {s:{c:0, r:0},e:{c:0, r:0}};
  	var stack/*:Array<string>*/ = [], e1, e2, /*::type,*/ c/*:CellAddress*/, ixti=0, nameidx=0, r, sname="";
  	if(!formula[0] || !formula[0][0]) return "";
  	var last_sp = -1, sp = "";
  	for(var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
  		var f = formula[0][ff];
  		switch(f[0]) {
  			case 'PtgUminus': /* [MS-XLS] 2.5.198.93 */
  				stack.push("-" + stack.pop()); break;
  			case 'PtgUplus': /* [MS-XLS] 2.5.198.95 */
  				stack.push("+" + stack.pop()); break;
  			case 'PtgPercent': /* [MS-XLS] 2.5.198.81 */
  				stack.push(stack.pop() + "%"); break;

  			case 'PtgAdd':    /* [MS-XLS] 2.5.198.26 */
  			case 'PtgConcat': /* [MS-XLS] 2.5.198.43 */
  			case 'PtgDiv':    /* [MS-XLS] 2.5.198.45 */
  			case 'PtgEq':     /* [MS-XLS] 2.5.198.56 */
  			case 'PtgGe':     /* [MS-XLS] 2.5.198.64 */
  			case 'PtgGt':     /* [MS-XLS] 2.5.198.65 */
  			case 'PtgLe':     /* [MS-XLS] 2.5.198.68 */
  			case 'PtgLt':     /* [MS-XLS] 2.5.198.69 */
  			case 'PtgMul':    /* [MS-XLS] 2.5.198.75 */
  			case 'PtgNe':     /* [MS-XLS] 2.5.198.78 */
  			case 'PtgPower':  /* [MS-XLS] 2.5.198.82 */
  			case 'PtgSub':    /* [MS-XLS] 2.5.198.90 */
  				e1 = stack.pop(); e2 = stack.pop();
  				if(last_sp >= 0) {
  					switch(formula[0][last_sp][1][0]) {
  						case 0:
  							// $FlowIgnore
  							sp = fill(" ", formula[0][last_sp][1][1]); break;
  						case 1:
  							// $FlowIgnore
  							sp = fill("\r", formula[0][last_sp][1][1]); break;
  						default:
  							sp = "";
  							// $FlowIgnore
  							if(opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
  					}
  					e2 = e2 + sp;
  					last_sp = -1;
  				}
  				stack.push(e2+PtgBinOp[f[0]]+e1);
  				break;

  			case 'PtgIsect': /* [MS-XLS] 2.5.198.67 */
  				e1 = stack.pop(); e2 = stack.pop();
  				stack.push(e2+" "+e1);
  				break;
  			case 'PtgUnion': /* [MS-XLS] 2.5.198.94 */
  				e1 = stack.pop(); e2 = stack.pop();
  				stack.push(e2+","+e1);
  				break;
  			case 'PtgRange': /* [MS-XLS] 2.5.198.83 */
  				e1 = stack.pop(); e2 = stack.pop();
  				stack.push(e2+":"+e1);
  				break;

  			case 'PtgAttrChoose': /* [MS-XLS] 2.5.198.34 */
  				break;
  			case 'PtgAttrGoto': /* [MS-XLS] 2.5.198.35 */
  				break;
  			case 'PtgAttrIf': /* [MS-XLS] 2.5.198.36 */
  				break;
  			case 'PtgAttrIfError': /* [MS-XLSB] 2.5.97.28 */
  				break;


  			case 'PtgRef': /* [MS-XLS] 2.5.198.84 */
  				/*::type = f[1][0]; */c = shift_cell_xls((f[1][1]/*:any*/), _range, opts);
  				stack.push(encode_cell_xls(c, biff));
  				break;
  			case 'PtgRefN': /* [MS-XLS] 2.5.198.88 */
  				/*::type = f[1][0]; */c = cell ? shift_cell_xls((f[1][1]/*:any*/), cell, opts) : (f[1][1]/*:any*/);
  				stack.push(encode_cell_xls(c, biff));
  				break;
  			case 'PtgRef3d': /* [MS-XLS] 2.5.198.85 */
  				/*::type = f[1][0]; */ixti = /*::Number(*/f[1][1]/*::)*/; c = shift_cell_xls((f[1][2]/*:any*/), _range, opts);
  				sname = get_ixti(supbooks, ixti, opts);
  				stack.push(sname + "!" + encode_cell_xls(c, biff));
  				break;

  			case 'PtgFunc': /* [MS-XLS] 2.5.198.62 */
  			case 'PtgFuncVar': /* [MS-XLS] 2.5.198.63 */
  				/* f[1] = [argc, func, type] */
  				var argc/*:number*/ = (f[1][0]/*:any*/), func/*:string*/ = (f[1][1]/*:any*/);
  				if(!argc) argc = 0;
  				argc &= 0x7F;
  				var args = argc == 0 ? [] : stack.slice(-argc);
  				stack.length -= argc;
  				if(func === 'User') func = args.shift();
  				stack.push(func + "(" + args.join(",") + ")");
  				break;

  			case 'PtgBool': /* [MS-XLS] 2.5.198.42 */
  				stack.push(f[1] ? "TRUE" : "FALSE"); break;
  			case 'PtgInt': /* [MS-XLS] 2.5.198.66 */
  				stack.push(/*::String(*/f[1]/*::)*/); break;
  			case 'PtgNum': /* [MS-XLS] 2.5.198.79 TODO: precision? */
  				stack.push(String(f[1])); break;
  			case 'PtgStr': /* [MS-XLS] 2.5.198.89 */
  				// $FlowIgnore
  				stack.push('"' + f[1].replace(/"/g, '""') + '"'); break;
  			case 'PtgErr': /* [MS-XLS] 2.5.198.57 */
  				stack.push(/*::String(*/f[1]/*::)*/); break;
  			case 'PtgAreaN': /* [MS-XLS] 2.5.198.31 TODO */
  				/*::type = f[1][0]; */r = shift_range_xls(f[1][1], cell ? {s:cell} : _range, opts);
  				stack.push(encode_range_xls((r/*:any*/), opts));
  				break;
  			case 'PtgArea': /* [MS-XLS] 2.5.198.27 TODO: fixed points */
  				/*::type = f[1][0]; */r = shift_range_xls(f[1][1], _range, opts);
  				stack.push(encode_range_xls((r/*:any*/), opts));
  				break;
  			case 'PtgArea3d': /* [MS-XLS] 2.5.198.28 TODO */
  				/*::type = f[1][0]; */ixti = /*::Number(*/f[1][1]/*::)*/; r = f[1][2];
  				sname = get_ixti(supbooks, ixti, opts);
  				stack.push(sname + "!" + encode_range_xls((r/*:any*/), opts));
  				break;
  			case 'PtgAttrSum': /* [MS-XLS] 2.5.198.41 */
  				stack.push("SUM(" + stack.pop() + ")");
  				break;

  			case 'PtgAttrBaxcel': /* [MS-XLS] 2.5.198.33 */
  			case 'PtgAttrSemi': /* [MS-XLS] 2.5.198.37 */
  				break;

  			case 'PtgName': /* [MS-XLS] 2.5.198.76 ; [MS-XLSB] 2.5.97.60 TODO: revisions */
  				/* f[1] = type, 0, nameindex */
  				nameidx = (f[1][2]/*:any*/);
  				var lbl = (supbooks.names||[])[nameidx-1] || (supbooks[0]||[])[nameidx];
  				var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
  				/* [MS-XLSB] 2.5.97.10 Ftab -- last verified 20220204 */
  				if(name && name.slice(0,6) == "_xlfn." && !opts.xlfn) name = name.slice(6);
  				stack.push(name);
  				break;

  			case 'PtgNameX': /* [MS-XLS] 2.5.198.77 ; [MS-XLSB] 2.5.97.61 TODO: revisions */
  				/* f[1] = type, ixti, nameindex */
  				var bookidx/*:number*/ = (f[1][1]/*:any*/); nameidx = (f[1][2]/*:any*/); var externbook;
  				/* TODO: Properly handle missing values -- this should be using get_ixti_raw primarily */
  				if(opts.biff <= 5) {
  					if(bookidx < 0) bookidx = -bookidx;
  					if(supbooks[bookidx]) externbook = supbooks[bookidx][nameidx];
  				} else {
  					var o = "";
  					if(((supbooks[bookidx]||[])[0]||[])[0] == 0x3A01);
  					else if(((supbooks[bookidx]||[])[0]||[])[0] == 0x0401){
  						if(supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
  							o = supbooks.SheetNames[supbooks[bookidx][nameidx].itab-1] + "!";
  						}
  					}
  					else o = supbooks.SheetNames[nameidx-1]+ "!";
  					if(supbooks[bookidx] && supbooks[bookidx][nameidx]) o += supbooks[bookidx][nameidx].Name;
  					else if(supbooks[0] && supbooks[0][nameidx]) o += supbooks[0][nameidx].Name;
  					else {
  						var ixtidata = (get_ixti_raw(supbooks, bookidx, opts)||"").split(";;");
  						if(ixtidata[nameidx - 1]) o = ixtidata[nameidx - 1]; // TODO: confirm this is correct
  						else o += "SH33TJSERRX";
  					}
  					stack.push(o);
  					break;
  				}
  				if(!externbook) externbook = {Name: "SH33TJSERRY"};
  				stack.push(externbook.Name);
  				break;

  			case 'PtgParen': /* [MS-XLS] 2.5.198.80 */
  				var lp = '(', rp = ')';
  				if(last_sp >= 0) {
  					sp = "";
  					switch(formula[0][last_sp][1][0]) {
  						// $FlowIgnore
  						case 2: lp = fill(" ", formula[0][last_sp][1][1]) + lp; break;
  						// $FlowIgnore
  						case 3: lp = fill("\r", formula[0][last_sp][1][1]) + lp; break;
  						// $FlowIgnore
  						case 4: rp = fill(" ", formula[0][last_sp][1][1]) + rp; break;
  						// $FlowIgnore
  						case 5: rp = fill("\r", formula[0][last_sp][1][1]) + rp; break;
  						default:
  							// $FlowIgnore
  							if(opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
  					}
  					last_sp = -1;
  				}
  				stack.push(lp + stack.pop() + rp); break;

  			case 'PtgRefErr': /* [MS-XLS] 2.5.198.86 */
  				stack.push('#REF!'); break;

  			case 'PtgRefErr3d': /* [MS-XLS] 2.5.198.87 */
  				stack.push('#REF!'); break;

  			case 'PtgExp': /* [MS-XLS] 2.5.198.58 TODO */
  				c = {c:(f[1][1]/*:any*/),r:(f[1][0]/*:any*/)};
  				var q = ({c: cell.c, r:cell.r}/*:any*/);
  				if(supbooks.sharedf[encode_cell(c)]) {
  					var parsedf = (supbooks.sharedf[encode_cell(c)]);
  					stack.push(stringify_formula(parsedf, _range, q, supbooks, opts));
  				} else {
  					var fnd = false;
  					for(e1=0;e1!=supbooks.arrayf.length; ++e1) {
  						/* TODO: should be something like range_has */
  						e2 = supbooks.arrayf[e1];
  						if(c.c < e2[0].s.c || c.c > e2[0].e.c) continue;
  						if(c.r < e2[0].s.r || c.r > e2[0].e.r) continue;
  						stack.push(stringify_formula(e2[1], _range, q, supbooks, opts));
  						fnd = true;
  						break;
  					}
  					if(!fnd) stack.push(/*::String(*/f[1]/*::)*/);
  				}
  				break;

  			case 'PtgArray': /* [MS-XLS] 2.5.198.32 TODO */
  				stack.push("{" + stringify_array(/*::(*/f[1]/*:: :any)*/) + "}");
  				break;

  			case 'PtgMemArea': /* [MS-XLS] 2.5.198.70 TODO: confirm this is a non-display */
  				//stack.push("(" + f[2].map(encode_range).join(",") + ")");
  				break;

  			case 'PtgAttrSpace': /* [MS-XLS] 2.5.198.38 */
  			case 'PtgAttrSpaceSemi': /* [MS-XLS] 2.5.198.39 */
  				last_sp = ff;
  				break;

  			case 'PtgTbl': /* [MS-XLS] 2.5.198.92 TODO */
  				break;

  			case 'PtgMemErr': /* [MS-XLS] 2.5.198.71 */
  				break;

  			case 'PtgMissArg': /* [MS-XLS] 2.5.198.74 */
  				stack.push("");
  				break;

  			case 'PtgAreaErr': /* [MS-XLS] 2.5.198.29 */
  				stack.push("#REF!"); break;

  			case 'PtgAreaErr3d': /* [MS-XLS] 2.5.198.30 */
  				stack.push("#REF!"); break;

  			case 'PtgList': /* [MS-XLSB] 2.5.97.52 */
  				// $FlowIgnore
  				stack.push("Table" + f[1].idx + "[#" + f[1].rt + "]");
  				break;

  			case 'PtgMemAreaN':
  			case 'PtgMemNoMemN':
  			case 'PtgAttrNoop':
  			case 'PtgSheet':
  			case 'PtgEndSheet':
  				break;

  			case 'PtgMemFunc': /* [MS-XLS] 2.5.198.72 TODO */
  				break;
  			case 'PtgMemNoMem': /* [MS-XLS] 2.5.198.73 TODO */
  				break;

  			case 'PtgElfCol': /* [MS-XLS] 2.5.198.46 */
  			case 'PtgElfColS': /* [MS-XLS] 2.5.198.47 */
  			case 'PtgElfColSV': /* [MS-XLS] 2.5.198.48 */
  			case 'PtgElfColV': /* [MS-XLS] 2.5.198.49 */
  			case 'PtgElfLel': /* [MS-XLS] 2.5.198.50 */
  			case 'PtgElfRadical': /* [MS-XLS] 2.5.198.51 */
  			case 'PtgElfRadicalLel': /* [MS-XLS] 2.5.198.52 */
  			case 'PtgElfRadicalS': /* [MS-XLS] 2.5.198.53 */
  			case 'PtgElfRw': /* [MS-XLS] 2.5.198.54 */
  			case 'PtgElfRwV': /* [MS-XLS] 2.5.198.55 */
  				throw new Error("Unsupported ELFs");

  			case 'PtgSxName': /* [MS-XLS] 2.5.198.91 TODO -- find a test case */
  				throw new Error('Unrecognized Formula Token: ' + String(f));
  			default: throw new Error('Unrecognized Formula Token: ' + String(f));
  		}
  		var PtgNonDisp = ['PtgAttrSpace', 'PtgAttrSpaceSemi', 'PtgAttrGoto'];
  		if(opts.biff != 3) if(last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {
  			f = formula[0][last_sp];
  			var _left = true;
  			switch(f[1][0]) {
  				/* note: some bad XLSB files omit the PtgParen */
  				case 4: _left = false;
  				/* falls through */
  				case 0:
  					// $FlowIgnore
  					sp = fill(" ", f[1][1]); break;
  				case 5: _left = false;
  				/* falls through */
  				case 1:
  					// $FlowIgnore
  					sp = fill("\r", f[1][1]); break;
  				default:
  					sp = "";
  					// $FlowIgnore
  					if(opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + f[1][0]);
  			}
  			stack.push((_left ? sp : "") + stack.pop() + (_left ? "" : sp));
  			last_sp = -1;
  		}
  	}
  	if(stack.length > 1 && opts.WTF) throw new Error("bad formula stack");
  	return stack[0];
  }
  function write_FormulaValue(value) {
  	if(value == null) {
  		// Blank String Value
  		var o = new_buf(8);
  		o.write_shift(1, 0x03);
  		o.write_shift(1, 0);
  		o.write_shift(2, 0);
  		o.write_shift(2, 0);
  		o.write_shift(2, 0xFFFF);
  		return o;
  	} else if(typeof value == "number") return write_Xnum(value);
  	return write_Xnum(0);
  }
  function write_Formula(cell/*:Cell*/, R/*:number*/, C/*:number*/, opts, os/*:number*/) {
  	// Cell
  	var o1 = write_XLSCell(R, C, os);

  	// FormulaValue
  	var o2 = write_FormulaValue(cell.v);

  	// flags + cache
  	var o3 = new_buf(6);
  	var flags = 0x01 | 0x20;
  	o3.write_shift(2, flags);
  	o3.write_shift(4, 0);

  	// CellParsedFormula
  	var bf = new_buf(cell.bf.length);
  	for(var i = 0; i < cell.bf.length; ++i) bf[i] = cell.bf[i];

  	var out = bconcat([o1, o2, o3, bf]);
  	return out;
  }


  /* XLSB Parsed Formula records have the same shape */
  function parse_XLSBParsedFormula(data, length, opts) {
  	var cce = data.read_shift(4);
  	var rgce = parse_Rgce(data, cce, opts);
  	var cb = data.read_shift(4);
  	var rgcb = cb > 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;
  	return [rgce, rgcb];
  }

  /* [MS-XLSB] 2.5.97.1 ArrayParsedFormula */
  var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
  /* [MS-XLSB] 2.5.97.4 CellParsedFormula */
  var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
  /* [MS-XLSB] 2.5.97.8 DVParsedFormula */
  //var parse_XLSBDVParsedFormula = parse_XLSBParsedFormula;
  /* [MS-XLSB] 2.5.97.9 FRTParsedFormula */
  //var parse_XLSBFRTParsedFormula = parse_XLSBParsedFormula2;
  /* [MS-XLSB] 2.5.97.12 NameParsedFormula */
  var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
  /* [MS-XLSB] 2.5.97.98 SharedParsedFormula */
  var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
  var Cetab = {
    0: "BEEP",
    1: "OPEN",
    2: "OPEN.LINKS",
    3: "CLOSE.ALL",
    4: "SAVE",
    5: "SAVE.AS",
    6: "FILE.DELETE",
    7: "PAGE.SETUP",
    8: "PRINT",
    9: "PRINTER.SETUP",
    10: "QUIT",
    11: "NEW.WINDOW",
    12: "ARRANGE.ALL",
    13: "WINDOW.SIZE",
    14: "WINDOW.MOVE",
    15: "FULL",
    16: "CLOSE",
    17: "RUN",
    22: "SET.PRINT.AREA",
    23: "SET.PRINT.TITLES",
    24: "SET.PAGE.BREAK",
    25: "REMOVE.PAGE.BREAK",
    26: "FONT",
    27: "DISPLAY",
    28: "PROTECT.DOCUMENT",
    29: "PRECISION",
    30: "A1.R1C1",
    31: "CALCULATE.NOW",
    32: "CALCULATION",
    34: "DATA.FIND",
    35: "EXTRACT",
    36: "DATA.DELETE",
    37: "SET.DATABASE",
    38: "SET.CRITERIA",
    39: "SORT",
    40: "DATA.SERIES",
    41: "TABLE",
    42: "FORMAT.NUMBER",
    43: "ALIGNMENT",
    44: "STYLE",
    45: "BORDER",
    46: "CELL.PROTECTION",
    47: "COLUMN.WIDTH",
    48: "UNDO",
    49: "CUT",
    50: "COPY",
    51: "PASTE",
    52: "CLEAR",
    53: "PASTE.SPECIAL",
    54: "EDIT.DELETE",
    55: "INSERT",
    56: "FILL.RIGHT",
    57: "FILL.DOWN",
    61: "DEFINE.NAME",
    62: "CREATE.NAMES",
    63: "FORMULA.GOTO",
    64: "FORMULA.FIND",
    65: "SELECT.LAST.CELL",
    66: "SHOW.ACTIVE.CELL",
    67: "GALLERY.AREA",
    68: "GALLERY.BAR",
    69: "GALLERY.COLUMN",
    70: "GALLERY.LINE",
    71: "GALLERY.PIE",
    72: "GALLERY.SCATTER",
    73: "COMBINATION",
    74: "PREFERRED",
    75: "ADD.OVERLAY",
    76: "GRIDLINES",
    77: "SET.PREFERRED",
    78: "AXES",
    79: "LEGEND",
    80: "ATTACH.TEXT",
    81: "ADD.ARROW",
    82: "SELECT.CHART",
    83: "SELECT.PLOT.AREA",
    84: "PATTERNS",
    85: "MAIN.CHART",
    86: "OVERLAY",
    87: "SCALE",
    88: "FORMAT.LEGEND",
    89: "FORMAT.TEXT",
    90: "EDIT.REPEAT",
    91: "PARSE",
    92: "JUSTIFY",
    93: "HIDE",
    94: "UNHIDE",
    95: "WORKSPACE",
    96: "FORMULA",
    97: "FORMULA.FILL",
    98: "FORMULA.ARRAY",
    99: "DATA.FIND.NEXT",
    100: "DATA.FIND.PREV",
    101: "FORMULA.FIND.NEXT",
    102: "FORMULA.FIND.PREV",
    103: "ACTIVATE",
    104: "ACTIVATE.NEXT",
    105: "ACTIVATE.PREV",
    106: "UNLOCKED.NEXT",
    107: "UNLOCKED.PREV",
    108: "COPY.PICTURE",
    109: "SELECT",
    110: "DELETE.NAME",
    111: "DELETE.FORMAT",
    112: "VLINE",
    113: "HLINE",
    114: "VPAGE",
    115: "HPAGE",
    116: "VSCROLL",
    117: "HSCROLL",
    118: "ALERT",
    119: "NEW",
    120: "CANCEL.COPY",
    121: "SHOW.CLIPBOARD",
    122: "MESSAGE",
    124: "PASTE.LINK",
    125: "APP.ACTIVATE",
    126: "DELETE.ARROW",
    127: "ROW.HEIGHT",
    128: "FORMAT.MOVE",
    129: "FORMAT.SIZE",
    130: "FORMULA.REPLACE",
    131: "SEND.KEYS",
    132: "SELECT.SPECIAL",
    133: "APPLY.NAMES",
    134: "REPLACE.FONT",
    135: "FREEZE.PANES",
    136: "SHOW.INFO",
    137: "SPLIT",
    138: "ON.WINDOW",
    139: "ON.DATA",
    140: "DISABLE.INPUT",
    142: "OUTLINE",
    143: "LIST.NAMES",
    144: "FILE.CLOSE",
    145: "SAVE.WORKBOOK",
    146: "DATA.FORM",
    147: "COPY.CHART",
    148: "ON.TIME",
    149: "WAIT",
    150: "FORMAT.FONT",
    151: "FILL.UP",
    152: "FILL.LEFT",
    153: "DELETE.OVERLAY",
    155: "SHORT.MENUS",
    159: "SET.UPDATE.STATUS",
    161: "COLOR.PALETTE",
    162: "DELETE.STYLE",
    163: "WINDOW.RESTORE",
    164: "WINDOW.MAXIMIZE",
    166: "CHANGE.LINK",
    167: "CALCULATE.DOCUMENT",
    168: "ON.KEY",
    169: "APP.RESTORE",
    170: "APP.MOVE",
    171: "APP.SIZE",
    172: "APP.MINIMIZE",
    173: "APP.MAXIMIZE",
    174: "BRING.TO.FRONT",
    175: "SEND.TO.BACK",
    185: "MAIN.CHART.TYPE",
    186: "OVERLAY.CHART.TYPE",
    187: "SELECT.END",
    188: "OPEN.MAIL",
    189: "SEND.MAIL",
    190: "STANDARD.FONT",
    191: "CONSOLIDATE",
    192: "SORT.SPECIAL",
    193: "GALLERY.3D.AREA",
    194: "GALLERY.3D.COLUMN",
    195: "GALLERY.3D.LINE",
    196: "GALLERY.3D.PIE",
    197: "VIEW.3D",
    198: "GOAL.SEEK",
    199: "WORKGROUP",
    200: "FILL.GROUP",
    201: "UPDATE.LINK",
    202: "PROMOTE",
    203: "DEMOTE",
    204: "SHOW.DETAIL",
    206: "UNGROUP",
    207: "OBJECT.PROPERTIES",
    208: "SAVE.NEW.OBJECT",
    209: "SHARE",
    210: "SHARE.NAME",
    211: "DUPLICATE",
    212: "APPLY.STYLE",
    213: "ASSIGN.TO.OBJECT",
    214: "OBJECT.PROTECTION",
    215: "HIDE.OBJECT",
    216: "SET.EXTRACT",
    217: "CREATE.PUBLISHER",
    218: "SUBSCRIBE.TO",
    219: "ATTRIBUTES",
    220: "SHOW.TOOLBAR",
    222: "PRINT.PREVIEW",
    223: "EDIT.COLOR",
    224: "SHOW.LEVELS",
    225: "FORMAT.MAIN",
    226: "FORMAT.OVERLAY",
    227: "ON.RECALC",
    228: "EDIT.SERIES",
    229: "DEFINE.STYLE",
    240: "LINE.PRINT",
    243: "ENTER.DATA",
    249: "GALLERY.RADAR",
    250: "MERGE.STYLES",
    251: "EDITION.OPTIONS",
    252: "PASTE.PICTURE",
    253: "PASTE.PICTURE.LINK",
    254: "SPELLING",
    256: "ZOOM",
    259: "INSERT.OBJECT",
    260: "WINDOW.MINIMIZE",
    265: "SOUND.NOTE",
    266: "SOUND.PLAY",
    267: "FORMAT.SHAPE",
    268: "EXTEND.POLYGON",
    269: "FORMAT.AUTO",
    272: "GALLERY.3D.BAR",
    273: "GALLERY.3D.SURFACE",
    274: "FILL.AUTO",
    276: "CUSTOMIZE.TOOLBAR",
    277: "ADD.TOOL",
    278: "EDIT.OBJECT",
    279: "ON.DOUBLECLICK",
    280: "ON.ENTRY",
    281: "WORKBOOK.ADD",
    282: "WORKBOOK.MOVE",
    283: "WORKBOOK.COPY",
    284: "WORKBOOK.OPTIONS",
    285: "SAVE.WORKSPACE",
    288: "CHART.WIZARD",
    289: "DELETE.TOOL",
    290: "MOVE.TOOL",
    291: "WORKBOOK.SELECT",
    292: "WORKBOOK.ACTIVATE",
    293: "ASSIGN.TO.TOOL",
    295: "COPY.TOOL",
    296: "RESET.TOOL",
    297: "CONSTRAIN.NUMERIC",
    298: "PASTE.TOOL",
    302: "WORKBOOK.NEW",
    305: "SCENARIO.CELLS",
    306: "SCENARIO.DELETE",
    307: "SCENARIO.ADD",
    308: "SCENARIO.EDIT",
    309: "SCENARIO.SHOW",
    310: "SCENARIO.SHOW.NEXT",
    311: "SCENARIO.SUMMARY",
    312: "PIVOT.TABLE.WIZARD",
    313: "PIVOT.FIELD.PROPERTIES",
    314: "PIVOT.FIELD",
    315: "PIVOT.ITEM",
    316: "PIVOT.ADD.FIELDS",
    318: "OPTIONS.CALCULATION",
    319: "OPTIONS.EDIT",
    320: "OPTIONS.VIEW",
    321: "ADDIN.MANAGER",
    322: "MENU.EDITOR",
    323: "ATTACH.TOOLBARS",
    324: "VBAActivate",
    325: "OPTIONS.CHART",
    328: "VBA.INSERT.FILE",
    330: "VBA.PROCEDURE.DEFINITION",
    336: "ROUTING.SLIP",
    338: "ROUTE.DOCUMENT",
    339: "MAIL.LOGON",
    342: "INSERT.PICTURE",
    343: "EDIT.TOOL",
    344: "GALLERY.DOUGHNUT",
    350: "CHART.TREND",
    352: "PIVOT.ITEM.PROPERTIES",
    354: "WORKBOOK.INSERT",
    355: "OPTIONS.TRANSITION",
    356: "OPTIONS.GENERAL",
    370: "FILTER.ADVANCED",
    373: "MAIL.ADD.MAILER",
    374: "MAIL.DELETE.MAILER",
    375: "MAIL.REPLY",
    376: "MAIL.REPLY.ALL",
    377: "MAIL.FORWARD",
    378: "MAIL.NEXT.LETTER",
    379: "DATA.LABEL",
    380: "INSERT.TITLE",
    381: "FONT.PROPERTIES",
    382: "MACRO.OPTIONS",
    383: "WORKBOOK.HIDE",
    384: "WORKBOOK.UNHIDE",
    385: "WORKBOOK.DELETE",
    386: "WORKBOOK.NAME",
    388: "GALLERY.CUSTOM",
    390: "ADD.CHART.AUTOFORMAT",
    391: "DELETE.CHART.AUTOFORMAT",
    392: "CHART.ADD.DATA",
    393: "AUTO.OUTLINE",
    394: "TAB.ORDER",
    395: "SHOW.DIALOG",
    396: "SELECT.ALL",
    397: "UNGROUP.SHEETS",
    398: "SUBTOTAL.CREATE",
    399: "SUBTOTAL.REMOVE",
    400: "RENAME.OBJECT",
    412: "WORKBOOK.SCROLL",
    413: "WORKBOOK.NEXT",
    414: "WORKBOOK.PREV",
    415: "WORKBOOK.TAB.SPLIT",
    416: "FULL.SCREEN",
    417: "WORKBOOK.PROTECT",
    420: "SCROLLBAR.PROPERTIES",
    421: "PIVOT.SHOW.PAGES",
    422: "TEXT.TO.COLUMNS",
    423: "FORMAT.CHARTTYPE",
    424: "LINK.FORMAT",
    425: "TRACER.DISPLAY",
    430: "TRACER.NAVIGATE",
    431: "TRACER.CLEAR",
    432: "TRACER.ERROR",
    433: "PIVOT.FIELD.GROUP",
    434: "PIVOT.FIELD.UNGROUP",
    435: "CHECKBOX.PROPERTIES",
    436: "LABEL.PROPERTIES",
    437: "LISTBOX.PROPERTIES",
    438: "EDITBOX.PROPERTIES",
    439: "PIVOT.REFRESH",
    440: "LINK.COMBO",
    441: "OPEN.TEXT",
    442: "HIDE.DIALOG",
    443: "SET.DIALOG.FOCUS",
    444: "ENABLE.OBJECT",
    445: "PUSHBUTTON.PROPERTIES",
    446: "SET.DIALOG.DEFAULT",
    447: "FILTER",
    448: "FILTER.SHOW.ALL",
    449: "CLEAR.OUTLINE",
    450: "FUNCTION.WIZARD",
    451: "ADD.LIST.ITEM",
    452: "SET.LIST.ITEM",
    453: "REMOVE.LIST.ITEM",
    454: "SELECT.LIST.ITEM",
    455: "SET.CONTROL.VALUE",
    456: "SAVE.COPY.AS",
    458: "OPTIONS.LISTS.ADD",
    459: "OPTIONS.LISTS.DELETE",
    460: "SERIES.AXES",
    461: "SERIES.X",
    462: "SERIES.Y",
    463: "ERRORBAR.X",
    464: "ERRORBAR.Y",
    465: "FORMAT.CHART",
    466: "SERIES.ORDER",
    467: "MAIL.LOGOFF",
    468: "CLEAR.ROUTING.SLIP",
    469: "APP.ACTIVATE.MICROSOFT",
    470: "MAIL.EDIT.MAILER",
    471: "ON.SHEET",
    472: "STANDARD.WIDTH",
    473: "SCENARIO.MERGE",
    474: "SUMMARY.INFO",
    475: "FIND.FILE",
    476: "ACTIVE.CELL.FONT",
    477: "ENABLE.TIPWIZARD",
    478: "VBA.MAKE.ADDIN",
    480: "INSERTDATATABLE",
    481: "WORKGROUP.OPTIONS",
    482: "MAIL.SEND.MAILER",
    485: "AUTOCORRECT",
    489: "POST.DOCUMENT",
    491: "PICKLIST",
    493: "VIEW.SHOW",
    494: "VIEW.DEFINE",
    495: "VIEW.DELETE",
    509: "SHEET.BACKGROUND",
    510: "INSERT.MAP.OBJECT",
    511: "OPTIONS.MENONO",
    517: "MSOCHECKS",
    518: "NORMAL",
    519: "LAYOUT",
    520: "RM.PRINT.AREA",
    521: "CLEAR.PRINT.AREA",
    522: "ADD.PRINT.AREA",
    523: "MOVE.BRK",
    545: "HIDECURR.NOTE",
    546: "HIDEALL.NOTES",
    547: "DELETE.NOTE",
    548: "TRAVERSE.NOTES",
    549: "ACTIVATE.NOTES",
    620: "PROTECT.REVISIONS",
    621: "UNPROTECT.REVISIONS",
    647: "OPTIONS.ME",
    653: "WEB.PUBLISH",
    667: "NEWWEBQUERY",
    673: "PIVOT.TABLE.CHART",
    753: "OPTIONS.SAVE",
    755: "OPTIONS.SPELL",
    808: "HIDEALL.INKANNOTS"
  };
  var Ftab = {
    0: "COUNT",
    1: "IF",
    2: "ISNA",
    3: "ISERROR",
    4: "SUM",
    5: "AVERAGE",
    6: "MIN",
    7: "MAX",
    8: "ROW",
    9: "COLUMN",
    10: "NA",
    11: "NPV",
    12: "STDEV",
    13: "DOLLAR",
    14: "FIXED",
    15: "SIN",
    16: "COS",
    17: "TAN",
    18: "ATAN",
    19: "PI",
    20: "SQRT",
    21: "EXP",
    22: "LN",
    23: "LOG10",
    24: "ABS",
    25: "INT",
    26: "SIGN",
    27: "ROUND",
    28: "LOOKUP",
    29: "INDEX",
    30: "REPT",
    31: "MID",
    32: "LEN",
    33: "VALUE",
    34: "TRUE",
    35: "FALSE",
    36: "AND",
    37: "OR",
    38: "NOT",
    39: "MOD",
    40: "DCOUNT",
    41: "DSUM",
    42: "DAVERAGE",
    43: "DMIN",
    44: "DMAX",
    45: "DSTDEV",
    46: "VAR",
    47: "DVAR",
    48: "TEXT",
    49: "LINEST",
    50: "TREND",
    51: "LOGEST",
    52: "GROWTH",
    53: "GOTO",
    54: "HALT",
    55: "RETURN",
    56: "PV",
    57: "FV",
    58: "NPER",
    59: "PMT",
    60: "RATE",
    61: "MIRR",
    62: "IRR",
    63: "RAND",
    64: "MATCH",
    65: "DATE",
    66: "TIME",
    67: "DAY",
    68: "MONTH",
    69: "YEAR",
    70: "WEEKDAY",
    71: "HOUR",
    72: "MINUTE",
    73: "SECOND",
    74: "NOW",
    75: "AREAS",
    76: "ROWS",
    77: "COLUMNS",
    78: "OFFSET",
    79: "ABSREF",
    80: "RELREF",
    81: "ARGUMENT",
    82: "SEARCH",
    83: "TRANSPOSE",
    84: "ERROR",
    85: "STEP",
    86: "TYPE",
    87: "ECHO",
    88: "SET.NAME",
    89: "CALLER",
    90: "DEREF",
    91: "WINDOWS",
    92: "SERIES",
    93: "DOCUMENTS",
    94: "ACTIVE.CELL",
    95: "SELECTION",
    96: "RESULT",
    97: "ATAN2",
    98: "ASIN",
    99: "ACOS",
    100: "CHOOSE",
    101: "HLOOKUP",
    102: "VLOOKUP",
    103: "LINKS",
    104: "INPUT",
    105: "ISREF",
    106: "GET.FORMULA",
    107: "GET.NAME",
    108: "SET.VALUE",
    109: "LOG",
    110: "EXEC",
    111: "CHAR",
    112: "LOWER",
    113: "UPPER",
    114: "PROPER",
    115: "LEFT",
    116: "RIGHT",
    117: "EXACT",
    118: "TRIM",
    119: "REPLACE",
    120: "SUBSTITUTE",
    121: "CODE",
    122: "NAMES",
    123: "DIRECTORY",
    124: "FIND",
    125: "CELL",
    126: "ISERR",
    127: "ISTEXT",
    128: "ISNUMBER",
    129: "ISBLANK",
    130: "T",
    131: "N",
    132: "FOPEN",
    133: "FCLOSE",
    134: "FSIZE",
    135: "FREADLN",
    136: "FREAD",
    137: "FWRITELN",
    138: "FWRITE",
    139: "FPOS",
    140: "DATEVALUE",
    141: "TIMEVALUE",
    142: "SLN",
    143: "SYD",
    144: "DDB",
    145: "GET.DEF",
    146: "REFTEXT",
    147: "TEXTREF",
    148: "INDIRECT",
    149: "REGISTER",
    150: "CALL",
    151: "ADD.BAR",
    152: "ADD.MENU",
    153: "ADD.COMMAND",
    154: "ENABLE.COMMAND",
    155: "CHECK.COMMAND",
    156: "RENAME.COMMAND",
    157: "SHOW.BAR",
    158: "DELETE.MENU",
    159: "DELETE.COMMAND",
    160: "GET.CHART.ITEM",
    161: "DIALOG.BOX",
    162: "CLEAN",
    163: "MDETERM",
    164: "MINVERSE",
    165: "MMULT",
    166: "FILES",
    167: "IPMT",
    168: "PPMT",
    169: "COUNTA",
    170: "CANCEL.KEY",
    171: "FOR",
    172: "WHILE",
    173: "BREAK",
    174: "NEXT",
    175: "INITIATE",
    176: "REQUEST",
    177: "POKE",
    178: "EXECUTE",
    179: "TERMINATE",
    180: "RESTART",
    181: "HELP",
    182: "GET.BAR",
    183: "PRODUCT",
    184: "FACT",
    185: "GET.CELL",
    186: "GET.WORKSPACE",
    187: "GET.WINDOW",
    188: "GET.DOCUMENT",
    189: "DPRODUCT",
    190: "ISNONTEXT",
    191: "GET.NOTE",
    192: "NOTE",
    193: "STDEVP",
    194: "VARP",
    195: "DSTDEVP",
    196: "DVARP",
    197: "TRUNC",
    198: "ISLOGICAL",
    199: "DCOUNTA",
    200: "DELETE.BAR",
    201: "UNREGISTER",
    204: "USDOLLAR",
    205: "FINDB",
    206: "SEARCHB",
    207: "REPLACEB",
    208: "LEFTB",
    209: "RIGHTB",
    210: "MIDB",
    211: "LENB",
    212: "ROUNDUP",
    213: "ROUNDDOWN",
    214: "ASC",
    215: "DBCS",
    216: "RANK",
    219: "ADDRESS",
    220: "DAYS360",
    221: "TODAY",
    222: "VDB",
    223: "ELSE",
    224: "ELSE.IF",
    225: "END.IF",
    226: "FOR.CELL",
    227: "MEDIAN",
    228: "SUMPRODUCT",
    229: "SINH",
    230: "COSH",
    231: "TANH",
    232: "ASINH",
    233: "ACOSH",
    234: "ATANH",
    235: "DGET",
    236: "CREATE.OBJECT",
    237: "VOLATILE",
    238: "LAST.ERROR",
    239: "CUSTOM.UNDO",
    240: "CUSTOM.REPEAT",
    241: "FORMULA.CONVERT",
    242: "GET.LINK.INFO",
    243: "TEXT.BOX",
    244: "INFO",
    245: "GROUP",
    246: "GET.OBJECT",
    247: "DB",
    248: "PAUSE",
    251: "RESUME",
    252: "FREQUENCY",
    253: "ADD.TOOLBAR",
    254: "DELETE.TOOLBAR",
    255: "User",
    256: "RESET.TOOLBAR",
    257: "EVALUATE",
    258: "GET.TOOLBAR",
    259: "GET.TOOL",
    260: "SPELLING.CHECK",
    261: "ERROR.TYPE",
    262: "APP.TITLE",
    263: "WINDOW.TITLE",
    264: "SAVE.TOOLBAR",
    265: "ENABLE.TOOL",
    266: "PRESS.TOOL",
    267: "REGISTER.ID",
    268: "GET.WORKBOOK",
    269: "AVEDEV",
    270: "BETADIST",
    271: "GAMMALN",
    272: "BETAINV",
    273: "BINOMDIST",
    274: "CHIDIST",
    275: "CHIINV",
    276: "COMBIN",
    277: "CONFIDENCE",
    278: "CRITBINOM",
    279: "EVEN",
    280: "EXPONDIST",
    281: "FDIST",
    282: "FINV",
    283: "FISHER",
    284: "FISHERINV",
    285: "FLOOR",
    286: "GAMMADIST",
    287: "GAMMAINV",
    288: "CEILING",
    289: "HYPGEOMDIST",
    290: "LOGNORMDIST",
    291: "LOGINV",
    292: "NEGBINOMDIST",
    293: "NORMDIST",
    294: "NORMSDIST",
    295: "NORMINV",
    296: "NORMSINV",
    297: "STANDARDIZE",
    298: "ODD",
    299: "PERMUT",
    300: "POISSON",
    301: "TDIST",
    302: "WEIBULL",
    303: "SUMXMY2",
    304: "SUMX2MY2",
    305: "SUMX2PY2",
    306: "CHITEST",
    307: "CORREL",
    308: "COVAR",
    309: "FORECAST",
    310: "FTEST",
    311: "INTERCEPT",
    312: "PEARSON",
    313: "RSQ",
    314: "STEYX",
    315: "SLOPE",
    316: "TTEST",
    317: "PROB",
    318: "DEVSQ",
    319: "GEOMEAN",
    320: "HARMEAN",
    321: "SUMSQ",
    322: "KURT",
    323: "SKEW",
    324: "ZTEST",
    325: "LARGE",
    326: "SMALL",
    327: "QUARTILE",
    328: "PERCENTILE",
    329: "PERCENTRANK",
    330: "MODE",
    331: "TRIMMEAN",
    332: "TINV",
    334: "MOVIE.COMMAND",
    335: "GET.MOVIE",
    336: "CONCATENATE",
    337: "POWER",
    338: "PIVOT.ADD.DATA",
    339: "GET.PIVOT.TABLE",
    340: "GET.PIVOT.FIELD",
    341: "GET.PIVOT.ITEM",
    342: "RADIANS",
    343: "DEGREES",
    344: "SUBTOTAL",
    345: "SUMIF",
    346: "COUNTIF",
    347: "COUNTBLANK",
    348: "SCENARIO.GET",
    349: "OPTIONS.LISTS.GET",
    350: "ISPMT",
    351: "DATEDIF",
    352: "DATESTRING",
    353: "NUMBERSTRING",
    354: "ROMAN",
    355: "OPEN.DIALOG",
    356: "SAVE.DIALOG",
    357: "VIEW.GET",
    358: "GETPIVOTDATA",
    359: "HYPERLINK",
    360: "PHONETIC",
    361: "AVERAGEA",
    362: "MAXA",
    363: "MINA",
    364: "STDEVPA",
    365: "VARPA",
    366: "STDEVA",
    367: "VARA",
    368: "BAHTTEXT",
    369: "THAIDAYOFWEEK",
    370: "THAIDIGIT",
    371: "THAIMONTHOFYEAR",
    372: "THAINUMSOUND",
    373: "THAINUMSTRING",
    374: "THAISTRINGLENGTH",
    375: "ISTHAIDIGIT",
    376: "ROUNDBAHTDOWN",
    377: "ROUNDBAHTUP",
    378: "THAIYEAR",
    379: "RTD",
    380: "CUBEVALUE",
    381: "CUBEMEMBER",
    382: "CUBEMEMBERPROPERTY",
    383: "CUBERANKEDMEMBER",
    384: "HEX2BIN",
    385: "HEX2DEC",
    386: "HEX2OCT",
    387: "DEC2BIN",
    388: "DEC2HEX",
    389: "DEC2OCT",
    390: "OCT2BIN",
    391: "OCT2HEX",
    392: "OCT2DEC",
    393: "BIN2DEC",
    394: "BIN2OCT",
    395: "BIN2HEX",
    396: "IMSUB",
    397: "IMDIV",
    398: "IMPOWER",
    399: "IMABS",
    400: "IMSQRT",
    401: "IMLN",
    402: "IMLOG2",
    403: "IMLOG10",
    404: "IMSIN",
    405: "IMCOS",
    406: "IMEXP",
    407: "IMARGUMENT",
    408: "IMCONJUGATE",
    409: "IMAGINARY",
    410: "IMREAL",
    411: "COMPLEX",
    412: "IMSUM",
    413: "IMPRODUCT",
    414: "SERIESSUM",
    415: "FACTDOUBLE",
    416: "SQRTPI",
    417: "QUOTIENT",
    418: "DELTA",
    419: "GESTEP",
    420: "ISEVEN",
    421: "ISODD",
    422: "MROUND",
    423: "ERF",
    424: "ERFC",
    425: "BESSELJ",
    426: "BESSELK",
    427: "BESSELY",
    428: "BESSELI",
    429: "XIRR",
    430: "XNPV",
    431: "PRICEMAT",
    432: "YIELDMAT",
    433: "INTRATE",
    434: "RECEIVED",
    435: "DISC",
    436: "PRICEDISC",
    437: "YIELDDISC",
    438: "TBILLEQ",
    439: "TBILLPRICE",
    440: "TBILLYIELD",
    441: "PRICE",
    442: "YIELD",
    443: "DOLLARDE",
    444: "DOLLARFR",
    445: "NOMINAL",
    446: "EFFECT",
    447: "CUMPRINC",
    448: "CUMIPMT",
    449: "EDATE",
    450: "EOMONTH",
    451: "YEARFRAC",
    452: "COUPDAYBS",
    453: "COUPDAYS",
    454: "COUPDAYSNC",
    455: "COUPNCD",
    456: "COUPNUM",
    457: "COUPPCD",
    458: "DURATION",
    459: "MDURATION",
    460: "ODDLPRICE",
    461: "ODDLYIELD",
    462: "ODDFPRICE",
    463: "ODDFYIELD",
    464: "RANDBETWEEN",
    465: "WEEKNUM",
    466: "AMORDEGRC",
    467: "AMORLINC",
    468: "CONVERT",
    724: "SHEETJS",
    469: "ACCRINT",
    470: "ACCRINTM",
    471: "WORKDAY",
    472: "NETWORKDAYS",
    473: "GCD",
    474: "MULTINOMIAL",
    475: "LCM",
    476: "FVSCHEDULE",
    477: "CUBEKPIMEMBER",
    478: "CUBESET",
    479: "CUBESETCOUNT",
    480: "IFERROR",
    481: "COUNTIFS",
    482: "SUMIFS",
    483: "AVERAGEIF",
    484: "AVERAGEIFS"
  };
  var FtabArgc = {
    2: 1,
    3: 1,
    10: 0,
    15: 1,
    16: 1,
    17: 1,
    18: 1,
    19: 0,
    20: 1,
    21: 1,
    22: 1,
    23: 1,
    24: 1,
    25: 1,
    26: 1,
    27: 2,
    30: 2,
    31: 3,
    32: 1,
    33: 1,
    34: 0,
    35: 0,
    38: 1,
    39: 2,
    40: 3,
    41: 3,
    42: 3,
    43: 3,
    44: 3,
    45: 3,
    47: 3,
    48: 2,
    53: 1,
    61: 3,
    63: 0,
    65: 3,
    66: 3,
    67: 1,
    68: 1,
    69: 1,
    70: 1,
    71: 1,
    72: 1,
    73: 1,
    74: 0,
    75: 1,
    76: 1,
    77: 1,
    79: 2,
    80: 2,
    83: 1,
    85: 0,
    86: 1,
    89: 0,
    90: 1,
    94: 0,
    95: 0,
    97: 2,
    98: 1,
    99: 1,
    101: 3,
    102: 3,
    105: 1,
    106: 1,
    108: 2,
    111: 1,
    112: 1,
    113: 1,
    114: 1,
    117: 2,
    118: 1,
    119: 4,
    121: 1,
    126: 1,
    127: 1,
    128: 1,
    129: 1,
    130: 1,
    131: 1,
    133: 1,
    134: 1,
    135: 1,
    136: 2,
    137: 2,
    138: 2,
    140: 1,
    141: 1,
    142: 3,
    143: 4,
    144: 4,
    161: 1,
    162: 1,
    163: 1,
    164: 1,
    165: 2,
    172: 1,
    175: 2,
    176: 2,
    177: 3,
    178: 2,
    179: 1,
    184: 1,
    186: 1,
    189: 3,
    190: 1,
    195: 3,
    196: 3,
    197: 1,
    198: 1,
    199: 3,
    201: 1,
    207: 4,
    210: 3,
    211: 1,
    212: 2,
    213: 2,
    214: 1,
    215: 1,
    225: 0,
    229: 1,
    230: 1,
    231: 1,
    232: 1,
    233: 1,
    234: 1,
    235: 3,
    244: 1,
    247: 4,
    252: 2,
    257: 1,
    261: 1,
    271: 1,
    273: 4,
    274: 2,
    275: 2,
    276: 2,
    277: 3,
    278: 3,
    279: 1,
    280: 3,
    281: 3,
    282: 3,
    283: 1,
    284: 1,
    285: 2,
    286: 4,
    287: 3,
    288: 2,
    289: 4,
    290: 3,
    291: 3,
    292: 3,
    293: 4,
    294: 1,
    295: 3,
    296: 1,
    297: 3,
    298: 1,
    299: 2,
    300: 3,
    301: 3,
    302: 4,
    303: 2,
    304: 2,
    305: 2,
    306: 2,
    307: 2,
    308: 2,
    309: 3,
    310: 2,
    311: 2,
    312: 2,
    313: 2,
    314: 2,
    315: 2,
    316: 4,
    325: 2,
    326: 2,
    327: 2,
    328: 2,
    331: 2,
    332: 2,
    337: 2,
    342: 1,
    343: 1,
    346: 2,
    347: 1,
    350: 4,
    351: 3,
    352: 1,
    353: 2,
    360: 1,
    368: 1,
    369: 1,
    370: 1,
    371: 1,
    372: 1,
    373: 1,
    374: 1,
    375: 1,
    376: 1,
    377: 1,
    378: 1,
    382: 3,
    385: 1,
    392: 1,
    393: 1,
    396: 2,
    397: 2,
    398: 2,
    399: 1,
    400: 1,
    401: 1,
    402: 1,
    403: 1,
    404: 1,
    405: 1,
    406: 1,
    407: 1,
    408: 1,
    409: 1,
    410: 1,
    414: 4,
    415: 1,
    416: 1,
    417: 2,
    420: 1,
    421: 1,
    422: 2,
    424: 1,
    425: 2,
    426: 2,
    427: 2,
    428: 2,
    430: 3,
    438: 3,
    439: 3,
    440: 3,
    443: 2,
    444: 2,
    445: 2,
    446: 2,
    447: 6,
    448: 6,
    449: 2,
    450: 2,
    464: 2,
    468: 3,
    476: 2,
    479: 1,
    480: 2,
    65535: 0
  };

  function csf_to_ods_formula(f/*:string*/)/*:string*/ {
  	var o = "of:=" + f.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g,":");
  	/* TODO: something other than this */
  	return o.replace(/;/g, "|").replace(/,/g,";");
  }

  function csf_to_ods_3D(r/*:string*/)/*:string*/ {
  	return r.replace(/\./,"!");
  }


  /*global Map */
  var browser_has_Map = typeof Map !== 'undefined';

  function get_sst_id(sst/*:SST*/, str/*:string*/, rev)/*:number*/ {
  	var i = 0, len = sst.length;
  	if(rev) {
  		if(browser_has_Map ? rev.has(str) : Object.prototype.hasOwnProperty.call(rev, str)) {
  			var revarr = browser_has_Map ? rev.get(str) : rev[str];
  			for(; i < revarr.length; ++i) {
  				if(sst[revarr[i]].t === str) { sst.Count ++; return revarr[i]; }
  			}
  		}
  	} else for(; i < len; ++i) {
  		if(sst[i].t === str) { sst.Count ++; return i; }
  	}
  	sst[len] = ({t:str}/*:any*/); sst.Count ++; sst.Unique ++;
  	if(rev) {
  		if(browser_has_Map) {
  			if(!rev.has(str)) rev.set(str, []);
  			rev.get(str).push(len);
  		} else {
  			if(!Object.prototype.hasOwnProperty.call(rev, str)) rev[str] = [];
  			rev[str].push(len);
  		}
  	}
  	return len;
  }

  function col_obj_w(C/*:number*/, col) {
  	var p = ({min:C+1,max:C+1}/*:any*/);
  	/* wch (chars), wpx (pixels) */
  	var wch = -1;
  	if(col.MDW) MDW = col.MDW;
  	if(col.width != null) p.customWidth = 1;
  	else if(col.wpx != null) wch = px2char(col.wpx);
  	else if(col.wch != null) wch = col.wch;
  	if(wch > -1) { p.width = char2width(wch); p.customWidth = 1; }
  	else if(col.width != null) p.width = col.width;
  	if(col.hidden) p.hidden = true;
  	if(col.level != null) { p.outlineLevel = p.level = col.level; }
  	return p;
  }

  function default_margins(margins/*:Margins*/, mode/*:?string*/) {
  	if(!margins) return;
  	var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
  	if(mode == 'xlml') defs = [1, 1, 1, 1, 0.5, 0.5];
  	if(margins.left   == null) margins.left   = defs[0];
  	if(margins.right  == null) margins.right  = defs[1];
  	if(margins.top    == null) margins.top    = defs[2];
  	if(margins.bottom == null) margins.bottom = defs[3];
  	if(margins.header == null) margins.header = defs[4];
  	if(margins.footer == null) margins.footer = defs[5];
  }

  function get_cell_style(styles/*:Array<any>*/, cell/*:Cell*/, opts) {
  	var z = opts.revssf[cell.z != null ? cell.z : "General"];
  	var i = 0x3c, len = styles.length;
  	if(z == null && opts.ssf) {
  		for(; i < 0x188; ++i) if(opts.ssf[i] == null) {
  			SSF_load(cell.z, i);
  			// $FlowIgnore
  			opts.ssf[i] = cell.z;
  			opts.revssf[cell.z] = z = i;
  			break;
  		}
  	}
  	for(i = 0; i != len; ++i) if(styles[i].numFmtId === z) return i;
  	styles[len] = {
  		numFmtId:z,
  		fontId:0,
  		fillId:0,
  		borderId:0,
  		xfId:0,
  		applyNumberFormat:1
  	};
  	return len;
  }

  function check_ws(ws/*:Worksheet*/, sname/*:string*/, i/*:number*/) {
  	if(ws && ws['!ref']) {
  		var range = safe_decode_range(ws['!ref']);
  		if(range.e.c < range.s.c || range.e.r < range.s.r) throw new Error("Bad range (" + i + "): " + ws['!ref']);
  	}
  }

  function write_ws_xml_merges(merges/*:Array<Range>*/)/*:string*/ {
  	if(merges.length === 0) return "";
  	var o = '<mergeCells count="' + merges.length + '">';
  	for(var i = 0; i != merges.length; ++i) o += '<mergeCell ref="' + encode_range(merges[i]) + '"/>';
  	return o + '</mergeCells>';
  }
  function write_ws_xml_sheetpr(ws, wb, idx, opts, o) {
  	var needed = false;
  	var props = {}, payload = null;
  	if(opts.bookType !== 'xlsx' && wb.vbaraw) {
  		var cname = wb.SheetNames[idx];
  		try { if(wb.Workbook) cname = wb.Workbook.Sheets[idx].CodeName || cname; } catch(e) {}
  		needed = true;
  		props.codeName = utf8write(escapexml(cname));
  	}

  	if(ws && ws["!outline"]) {
  		var outlineprops = {summaryBelow:1, summaryRight:1};
  		if(ws["!outline"].above) outlineprops.summaryBelow = 0;
  		if(ws["!outline"].left) outlineprops.summaryRight = 0;
  		payload = (payload||"") + writextag('outlinePr', null, outlineprops);
  	}

  	if(!needed && !payload) return;
  	o[o.length] = (writextag('sheetPr', payload, props));
  }

  /* 18.3.1.85 sheetProtection CT_SheetProtection */
  var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"];
  var sheetprot_deftrue = [
  	"formatColumns", "formatRows", "formatCells",
  	"insertColumns", "insertRows", "insertHyperlinks",
  	"deleteColumns", "deleteRows",
  	"sort", "autoFilter", "pivotTables"
  ];
  function write_ws_xml_protection(sp)/*:string*/ {
  	// algorithmName, hashValue, saltValue, spinCount
  	var o = ({sheet:1}/*:any*/);
  	sheetprot_deffalse.forEach(function(n) { if(sp[n] != null && sp[n]) o[n] = "1"; });
  	sheetprot_deftrue.forEach(function(n) { if(sp[n] != null && !sp[n]) o[n] = "0"; });
  	/* TODO: algorithm */
  	if(sp.password) o.password = crypto_CreatePasswordVerifier_Method1(sp.password).toString(16).toUpperCase();
  	return writextag('sheetProtection', null, o);
  }
  function write_ws_xml_margins(margin)/*:string*/ {
  	default_margins(margin);
  	return writextag('pageMargins', null, margin);
  }
  function write_ws_xml_cols(ws, cols)/*:string*/ {
  	var o = ["<cols>"], col;
  	for(var i = 0; i != cols.length; ++i) {
  		if(!(col = cols[i])) continue;
  		o[o.length] = (writextag('col', null, col_obj_w(i, col)));
  	}
  	o[o.length] = "</cols>";
  	return o.join("");
  }
  function write_ws_xml_autofilter(data, ws, wb, idx)/*:string*/ {
  	var ref = typeof data.ref == "string" ? data.ref : encode_range(data.ref);
  	if(!wb.Workbook) wb.Workbook = ({Sheets:[]}/*:any*/);
  	if(!wb.Workbook.Names) wb.Workbook.Names = [];
  	var names/*: Array<any> */ = wb.Workbook.Names;
  	var range = decode_range(ref);
  	if(range.s.r == range.e.r) { range.e.r = decode_range(ws["!ref"]).e.r; ref = encode_range(range); }
  	for(var i = 0; i < names.length; ++i) {
  		var name = names[i];
  		if(name.Name != '_xlnm._FilterDatabase') continue;
  		if(name.Sheet != idx) continue;
  		name.Ref = "'" + wb.SheetNames[idx] + "'!" + ref; break;
  	}
  	if(i == names.length) names.push({ Name: '_xlnm._FilterDatabase', Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref  });
  	return writextag("autoFilter", null, {ref:ref});
  }
  function write_ws_xml_sheetviews(ws, opts, idx, wb)/*:string*/ {
  	var sview = ({workbookViewId:"0"}/*:any*/);
  	// $FlowIgnore
  	if((((wb||{}).Workbook||{}).Views||[])[0]) sview.rightToLeft = wb.Workbook.Views[0].RTL ? "1" : "0";
  	return writextag("sheetViews", writextag("sheetView", null, sview), {});
  }

  function write_ws_xml_cell(cell/*:Cell*/, ref, ws, opts/*::, idx, wb*/)/*:string*/ {
  	if(cell.c) ws['!comments'].push([ref, cell.c]);
  	if(cell.v === undefined && typeof cell.f !== "string" || cell.t === 'z' && !cell.f) return "";
  	var vv = "";
  	var oldt = cell.t, oldv = cell.v;
  	if(cell.t !== "z") switch(cell.t) {
  		case 'b': vv = cell.v ? "1" : "0"; break;
  		case 'n': vv = ''+cell.v; break;
  		case 'e': vv = BErr[cell.v]; break;
  		case 'd':
  			if(opts && opts.cellDates) vv = parseDate(cell.v, -1).toISOString();
  			else {
  				cell = dup(cell);
  				cell.t = 'n';
  				vv = ''+(cell.v = datenum(parseDate(cell.v)));
  			}
  			if(typeof cell.z === 'undefined') cell.z = table_fmt[14];
  			break;
  		default: vv = cell.v; break;
  	}
  	var v = writetag('v', escapexml(vv)), o = ({r:ref}/*:any*/);
  	/* TODO: cell style */
  	var os = get_cell_style(opts.cellXfs, cell, opts);
  	if(os !== 0) o.s = os;
  	switch(cell.t) {
  		case 'n': break;
  		case 'd': o.t = "d"; break;
  		case 'b': o.t = "b"; break;
  		case 'e': o.t = "e"; break;
  		case 'z': break;
  		default: if(cell.v == null) { delete cell.t; break; }
  			if(cell.v.length > 32767) throw new Error("Text length must not exceed 32767 characters");
  			if(opts && opts.bookSST) {
  				v = writetag('v', ''+get_sst_id(opts.Strings, cell.v, opts.revStrings));
  				o.t = "s"; break;
  			}
  			o.t = "str"; break;
  	}
  	if(cell.t != oldt) { cell.t = oldt; cell.v = oldv; }
  	if(typeof cell.f == "string" && cell.f) {
  		var ff = cell.F && cell.F.slice(0, ref.length) == ref ? {t:"array", ref:cell.F} : null;
  		v = writextag('f', escapexml(cell.f), ff) + (cell.v != null ? v : "");
  	}
  	if(cell.l) ws['!links'].push([ref, cell.l]);
  	if(cell.D) o.cm = 1;
  	return writextag('c', v, o);
  }

  function write_ws_xml_data(ws/*:Worksheet*/, opts, idx/*:number*/, wb/*:Workbook*//*::, rels*/)/*:string*/ {
  	var o/*:Array<string>*/ = [], r/*:Array<string>*/ = [], range = safe_decode_range(ws['!ref']), cell="", ref, rr = "", cols/*:Array<string>*/ = [], R=0, C=0, rows = ws['!rows'];
  	var dense = Array.isArray(ws);
  	var params = ({r:rr}/*:any*/), row/*:RowInfo*/, height = -1;
  	for(C = range.s.c; C <= range.e.c; ++C) cols[C] = encode_col(C);
  	for(R = range.s.r; R <= range.e.r; ++R) {
  		r = [];
  		rr = encode_row(R);
  		for(C = range.s.c; C <= range.e.c; ++C) {
  			ref = cols[C] + rr;
  			var _cell = dense ? (ws[R]||[])[C]: ws[ref];
  			if(_cell === undefined) continue;
  			if((cell = write_ws_xml_cell(_cell, ref, ws, opts)) != null) r.push(cell);
  		}
  		if(r.length > 0 || (rows && rows[R])) {
  			params = ({r:rr}/*:any*/);
  			if(rows && rows[R]) {
  				row = rows[R];
  				if(row.hidden) params.hidden = 1;
  				height = -1;
  				if(row.hpx) height = px2pt(row.hpx);
  				else if(row.hpt) height = row.hpt;
  				if(height > -1) { params.ht = height; params.customHeight = 1; }
  				if(row.level) { params.outlineLevel = row.level; }
  			}
  			o[o.length] = (writextag('row', r.join(""), params));
  		}
  	}
  	if(rows) for(; R < rows.length; ++R) {
  		if(rows && rows[R]) {
  			params = ({r:R+1}/*:any*/);
  			row = rows[R];
  			if(row.hidden) params.hidden = 1;
  			height = -1;
  			if (row.hpx) height = px2pt(row.hpx);
  			else if (row.hpt) height = row.hpt;
  			if (height > -1) { params.ht = height; params.customHeight = 1; }
  			if (row.level) { params.outlineLevel = row.level; }
  			o[o.length] = (writextag('row', "", params));
  		}
  	}
  	return o.join("");
  }

  function write_ws_xml(idx/*:number*/, opts, wb/*:Workbook*/, rels)/*:string*/ {
  	var o = [XML_HEADER, writextag('worksheet', null, {
  		'xmlns': XMLNS_main[0],
  		'xmlns:r': XMLNS.r
  	})];
  	var s = wb.SheetNames[idx], sidx = 0, rdata = "";
  	var ws = wb.Sheets[s];
  	if(ws == null) ws = {};
  	var ref = ws['!ref'] || 'A1';
  	var range = safe_decode_range(ref);
  	if(range.e.c > 0x3FFF || range.e.r > 0xFFFFF) {
  		if(opts.WTF) throw new Error("Range " + ref + " exceeds format limit A1:XFD1048576");
  		range.e.c = Math.min(range.e.c, 0x3FFF);
  		range.e.r = Math.min(range.e.c, 0xFFFFF);
  		ref = encode_range(range);
  	}
  	if(!rels) rels = {};
  	ws['!comments'] = [];
  	var _drawing = [];

  	write_ws_xml_sheetpr(ws, wb, idx, opts, o);

  	o[o.length] = (writextag('dimension', null, {'ref': ref}));

  	o[o.length] = write_ws_xml_sheetviews(ws, opts, idx, wb);

  	/* TODO: store in WB, process styles */
  	if(opts.sheetFormat) o[o.length] = (writextag('sheetFormatPr', null, {
  		defaultRowHeight:opts.sheetFormat.defaultRowHeight||'16',
  		baseColWidth:opts.sheetFormat.baseColWidth||'10',
  		outlineLevelRow:opts.sheetFormat.outlineLevelRow||'7'
  	}));

  	if(ws['!cols'] != null && ws['!cols'].length > 0) o[o.length] = (write_ws_xml_cols(ws, ws['!cols']));

  	o[sidx = o.length] = '<sheetData/>';
  	ws['!links'] = [];
  	if(ws['!ref'] != null) {
  		rdata = write_ws_xml_data(ws, opts);
  		if(rdata.length > 0) o[o.length] = (rdata);
  	}
  	if(o.length>sidx+1) { o[o.length] = ('</sheetData>'); o[sidx]=o[sidx].replace("/>",">"); }

  	/* sheetCalcPr */

  	if(ws['!protect']) o[o.length] = write_ws_xml_protection(ws['!protect']);

  	/* protectedRanges */
  	/* scenarios */

  	if(ws['!autofilter'] != null) o[o.length] = write_ws_xml_autofilter(ws['!autofilter'], ws, wb, idx);

  	/* sortState */
  	/* dataConsolidate */
  	/* customSheetViews */

  	if(ws['!merges'] != null && ws['!merges'].length > 0) o[o.length] = (write_ws_xml_merges(ws['!merges']));

  	/* phoneticPr */
  	/* conditionalFormatting */
  	/* dataValidations */

  	var relc = -1, rel, rId = -1;
  	if(/*::(*/ws['!links']/*::||[])*/.length > 0) {
  		o[o.length] = "<hyperlinks>";
  		/*::(*/ws['!links']/*::||[])*/.forEach(function(l) {
  			if(!l[1].Target) return;
  			rel = ({"ref":l[0]}/*:any*/);
  			if(l[1].Target.charAt(0) != "#") {
  				rId = add_rels(rels, -1, escapexml(l[1].Target).replace(/#.*$/, ""), RELS.HLINK);
  				rel["r:id"] = "rId"+rId;
  			}
  			if((relc = l[1].Target.indexOf("#")) > -1) rel.location = escapexml(l[1].Target.slice(relc+1));
  			if(l[1].Tooltip) rel.tooltip = escapexml(l[1].Tooltip);
  			o[o.length] = writextag("hyperlink",null,rel);
  		});
  		o[o.length] = "</hyperlinks>";
  	}
  	delete ws['!links'];

  	/* printOptions */

  	if(ws['!margins'] != null) o[o.length] =  write_ws_xml_margins(ws['!margins']);

  	/* pageSetup */
  	/* headerFooter */
  	/* rowBreaks */
  	/* colBreaks */
  	/* customProperties */
  	/* cellWatches */

  	if(!opts || opts.ignoreEC || (opts.ignoreEC == (void 0))) o[o.length] = writetag("ignoredErrors", writextag("ignoredError", null, {numberStoredAsText:1, sqref:ref}));

  	/* smartTags */

  	if(_drawing.length > 0) {
  		rId = add_rels(rels, -1, "../drawings/drawing" + (idx+1) + ".xml", RELS.DRAW);
  		o[o.length] = writextag("drawing", null, {"r:id":"rId" + rId});
  		ws['!drawing'] = _drawing;
  	}

  	if(ws['!comments'].length > 0) {
  		rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx+1) + ".vml", RELS.VML);
  		o[o.length] = writextag("legacyDrawing", null, {"r:id":"rId" + rId});
  		ws['!legacy'] = rId;
  	}

  	/* legacyDrawingHF */
  	/* picture */
  	/* oleObjects */
  	/* controls */
  	/* webPublishItems */
  	/* tableParts */
  	/* extLst */

  	if(o.length>1) { o[o.length] = ('</worksheet>'); o[1]=o[1].replace("/>",">"); }
  	return o.join("");
  }

  /* [MS-XLSB] 2.4.726 BrtRowHdr */
  function parse_BrtRowHdr(data, length) {
  	var z = ({}/*:any*/);
  	var tgt = data.l + length;
  	z.r = data.read_shift(4);
  	data.l += 4; // TODO: ixfe
  	var miyRw = data.read_shift(2);
  	data.l += 1; // TODO: top/bot padding
  	var flags = data.read_shift(1);
  	data.l = tgt;
  	if(flags & 0x07) z.level = flags & 0x07;
  	if(flags & 0x10) z.hidden = true;
  	if(flags & 0x20) z.hpt = miyRw / 20;
  	return z;
  }
  function write_BrtRowHdr(R/*:number*/, range, ws) {
  	var o = new_buf(17+8*16);
  	var row = (ws['!rows']||[])[R]||{};
  	o.write_shift(4, R);

  	o.write_shift(4, 0); /* TODO: ixfe */

  	var miyRw = 0x0140;
  	if(row.hpx) miyRw = px2pt(row.hpx) * 20;
  	else if(row.hpt) miyRw = row.hpt * 20;
  	o.write_shift(2, miyRw);

  	o.write_shift(1, 0); /* top/bot padding */

  	var flags = 0x0;
  	if(row.level) flags |= row.level;
  	if(row.hidden) flags |= 0x10;
  	if(row.hpx || row.hpt) flags |= 0x20;
  	o.write_shift(1, flags);

  	o.write_shift(1, 0); /* phonetic guide */

  	/* [MS-XLSB] 2.5.8 BrtColSpan explains the mechanism */
  	var ncolspan = 0, lcs = o.l;
  	o.l += 4;

  	var caddr = {r:R, c:0};
  	for(var i = 0; i < 16; ++i) {
  		if((range.s.c > ((i+1) << 10)) || (range.e.c < (i << 10))) continue;
  		var first = -1, last = -1;
  		for(var j = (i<<10); j < ((i+1)<<10); ++j) {
  			caddr.c = j;
  			var cell = Array.isArray(ws) ? (ws[caddr.r]||[])[caddr.c] : ws[encode_cell(caddr)];
  			if(cell) { if(first < 0) first = j; last = j; }
  		}
  		if(first < 0) continue;
  		++ncolspan;
  		o.write_shift(4, first);
  		o.write_shift(4, last);
  	}

  	var l = o.l;
  	o.l = lcs;
  	o.write_shift(4, ncolspan);
  	o.l = l;

  	return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_row_header(ba, ws, range, R) {
  	var o = write_BrtRowHdr(R, range, ws);
  	if((o.length > 17) || (ws['!rows']||[])[R]) write_record(ba, 0x0000 /* BrtRowHdr */, o);
  }

  /* [MS-XLSB] 2.4.820 BrtWsDim */
  var parse_BrtWsDim = parse_UncheckedRfX;
  var write_BrtWsDim = write_UncheckedRfX;

  /* [MS-XLSB] 2.4.821 BrtWsFmtInfo */
  function parse_BrtWsFmtInfo(/*::data, length*/) {
  }
  //function write_BrtWsFmtInfo(ws, o) { }

  /* [MS-XLSB] 2.4.823 BrtWsProp */
  function parse_BrtWsProp(data, length) {
  	var z = {};
  	var f = data[data.l]; ++data.l;
  	z.above = !(f & 0x40);
  	z.left  = !(f & 0x80);
  	/* TODO: pull flags */
  	data.l += 18;
  	z.name = parse_XLSBCodeName(data);
  	return z;
  }
  function write_BrtWsProp(str, outl, o) {
  	if(o == null) o = new_buf(84+4*str.length);
  	var f = 0xC0;
  	if(outl) {
  		if(outl.above) f &= ~0x40;
  		if(outl.left)  f &= ~0x80;
  	}
  	o.write_shift(1, f);
  	for(var i = 1; i < 3; ++i) o.write_shift(1,0);
  	write_BrtColor({auto:1}, o);
  	o.write_shift(-4,-1);
  	o.write_shift(-4,-1);
  	write_XLSBCodeName(str, o);
  	return o.slice(0, o.l);
  }

  /* [MS-XLSB] 2.4.306 BrtCellBlank */
  function parse_BrtCellBlank(data) {
  	var cell = parse_XLSBCell(data);
  	return [cell];
  }
  function write_BrtCellBlank(cell, ncell, o) {
  	if(o == null) o = new_buf(8);
  	return write_XLSBCell(ncell, o);
  }
  function parse_BrtShortBlank(data) {
  	var cell = parse_XLSBShortCell(data);
  	return [cell];
  }
  function write_BrtShortBlank(cell, ncell, o) {
  	if(o == null) o = new_buf(4);
  	return write_XLSBShortCell(ncell, o);
  }

  /* [MS-XLSB] 2.4.307 BrtCellBool */
  function parse_BrtCellBool(data) {
  	var cell = parse_XLSBCell(data);
  	var fBool = data.read_shift(1);
  	return [cell, fBool, 'b'];
  }
  function write_BrtCellBool(cell, ncell, o) {
  	if(o == null) o = new_buf(9);
  	write_XLSBCell(ncell, o);
  	o.write_shift(1, cell.v ? 1 : 0);
  	return o;
  }
  function parse_BrtShortBool(data) {
  	var cell = parse_XLSBShortCell(data);
  	var fBool = data.read_shift(1);
  	return [cell, fBool, 'b'];
  }
  function write_BrtShortBool(cell, ncell, o) {
  	if(o == null) o = new_buf(5);
  	write_XLSBShortCell(ncell, o);
  	o.write_shift(1, cell.v ? 1 : 0);
  	return o;
  }

  /* [MS-XLSB] 2.4.308 BrtCellError */
  function parse_BrtCellError(data) {
  	var cell = parse_XLSBCell(data);
  	var bError = data.read_shift(1);
  	return [cell, bError, 'e'];
  }
  function write_BrtCellError(cell, ncell, o) {
  	if(o == null) o = new_buf(9);
  	write_XLSBCell(ncell, o);
  	o.write_shift(1, cell.v);
  	return o;
  }
  function parse_BrtShortError(data) {
  	var cell = parse_XLSBShortCell(data);
  	var bError = data.read_shift(1);
  	return [cell, bError, 'e'];
  }
  function write_BrtShortError(cell, ncell, o) {
  	if(o == null) o = new_buf(8);
  	write_XLSBShortCell(ncell, o);
  	o.write_shift(1, cell.v);
  	o.write_shift(2, 0);
  	o.write_shift(1, 0);
  	return o;
  }


  /* [MS-XLSB] 2.4.311 BrtCellIsst */
  function parse_BrtCellIsst(data) {
  	var cell = parse_XLSBCell(data);
  	var isst = data.read_shift(4);
  	return [cell, isst, 's'];
  }
  function write_BrtCellIsst(cell, ncell, o) {
  	if(o == null) o = new_buf(12);
  	write_XLSBCell(ncell, o);
  	o.write_shift(4, ncell.v);
  	return o;
  }
  function parse_BrtShortIsst(data) {
  	var cell = parse_XLSBShortCell(data);
  	var isst = data.read_shift(4);
  	return [cell, isst, 's'];
  }
  function write_BrtShortIsst(cell, ncell, o) {
  	if(o == null) o = new_buf(8);
  	write_XLSBShortCell(ncell, o);
  	o.write_shift(4, ncell.v);
  	return o;
  }

  /* [MS-XLSB] 2.4.313 BrtCellReal */
  function parse_BrtCellReal(data) {
  	var cell = parse_XLSBCell(data);
  	var value = parse_Xnum(data);
  	return [cell, value, 'n'];
  }
  function write_BrtCellReal(cell, ncell, o) {
  	if(o == null) o = new_buf(16);
  	write_XLSBCell(ncell, o);
  	write_Xnum(cell.v, o);
  	return o;
  }
  function parse_BrtShortReal(data) {
  	var cell = parse_XLSBShortCell(data);
  	var value = parse_Xnum(data);
  	return [cell, value, 'n'];
  }
  function write_BrtShortReal(cell, ncell, o) {
  	if(o == null) o = new_buf(12);
  	write_XLSBShortCell(ncell, o);
  	write_Xnum(cell.v, o);
  	return o;
  }

  /* [MS-XLSB] 2.4.314 BrtCellRk */
  function parse_BrtCellRk(data) {
  	var cell = parse_XLSBCell(data);
  	var value = parse_RkNumber(data);
  	return [cell, value, 'n'];
  }
  function write_BrtCellRk(cell, ncell, o) {
  	if(o == null) o = new_buf(12);
  	write_XLSBCell(ncell, o);
  	write_RkNumber(cell.v, o);
  	return o;
  }
  function parse_BrtShortRk(data) {
  	var cell = parse_XLSBShortCell(data);
  	var value = parse_RkNumber(data);
  	return [cell, value, 'n'];
  }
  function write_BrtShortRk(cell, ncell, o) {
  	if(o == null) o = new_buf(8);
  	write_XLSBShortCell(ncell, o);
  	write_RkNumber(cell.v, o);
  	return o;
  }

  /* [MS-XLSB] 2.4.323 BrtCellRString */
  function parse_BrtCellRString(data) {
  	var cell = parse_XLSBCell(data);
  	var value = parse_RichStr(data);
  	return [cell, value, 'is'];
  }

  /* [MS-XLSB] 2.4.317 BrtCellSt */
  function parse_BrtCellSt(data) {
  	var cell = parse_XLSBCell(data);
  	var value = parse_XLWideString(data);
  	return [cell, value, 'str'];
  }
  function write_BrtCellSt(cell, ncell, o) {
  	if(o == null) o = new_buf(12 + 4 * cell.v.length);
  	write_XLSBCell(ncell, o);
  	write_XLWideString(cell.v, o);
  	return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function parse_BrtShortSt(data) {
  	var cell = parse_XLSBShortCell(data);
  	var value = parse_XLWideString(data);
  	return [cell, value, 'str'];
  }
  function write_BrtShortSt(cell, ncell, o) {
  	if(o == null) o = new_buf(8 + 4 * cell.v.length);
  	write_XLSBShortCell(ncell, o);
  	write_XLWideString(cell.v, o);
  	return o.length > o.l ? o.slice(0, o.l) : o;
  }

  /* [MS-XLSB] 2.4.653 BrtFmlaBool */
  function parse_BrtFmlaBool(data, length, opts) {
  	var end = data.l + length;
  	var cell = parse_XLSBCell(data);
  	cell.r = opts['!row'];
  	var value = data.read_shift(1);
  	var o = [cell, value, 'b'];
  	if(opts.cellFormula) {
  		data.l += 2;
  		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
  		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */
  	}
  	else data.l = end;
  	return o;
  }

  /* [MS-XLSB] 2.4.654 BrtFmlaError */
  function parse_BrtFmlaError(data, length, opts) {
  	var end = data.l + length;
  	var cell = parse_XLSBCell(data);
  	cell.r = opts['!row'];
  	var value = data.read_shift(1);
  	var o = [cell, value, 'e'];
  	if(opts.cellFormula) {
  		data.l += 2;
  		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
  		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */
  	}
  	else data.l = end;
  	return o;
  }

  /* [MS-XLSB] 2.4.655 BrtFmlaNum */
  function parse_BrtFmlaNum(data, length, opts) {
  	var end = data.l + length;
  	var cell = parse_XLSBCell(data);
  	cell.r = opts['!row'];
  	var value = parse_Xnum(data);
  	var o = [cell, value, 'n'];
  	if(opts.cellFormula) {
  		data.l += 2;
  		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
  		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */
  	}
  	else data.l = end;
  	return o;
  }

  /* [MS-XLSB] 2.4.656 BrtFmlaString */
  function parse_BrtFmlaString(data, length, opts) {
  	var end = data.l + length;
  	var cell = parse_XLSBCell(data);
  	cell.r = opts['!row'];
  	var value = parse_XLWideString(data);
  	var o = [cell, value, 'str'];
  	if(opts.cellFormula) {
  		data.l += 2;
  		var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
  		o[3] = stringify_formula(formula, null/*range*/, cell, opts.supbooks, opts);/* TODO */
  	}
  	else data.l = end;
  	return o;
  }

  /* [MS-XLSB] 2.4.682 BrtMergeCell */
  var parse_BrtMergeCell = parse_UncheckedRfX;
  var write_BrtMergeCell = write_UncheckedRfX;
  /* [MS-XLSB] 2.4.107 BrtBeginMergeCells */
  function write_BrtBeginMergeCells(cnt, o) {
  	if(o == null) o = new_buf(4);
  	o.write_shift(4, cnt);
  	return o;
  }

  /* [MS-XLSB] 2.4.662 BrtHLink */
  function parse_BrtHLink(data, length/*::, opts*/) {
  	var end = data.l + length;
  	var rfx = parse_UncheckedRfX(data);
  	var relId = parse_XLNullableWideString(data);
  	var loc = parse_XLWideString(data);
  	var tooltip = parse_XLWideString(data);
  	var display = parse_XLWideString(data);
  	data.l = end;
  	var o = ({rfx:rfx, relId:relId, loc:loc, display:display}/*:any*/);
  	if(tooltip) o.Tooltip = tooltip;
  	return o;
  }
  function write_BrtHLink(l, rId) {
  	var o = new_buf(50+4*(l[1].Target.length + (l[1].Tooltip || "").length));
  	write_UncheckedRfX({s:decode_cell(l[0]), e:decode_cell(l[0])}, o);
  	write_RelID("rId" + rId, o);
  	var locidx = l[1].Target.indexOf("#");
  	var loc = locidx == -1 ? "" : l[1].Target.slice(locidx+1);
  	write_XLWideString(loc || "", o);
  	write_XLWideString(l[1].Tooltip || "", o);
  	write_XLWideString("", o);
  	return o.slice(0, o.l);
  }

  /* [MS-XLSB] 2.4.692 BrtPane */
  function parse_BrtPane(/*data, length, opts*/) {
  }

  /* [MS-XLSB] 2.4.6 BrtArrFmla */
  function parse_BrtArrFmla(data, length, opts) {
  	var end = data.l + length;
  	var rfx = parse_RfX(data);
  	var fAlwaysCalc = data.read_shift(1);
  	var o = [rfx]; o[2] = fAlwaysCalc;
  	if(opts.cellFormula) {
  		var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
  		o[1] = formula;
  	} else data.l = end;
  	return o;
  }

  /* [MS-XLSB] 2.4.750 BrtShrFmla */
  function parse_BrtShrFmla(data, length, opts) {
  	var end = data.l + length;
  	var rfx = parse_UncheckedRfX(data);
  	var o = [rfx];
  	if(opts.cellFormula) {
  		var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
  		o[1] = formula;
  		data.l = end;
  	} else data.l = end;
  	return o;
  }

  /* [MS-XLSB] 2.4.323 BrtColInfo */
  /* TODO: once XLS ColInfo is set, combine the functions */
  function write_BrtColInfo(C/*:number*/, col, o) {
  	if(o == null) o = new_buf(18);
  	var p = col_obj_w(C, col);
  	o.write_shift(-4, C);
  	o.write_shift(-4, C);
  	o.write_shift(4, (p.width || 10) * 256);
  	o.write_shift(4, 0/*ixfe*/); // style
  	var flags = 0;
  	if(col.hidden) flags |= 0x01;
  	if(typeof p.width == 'number') flags |= 0x02;
  	if(col.level) flags |= (col.level << 8);
  	o.write_shift(2, flags); // bit flag
  	return o;
  }

  /* [MS-XLSB] 2.4.678 BrtMargins */
  var BrtMarginKeys = ["left","right","top","bottom","header","footer"];
  function parse_BrtMargins(data/*::, length, opts*/)/*:Margins*/ {
  	var margins = ({}/*:any*/);
  	BrtMarginKeys.forEach(function(k) { margins[k] = parse_Xnum(data); });
  	return margins;
  }
  function write_BrtMargins(margins/*:Margins*/, o) {
  	if(o == null) o = new_buf(6*8);
  	default_margins(margins);
  	BrtMarginKeys.forEach(function(k) { write_Xnum((margins/*:any*/)[k], o); });
  	return o;
  }

  /* [MS-XLSB] 2.4.299 BrtBeginWsView */
  function parse_BrtBeginWsView(data/*::, length, opts*/) {
  	var f = data.read_shift(2);
  	data.l += 28;
  	return { RTL: f & 0x20 };
  }
  function write_BrtBeginWsView(ws, Workbook, o) {
  	if(o == null) o = new_buf(30);
  	var f = 0x39c;
  	if((((Workbook||{}).Views||[])[0]||{}).RTL) f |= 0x20;
  	o.write_shift(2, f); // bit flag
  	o.write_shift(4, 0);
  	o.write_shift(4, 0); // view first row
  	o.write_shift(4, 0); // view first col
  	o.write_shift(1, 0); // gridline color ICV
  	o.write_shift(1, 0);
  	o.write_shift(2, 0);
  	o.write_shift(2, 100); // zoom scale
  	o.write_shift(2, 0);
  	o.write_shift(2, 0);
  	o.write_shift(2, 0);
  	o.write_shift(4, 0); // workbook view id
  	return o;
  }

  /* [MS-XLSB] 2.4.309 BrtCellIgnoreEC */
  function write_BrtCellIgnoreEC(ref) {
  	var o = new_buf(24);
  	o.write_shift(4, 4);
  	o.write_shift(4, 1);
  	write_UncheckedRfX(ref, o);
  	return o;
  }

  /* [MS-XLSB] 2.4.748 BrtSheetProtection */
  function write_BrtSheetProtection(sp, o) {
  	if(o == null) o = new_buf(16*4+2);
  	o.write_shift(2, sp.password ? crypto_CreatePasswordVerifier_Method1(sp.password) : 0);
  	o.write_shift(4, 1); // this record should not be written if no protection
  	[
  		["objects",             false], // fObjects
  		["scenarios",           false], // fScenarios
  		["formatCells",          true], // fFormatCells
  		["formatColumns",        true], // fFormatColumns
  		["formatRows",           true], // fFormatRows
  		["insertColumns",        true], // fInsertColumns
  		["insertRows",           true], // fInsertRows
  		["insertHyperlinks",     true], // fInsertHyperlinks
  		["deleteColumns",        true], // fDeleteColumns
  		["deleteRows",           true], // fDeleteRows
  		["selectLockedCells",   false], // fSelLockedCells
  		["sort",                 true], // fSort
  		["autoFilter",           true], // fAutoFilter
  		["pivotTables",          true], // fPivotTables
  		["selectUnlockedCells", false]  // fSelUnlockedCells
  	].forEach(function(n) {
  		/*:: if(o == null) throw "unreachable"; */
  		if(n[1]) o.write_shift(4, sp[n[0]] != null && !sp[n[0]] ? 1 : 0);
  		else      o.write_shift(4, sp[n[0]] != null && sp[n[0]] ? 0 : 1);
  	});
  	return o;
  }

  function parse_BrtDVal(/*data, length, opts*/) {
  }
  function parse_BrtDVal14(/*data, length, opts*/) {
  }

  /* TODO: something useful -- this is a stub */
  function write_ws_bin_cell(ba/*:BufArray*/, cell/*:Cell*/, R/*:number*/, C/*:number*/, opts, ws/*:Worksheet*/, last_seen/*:boolean*/)/*:boolean*/ {
  	if(cell.v === undefined) return false;
  	var vv = "";
  	switch(cell.t) {
  		case 'b': vv = cell.v ? "1" : "0"; break;
  		case 'd': // no BrtCellDate :(
  			cell = dup(cell);
  			cell.z = cell.z || table_fmt[14];
  			cell.v = datenum(parseDate(cell.v)); cell.t = 'n';
  			break;
  		/* falls through */
  		case 'n': case 'e': vv = ''+cell.v; break;
  		default: vv = cell.v; break;
  	}
  	var o/*:any*/ = ({r:R, c:C}/*:any*/);
  	/* TODO: cell style */
  	o.s = get_cell_style(opts.cellXfs, cell, opts);
  	if(cell.l) ws['!links'].push([encode_cell(o), cell.l]);
  	if(cell.c) ws['!comments'].push([encode_cell(o), cell.c]);
  	switch(cell.t) {
  		case 's': case 'str':
  			if(opts.bookSST) {
  				vv = get_sst_id(opts.Strings, (cell.v/*:any*/), opts.revStrings);
  				o.t = "s"; o.v = vv;
  				if(last_seen) write_record(ba, 0x0012 /* BrtShortIsst */, write_BrtShortIsst(cell, o));
  				else write_record(ba, 0x0007 /* BrtCellIsst */, write_BrtCellIsst(cell, o));
  			} else {
  				o.t = "str";
  				if(last_seen) write_record(ba, 0x0011 /* BrtShortSt */, write_BrtShortSt(cell, o));
  				else write_record(ba, 0x0006 /* BrtCellSt */, write_BrtCellSt(cell, o));
  			}
  			return true;
  		case 'n':
  			/* TODO: determine threshold for Real vs RK */
  			if(cell.v == (cell.v | 0) && cell.v > -1000 && cell.v < 1000) {
  				if(last_seen) write_record(ba, 0x000D /* BrtShortRk */, write_BrtShortRk(cell, o));
  				else write_record(ba, 0x0002 /* BrtCellRk */, write_BrtCellRk(cell, o));
  			} else {
  				if(last_seen) write_record(ba, 0x0010 /* BrtShortReal */, write_BrtShortReal(cell, o));
  				else write_record(ba, 0x0005 /* BrtCellReal */, write_BrtCellReal(cell, o));
  			} return true;
  		case 'b':
  			o.t = "b";
  			if(last_seen) write_record(ba, 0x000F /* BrtShortBool */, write_BrtShortBool(cell, o));
  			else write_record(ba, 0x0004 /* BrtCellBool */, write_BrtCellBool(cell, o));
  			return true;
  		case 'e':
  			o.t = "e";
  			if(last_seen) write_record(ba, 0x000E /* BrtShortError */, write_BrtShortError(cell, o));
  			else write_record(ba, 0x0003 /* BrtCellError */, write_BrtCellError(cell, o));
  			return true;
  	}
  	if(last_seen) write_record(ba, 0x000C /* BrtShortBlank */, write_BrtShortBlank(cell, o));
  	else write_record(ba, 0x0001 /* BrtCellBlank */, write_BrtCellBlank(cell, o));
  	return true;
  }

  function write_CELLTABLE(ba, ws/*:Worksheet*/, idx/*:number*/, opts/*::, wb:Workbook*/) {
  	var range = safe_decode_range(ws['!ref'] || "A1"), ref, rr = "", cols/*:Array<string>*/ = [];
  	write_record(ba, 0x0091 /* BrtBeginSheetData */);
  	var dense = Array.isArray(ws);
  	var cap = range.e.r;
  	if(ws['!rows']) cap = Math.max(range.e.r, ws['!rows'].length - 1);
  	for(var R = range.s.r; R <= cap; ++R) {
  		rr = encode_row(R);
  		/* [ACCELLTABLE] */
  		/* BrtRowHdr */
  		write_row_header(ba, ws, range, R);
  		var last_seen = false;
  		if(R <= range.e.r) for(var C = range.s.c; C <= range.e.c; ++C) {
  			/* *16384CELL */
  			if(R === range.s.r) cols[C] = encode_col(C);
  			ref = cols[C] + rr;
  			var cell = dense ? (ws[R]||[])[C] : ws[ref];
  			if(!cell) { last_seen = false; continue; }
  			/* write cell */
  			last_seen = write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen);
  		}
  	}
  	write_record(ba, 0x0092 /* BrtEndSheetData */);
  }

  function write_MERGECELLS(ba, ws/*:Worksheet*/) {
  	if(!ws || !ws['!merges']) return;
  	write_record(ba, 0x00B1 /* BrtBeginMergeCells */, write_BrtBeginMergeCells(ws['!merges'].length));
  	ws['!merges'].forEach(function(m) { write_record(ba, 0x00B0 /* BrtMergeCell */, write_BrtMergeCell(m)); });
  	write_record(ba, 0x00B2 /* BrtEndMergeCells */);
  }

  function write_COLINFOS(ba, ws/*:Worksheet*//*::, idx:number, opts, wb:Workbook*/) {
  	if(!ws || !ws['!cols']) return;
  	write_record(ba, 0x0186 /* BrtBeginColInfos */);
  	ws['!cols'].forEach(function(m, i) { if(m) write_record(ba, 0x003C /* 'BrtColInfo' */, write_BrtColInfo(i, m)); });
  	write_record(ba, 0x0187 /* BrtEndColInfos */);
  }

  function write_IGNOREECS(ba, ws/*:Worksheet*/) {
  	if(!ws || !ws['!ref']) return;
  	write_record(ba, 0x0288 /* BrtBeginCellIgnoreECs */);
  	write_record(ba, 0x0289 /* BrtCellIgnoreEC */, write_BrtCellIgnoreEC(safe_decode_range(ws['!ref'])));
  	write_record(ba, 0x028A /* BrtEndCellIgnoreECs */);
  }

  function write_HLINKS(ba, ws/*:Worksheet*/, rels) {
  	/* *BrtHLink */
  	ws['!links'].forEach(function(l) {
  		if(!l[1].Target) return;
  		var rId = add_rels(rels, -1, l[1].Target.replace(/#.*$/, ""), RELS.HLINK);
  		write_record(ba, 0x01EE /* BrtHLink */, write_BrtHLink(l, rId));
  	});
  	delete ws['!links'];
  }
  function write_LEGACYDRAWING(ba, ws/*:Worksheet*/, idx/*:number*/, rels) {
  	/* [BrtLegacyDrawing] */
  	if(ws['!comments'].length > 0) {
  		var rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx+1) + ".vml", RELS.VML);
  		write_record(ba, 0x0227 /* BrtLegacyDrawing */, write_RelID("rId" + rId));
  		ws['!legacy'] = rId;
  	}
  }

  function write_AUTOFILTER(ba, ws, wb, idx) {
  	if(!ws['!autofilter']) return;
  	var data = ws['!autofilter'];
  	var ref = typeof data.ref === "string" ? data.ref : encode_range(data.ref);

  	/* Update FilterDatabase defined name for the worksheet */
  	if(!wb.Workbook) wb.Workbook = ({Sheets:[]}/*:any*/);
  	if(!wb.Workbook.Names) wb.Workbook.Names = [];
  	var names/*: Array<any> */ = wb.Workbook.Names;
  	var range = decode_range(ref);
  	if(range.s.r == range.e.r) { range.e.r = decode_range(ws["!ref"]).e.r; ref = encode_range(range); }
  	for(var i = 0; i < names.length; ++i) {
  		var name = names[i];
  		if(name.Name != '_xlnm._FilterDatabase') continue;
  		if(name.Sheet != idx) continue;
  		name.Ref = "'" + wb.SheetNames[idx] + "'!" + ref; break;
  	}
  	if(i == names.length) names.push({ Name: '_xlnm._FilterDatabase', Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref  });

  	write_record(ba, 0x00A1 /* BrtBeginAFilter */, write_UncheckedRfX(safe_decode_range(ref)));
  	/* *FILTERCOLUMN */
  	/* [SORTSTATE] */
  	/* BrtEndAFilter */
  	write_record(ba, 0x00A2 /* BrtEndAFilter */);
  }

  function write_WSVIEWS2(ba, ws, Workbook) {
  	write_record(ba, 0x0085 /* BrtBeginWsViews */);
  	{ /* 1*WSVIEW2 */
  		/* [ACUID] */
  		write_record(ba, 0x0089 /* BrtBeginWsView */, write_BrtBeginWsView(ws, Workbook));
  		/* [BrtPane] */
  		/* *4BrtSel */
  		/* *4SXSELECT */
  		/* *FRT */
  		write_record(ba, 0x008A /* BrtEndWsView */);
  	}
  	/* *FRT */
  	write_record(ba, 0x0086 /* BrtEndWsViews */);
  }

  function write_SHEETPROTECT(ba, ws) {
  	if(!ws['!protect']) return;
  	/* [BrtSheetProtectionIso] */
  	write_record(ba, 0x0217 /* BrtSheetProtection */, write_BrtSheetProtection(ws['!protect']));
  }

  function write_ws_bin(idx/*:number*/, opts, wb/*:Workbook*/, rels) {
  	var ba = buf_array();
  	var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
  	var c/*:string*/ = s; try { if(wb && wb.Workbook) c = wb.Workbook.Sheets[idx].CodeName || c; } catch(e) {}
  	var r = safe_decode_range(ws['!ref'] || "A1");
  	if(r.e.c > 0x3FFF || r.e.r > 0xFFFFF) {
  		if(opts.WTF) throw new Error("Range " + (ws['!ref'] || "A1") + " exceeds format limit A1:XFD1048576");
  		r.e.c = Math.min(r.e.c, 0x3FFF);
  		r.e.r = Math.min(r.e.c, 0xFFFFF);
  	}
  	ws['!links'] = [];
  	/* passed back to write_zip and removed there */
  	ws['!comments'] = [];
  	write_record(ba, 0x0081 /* BrtBeginSheet */);
  	if(wb.vbaraw || ws['!outline']) write_record(ba, 0x0093 /* BrtWsProp */, write_BrtWsProp(c, ws['!outline']));
  	write_record(ba, 0x0094 /* BrtWsDim */, write_BrtWsDim(r));
  	write_WSVIEWS2(ba, ws, wb.Workbook);
  	write_COLINFOS(ba, ws);
  	write_CELLTABLE(ba, ws, idx, opts);
  	/* [BrtSheetCalcProp] */
  	write_SHEETPROTECT(ba, ws);
  	/* *([BrtRangeProtectionIso] BrtRangeProtection) */
  	/* [SCENMAN] */
  	write_AUTOFILTER(ba, ws, wb, idx);
  	/* [SORTSTATE] */
  	/* [DCON] */
  	/* [USERSHVIEWS] */
  	write_MERGECELLS(ba, ws);
  	/* [BrtPhoneticInfo] */
  	/* *CONDITIONALFORMATTING */
  	/* [DVALS] */
  	write_HLINKS(ba, ws, rels);
  	/* [BrtPrintOptions] */
  	if(ws['!margins']) write_record(ba, 0x01DC /* BrtMargins */, write_BrtMargins(ws['!margins']));
  	/* [BrtPageSetup] */
  	/* [HEADERFOOTER] */
  	/* [RWBRK] */
  	/* [COLBRK] */
  	/* *BrtBigName */
  	/* [CELLWATCHES] */
  	if(!opts || opts.ignoreEC || (opts.ignoreEC == (void 0))) write_IGNOREECS(ba, ws);
  	/* [SMARTTAGS] */
  	/* [BrtDrawing] */
  	write_LEGACYDRAWING(ba, ws, idx, rels);
  	/* [BrtLegacyDrawingHF] */
  	/* [BrtBkHim] */
  	/* [OLEOBJECTS] */
  	/* [ACTIVEXCONTROLS] */
  	/* [WEBPUBITEMS] */
  	/* [LISTPARTS] */
  	/* FRTWORKSHEET */
  	write_record(ba, 0x0082 /* BrtEndSheet */);
  	return ba.end();
  }

  /* [MS-XLSB] 2.4.331 BrtCsProp */
  function parse_BrtCsProp(data, length/*:number*/) {
  	data.l += 10;
  	var name = parse_XLWideString(data);
  	return { name: name };
  }
  /* 18.2.28 (CT_WorkbookProtection) Defaults */
  var WBPropsDef = [
  	['allowRefreshQuery',           false, "bool"],
  	['autoCompressPictures',        true,  "bool"],
  	['backupFile',                  false, "bool"],
  	['checkCompatibility',          false, "bool"],
  	['CodeName',                    ''],
  	['date1904',                    false, "bool"],
  	['defaultThemeVersion',         0,      "int"],
  	['filterPrivacy',               false, "bool"],
  	['hidePivotFieldList',          false, "bool"],
  	['promptedSolutions',           false, "bool"],
  	['publishItems',                false, "bool"],
  	['refreshAllConnections',       false, "bool"],
  	['saveExternalLinkValues',      true,  "bool"],
  	['showBorderUnselectedTables',  true,  "bool"],
  	['showInkAnnotation',           true,  "bool"],
  	['showObjects',                 'all'],
  	['showPivotChartFilter',        false, "bool"],
  	['updateLinks', 'userSet']
  ];

  function safe1904(wb/*:Workbook*/)/*:string*/ {
  	/* TODO: store date1904 somewhere else */
  	if(!wb.Workbook) return "false";
  	if(!wb.Workbook.WBProps) return "false";
  	return parsexmlbool(wb.Workbook.WBProps.date1904) ? "true" : "false";
  }

  var badchars = /*#__PURE__*/"][*?\/\\".split("");
  function check_ws_name(n/*:string*/, safe/*:?boolean*/)/*:boolean*/ {
  	if(n.length > 31) { if(safe) return false; throw new Error("Sheet names cannot exceed 31 chars"); }
  	var _good = true;
  	badchars.forEach(function(c) {
  		if(n.indexOf(c) == -1) return;
  		if(!safe) throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
  		_good = false;
  	});
  	return _good;
  }
  function check_wb_names(N, S, codes) {
  	N.forEach(function(n,i) {
  		check_ws_name(n);
  		for(var j = 0; j < i; ++j) if(n == N[j]) throw new Error("Duplicate Sheet Name: " + n);
  		if(codes) {
  			var cn = (S && S[i] && S[i].CodeName) || n;
  			if(cn.charCodeAt(0) == 95 && cn.length > 22) throw new Error("Bad Code Name: Worksheet" + cn);
  		}
  	});
  }
  function check_wb(wb) {
  	if(!wb || !wb.SheetNames || !wb.Sheets) throw new Error("Invalid Workbook");
  	if(!wb.SheetNames.length) throw new Error("Workbook is empty");
  	var Sheets = (wb.Workbook && wb.Workbook.Sheets) || [];
  	check_wb_names(wb.SheetNames, Sheets, !!wb.vbaraw);
  	for(var i = 0; i < wb.SheetNames.length; ++i) check_ws(wb.Sheets[wb.SheetNames[i]], wb.SheetNames[i], i);
  	/* TODO: validate workbook */
  }

  function write_wb_xml(wb/*:Workbook*//*::, opts:?WriteOpts*/)/*:string*/ {
  	var o = [XML_HEADER];
  	o[o.length] = writextag('workbook', null, {
  		'xmlns': XMLNS_main[0],
  		//'xmlns:mx': XMLNS.mx,
  		//'xmlns:s': XMLNS_main[0],
  		'xmlns:r': XMLNS.r
  	});

  	var write_names = (wb.Workbook && (wb.Workbook.Names||[]).length > 0);

  	/* fileVersion */
  	/* fileSharing */

  	var workbookPr/*:any*/ = ({codeName:"ThisWorkbook"}/*:any*/);
  	if(wb.Workbook && wb.Workbook.WBProps) {
  		WBPropsDef.forEach(function(x) {
  			/*:: if(!wb.Workbook || !wb.Workbook.WBProps) throw "unreachable"; */
  			if((wb.Workbook.WBProps[x[0]]/*:any*/) == null) return;
  			if((wb.Workbook.WBProps[x[0]]/*:any*/) == x[1]) return;
  			workbookPr[x[0]] = (wb.Workbook.WBProps[x[0]]/*:any*/);
  		});
  		/*:: if(!wb.Workbook || !wb.Workbook.WBProps) throw "unreachable"; */
  		if(wb.Workbook.WBProps.CodeName) { workbookPr.codeName = wb.Workbook.WBProps.CodeName; delete workbookPr.CodeName; }
  	}
  	o[o.length] = (writextag('workbookPr', null, workbookPr));

  	/* workbookProtection */

  	var sheets = wb.Workbook && wb.Workbook.Sheets || [];
  	var i = 0;

  	/* bookViews only written if first worksheet is hidden */
  	if(sheets && sheets[0] && !!sheets[0].Hidden) {
  		o[o.length] = "<bookViews>";
  		for(i = 0; i != wb.SheetNames.length; ++i) {
  			if(!sheets[i]) break;
  			if(!sheets[i].Hidden) break;
  		}
  		if(i == wb.SheetNames.length) i = 0;
  		o[o.length] = '<workbookView firstSheet="' + i + '" activeTab="' + i + '"/>';
  		o[o.length] = "</bookViews>";
  	}

  	o[o.length] = "<sheets>";
  	for(i = 0; i != wb.SheetNames.length; ++i) {
  		var sht = ({name:escapexml(wb.SheetNames[i].slice(0,31))}/*:any*/);
  		sht.sheetId = ""+(i+1);
  		sht["r:id"] = "rId"+(i+1);
  		if(sheets[i]) switch(sheets[i].Hidden) {
  			case 1: sht.state = "hidden"; break;
  			case 2: sht.state = "veryHidden"; break;
  		}
  		o[o.length] = (writextag('sheet',null,sht));
  	}
  	o[o.length] = "</sheets>";

  	/* functionGroups */
  	/* externalReferences */

  	if(write_names) {
  		o[o.length] = "<definedNames>";
  		if(wb.Workbook && wb.Workbook.Names) wb.Workbook.Names.forEach(function(n) {
  			var d/*:any*/ = {name:n.Name};
  			if(n.Comment) d.comment = n.Comment;
  			if(n.Sheet != null) d.localSheetId = ""+n.Sheet;
  			if(n.Hidden) d.hidden = "1";
  			if(!n.Ref) return;
  			o[o.length] = writextag('definedName', escapexml(n.Ref), d);
  		});
  		o[o.length] = "</definedNames>";
  	}

  	/* calcPr */
  	/* oleSize */
  	/* customWorkbookViews */
  	/* pivotCaches */
  	/* smartTagPr */
  	/* smartTagTypes */
  	/* webPublishing */
  	/* fileRecoveryPr */
  	/* webPublishObjects */
  	/* extLst */

  	if(o.length>2){ o[o.length] = '</workbook>'; o[1]=o[1].replace("/>",">"); }
  	return o.join("");
  }
  /* [MS-XLSB] 2.4.304 BrtBundleSh */
  function parse_BrtBundleSh(data, length/*:number*/) {
  	var z = {};
  	z.Hidden = data.read_shift(4); //hsState ST_SheetState
  	z.iTabID = data.read_shift(4);
  	z.strRelID = parse_RelID(data);
  	z.name = parse_XLWideString(data);
  	return z;
  }
  function write_BrtBundleSh(data, o) {
  	if(!o) o = new_buf(127);
  	o.write_shift(4, data.Hidden);
  	o.write_shift(4, data.iTabID);
  	write_RelID(data.strRelID, o);
  	write_XLWideString(data.name.slice(0,31), o);
  	return o.length > o.l ? o.slice(0, o.l) : o;
  }

  /* [MS-XLSB] 2.4.815 BrtWbProp */
  function parse_BrtWbProp(data, length)/*:WBProps*/ {
  	var o/*:WBProps*/ = ({}/*:any*/);
  	var flags = data.read_shift(4);
  	o.defaultThemeVersion = data.read_shift(4);
  	var strName = (length > 8) ? parse_XLWideString(data) : "";
  	if(strName.length > 0) o.CodeName = strName;
  	o.autoCompressPictures = !!(flags & 0x10000);
  	o.backupFile = !!(flags & 0x40);
  	o.checkCompatibility = !!(flags & 0x1000);
  	o.date1904 = !!(flags & 0x01);
  	o.filterPrivacy = !!(flags & 0x08);
  	o.hidePivotFieldList = !!(flags & 0x400);
  	o.promptedSolutions = !!(flags & 0x10);
  	o.publishItems = !!(flags & 0x800);
  	o.refreshAllConnections = !!(flags & 0x40000);
  	o.saveExternalLinkValues = !!(flags & 0x80);
  	o.showBorderUnselectedTables = !!(flags & 0x04);
  	o.showInkAnnotation = !!(flags & 0x20);
  	o.showObjects = ["all", "placeholders", "none"][(flags >> 13) & 0x03];
  	o.showPivotChartFilter = !!(flags & 0x8000);
  	o.updateLinks = ["userSet", "never", "always"][(flags >> 8) & 0x03];
  	return o;
  }
  function write_BrtWbProp(data/*:?WBProps*/, o) {
  	if(!o) o = new_buf(72);
  	var flags = 0;
  	if(data) {
  		/* TODO: mirror parse_BrtWbProp fields */
  		if(data.filterPrivacy) flags |= 0x08;
  	}
  	o.write_shift(4, flags);
  	o.write_shift(4, 0);
  	write_XLSBCodeName(data && data.CodeName || "ThisWorkbook", o);
  	return o.slice(0, o.l);
  }

  /* [MS-XLSB] 2.4.687 BrtName */
  function parse_BrtName(data, length, opts) {
  	var end = data.l + length;
  	data.l += 4; //var flags = data.read_shift(4);
  	data.l += 1; //var chKey = data.read_shift(1);
  	var itab = data.read_shift(4);
  	var name = parse_XLNameWideString(data);
  	var formula = parse_XLSBNameParsedFormula(data, 0, opts);
  	var comment = parse_XLNullableWideString(data);
  	//if(0 /* fProc */) {
  		// unusedstring1: XLNullableWideString
  		// description: XLNullableWideString
  		// helpTopic: XLNullableWideString
  		// unusedstring2: XLNullableWideString
  	//}
  	data.l = end;
  	var out = ({Name:name, Ptg:formula}/*:any*/);
  	if(itab < 0xFFFFFFF) out.Sheet = itab;
  	if(comment) out.Comment = comment;
  	return out;
  }

  function write_BUNDLESHS(ba, wb/*::, opts*/) {
  	write_record(ba, 0x008F /* BrtBeginBundleShs */);
  	for(var idx = 0; idx != wb.SheetNames.length; ++idx) {
  		var viz = wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx] && wb.Workbook.Sheets[idx].Hidden || 0;
  		var d = { Hidden: viz, iTabID: idx+1, strRelID: 'rId' + (idx+1), name: wb.SheetNames[idx] };
  		write_record(ba, 0x009C /* BrtBundleSh */, write_BrtBundleSh(d));
  	}
  	write_record(ba, 0x0090 /* BrtEndBundleShs */);
  }

  /* [MS-XLSB] 2.4.649 BrtFileVersion */
  function write_BrtFileVersion(data, o) {
  	if(!o) o = new_buf(127);
  	for(var i = 0; i != 4; ++i) o.write_shift(4, 0);
  	write_XLWideString("SheetJS", o);
  	write_XLWideString(XLSX.version, o);
  	write_XLWideString(XLSX.version, o);
  	write_XLWideString("7262", o);
  	return o.length > o.l ? o.slice(0, o.l) : o;
  }

  /* [MS-XLSB] 2.4.301 BrtBookView */
  function write_BrtBookView(idx, o) {
  	if(!o) o = new_buf(29);
  	o.write_shift(-4, 0);
  	o.write_shift(-4, 460);
  	o.write_shift(4,  28800);
  	o.write_shift(4,  17600);
  	o.write_shift(4,  500);
  	o.write_shift(4,  idx);
  	o.write_shift(4,  idx);
  	var flags = 0x78;
  	o.write_shift(1,  flags);
  	return o.length > o.l ? o.slice(0, o.l) : o;
  }

  function write_BOOKVIEWS(ba, wb/*::, opts*/) {
  	/* required if hidden tab appears before visible tab */
  	if(!wb.Workbook || !wb.Workbook.Sheets) return;
  	var sheets = wb.Workbook.Sheets;
  	var i = 0, vistab = -1, hidden = -1;
  	for(; i < sheets.length; ++i) {
  		if(!sheets[i] || !sheets[i].Hidden && vistab == -1) vistab = i;
  		else if(sheets[i].Hidden == 1 && hidden == -1) hidden = i;
  	}
  	if(hidden > vistab) return;
  	write_record(ba, 0x0087 /* BrtBeginBookViews */);
  	write_record(ba, 0x009E /* BrtBookView */, write_BrtBookView(vistab));
  	/* 1*(BrtBookView *FRT) */
  	write_record(ba, 0x0088 /* BrtEndBookViews */);
  }

  /* [MS-XLSB] 2.4.305 BrtCalcProp */
  /*function write_BrtCalcProp(data, o) {
  	if(!o) o = new_buf(26);
  	o.write_shift(4,0); // force recalc
  	o.write_shift(4,1);
  	o.write_shift(4,0);
  	write_Xnum(0, o);
  	o.write_shift(-4, 1023);
  	o.write_shift(1, 0x33);
  	o.write_shift(1, 0x00);
  	return o;
  }*/

  /* [MS-XLSB] 2.4.646 BrtFileRecover */
  /*function write_BrtFileRecover(data, o) {
  	if(!o) o = new_buf(1);
  	o.write_shift(1,0);
  	return o;
  }*/

  /* [MS-XLSB] 2.1.7.61 Workbook */
  function write_wb_bin(wb, opts) {
  	var ba = buf_array();
  	write_record(ba, 0x0083 /* BrtBeginBook */);
  	write_record(ba, 0x0080 /* BrtFileVersion */, write_BrtFileVersion());
  	/* [[BrtFileSharingIso] BrtFileSharing] */
  	write_record(ba, 0x0099 /* BrtWbProp */, write_BrtWbProp(wb.Workbook && wb.Workbook.WBProps || null));
  	/* [ACABSPATH] */
  	/* [[BrtBookProtectionIso] BrtBookProtection] */
  	write_BOOKVIEWS(ba, wb);
  	write_BUNDLESHS(ba, wb);
  	/* [FNGROUP] */
  	/* [EXTERNALS] */
  	/* *BrtName */
  	/* write_record(ba, 0x009D BrtCalcProp, write_BrtCalcProp()); */
  	/* [BrtOleSize] */
  	/* *(BrtUserBookView *FRT) */
  	/* [PIVOTCACHEIDS] */
  	/* [BrtWbFactoid] */
  	/* [SMARTTAGTYPES] */
  	/* [BrtWebOpt] */
  	/* write_record(ba, 0x009B BrtFileRecover, write_BrtFileRecover()); */
  	/* [WEBPUBITEMS] */
  	/* [CRERRS] */
  	/* FRTWORKBOOK */
  	write_record(ba, 0x0084 /* BrtEndBook */);

  	return ba.end();
  }

  function write_wb(wb, name/*:string*/, opts) {
  	return (name.slice(-4)===".bin" ? write_wb_bin : write_wb_xml)(wb);
  }

  function write_ws(data/*:number*/, name/*:string*/, opts, wb/*:Workbook*/, rels) {
  	return (name.slice(-4)===".bin" ? write_ws_bin : write_ws_xml)(data, opts, wb, rels);
  }

  function write_sty(data, name/*:string*/, opts) {
  	return (name.slice(-4)===".bin" ? write_sty_bin : write_sty_xml)(data, opts);
  }

  function write_sst(data/*:SST*/, name/*:string*/, opts) {
  	return (name.slice(-4)===".bin" ? write_sst_bin : write_sst_xml)(data, opts);
  }

  function write_cmnt(data/*:Array<any>*/, name/*:string*/, opts) {
  	return (name.slice(-4)===".bin" ? write_comments_bin : write_comments_xml)(data);
  }
  /*
  function write_cc(data, name:string, opts) {
  	return (name.slice(-4)===".bin" ? write_cc_bin : write_cc_xml)(data, opts);
  }
  */

  function write_xlmeta(name/*:string*/) {
  	return (name.slice(-4)===".bin" ? write_xlmeta_bin : write_xlmeta_xml)();
  }

  /* TODO */
  function write_props_xlml(wb/*:Workbook*/, opts)/*:string*/ {
  	var o/*:Array<string>*/ = [];
  	/* DocumentProperties */
  	if(wb.Props) o.push(xlml_write_docprops(wb.Props, opts));
  	/* CustomDocumentProperties */
  	if(wb.Custprops) o.push(xlml_write_custprops(wb.Props, wb.Custprops));
  	return o.join("");
  }
  /* TODO */
  function write_wb_xlml(/*::wb, opts*/)/*:string*/ {
  	/* OfficeDocumentSettings */
  	/* ExcelWorkbook */
  	return "";
  }
  /* TODO */
  function write_sty_xlml(wb, opts)/*:string*/ {
  	/* Styles */
  	var styles/*:Array<string>*/ = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
  	opts.cellXfs.forEach(function(xf, id) {
  		var payload/*:Array<string>*/ = [];
  		payload.push(writextag('NumberFormat', null, {"ss:Format": escapexml(table_fmt[xf.numFmtId])}));

  		var o = /*::(*/{"ss:ID": "s" + (21+id)}/*:: :any)*/;
  		styles.push(writextag('Style', payload.join(""), o));
  	});
  	return writextag("Styles", styles.join(""));
  }
  function write_name_xlml(n) { return writextag("NamedRange", null, {"ss:Name": n.Name, "ss:RefersTo":"=" + a1_to_rc(n.Ref, {r:0,c:0})}); }
  function write_names_xlml(wb/*::, opts*/)/*:string*/ {
  	if(!((wb||{}).Workbook||{}).Names) return "";
  	/*:: if(!wb || !wb.Workbook || !wb.Workbook.Names) throw new Error("unreachable"); */
  	var names/*:Array<any>*/ = wb.Workbook.Names;
  	var out/*:Array<string>*/ = [];
  	for(var i = 0; i < names.length; ++i) {
  		var n = names[i];
  		if(n.Sheet != null) continue;
  		if(n.Name.match(/^_xlfn\./)) continue;
  		out.push(write_name_xlml(n));
  	}
  	return writextag("Names", out.join(""));
  }
  function write_ws_xlml_names(ws/*:Worksheet*/, opts, idx/*:number*/, wb/*:Workbook*/)/*:string*/ {
  	if(!ws) return "";
  	if(!((wb||{}).Workbook||{}).Names) return "";
  	/*:: if(!wb || !wb.Workbook || !wb.Workbook.Names) throw new Error("unreachable"); */
  	var names/*:Array<any>*/ = wb.Workbook.Names;
  	var out/*:Array<string>*/ = [];
  	for(var i = 0; i < names.length; ++i) {
  		var n = names[i];
  		if(n.Sheet != idx) continue;
  		/*switch(n.Name) {
  			case "_": continue;
  		}*/
  		if(n.Name.match(/^_xlfn\./)) continue;
  		out.push(write_name_xlml(n));
  	}
  	return out.join("");
  }
  /* WorksheetOptions */
  function write_ws_xlml_wsopts(ws/*:Worksheet*/, opts, idx/*:number*/, wb/*:Workbook*/)/*:string*/ {
  	if(!ws) return "";
  	var o/*:Array<string>*/ = [];
  	/* NOTE: spec technically allows any order, but stick with implied order */

  	/* FitToPage */
  	/* DoNotDisplayColHeaders */
  	/* DoNotDisplayRowHeaders */
  	/* ViewableRange */
  	/* Selection */
  	/* GridlineColor */
  	/* Name */
  	/* ExcelWorksheetType */
  	/* IntlMacro */
  	/* Unsynced */
  	/* Selected */
  	/* CodeName */

  	if(ws['!margins']) {
  		o.push("<PageSetup>");
  		if(ws['!margins'].header) o.push(writextag("Header", null, {'x:Margin':ws['!margins'].header}));
  		if(ws['!margins'].footer) o.push(writextag("Footer", null, {'x:Margin':ws['!margins'].footer}));
  		o.push(writextag("PageMargins", null, {
  			'x:Bottom': ws['!margins'].bottom || "0.75",
  			'x:Left': ws['!margins'].left || "0.7",
  			'x:Right': ws['!margins'].right || "0.7",
  			'x:Top': ws['!margins'].top || "0.75"
  		}));
  		o.push("</PageSetup>");
  	}

  	/* PageSetup */
  	/* DisplayPageBreak */
  	/* TransitionExpressionEvaluation */
  	/* TransitionFormulaEntry */
  	/* Print */
  	/* Zoom */
  	/* PageLayoutZoom */
  	/* PageBreakZoom */
  	/* ShowPageBreakZoom */
  	/* DefaultRowHeight */
  	/* DefaultColumnWidth */
  	/* StandardWidth */

  	if(wb && wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx]) {
  		/* Visible */
  		if(wb.Workbook.Sheets[idx].Hidden) o.push(writextag("Visible", (wb.Workbook.Sheets[idx].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden"), {}));
  		else {
  			/* Selected */
  			for(var i = 0; i < idx; ++i) if(wb.Workbook.Sheets[i] && !wb.Workbook.Sheets[i].Hidden) break;
  			if(i == idx) o.push("<Selected/>");
  		}
  	}

  	/* LeftColumnVisible */

  	if(((((wb||{}).Workbook||{}).Views||[])[0]||{}).RTL) o.push("<DisplayRightToLeft/>");

  	/* GridlineColorIndex */
  	/* DisplayFormulas */
  	/* DoNotDisplayGridlines */
  	/* DoNotDisplayHeadings */
  	/* DoNotDisplayOutline */
  	/* ApplyAutomaticOutlineStyles */
  	/* NoSummaryRowsBelowDetail */
  	/* NoSummaryColumnsRightDetail */
  	/* DoNotDisplayZeros */
  	/* ActiveRow */
  	/* ActiveColumn */
  	/* FilterOn */
  	/* RangeSelection */
  	/* TopRowVisible */
  	/* TopRowBottomPane */
  	/* LeftColumnRightPane */
  	/* ActivePane */
  	/* SplitHorizontal */
  	/* SplitVertical */
  	/* FreezePanes */
  	/* FrozenNoSplit */
  	/* TabColorIndex */
  	/* Panes */

  	/* NOTE: Password not supported in XLML Format */
  	if(ws['!protect']) {
  		o.push(writetag("ProtectContents", "True"));
  		if(ws['!protect'].objects) o.push(writetag("ProtectObjects", "True"));
  		if(ws['!protect'].scenarios) o.push(writetag("ProtectScenarios", "True"));
  		if(ws['!protect'].selectLockedCells != null && !ws['!protect'].selectLockedCells) o.push(writetag("EnableSelection", "NoSelection"));
  		else if(ws['!protect'].selectUnlockedCells != null && !ws['!protect'].selectUnlockedCells) o.push(writetag("EnableSelection", "UnlockedCells"));
  	[
  		[ "formatCells", "AllowFormatCells" ],
  		[ "formatColumns", "AllowSizeCols" ],
  		[ "formatRows", "AllowSizeRows" ],
  		[ "insertColumns", "AllowInsertCols" ],
  		[ "insertRows", "AllowInsertRows" ],
  		[ "insertHyperlinks", "AllowInsertHyperlinks" ],
  		[ "deleteColumns", "AllowDeleteCols" ],
  		[ "deleteRows", "AllowDeleteRows" ],
  		[ "sort", "AllowSort" ],
  		[ "autoFilter", "AllowFilter" ],
  		[ "pivotTables", "AllowUsePivotTables" ]
  	].forEach(function(x) { if(ws['!protect'][x[0]]) o.push("<"+x[1]+"/>"); });
  	}

  	if(o.length == 0) return "";
  	return writextag("WorksheetOptions", o.join(""), {xmlns:XLMLNS.x});
  }
  function write_ws_xlml_comment(comments/*:Array<any>*/)/*:string*/ {
  	return comments.map(function(c) {
  		// TODO: formatted text
  		var t = xlml_unfixstr(c.t||"");
  		var d =writextag("ss:Data", t, {"xmlns":"http://www.w3.org/TR/REC-html40"});
  		return writextag("Comment", d, {"ss:Author":c.a});
  	}).join("");
  }
  function write_ws_xlml_cell(cell, ref/*:string*/, ws, opts, idx/*:number*/, wb, addr)/*:string*/{
  	if(!cell || (cell.v == undefined && cell.f == undefined)) return "";

  	var attr = {};
  	if(cell.f) attr["ss:Formula"] = "=" + escapexml(a1_to_rc(cell.f, addr));
  	if(cell.F && cell.F.slice(0, ref.length) == ref) {
  		var end = decode_cell(cell.F.slice(ref.length + 1));
  		attr["ss:ArrayRange"] = "RC:R" + (end.r == addr.r ? "" : "[" + (end.r - addr.r) + "]") + "C" + (end.c == addr.c ? "" : "[" + (end.c - addr.c) + "]");
  	}

  	if(cell.l && cell.l.Target) {
  		attr["ss:HRef"] = escapexml(cell.l.Target);
  		if(cell.l.Tooltip) attr["x:HRefScreenTip"] = escapexml(cell.l.Tooltip);
  	}

  	if(ws['!merges']) {
  		var marr = ws['!merges'];
  		for(var mi = 0; mi != marr.length; ++mi) {
  			if(marr[mi].s.c != addr.c || marr[mi].s.r != addr.r) continue;
  			if(marr[mi].e.c > marr[mi].s.c) attr['ss:MergeAcross'] = marr[mi].e.c - marr[mi].s.c;
  			if(marr[mi].e.r > marr[mi].s.r) attr['ss:MergeDown'] = marr[mi].e.r - marr[mi].s.r;
  		}
  	}

  	var t = "", p = "";
  	switch(cell.t) {
  		case 'z': if(!opts.sheetStubs) return ""; break;
  		case 'n': t = 'Number'; p = String(cell.v); break;
  		case 'b': t = 'Boolean'; p = (cell.v ? "1" : "0"); break;
  		case 'e': t = 'Error'; p = BErr[cell.v]; break;
  		case 'd': t = 'DateTime'; p = new Date(cell.v).toISOString(); if(cell.z == null) cell.z = cell.z || table_fmt[14]; break;
  		case 's': t = 'String'; p = escapexlml(cell.v||""); break;
  	}
  	/* TODO: cell style */
  	var os = get_cell_style(opts.cellXfs, cell, opts);
  	attr["ss:StyleID"] = "s" + (21+os);
  	attr["ss:Index"] = addr.c + 1;
  	var _v = (cell.v != null ? p : "");
  	var m = cell.t == 'z' ? "" : ('<Data ss:Type="' + t + '">' + _v + '</Data>');

  	if((cell.c||[]).length > 0) m += write_ws_xlml_comment(cell.c);

  	return writextag("Cell", m, attr);
  }
  function write_ws_xlml_row(R/*:number*/, row)/*:string*/ {
  	var o = '<Row ss:Index="' + (R+1) + '"';
  	if(row) {
  		if(row.hpt && !row.hpx) row.hpx = pt2px(row.hpt);
  		if(row.hpx) o += ' ss:AutoFitHeight="0" ss:Height="' + row.hpx + '"';
  		if(row.hidden) o += ' ss:Hidden="1"';
  	}
  	return o + '>';
  }
  /* TODO */
  function write_ws_xlml_table(ws/*:Worksheet*/, opts, idx/*:number*/, wb/*:Workbook*/)/*:string*/ {
  	if(!ws['!ref']) return "";
  	var range/*:Range*/ = safe_decode_range(ws['!ref']);
  	var marr/*:Array<Range>*/ = ws['!merges'] || [], mi = 0;
  	var o/*:Array<string>*/ = [];
  	if(ws['!cols']) ws['!cols'].forEach(function(n, i) {
  		process_col(n);
  		var w = !!n.width;
  		var p = col_obj_w(i, n);
  		var k/*:any*/ = {"ss:Index":i+1};
  		if(w) k['ss:Width'] = width2px(p.width);
  		if(n.hidden) k['ss:Hidden']="1";
  		o.push(writextag("Column",null,k));
  	});
  	var dense = Array.isArray(ws);
  	for(var R = range.s.r; R <= range.e.r; ++R) {
  		var row = [write_ws_xlml_row(R, (ws['!rows']||[])[R])];
  		for(var C = range.s.c; C <= range.e.c; ++C) {
  			var skip = false;
  			for(mi = 0; mi != marr.length; ++mi) {
  				if(marr[mi].s.c > C) continue;
  				if(marr[mi].s.r > R) continue;
  				if(marr[mi].e.c < C) continue;
  				if(marr[mi].e.r < R) continue;
  				if(marr[mi].s.c != C || marr[mi].s.r != R) skip = true;
  				break;
  			}
  			if(skip) continue;
  			var addr = {r:R,c:C};
  			var ref = encode_cell(addr), cell = dense ? (ws[R]||[])[C] : ws[ref];
  			row.push(write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr));
  		}
  		row.push("</Row>");
  		if(row.length > 2) o.push(row.join(""));
  	}
  	return o.join("");
  }
  function write_ws_xlml(idx/*:number*/, opts, wb/*:Workbook*/)/*:string*/ {
  	var o/*:Array<string>*/ = [];
  	var s = wb.SheetNames[idx];
  	var ws = wb.Sheets[s];

  	var t/*:string*/ = ws ? write_ws_xlml_names(ws, opts, idx, wb) : "";
  	if(t.length > 0) o.push("<Names>" + t + "</Names>");

  	/* Table */
  	t = ws ? write_ws_xlml_table(ws, opts, idx, wb) : "";
  	if(t.length > 0) o.push("<Table>" + t + "</Table>");

  	/* WorksheetOptions */
  	o.push(write_ws_xlml_wsopts(ws, opts, idx, wb));

  	return o.join("");
  }
  function write_xlml(wb, opts)/*:string*/ {
  	if(!opts) opts = {};
  	if(!wb.SSF) wb.SSF = dup(table_fmt);
  	if(wb.SSF) {
  		make_ssf(); SSF_load_table(wb.SSF);
  		// $FlowIgnore
  		opts.revssf = evert_num(wb.SSF); opts.revssf[wb.SSF[65535]] = 0;
  		opts.ssf = wb.SSF;
  		opts.cellXfs = [];
  		get_cell_style(opts.cellXfs, {}, {revssf:{"General":0}});
  	}
  	var d/*:Array<string>*/ = [];
  	d.push(write_props_xlml(wb, opts));
  	d.push(write_wb_xlml());
  	d.push("");
  	d.push("");
  	for(var i = 0; i < wb.SheetNames.length; ++i)
  		d.push(writextag("Worksheet", write_ws_xlml(i, opts, wb), {"ss:Name":escapexml(wb.SheetNames[i])}));
  	d[2] = write_sty_xlml(wb, opts);
  	d[3] = write_names_xlml(wb);
  	return XML_HEADER + writextag("Workbook", d.join(""), {
  		'xmlns':      XLMLNS.ss,
  		'xmlns:o':    XLMLNS.o,
  		'xmlns:x':    XLMLNS.x,
  		'xmlns:ss':   XLMLNS.ss,
  		'xmlns:dt':   XLMLNS.dt,
  		'xmlns:html': XLMLNS.html
  	});
  }

  /* TODO: split props*/
  var PSCLSID = {
  	SI: "e0859ff2f94f6810ab9108002b27b3d9",
  	DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  	UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
  };
  function write_xls_props(wb/*:Workbook*/, cfb/*:CFBContainer*/) {
  	var DSEntries = [], SEntries = [], CEntries = [];
  	var i = 0, Keys;
  	var DocSummaryRE/*:{[key:string]:string}*/ = evert_key(DocSummaryPIDDSI, "n");
  	var SummaryRE/*:{[key:string]:string}*/ = evert_key(SummaryPIDSI, "n");
  	if(wb.Props) {
  		Keys = keys(wb.Props);
  		// $FlowIgnore
  		for(i = 0; i < Keys.length; ++i) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Props[Keys[i]]]);
  	}
  	if(wb.Custprops) {
  		Keys = keys(wb.Custprops);
  		// $FlowIgnore
  		for(i = 0; i < Keys.length; ++i) if(!Object.prototype.hasOwnProperty.call((wb.Props||{}), Keys[i])) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Custprops[Keys[i]]]);
  	}
  	var CEntries2 = [];
  	for(i = 0; i < CEntries.length; ++i) {
  		if(XLSPSSkip.indexOf(CEntries[i][0]) > -1 || PseudoPropsPairs.indexOf(CEntries[i][0]) > -1) continue;
  		if(CEntries[i][1] == null) continue;
  		CEntries2.push(CEntries[i]);
  	}
  	if(SEntries.length) CFB.utils.cfb_add(cfb, "/\u0005SummaryInformation", write_PropertySetStream(SEntries, PSCLSID.SI, SummaryRE, SummaryPIDSI));
  	if(DSEntries.length || CEntries2.length) CFB.utils.cfb_add(cfb, "/\u0005DocumentSummaryInformation", write_PropertySetStream(DSEntries, PSCLSID.DSI, DocSummaryRE, DocSummaryPIDDSI, CEntries2.length ? CEntries2 : null, PSCLSID.UDI));
  }


  function write_xlscfb(wb/*:Workbook*/, opts/*:WriteOpts*/)/*:CFBContainer*/ {
  	var o = opts || {};
  	var cfb = CFB.utils.cfb_new({root:"R"});
  	var wbpath = "/Workbook";
  	switch(o.bookType || "xls") {
  		case "xls": o.bookType = "biff8";
  		/* falls through */
  		case "xla": if(!o.bookType) o.bookType = "xla";
  		/* falls through */
  		case "biff8": wbpath = "/Workbook"; o.biff = 8; break;
  		case "biff5": wbpath = "/Book"; o.biff = 5; break;
  		default: throw new Error("invalid type " + o.bookType + " for XLS CFB");
  	}
  	CFB.utils.cfb_add(cfb, wbpath, write_biff_buf(wb, o));
  	if(o.biff == 8 && (wb.Props || wb.Custprops)) write_xls_props(wb, cfb);
  	// TODO: SI, DSI, CO
  	if(o.biff == 8 && wb.vbaraw) fill_vba_xls(cfb, CFB.read(wb.vbaraw, {type: typeof wb.vbaraw == "string" ? "binary" : "buffer"}));
  	return cfb;
  }
  /* [MS-XLSB] 2.3 Record Enumeration */
  var XLSBRecordEnum = {
  	/*::[*/0x0000/*::]*/: { /* n:"BrtRowHdr", */ f:parse_BrtRowHdr },
  	/*::[*/0x0001/*::]*/: { /* n:"BrtCellBlank", */ f:parse_BrtCellBlank },
  	/*::[*/0x0002/*::]*/: { /* n:"BrtCellRk", */ f:parse_BrtCellRk },
  	/*::[*/0x0003/*::]*/: { /* n:"BrtCellError", */ f:parse_BrtCellError },
  	/*::[*/0x0004/*::]*/: { /* n:"BrtCellBool", */ f:parse_BrtCellBool },
  	/*::[*/0x0005/*::]*/: { /* n:"BrtCellReal", */ f:parse_BrtCellReal },
  	/*::[*/0x0006/*::]*/: { /* n:"BrtCellSt", */ f:parse_BrtCellSt },
  	/*::[*/0x0007/*::]*/: { /* n:"BrtCellIsst", */ f:parse_BrtCellIsst },
  	/*::[*/0x0008/*::]*/: { /* n:"BrtFmlaString", */ f:parse_BrtFmlaString },
  	/*::[*/0x0009/*::]*/: { /* n:"BrtFmlaNum", */ f:parse_BrtFmlaNum },
  	/*::[*/0x000A/*::]*/: { /* n:"BrtFmlaBool", */ f:parse_BrtFmlaBool },
  	/*::[*/0x000B/*::]*/: { /* n:"BrtFmlaError", */ f:parse_BrtFmlaError },
  	/*::[*/0x000C/*::]*/: { /* n:"BrtShortBlank", */ f:parse_BrtShortBlank },
  	/*::[*/0x000D/*::]*/: { /* n:"BrtShortRk", */ f:parse_BrtShortRk },
  	/*::[*/0x000E/*::]*/: { /* n:"BrtShortError", */ f:parse_BrtShortError },
  	/*::[*/0x000F/*::]*/: { /* n:"BrtShortBool", */ f:parse_BrtShortBool },
  	/*::[*/0x0010/*::]*/: { /* n:"BrtShortReal", */ f:parse_BrtShortReal },
  	/*::[*/0x0011/*::]*/: { /* n:"BrtShortSt", */ f:parse_BrtShortSt },
  	/*::[*/0x0012/*::]*/: { /* n:"BrtShortIsst", */ f:parse_BrtShortIsst },
  	/*::[*/0x0013/*::]*/: { /* n:"BrtSSTItem", */ f:parse_RichStr },
  	/*::[*/0x0014/*::]*/: { /* n:"BrtPCDIMissing" */ },
  	/*::[*/0x0015/*::]*/: { /* n:"BrtPCDINumber" */ },
  	/*::[*/0x0016/*::]*/: { /* n:"BrtPCDIBoolean" */ },
  	/*::[*/0x0017/*::]*/: { /* n:"BrtPCDIError" */ },
  	/*::[*/0x0018/*::]*/: { /* n:"BrtPCDIString" */ },
  	/*::[*/0x0019/*::]*/: { /* n:"BrtPCDIDatetime" */ },
  	/*::[*/0x001A/*::]*/: { /* n:"BrtPCDIIndex" */ },
  	/*::[*/0x001B/*::]*/: { /* n:"BrtPCDIAMissing" */ },
  	/*::[*/0x001C/*::]*/: { /* n:"BrtPCDIANumber" */ },
  	/*::[*/0x001D/*::]*/: { /* n:"BrtPCDIABoolean" */ },
  	/*::[*/0x001E/*::]*/: { /* n:"BrtPCDIAError" */ },
  	/*::[*/0x001F/*::]*/: { /* n:"BrtPCDIAString" */ },
  	/*::[*/0x0020/*::]*/: { /* n:"BrtPCDIADatetime" */ },
  	/*::[*/0x0021/*::]*/: { /* n:"BrtPCRRecord" */ },
  	/*::[*/0x0022/*::]*/: { /* n:"BrtPCRRecordDt" */ },
  	/*::[*/0x0023/*::]*/: { /* n:"BrtFRTBegin", */ T:1 },
  	/*::[*/0x0024/*::]*/: { /* n:"BrtFRTEnd", */ T:-1 },
  	/*::[*/0x0025/*::]*/: { /* n:"BrtACBegin", */ T:1 },
  	/*::[*/0x0026/*::]*/: { /* n:"BrtACEnd", */ T:-1 },
  	/*::[*/0x0027/*::]*/: { /* n:"BrtName", */ f:parse_BrtName },
  	/*::[*/0x0028/*::]*/: { /* n:"BrtIndexRowBlock" */ },
  	/*::[*/0x002A/*::]*/: { /* n:"BrtIndexBlock" */ },
  	/*::[*/0x002B/*::]*/: { /* n:"BrtFont", */ f:parse_BrtFont },
  	/*::[*/0x002C/*::]*/: { /* n:"BrtFmt", */ f:parse_BrtFmt },
  	/*::[*/0x002D/*::]*/: { /* n:"BrtFill", */ f:parse_BrtFill },
  	/*::[*/0x002E/*::]*/: { /* n:"BrtBorder", */ f:parse_BrtBorder },
  	/*::[*/0x002F/*::]*/: { /* n:"BrtXF", */ f:parse_BrtXF },
  	/*::[*/0x0030/*::]*/: { /* n:"BrtStyle" */ },
  	/*::[*/0x0031/*::]*/: { /* n:"BrtCellMeta", */ f:parse_Int32LE },
  	/*::[*/0x0032/*::]*/: { /* n:"BrtValueMeta" */ },
  	/*::[*/0x0033/*::]*/: { /* n:"BrtMdb" */ f:parse_BrtMdb },
  	/*::[*/0x0034/*::]*/: { /* n:"BrtBeginFmd", */ T:1 },
  	/*::[*/0x0035/*::]*/: { /* n:"BrtEndFmd", */ T:-1 },
  	/*::[*/0x0036/*::]*/: { /* n:"BrtBeginMdx", */ T:1 },
  	/*::[*/0x0037/*::]*/: { /* n:"BrtEndMdx", */ T:-1 },
  	/*::[*/0x0038/*::]*/: { /* n:"BrtBeginMdxTuple", */ T:1 },
  	/*::[*/0x0039/*::]*/: { /* n:"BrtEndMdxTuple", */ T:-1 },
  	/*::[*/0x003A/*::]*/: { /* n:"BrtMdxMbrIstr" */ },
  	/*::[*/0x003B/*::]*/: { /* n:"BrtStr" */ },
  	/*::[*/0x003C/*::]*/: { /* n:"BrtColInfo", */ f:parse_ColInfo },
  	/*::[*/0x003E/*::]*/: { /* n:"BrtCellRString", */ f:parse_BrtCellRString },
  	/*::[*/0x003F/*::]*/: { /* n:"BrtCalcChainItem$", */ f:parse_BrtCalcChainItem$ },
  	/*::[*/0x0040/*::]*/: { /* n:"BrtDVal", */ f:parse_BrtDVal },
  	/*::[*/0x0041/*::]*/: { /* n:"BrtSxvcellNum" */ },
  	/*::[*/0x0042/*::]*/: { /* n:"BrtSxvcellStr" */ },
  	/*::[*/0x0043/*::]*/: { /* n:"BrtSxvcellBool" */ },
  	/*::[*/0x0044/*::]*/: { /* n:"BrtSxvcellErr" */ },
  	/*::[*/0x0045/*::]*/: { /* n:"BrtSxvcellDate" */ },
  	/*::[*/0x0046/*::]*/: { /* n:"BrtSxvcellNil" */ },
  	/*::[*/0x0080/*::]*/: { /* n:"BrtFileVersion" */ },
  	/*::[*/0x0081/*::]*/: { /* n:"BrtBeginSheet", */ T:1 },
  	/*::[*/0x0082/*::]*/: { /* n:"BrtEndSheet", */ T:-1 },
  	/*::[*/0x0083/*::]*/: { /* n:"BrtBeginBook", */ T:1, f:parsenoop, p:0 },
  	/*::[*/0x0084/*::]*/: { /* n:"BrtEndBook", */ T:-1 },
  	/*::[*/0x0085/*::]*/: { /* n:"BrtBeginWsViews", */ T:1 },
  	/*::[*/0x0086/*::]*/: { /* n:"BrtEndWsViews", */ T:-1 },
  	/*::[*/0x0087/*::]*/: { /* n:"BrtBeginBookViews", */ T:1 },
  	/*::[*/0x0088/*::]*/: { /* n:"BrtEndBookViews", */ T:-1 },
  	/*::[*/0x0089/*::]*/: { /* n:"BrtBeginWsView", */ T:1, f:parse_BrtBeginWsView },
  	/*::[*/0x008A/*::]*/: { /* n:"BrtEndWsView", */ T:-1 },
  	/*::[*/0x008B/*::]*/: { /* n:"BrtBeginCsViews", */ T:1 },
  	/*::[*/0x008C/*::]*/: { /* n:"BrtEndCsViews", */ T:-1 },
  	/*::[*/0x008D/*::]*/: { /* n:"BrtBeginCsView", */ T:1 },
  	/*::[*/0x008E/*::]*/: { /* n:"BrtEndCsView", */ T:-1 },
  	/*::[*/0x008F/*::]*/: { /* n:"BrtBeginBundleShs", */ T:1 },
  	/*::[*/0x0090/*::]*/: { /* n:"BrtEndBundleShs", */ T:-1 },
  	/*::[*/0x0091/*::]*/: { /* n:"BrtBeginSheetData", */ T:1 },
  	/*::[*/0x0092/*::]*/: { /* n:"BrtEndSheetData", */ T:-1 },
  	/*::[*/0x0093/*::]*/: { /* n:"BrtWsProp", */ f:parse_BrtWsProp },
  	/*::[*/0x0094/*::]*/: { /* n:"BrtWsDim", */ f:parse_BrtWsDim, p:16 },
  	/*::[*/0x0097/*::]*/: { /* n:"BrtPane", */ f:parse_BrtPane },
  	/*::[*/0x0098/*::]*/: { /* n:"BrtSel" */ },
  	/*::[*/0x0099/*::]*/: { /* n:"BrtWbProp", */ f:parse_BrtWbProp },
  	/*::[*/0x009A/*::]*/: { /* n:"BrtWbFactoid" */ },
  	/*::[*/0x009B/*::]*/: { /* n:"BrtFileRecover" */ },
  	/*::[*/0x009C/*::]*/: { /* n:"BrtBundleSh", */ f:parse_BrtBundleSh },
  	/*::[*/0x009D/*::]*/: { /* n:"BrtCalcProp" */ },
  	/*::[*/0x009E/*::]*/: { /* n:"BrtBookView" */ },
  	/*::[*/0x009F/*::]*/: { /* n:"BrtBeginSst", */ T:1, f:parse_BrtBeginSst },
  	/*::[*/0x00A0/*::]*/: { /* n:"BrtEndSst", */ T:-1 },
  	/*::[*/0x00A1/*::]*/: { /* n:"BrtBeginAFilter", */ T:1, f:parse_UncheckedRfX },
  	/*::[*/0x00A2/*::]*/: { /* n:"BrtEndAFilter", */ T:-1 },
  	/*::[*/0x00A3/*::]*/: { /* n:"BrtBeginFilterColumn", */ T:1 },
  	/*::[*/0x00A4/*::]*/: { /* n:"BrtEndFilterColumn", */ T:-1 },
  	/*::[*/0x00A5/*::]*/: { /* n:"BrtBeginFilters", */ T:1 },
  	/*::[*/0x00A6/*::]*/: { /* n:"BrtEndFilters", */ T:-1 },
  	/*::[*/0x00A7/*::]*/: { /* n:"BrtFilter" */ },
  	/*::[*/0x00A8/*::]*/: { /* n:"BrtColorFilter" */ },
  	/*::[*/0x00A9/*::]*/: { /* n:"BrtIconFilter" */ },
  	/*::[*/0x00AA/*::]*/: { /* n:"BrtTop10Filter" */ },
  	/*::[*/0x00AB/*::]*/: { /* n:"BrtDynamicFilter" */ },
  	/*::[*/0x00AC/*::]*/: { /* n:"BrtBeginCustomFilters", */ T:1 },
  	/*::[*/0x00AD/*::]*/: { /* n:"BrtEndCustomFilters", */ T:-1 },
  	/*::[*/0x00AE/*::]*/: { /* n:"BrtCustomFilter" */ },
  	/*::[*/0x00AF/*::]*/: { /* n:"BrtAFilterDateGroupItem" */ },
  	/*::[*/0x00B0/*::]*/: { /* n:"BrtMergeCell", */ f:parse_BrtMergeCell },
  	/*::[*/0x00B1/*::]*/: { /* n:"BrtBeginMergeCells", */ T:1 },
  	/*::[*/0x00B2/*::]*/: { /* n:"BrtEndMergeCells", */ T:-1 },
  	/*::[*/0x00B3/*::]*/: { /* n:"BrtBeginPivotCacheDef", */ T:1 },
  	/*::[*/0x00B4/*::]*/: { /* n:"BrtEndPivotCacheDef", */ T:-1 },
  	/*::[*/0x00B5/*::]*/: { /* n:"BrtBeginPCDFields", */ T:1 },
  	/*::[*/0x00B6/*::]*/: { /* n:"BrtEndPCDFields", */ T:-1 },
  	/*::[*/0x00B7/*::]*/: { /* n:"BrtBeginPCDField", */ T:1 },
  	/*::[*/0x00B8/*::]*/: { /* n:"BrtEndPCDField", */ T:-1 },
  	/*::[*/0x00B9/*::]*/: { /* n:"BrtBeginPCDSource", */ T:1 },
  	/*::[*/0x00BA/*::]*/: { /* n:"BrtEndPCDSource", */ T:-1 },
  	/*::[*/0x00BB/*::]*/: { /* n:"BrtBeginPCDSRange", */ T:1 },
  	/*::[*/0x00BC/*::]*/: { /* n:"BrtEndPCDSRange", */ T:-1 },
  	/*::[*/0x00BD/*::]*/: { /* n:"BrtBeginPCDFAtbl", */ T:1 },
  	/*::[*/0x00BE/*::]*/: { /* n:"BrtEndPCDFAtbl", */ T:-1 },
  	/*::[*/0x00BF/*::]*/: { /* n:"BrtBeginPCDIRun", */ T:1 },
  	/*::[*/0x00C0/*::]*/: { /* n:"BrtEndPCDIRun", */ T:-1 },
  	/*::[*/0x00C1/*::]*/: { /* n:"BrtBeginPivotCacheRecords", */ T:1 },
  	/*::[*/0x00C2/*::]*/: { /* n:"BrtEndPivotCacheRecords", */ T:-1 },
  	/*::[*/0x00C3/*::]*/: { /* n:"BrtBeginPCDHierarchies", */ T:1 },
  	/*::[*/0x00C4/*::]*/: { /* n:"BrtEndPCDHierarchies", */ T:-1 },
  	/*::[*/0x00C5/*::]*/: { /* n:"BrtBeginPCDHierarchy", */ T:1 },
  	/*::[*/0x00C6/*::]*/: { /* n:"BrtEndPCDHierarchy", */ T:-1 },
  	/*::[*/0x00C7/*::]*/: { /* n:"BrtBeginPCDHFieldsUsage", */ T:1 },
  	/*::[*/0x00C8/*::]*/: { /* n:"BrtEndPCDHFieldsUsage", */ T:-1 },
  	/*::[*/0x00C9/*::]*/: { /* n:"BrtBeginExtConnection", */ T:1 },
  	/*::[*/0x00CA/*::]*/: { /* n:"BrtEndExtConnection", */ T:-1 },
  	/*::[*/0x00CB/*::]*/: { /* n:"BrtBeginECDbProps", */ T:1 },
  	/*::[*/0x00CC/*::]*/: { /* n:"BrtEndECDbProps", */ T:-1 },
  	/*::[*/0x00CD/*::]*/: { /* n:"BrtBeginECOlapProps", */ T:1 },
  	/*::[*/0x00CE/*::]*/: { /* n:"BrtEndECOlapProps", */ T:-1 },
  	/*::[*/0x00CF/*::]*/: { /* n:"BrtBeginPCDSConsol", */ T:1 },
  	/*::[*/0x00D0/*::]*/: { /* n:"BrtEndPCDSConsol", */ T:-1 },
  	/*::[*/0x00D1/*::]*/: { /* n:"BrtBeginPCDSCPages", */ T:1 },
  	/*::[*/0x00D2/*::]*/: { /* n:"BrtEndPCDSCPages", */ T:-1 },
  	/*::[*/0x00D3/*::]*/: { /* n:"BrtBeginPCDSCPage", */ T:1 },
  	/*::[*/0x00D4/*::]*/: { /* n:"BrtEndPCDSCPage", */ T:-1 },
  	/*::[*/0x00D5/*::]*/: { /* n:"BrtBeginPCDSCPItem", */ T:1 },
  	/*::[*/0x00D6/*::]*/: { /* n:"BrtEndPCDSCPItem", */ T:-1 },
  	/*::[*/0x00D7/*::]*/: { /* n:"BrtBeginPCDSCSets", */ T:1 },
  	/*::[*/0x00D8/*::]*/: { /* n:"BrtEndPCDSCSets", */ T:-1 },
  	/*::[*/0x00D9/*::]*/: { /* n:"BrtBeginPCDSCSet", */ T:1 },
  	/*::[*/0x00DA/*::]*/: { /* n:"BrtEndPCDSCSet", */ T:-1 },
  	/*::[*/0x00DB/*::]*/: { /* n:"BrtBeginPCDFGroup", */ T:1 },
  	/*::[*/0x00DC/*::]*/: { /* n:"BrtEndPCDFGroup", */ T:-1 },
  	/*::[*/0x00DD/*::]*/: { /* n:"BrtBeginPCDFGItems", */ T:1 },
  	/*::[*/0x00DE/*::]*/: { /* n:"BrtEndPCDFGItems", */ T:-1 },
  	/*::[*/0x00DF/*::]*/: { /* n:"BrtBeginPCDFGRange", */ T:1 },
  	/*::[*/0x00E0/*::]*/: { /* n:"BrtEndPCDFGRange", */ T:-1 },
  	/*::[*/0x00E1/*::]*/: { /* n:"BrtBeginPCDFGDiscrete", */ T:1 },
  	/*::[*/0x00E2/*::]*/: { /* n:"BrtEndPCDFGDiscrete", */ T:-1 },
  	/*::[*/0x00E3/*::]*/: { /* n:"BrtBeginPCDSDTupleCache", */ T:1 },
  	/*::[*/0x00E4/*::]*/: { /* n:"BrtEndPCDSDTupleCache", */ T:-1 },
  	/*::[*/0x00E5/*::]*/: { /* n:"BrtBeginPCDSDTCEntries", */ T:1 },
  	/*::[*/0x00E6/*::]*/: { /* n:"BrtEndPCDSDTCEntries", */ T:-1 },
  	/*::[*/0x00E7/*::]*/: { /* n:"BrtBeginPCDSDTCEMembers", */ T:1 },
  	/*::[*/0x00E8/*::]*/: { /* n:"BrtEndPCDSDTCEMembers", */ T:-1 },
  	/*::[*/0x00E9/*::]*/: { /* n:"BrtBeginPCDSDTCEMember", */ T:1 },
  	/*::[*/0x00EA/*::]*/: { /* n:"BrtEndPCDSDTCEMember", */ T:-1 },
  	/*::[*/0x00EB/*::]*/: { /* n:"BrtBeginPCDSDTCQueries", */ T:1 },
  	/*::[*/0x00EC/*::]*/: { /* n:"BrtEndPCDSDTCQueries", */ T:-1 },
  	/*::[*/0x00ED/*::]*/: { /* n:"BrtBeginPCDSDTCQuery", */ T:1 },
  	/*::[*/0x00EE/*::]*/: { /* n:"BrtEndPCDSDTCQuery", */ T:-1 },
  	/*::[*/0x00EF/*::]*/: { /* n:"BrtBeginPCDSDTCSets", */ T:1 },
  	/*::[*/0x00F0/*::]*/: { /* n:"BrtEndPCDSDTCSets", */ T:-1 },
  	/*::[*/0x00F1/*::]*/: { /* n:"BrtBeginPCDSDTCSet", */ T:1 },
  	/*::[*/0x00F2/*::]*/: { /* n:"BrtEndPCDSDTCSet", */ T:-1 },
  	/*::[*/0x00F3/*::]*/: { /* n:"BrtBeginPCDCalcItems", */ T:1 },
  	/*::[*/0x00F4/*::]*/: { /* n:"BrtEndPCDCalcItems", */ T:-1 },
  	/*::[*/0x00F5/*::]*/: { /* n:"BrtBeginPCDCalcItem", */ T:1 },
  	/*::[*/0x00F6/*::]*/: { /* n:"BrtEndPCDCalcItem", */ T:-1 },
  	/*::[*/0x00F7/*::]*/: { /* n:"BrtBeginPRule", */ T:1 },
  	/*::[*/0x00F8/*::]*/: { /* n:"BrtEndPRule", */ T:-1 },
  	/*::[*/0x00F9/*::]*/: { /* n:"BrtBeginPRFilters", */ T:1 },
  	/*::[*/0x00FA/*::]*/: { /* n:"BrtEndPRFilters", */ T:-1 },
  	/*::[*/0x00FB/*::]*/: { /* n:"BrtBeginPRFilter", */ T:1 },
  	/*::[*/0x00FC/*::]*/: { /* n:"BrtEndPRFilter", */ T:-1 },
  	/*::[*/0x00FD/*::]*/: { /* n:"BrtBeginPNames", */ T:1 },
  	/*::[*/0x00FE/*::]*/: { /* n:"BrtEndPNames", */ T:-1 },
  	/*::[*/0x00FF/*::]*/: { /* n:"BrtBeginPName", */ T:1 },
  	/*::[*/0x0100/*::]*/: { /* n:"BrtEndPName", */ T:-1 },
  	/*::[*/0x0101/*::]*/: { /* n:"BrtBeginPNPairs", */ T:1 },
  	/*::[*/0x0102/*::]*/: { /* n:"BrtEndPNPairs", */ T:-1 },
  	/*::[*/0x0103/*::]*/: { /* n:"BrtBeginPNPair", */ T:1 },
  	/*::[*/0x0104/*::]*/: { /* n:"BrtEndPNPair", */ T:-1 },
  	/*::[*/0x0105/*::]*/: { /* n:"BrtBeginECWebProps", */ T:1 },
  	/*::[*/0x0106/*::]*/: { /* n:"BrtEndECWebProps", */ T:-1 },
  	/*::[*/0x0107/*::]*/: { /* n:"BrtBeginEcWpTables", */ T:1 },
  	/*::[*/0x0108/*::]*/: { /* n:"BrtEndECWPTables", */ T:-1 },
  	/*::[*/0x0109/*::]*/: { /* n:"BrtBeginECParams", */ T:1 },
  	/*::[*/0x010A/*::]*/: { /* n:"BrtEndECParams", */ T:-1 },
  	/*::[*/0x010B/*::]*/: { /* n:"BrtBeginECParam", */ T:1 },
  	/*::[*/0x010C/*::]*/: { /* n:"BrtEndECParam", */ T:-1 },
  	/*::[*/0x010D/*::]*/: { /* n:"BrtBeginPCDKPIs", */ T:1 },
  	/*::[*/0x010E/*::]*/: { /* n:"BrtEndPCDKPIs", */ T:-1 },
  	/*::[*/0x010F/*::]*/: { /* n:"BrtBeginPCDKPI", */ T:1 },
  	/*::[*/0x0110/*::]*/: { /* n:"BrtEndPCDKPI", */ T:-1 },
  	/*::[*/0x0111/*::]*/: { /* n:"BrtBeginDims", */ T:1 },
  	/*::[*/0x0112/*::]*/: { /* n:"BrtEndDims", */ T:-1 },
  	/*::[*/0x0113/*::]*/: { /* n:"BrtBeginDim", */ T:1 },
  	/*::[*/0x0114/*::]*/: { /* n:"BrtEndDim", */ T:-1 },
  	/*::[*/0x0115/*::]*/: { /* n:"BrtIndexPartEnd" */ },
  	/*::[*/0x0116/*::]*/: { /* n:"BrtBeginStyleSheet", */ T:1 },
  	/*::[*/0x0117/*::]*/: { /* n:"BrtEndStyleSheet", */ T:-1 },
  	/*::[*/0x0118/*::]*/: { /* n:"BrtBeginSXView", */ T:1 },
  	/*::[*/0x0119/*::]*/: { /* n:"BrtEndSXVI", */ T:-1 },
  	/*::[*/0x011A/*::]*/: { /* n:"BrtBeginSXVI", */ T:1 },
  	/*::[*/0x011B/*::]*/: { /* n:"BrtBeginSXVIs", */ T:1 },
  	/*::[*/0x011C/*::]*/: { /* n:"BrtEndSXVIs", */ T:-1 },
  	/*::[*/0x011D/*::]*/: { /* n:"BrtBeginSXVD", */ T:1 },
  	/*::[*/0x011E/*::]*/: { /* n:"BrtEndSXVD", */ T:-1 },
  	/*::[*/0x011F/*::]*/: { /* n:"BrtBeginSXVDs", */ T:1 },
  	/*::[*/0x0120/*::]*/: { /* n:"BrtEndSXVDs", */ T:-1 },
  	/*::[*/0x0121/*::]*/: { /* n:"BrtBeginSXPI", */ T:1 },
  	/*::[*/0x0122/*::]*/: { /* n:"BrtEndSXPI", */ T:-1 },
  	/*::[*/0x0123/*::]*/: { /* n:"BrtBeginSXPIs", */ T:1 },
  	/*::[*/0x0124/*::]*/: { /* n:"BrtEndSXPIs", */ T:-1 },
  	/*::[*/0x0125/*::]*/: { /* n:"BrtBeginSXDI", */ T:1 },
  	/*::[*/0x0126/*::]*/: { /* n:"BrtEndSXDI", */ T:-1 },
  	/*::[*/0x0127/*::]*/: { /* n:"BrtBeginSXDIs", */ T:1 },
  	/*::[*/0x0128/*::]*/: { /* n:"BrtEndSXDIs", */ T:-1 },
  	/*::[*/0x0129/*::]*/: { /* n:"BrtBeginSXLI", */ T:1 },
  	/*::[*/0x012A/*::]*/: { /* n:"BrtEndSXLI", */ T:-1 },
  	/*::[*/0x012B/*::]*/: { /* n:"BrtBeginSXLIRws", */ T:1 },
  	/*::[*/0x012C/*::]*/: { /* n:"BrtEndSXLIRws", */ T:-1 },
  	/*::[*/0x012D/*::]*/: { /* n:"BrtBeginSXLICols", */ T:1 },
  	/*::[*/0x012E/*::]*/: { /* n:"BrtEndSXLICols", */ T:-1 },
  	/*::[*/0x012F/*::]*/: { /* n:"BrtBeginSXFormat", */ T:1 },
  	/*::[*/0x0130/*::]*/: { /* n:"BrtEndSXFormat", */ T:-1 },
  	/*::[*/0x0131/*::]*/: { /* n:"BrtBeginSXFormats", */ T:1 },
  	/*::[*/0x0132/*::]*/: { /* n:"BrtEndSxFormats", */ T:-1 },
  	/*::[*/0x0133/*::]*/: { /* n:"BrtBeginSxSelect", */ T:1 },
  	/*::[*/0x0134/*::]*/: { /* n:"BrtEndSxSelect", */ T:-1 },
  	/*::[*/0x0135/*::]*/: { /* n:"BrtBeginISXVDRws", */ T:1 },
  	/*::[*/0x0136/*::]*/: { /* n:"BrtEndISXVDRws", */ T:-1 },
  	/*::[*/0x0137/*::]*/: { /* n:"BrtBeginISXVDCols", */ T:1 },
  	/*::[*/0x0138/*::]*/: { /* n:"BrtEndISXVDCols", */ T:-1 },
  	/*::[*/0x0139/*::]*/: { /* n:"BrtEndSXLocation", */ T:-1 },
  	/*::[*/0x013A/*::]*/: { /* n:"BrtBeginSXLocation", */ T:1 },
  	/*::[*/0x013B/*::]*/: { /* n:"BrtEndSXView", */ T:-1 },
  	/*::[*/0x013C/*::]*/: { /* n:"BrtBeginSXTHs", */ T:1 },
  	/*::[*/0x013D/*::]*/: { /* n:"BrtEndSXTHs", */ T:-1 },
  	/*::[*/0x013E/*::]*/: { /* n:"BrtBeginSXTH", */ T:1 },
  	/*::[*/0x013F/*::]*/: { /* n:"BrtEndSXTH", */ T:-1 },
  	/*::[*/0x0140/*::]*/: { /* n:"BrtBeginISXTHRws", */ T:1 },
  	/*::[*/0x0141/*::]*/: { /* n:"BrtEndISXTHRws", */ T:-1 },
  	/*::[*/0x0142/*::]*/: { /* n:"BrtBeginISXTHCols", */ T:1 },
  	/*::[*/0x0143/*::]*/: { /* n:"BrtEndISXTHCols", */ T:-1 },
  	/*::[*/0x0144/*::]*/: { /* n:"BrtBeginSXTDMPS", */ T:1 },
  	/*::[*/0x0145/*::]*/: { /* n:"BrtEndSXTDMPs", */ T:-1 },
  	/*::[*/0x0146/*::]*/: { /* n:"BrtBeginSXTDMP", */ T:1 },
  	/*::[*/0x0147/*::]*/: { /* n:"BrtEndSXTDMP", */ T:-1 },
  	/*::[*/0x0148/*::]*/: { /* n:"BrtBeginSXTHItems", */ T:1 },
  	/*::[*/0x0149/*::]*/: { /* n:"BrtEndSXTHItems", */ T:-1 },
  	/*::[*/0x014A/*::]*/: { /* n:"BrtBeginSXTHItem", */ T:1 },
  	/*::[*/0x014B/*::]*/: { /* n:"BrtEndSXTHItem", */ T:-1 },
  	/*::[*/0x014C/*::]*/: { /* n:"BrtBeginMetadata", */ T:1 },
  	/*::[*/0x014D/*::]*/: { /* n:"BrtEndMetadata", */ T:-1 },
  	/*::[*/0x014E/*::]*/: { /* n:"BrtBeginEsmdtinfo", */ T:1 },
  	/*::[*/0x014F/*::]*/: { /* n:"BrtMdtinfo", */ f:parse_BrtMdtinfo },
  	/*::[*/0x0150/*::]*/: { /* n:"BrtEndEsmdtinfo", */ T:-1 },
  	/*::[*/0x0151/*::]*/: { /* n:"BrtBeginEsmdb", */ f:parse_BrtBeginEsmdb, T:1 },
  	/*::[*/0x0152/*::]*/: { /* n:"BrtEndEsmdb", */ T:-1 },
  	/*::[*/0x0153/*::]*/: { /* n:"BrtBeginEsfmd", */ T:1 },
  	/*::[*/0x0154/*::]*/: { /* n:"BrtEndEsfmd", */ T:-1 },
  	/*::[*/0x0155/*::]*/: { /* n:"BrtBeginSingleCells", */ T:1 },
  	/*::[*/0x0156/*::]*/: { /* n:"BrtEndSingleCells", */ T:-1 },
  	/*::[*/0x0157/*::]*/: { /* n:"BrtBeginList", */ T:1 },
  	/*::[*/0x0158/*::]*/: { /* n:"BrtEndList", */ T:-1 },
  	/*::[*/0x0159/*::]*/: { /* n:"BrtBeginListCols", */ T:1 },
  	/*::[*/0x015A/*::]*/: { /* n:"BrtEndListCols", */ T:-1 },
  	/*::[*/0x015B/*::]*/: { /* n:"BrtBeginListCol", */ T:1 },
  	/*::[*/0x015C/*::]*/: { /* n:"BrtEndListCol", */ T:-1 },
  	/*::[*/0x015D/*::]*/: { /* n:"BrtBeginListXmlCPr", */ T:1 },
  	/*::[*/0x015E/*::]*/: { /* n:"BrtEndListXmlCPr", */ T:-1 },
  	/*::[*/0x015F/*::]*/: { /* n:"BrtListCCFmla" */ },
  	/*::[*/0x0160/*::]*/: { /* n:"BrtListTrFmla" */ },
  	/*::[*/0x0161/*::]*/: { /* n:"BrtBeginExternals", */ T:1 },
  	/*::[*/0x0162/*::]*/: { /* n:"BrtEndExternals", */ T:-1 },
  	/*::[*/0x0163/*::]*/: { /* n:"BrtSupBookSrc", */ f:parse_RelID},
  	/*::[*/0x0165/*::]*/: { /* n:"BrtSupSelf" */ },
  	/*::[*/0x0166/*::]*/: { /* n:"BrtSupSame" */ },
  	/*::[*/0x0167/*::]*/: { /* n:"BrtSupTabs" */ },
  	/*::[*/0x0168/*::]*/: { /* n:"BrtBeginSupBook", */ T:1 },
  	/*::[*/0x0169/*::]*/: { /* n:"BrtPlaceholderName" */ },
  	/*::[*/0x016A/*::]*/: { /* n:"BrtExternSheet", */ f:parse_ExternSheet },
  	/*::[*/0x016B/*::]*/: { /* n:"BrtExternTableStart" */ },
  	/*::[*/0x016C/*::]*/: { /* n:"BrtExternTableEnd" */ },
  	/*::[*/0x016E/*::]*/: { /* n:"BrtExternRowHdr" */ },
  	/*::[*/0x016F/*::]*/: { /* n:"BrtExternCellBlank" */ },
  	/*::[*/0x0170/*::]*/: { /* n:"BrtExternCellReal" */ },
  	/*::[*/0x0171/*::]*/: { /* n:"BrtExternCellBool" */ },
  	/*::[*/0x0172/*::]*/: { /* n:"BrtExternCellError" */ },
  	/*::[*/0x0173/*::]*/: { /* n:"BrtExternCellString" */ },
  	/*::[*/0x0174/*::]*/: { /* n:"BrtBeginEsmdx", */ T:1 },
  	/*::[*/0x0175/*::]*/: { /* n:"BrtEndEsmdx", */ T:-1 },
  	/*::[*/0x0176/*::]*/: { /* n:"BrtBeginMdxSet", */ T:1 },
  	/*::[*/0x0177/*::]*/: { /* n:"BrtEndMdxSet", */ T:-1 },
  	/*::[*/0x0178/*::]*/: { /* n:"BrtBeginMdxMbrProp", */ T:1 },
  	/*::[*/0x0179/*::]*/: { /* n:"BrtEndMdxMbrProp", */ T:-1 },
  	/*::[*/0x017A/*::]*/: { /* n:"BrtBeginMdxKPI", */ T:1 },
  	/*::[*/0x017B/*::]*/: { /* n:"BrtEndMdxKPI", */ T:-1 },
  	/*::[*/0x017C/*::]*/: { /* n:"BrtBeginEsstr", */ T:1 },
  	/*::[*/0x017D/*::]*/: { /* n:"BrtEndEsstr", */ T:-1 },
  	/*::[*/0x017E/*::]*/: { /* n:"BrtBeginPRFItem", */ T:1 },
  	/*::[*/0x017F/*::]*/: { /* n:"BrtEndPRFItem", */ T:-1 },
  	/*::[*/0x0180/*::]*/: { /* n:"BrtBeginPivotCacheIDs", */ T:1 },
  	/*::[*/0x0181/*::]*/: { /* n:"BrtEndPivotCacheIDs", */ T:-1 },
  	/*::[*/0x0182/*::]*/: { /* n:"BrtBeginPivotCacheID", */ T:1 },
  	/*::[*/0x0183/*::]*/: { /* n:"BrtEndPivotCacheID", */ T:-1 },
  	/*::[*/0x0184/*::]*/: { /* n:"BrtBeginISXVIs", */ T:1 },
  	/*::[*/0x0185/*::]*/: { /* n:"BrtEndISXVIs", */ T:-1 },
  	/*::[*/0x0186/*::]*/: { /* n:"BrtBeginColInfos", */ T:1 },
  	/*::[*/0x0187/*::]*/: { /* n:"BrtEndColInfos", */ T:-1 },
  	/*::[*/0x0188/*::]*/: { /* n:"BrtBeginRwBrk", */ T:1 },
  	/*::[*/0x0189/*::]*/: { /* n:"BrtEndRwBrk", */ T:-1 },
  	/*::[*/0x018A/*::]*/: { /* n:"BrtBeginColBrk", */ T:1 },
  	/*::[*/0x018B/*::]*/: { /* n:"BrtEndColBrk", */ T:-1 },
  	/*::[*/0x018C/*::]*/: { /* n:"BrtBrk" */ },
  	/*::[*/0x018D/*::]*/: { /* n:"BrtUserBookView" */ },
  	/*::[*/0x018E/*::]*/: { /* n:"BrtInfo" */ },
  	/*::[*/0x018F/*::]*/: { /* n:"BrtCUsr" */ },
  	/*::[*/0x0190/*::]*/: { /* n:"BrtUsr" */ },
  	/*::[*/0x0191/*::]*/: { /* n:"BrtBeginUsers", */ T:1 },
  	/*::[*/0x0193/*::]*/: { /* n:"BrtEOF" */ },
  	/*::[*/0x0194/*::]*/: { /* n:"BrtUCR" */ },
  	/*::[*/0x0195/*::]*/: { /* n:"BrtRRInsDel" */ },
  	/*::[*/0x0196/*::]*/: { /* n:"BrtRREndInsDel" */ },
  	/*::[*/0x0197/*::]*/: { /* n:"BrtRRMove" */ },
  	/*::[*/0x0198/*::]*/: { /* n:"BrtRREndMove" */ },
  	/*::[*/0x0199/*::]*/: { /* n:"BrtRRChgCell" */ },
  	/*::[*/0x019A/*::]*/: { /* n:"BrtRREndChgCell" */ },
  	/*::[*/0x019B/*::]*/: { /* n:"BrtRRHeader" */ },
  	/*::[*/0x019C/*::]*/: { /* n:"BrtRRUserView" */ },
  	/*::[*/0x019D/*::]*/: { /* n:"BrtRRRenSheet" */ },
  	/*::[*/0x019E/*::]*/: { /* n:"BrtRRInsertSh" */ },
  	/*::[*/0x019F/*::]*/: { /* n:"BrtRRDefName" */ },
  	/*::[*/0x01A0/*::]*/: { /* n:"BrtRRNote" */ },
  	/*::[*/0x01A1/*::]*/: { /* n:"BrtRRConflict" */ },
  	/*::[*/0x01A2/*::]*/: { /* n:"BrtRRTQSIF" */ },
  	/*::[*/0x01A3/*::]*/: { /* n:"BrtRRFormat" */ },
  	/*::[*/0x01A4/*::]*/: { /* n:"BrtRREndFormat" */ },
  	/*::[*/0x01A5/*::]*/: { /* n:"BrtRRAutoFmt" */ },
  	/*::[*/0x01A6/*::]*/: { /* n:"BrtBeginUserShViews", */ T:1 },
  	/*::[*/0x01A7/*::]*/: { /* n:"BrtBeginUserShView", */ T:1 },
  	/*::[*/0x01A8/*::]*/: { /* n:"BrtEndUserShView", */ T:-1 },
  	/*::[*/0x01A9/*::]*/: { /* n:"BrtEndUserShViews", */ T:-1 },
  	/*::[*/0x01AA/*::]*/: { /* n:"BrtArrFmla", */ f:parse_BrtArrFmla },
  	/*::[*/0x01AB/*::]*/: { /* n:"BrtShrFmla", */ f:parse_BrtShrFmla },
  	/*::[*/0x01AC/*::]*/: { /* n:"BrtTable" */ },
  	/*::[*/0x01AD/*::]*/: { /* n:"BrtBeginExtConnections", */ T:1 },
  	/*::[*/0x01AE/*::]*/: { /* n:"BrtEndExtConnections", */ T:-1 },
  	/*::[*/0x01AF/*::]*/: { /* n:"BrtBeginPCDCalcMems", */ T:1 },
  	/*::[*/0x01B0/*::]*/: { /* n:"BrtEndPCDCalcMems", */ T:-1 },
  	/*::[*/0x01B1/*::]*/: { /* n:"BrtBeginPCDCalcMem", */ T:1 },
  	/*::[*/0x01B2/*::]*/: { /* n:"BrtEndPCDCalcMem", */ T:-1 },
  	/*::[*/0x01B3/*::]*/: { /* n:"BrtBeginPCDHGLevels", */ T:1 },
  	/*::[*/0x01B4/*::]*/: { /* n:"BrtEndPCDHGLevels", */ T:-1 },
  	/*::[*/0x01B5/*::]*/: { /* n:"BrtBeginPCDHGLevel", */ T:1 },
  	/*::[*/0x01B6/*::]*/: { /* n:"BrtEndPCDHGLevel", */ T:-1 },
  	/*::[*/0x01B7/*::]*/: { /* n:"BrtBeginPCDHGLGroups", */ T:1 },
  	/*::[*/0x01B8/*::]*/: { /* n:"BrtEndPCDHGLGroups", */ T:-1 },
  	/*::[*/0x01B9/*::]*/: { /* n:"BrtBeginPCDHGLGroup", */ T:1 },
  	/*::[*/0x01BA/*::]*/: { /* n:"BrtEndPCDHGLGroup", */ T:-1 },
  	/*::[*/0x01BB/*::]*/: { /* n:"BrtBeginPCDHGLGMembers", */ T:1 },
  	/*::[*/0x01BC/*::]*/: { /* n:"BrtEndPCDHGLGMembers", */ T:-1 },
  	/*::[*/0x01BD/*::]*/: { /* n:"BrtBeginPCDHGLGMember", */ T:1 },
  	/*::[*/0x01BE/*::]*/: { /* n:"BrtEndPCDHGLGMember", */ T:-1 },
  	/*::[*/0x01BF/*::]*/: { /* n:"BrtBeginQSI", */ T:1 },
  	/*::[*/0x01C0/*::]*/: { /* n:"BrtEndQSI", */ T:-1 },
  	/*::[*/0x01C1/*::]*/: { /* n:"BrtBeginQSIR", */ T:1 },
  	/*::[*/0x01C2/*::]*/: { /* n:"BrtEndQSIR", */ T:-1 },
  	/*::[*/0x01C3/*::]*/: { /* n:"BrtBeginDeletedNames", */ T:1 },
  	/*::[*/0x01C4/*::]*/: { /* n:"BrtEndDeletedNames", */ T:-1 },
  	/*::[*/0x01C5/*::]*/: { /* n:"BrtBeginDeletedName", */ T:1 },
  	/*::[*/0x01C6/*::]*/: { /* n:"BrtEndDeletedName", */ T:-1 },
  	/*::[*/0x01C7/*::]*/: { /* n:"BrtBeginQSIFs", */ T:1 },
  	/*::[*/0x01C8/*::]*/: { /* n:"BrtEndQSIFs", */ T:-1 },
  	/*::[*/0x01C9/*::]*/: { /* n:"BrtBeginQSIF", */ T:1 },
  	/*::[*/0x01CA/*::]*/: { /* n:"BrtEndQSIF", */ T:-1 },
  	/*::[*/0x01CB/*::]*/: { /* n:"BrtBeginAutoSortScope", */ T:1 },
  	/*::[*/0x01CC/*::]*/: { /* n:"BrtEndAutoSortScope", */ T:-1 },
  	/*::[*/0x01CD/*::]*/: { /* n:"BrtBeginConditionalFormatting", */ T:1 },
  	/*::[*/0x01CE/*::]*/: { /* n:"BrtEndConditionalFormatting", */ T:-1 },
  	/*::[*/0x01CF/*::]*/: { /* n:"BrtBeginCFRule", */ T:1 },
  	/*::[*/0x01D0/*::]*/: { /* n:"BrtEndCFRule", */ T:-1 },
  	/*::[*/0x01D1/*::]*/: { /* n:"BrtBeginIconSet", */ T:1 },
  	/*::[*/0x01D2/*::]*/: { /* n:"BrtEndIconSet", */ T:-1 },
  	/*::[*/0x01D3/*::]*/: { /* n:"BrtBeginDatabar", */ T:1 },
  	/*::[*/0x01D4/*::]*/: { /* n:"BrtEndDatabar", */ T:-1 },
  	/*::[*/0x01D5/*::]*/: { /* n:"BrtBeginColorScale", */ T:1 },
  	/*::[*/0x01D6/*::]*/: { /* n:"BrtEndColorScale", */ T:-1 },
  	/*::[*/0x01D7/*::]*/: { /* n:"BrtCFVO" */ },
  	/*::[*/0x01D8/*::]*/: { /* n:"BrtExternValueMeta" */ },
  	/*::[*/0x01D9/*::]*/: { /* n:"BrtBeginColorPalette", */ T:1 },
  	/*::[*/0x01DA/*::]*/: { /* n:"BrtEndColorPalette", */ T:-1 },
  	/*::[*/0x01DB/*::]*/: { /* n:"BrtIndexedColor" */ },
  	/*::[*/0x01DC/*::]*/: { /* n:"BrtMargins", */ f:parse_BrtMargins },
  	/*::[*/0x01DD/*::]*/: { /* n:"BrtPrintOptions" */ },
  	/*::[*/0x01DE/*::]*/: { /* n:"BrtPageSetup" */ },
  	/*::[*/0x01DF/*::]*/: { /* n:"BrtBeginHeaderFooter", */ T:1 },
  	/*::[*/0x01E0/*::]*/: { /* n:"BrtEndHeaderFooter", */ T:-1 },
  	/*::[*/0x01E1/*::]*/: { /* n:"BrtBeginSXCrtFormat", */ T:1 },
  	/*::[*/0x01E2/*::]*/: { /* n:"BrtEndSXCrtFormat", */ T:-1 },
  	/*::[*/0x01E3/*::]*/: { /* n:"BrtBeginSXCrtFormats", */ T:1 },
  	/*::[*/0x01E4/*::]*/: { /* n:"BrtEndSXCrtFormats", */ T:-1 },
  	/*::[*/0x01E5/*::]*/: { /* n:"BrtWsFmtInfo", */ f:parse_BrtWsFmtInfo },
  	/*::[*/0x01E6/*::]*/: { /* n:"BrtBeginMgs", */ T:1 },
  	/*::[*/0x01E7/*::]*/: { /* n:"BrtEndMGs", */ T:-1 },
  	/*::[*/0x01E8/*::]*/: { /* n:"BrtBeginMGMaps", */ T:1 },
  	/*::[*/0x01E9/*::]*/: { /* n:"BrtEndMGMaps", */ T:-1 },
  	/*::[*/0x01EA/*::]*/: { /* n:"BrtBeginMG", */ T:1 },
  	/*::[*/0x01EB/*::]*/: { /* n:"BrtEndMG", */ T:-1 },
  	/*::[*/0x01EC/*::]*/: { /* n:"BrtBeginMap", */ T:1 },
  	/*::[*/0x01ED/*::]*/: { /* n:"BrtEndMap", */ T:-1 },
  	/*::[*/0x01EE/*::]*/: { /* n:"BrtHLink", */ f:parse_BrtHLink },
  	/*::[*/0x01EF/*::]*/: { /* n:"BrtBeginDCon", */ T:1 },
  	/*::[*/0x01F0/*::]*/: { /* n:"BrtEndDCon", */ T:-1 },
  	/*::[*/0x01F1/*::]*/: { /* n:"BrtBeginDRefs", */ T:1 },
  	/*::[*/0x01F2/*::]*/: { /* n:"BrtEndDRefs", */ T:-1 },
  	/*::[*/0x01F3/*::]*/: { /* n:"BrtDRef" */ },
  	/*::[*/0x01F4/*::]*/: { /* n:"BrtBeginScenMan", */ T:1 },
  	/*::[*/0x01F5/*::]*/: { /* n:"BrtEndScenMan", */ T:-1 },
  	/*::[*/0x01F6/*::]*/: { /* n:"BrtBeginSct", */ T:1 },
  	/*::[*/0x01F7/*::]*/: { /* n:"BrtEndSct", */ T:-1 },
  	/*::[*/0x01F8/*::]*/: { /* n:"BrtSlc" */ },
  	/*::[*/0x01F9/*::]*/: { /* n:"BrtBeginDXFs", */ T:1 },
  	/*::[*/0x01FA/*::]*/: { /* n:"BrtEndDXFs", */ T:-1 },
  	/*::[*/0x01FB/*::]*/: { /* n:"BrtDXF" */ },
  	/*::[*/0x01FC/*::]*/: { /* n:"BrtBeginTableStyles", */ T:1 },
  	/*::[*/0x01FD/*::]*/: { /* n:"BrtEndTableStyles", */ T:-1 },
  	/*::[*/0x01FE/*::]*/: { /* n:"BrtBeginTableStyle", */ T:1 },
  	/*::[*/0x01FF/*::]*/: { /* n:"BrtEndTableStyle", */ T:-1 },
  	/*::[*/0x0200/*::]*/: { /* n:"BrtTableStyleElement" */ },
  	/*::[*/0x0201/*::]*/: { /* n:"BrtTableStyleClient" */ },
  	/*::[*/0x0202/*::]*/: { /* n:"BrtBeginVolDeps", */ T:1 },
  	/*::[*/0x0203/*::]*/: { /* n:"BrtEndVolDeps", */ T:-1 },
  	/*::[*/0x0204/*::]*/: { /* n:"BrtBeginVolType", */ T:1 },
  	/*::[*/0x0205/*::]*/: { /* n:"BrtEndVolType", */ T:-1 },
  	/*::[*/0x0206/*::]*/: { /* n:"BrtBeginVolMain", */ T:1 },
  	/*::[*/0x0207/*::]*/: { /* n:"BrtEndVolMain", */ T:-1 },
  	/*::[*/0x0208/*::]*/: { /* n:"BrtBeginVolTopic", */ T:1 },
  	/*::[*/0x0209/*::]*/: { /* n:"BrtEndVolTopic", */ T:-1 },
  	/*::[*/0x020A/*::]*/: { /* n:"BrtVolSubtopic" */ },
  	/*::[*/0x020B/*::]*/: { /* n:"BrtVolRef" */ },
  	/*::[*/0x020C/*::]*/: { /* n:"BrtVolNum" */ },
  	/*::[*/0x020D/*::]*/: { /* n:"BrtVolErr" */ },
  	/*::[*/0x020E/*::]*/: { /* n:"BrtVolStr" */ },
  	/*::[*/0x020F/*::]*/: { /* n:"BrtVolBool" */ },
  	/*::[*/0x0210/*::]*/: { /* n:"BrtBeginCalcChain$", */ T:1 },
  	/*::[*/0x0211/*::]*/: { /* n:"BrtEndCalcChain$", */ T:-1 },
  	/*::[*/0x0212/*::]*/: { /* n:"BrtBeginSortState", */ T:1 },
  	/*::[*/0x0213/*::]*/: { /* n:"BrtEndSortState", */ T:-1 },
  	/*::[*/0x0214/*::]*/: { /* n:"BrtBeginSortCond", */ T:1 },
  	/*::[*/0x0215/*::]*/: { /* n:"BrtEndSortCond", */ T:-1 },
  	/*::[*/0x0216/*::]*/: { /* n:"BrtBookProtection" */ },
  	/*::[*/0x0217/*::]*/: { /* n:"BrtSheetProtection" */ },
  	/*::[*/0x0218/*::]*/: { /* n:"BrtRangeProtection" */ },
  	/*::[*/0x0219/*::]*/: { /* n:"BrtPhoneticInfo" */ },
  	/*::[*/0x021A/*::]*/: { /* n:"BrtBeginECTxtWiz", */ T:1 },
  	/*::[*/0x021B/*::]*/: { /* n:"BrtEndECTxtWiz", */ T:-1 },
  	/*::[*/0x021C/*::]*/: { /* n:"BrtBeginECTWFldInfoLst", */ T:1 },
  	/*::[*/0x021D/*::]*/: { /* n:"BrtEndECTWFldInfoLst", */ T:-1 },
  	/*::[*/0x021E/*::]*/: { /* n:"BrtBeginECTwFldInfo", */ T:1 },
  	/*::[*/0x0224/*::]*/: { /* n:"BrtFileSharing" */ },
  	/*::[*/0x0225/*::]*/: { /* n:"BrtOleSize" */ },
  	/*::[*/0x0226/*::]*/: { /* n:"BrtDrawing", */ f:parse_RelID },
  	/*::[*/0x0227/*::]*/: { /* n:"BrtLegacyDrawing" */ },
  	/*::[*/0x0228/*::]*/: { /* n:"BrtLegacyDrawingHF" */ },
  	/*::[*/0x0229/*::]*/: { /* n:"BrtWebOpt" */ },
  	/*::[*/0x022A/*::]*/: { /* n:"BrtBeginWebPubItems", */ T:1 },
  	/*::[*/0x022B/*::]*/: { /* n:"BrtEndWebPubItems", */ T:-1 },
  	/*::[*/0x022C/*::]*/: { /* n:"BrtBeginWebPubItem", */ T:1 },
  	/*::[*/0x022D/*::]*/: { /* n:"BrtEndWebPubItem", */ T:-1 },
  	/*::[*/0x022E/*::]*/: { /* n:"BrtBeginSXCondFmt", */ T:1 },
  	/*::[*/0x022F/*::]*/: { /* n:"BrtEndSXCondFmt", */ T:-1 },
  	/*::[*/0x0230/*::]*/: { /* n:"BrtBeginSXCondFmts", */ T:1 },
  	/*::[*/0x0231/*::]*/: { /* n:"BrtEndSXCondFmts", */ T:-1 },
  	/*::[*/0x0232/*::]*/: { /* n:"BrtBkHim" */ },
  	/*::[*/0x0234/*::]*/: { /* n:"BrtColor" */ },
  	/*::[*/0x0235/*::]*/: { /* n:"BrtBeginIndexedColors", */ T:1 },
  	/*::[*/0x0236/*::]*/: { /* n:"BrtEndIndexedColors", */ T:-1 },
  	/*::[*/0x0239/*::]*/: { /* n:"BrtBeginMRUColors", */ T:1 },
  	/*::[*/0x023A/*::]*/: { /* n:"BrtEndMRUColors", */ T:-1 },
  	/*::[*/0x023C/*::]*/: { /* n:"BrtMRUColor" */ },
  	/*::[*/0x023D/*::]*/: { /* n:"BrtBeginDVals", */ T:1 },
  	/*::[*/0x023E/*::]*/: { /* n:"BrtEndDVals", */ T:-1 },
  	/*::[*/0x0241/*::]*/: { /* n:"BrtSupNameStart" */ },
  	/*::[*/0x0242/*::]*/: { /* n:"BrtSupNameValueStart" */ },
  	/*::[*/0x0243/*::]*/: { /* n:"BrtSupNameValueEnd" */ },
  	/*::[*/0x0244/*::]*/: { /* n:"BrtSupNameNum" */ },
  	/*::[*/0x0245/*::]*/: { /* n:"BrtSupNameErr" */ },
  	/*::[*/0x0246/*::]*/: { /* n:"BrtSupNameSt" */ },
  	/*::[*/0x0247/*::]*/: { /* n:"BrtSupNameNil" */ },
  	/*::[*/0x0248/*::]*/: { /* n:"BrtSupNameBool" */ },
  	/*::[*/0x0249/*::]*/: { /* n:"BrtSupNameFmla" */ },
  	/*::[*/0x024A/*::]*/: { /* n:"BrtSupNameBits" */ },
  	/*::[*/0x024B/*::]*/: { /* n:"BrtSupNameEnd" */ },
  	/*::[*/0x024C/*::]*/: { /* n:"BrtEndSupBook", */ T:-1 },
  	/*::[*/0x024D/*::]*/: { /* n:"BrtCellSmartTagProperty" */ },
  	/*::[*/0x024E/*::]*/: { /* n:"BrtBeginCellSmartTag", */ T:1 },
  	/*::[*/0x024F/*::]*/: { /* n:"BrtEndCellSmartTag", */ T:-1 },
  	/*::[*/0x0250/*::]*/: { /* n:"BrtBeginCellSmartTags", */ T:1 },
  	/*::[*/0x0251/*::]*/: { /* n:"BrtEndCellSmartTags", */ T:-1 },
  	/*::[*/0x0252/*::]*/: { /* n:"BrtBeginSmartTags", */ T:1 },
  	/*::[*/0x0253/*::]*/: { /* n:"BrtEndSmartTags", */ T:-1 },
  	/*::[*/0x0254/*::]*/: { /* n:"BrtSmartTagType" */ },
  	/*::[*/0x0255/*::]*/: { /* n:"BrtBeginSmartTagTypes", */ T:1 },
  	/*::[*/0x0256/*::]*/: { /* n:"BrtEndSmartTagTypes", */ T:-1 },
  	/*::[*/0x0257/*::]*/: { /* n:"BrtBeginSXFilters", */ T:1 },
  	/*::[*/0x0258/*::]*/: { /* n:"BrtEndSXFilters", */ T:-1 },
  	/*::[*/0x0259/*::]*/: { /* n:"BrtBeginSXFILTER", */ T:1 },
  	/*::[*/0x025A/*::]*/: { /* n:"BrtEndSXFilter", */ T:-1 },
  	/*::[*/0x025B/*::]*/: { /* n:"BrtBeginFills", */ T:1 },
  	/*::[*/0x025C/*::]*/: { /* n:"BrtEndFills", */ T:-1 },
  	/*::[*/0x025D/*::]*/: { /* n:"BrtBeginCellWatches", */ T:1 },
  	/*::[*/0x025E/*::]*/: { /* n:"BrtEndCellWatches", */ T:-1 },
  	/*::[*/0x025F/*::]*/: { /* n:"BrtCellWatch" */ },
  	/*::[*/0x0260/*::]*/: { /* n:"BrtBeginCRErrs", */ T:1 },
  	/*::[*/0x0261/*::]*/: { /* n:"BrtEndCRErrs", */ T:-1 },
  	/*::[*/0x0262/*::]*/: { /* n:"BrtCrashRecErr" */ },
  	/*::[*/0x0263/*::]*/: { /* n:"BrtBeginFonts", */ T:1 },
  	/*::[*/0x0264/*::]*/: { /* n:"BrtEndFonts", */ T:-1 },
  	/*::[*/0x0265/*::]*/: { /* n:"BrtBeginBorders", */ T:1 },
  	/*::[*/0x0266/*::]*/: { /* n:"BrtEndBorders", */ T:-1 },
  	/*::[*/0x0267/*::]*/: { /* n:"BrtBeginFmts", */ T:1 },
  	/*::[*/0x0268/*::]*/: { /* n:"BrtEndFmts", */ T:-1 },
  	/*::[*/0x0269/*::]*/: { /* n:"BrtBeginCellXFs", */ T:1 },
  	/*::[*/0x026A/*::]*/: { /* n:"BrtEndCellXFs", */ T:-1 },
  	/*::[*/0x026B/*::]*/: { /* n:"BrtBeginStyles", */ T:1 },
  	/*::[*/0x026C/*::]*/: { /* n:"BrtEndStyles", */ T:-1 },
  	/*::[*/0x0271/*::]*/: { /* n:"BrtBigName" */ },
  	/*::[*/0x0272/*::]*/: { /* n:"BrtBeginCellStyleXFs", */ T:1 },
  	/*::[*/0x0273/*::]*/: { /* n:"BrtEndCellStyleXFs", */ T:-1 },
  	/*::[*/0x0274/*::]*/: { /* n:"BrtBeginComments", */ T:1 },
  	/*::[*/0x0275/*::]*/: { /* n:"BrtEndComments", */ T:-1 },
  	/*::[*/0x0276/*::]*/: { /* n:"BrtBeginCommentAuthors", */ T:1 },
  	/*::[*/0x0277/*::]*/: { /* n:"BrtEndCommentAuthors", */ T:-1 },
  	/*::[*/0x0278/*::]*/: { /* n:"BrtCommentAuthor", */ f:parse_BrtCommentAuthor },
  	/*::[*/0x0279/*::]*/: { /* n:"BrtBeginCommentList", */ T:1 },
  	/*::[*/0x027A/*::]*/: { /* n:"BrtEndCommentList", */ T:-1 },
  	/*::[*/0x027B/*::]*/: { /* n:"BrtBeginComment", */ T:1, f:parse_BrtBeginComment},
  	/*::[*/0x027C/*::]*/: { /* n:"BrtEndComment", */ T:-1 },
  	/*::[*/0x027D/*::]*/: { /* n:"BrtCommentText", */ f:parse_BrtCommentText },
  	/*::[*/0x027E/*::]*/: { /* n:"BrtBeginOleObjects", */ T:1 },
  	/*::[*/0x027F/*::]*/: { /* n:"BrtOleObject" */ },
  	/*::[*/0x0280/*::]*/: { /* n:"BrtEndOleObjects", */ T:-1 },
  	/*::[*/0x0281/*::]*/: { /* n:"BrtBeginSxrules", */ T:1 },
  	/*::[*/0x0282/*::]*/: { /* n:"BrtEndSxRules", */ T:-1 },
  	/*::[*/0x0283/*::]*/: { /* n:"BrtBeginActiveXControls", */ T:1 },
  	/*::[*/0x0284/*::]*/: { /* n:"BrtActiveX" */ },
  	/*::[*/0x0285/*::]*/: { /* n:"BrtEndActiveXControls", */ T:-1 },
  	/*::[*/0x0286/*::]*/: { /* n:"BrtBeginPCDSDTCEMembersSortBy", */ T:1 },
  	/*::[*/0x0288/*::]*/: { /* n:"BrtBeginCellIgnoreECs", */ T:1 },
  	/*::[*/0x0289/*::]*/: { /* n:"BrtCellIgnoreEC" */ },
  	/*::[*/0x028A/*::]*/: { /* n:"BrtEndCellIgnoreECs", */ T:-1 },
  	/*::[*/0x028B/*::]*/: { /* n:"BrtCsProp", */ f:parse_BrtCsProp },
  	/*::[*/0x028C/*::]*/: { /* n:"BrtCsPageSetup" */ },
  	/*::[*/0x028D/*::]*/: { /* n:"BrtBeginUserCsViews", */ T:1 },
  	/*::[*/0x028E/*::]*/: { /* n:"BrtEndUserCsViews", */ T:-1 },
  	/*::[*/0x028F/*::]*/: { /* n:"BrtBeginUserCsView", */ T:1 },
  	/*::[*/0x0290/*::]*/: { /* n:"BrtEndUserCsView", */ T:-1 },
  	/*::[*/0x0291/*::]*/: { /* n:"BrtBeginPcdSFCIEntries", */ T:1 },
  	/*::[*/0x0292/*::]*/: { /* n:"BrtEndPCDSFCIEntries", */ T:-1 },
  	/*::[*/0x0293/*::]*/: { /* n:"BrtPCDSFCIEntry" */ },
  	/*::[*/0x0294/*::]*/: { /* n:"BrtBeginListParts", */ T:1 },
  	/*::[*/0x0295/*::]*/: { /* n:"BrtListPart" */ },
  	/*::[*/0x0296/*::]*/: { /* n:"BrtEndListParts", */ T:-1 },
  	/*::[*/0x0297/*::]*/: { /* n:"BrtSheetCalcProp" */ },
  	/*::[*/0x0298/*::]*/: { /* n:"BrtBeginFnGroup", */ T:1 },
  	/*::[*/0x0299/*::]*/: { /* n:"BrtFnGroup" */ },
  	/*::[*/0x029A/*::]*/: { /* n:"BrtEndFnGroup", */ T:-1 },
  	/*::[*/0x029B/*::]*/: { /* n:"BrtSupAddin" */ },
  	/*::[*/0x029C/*::]*/: { /* n:"BrtSXTDMPOrder" */ },
  	/*::[*/0x029D/*::]*/: { /* n:"BrtCsProtection" */ },
  	/*::[*/0x029F/*::]*/: { /* n:"BrtBeginWsSortMap", */ T:1 },
  	/*::[*/0x02A0/*::]*/: { /* n:"BrtEndWsSortMap", */ T:-1 },
  	/*::[*/0x02A1/*::]*/: { /* n:"BrtBeginRRSort", */ T:1 },
  	/*::[*/0x02A2/*::]*/: { /* n:"BrtEndRRSort", */ T:-1 },
  	/*::[*/0x02A3/*::]*/: { /* n:"BrtRRSortItem" */ },
  	/*::[*/0x02A4/*::]*/: { /* n:"BrtFileSharingIso" */ },
  	/*::[*/0x02A5/*::]*/: { /* n:"BrtBookProtectionIso" */ },
  	/*::[*/0x02A6/*::]*/: { /* n:"BrtSheetProtectionIso" */ },
  	/*::[*/0x02A7/*::]*/: { /* n:"BrtCsProtectionIso" */ },
  	/*::[*/0x02A8/*::]*/: { /* n:"BrtRangeProtectionIso" */ },
  	/*::[*/0x02A9/*::]*/: { /* n:"BrtDValList" */ },
  	/*::[*/0x0400/*::]*/: { /* n:"BrtRwDescent" */ },
  	/*::[*/0x0401/*::]*/: { /* n:"BrtKnownFonts" */ },
  	/*::[*/0x0402/*::]*/: { /* n:"BrtBeginSXTupleSet", */ T:1 },
  	/*::[*/0x0403/*::]*/: { /* n:"BrtEndSXTupleSet", */ T:-1 },
  	/*::[*/0x0404/*::]*/: { /* n:"BrtBeginSXTupleSetHeader", */ T:1 },
  	/*::[*/0x0405/*::]*/: { /* n:"BrtEndSXTupleSetHeader", */ T:-1 },
  	/*::[*/0x0406/*::]*/: { /* n:"BrtSXTupleSetHeaderItem" */ },
  	/*::[*/0x0407/*::]*/: { /* n:"BrtBeginSXTupleSetData", */ T:1 },
  	/*::[*/0x0408/*::]*/: { /* n:"BrtEndSXTupleSetData", */ T:-1 },
  	/*::[*/0x0409/*::]*/: { /* n:"BrtBeginSXTupleSetRow", */ T:1 },
  	/*::[*/0x040A/*::]*/: { /* n:"BrtEndSXTupleSetRow", */ T:-1 },
  	/*::[*/0x040B/*::]*/: { /* n:"BrtSXTupleSetRowItem" */ },
  	/*::[*/0x040C/*::]*/: { /* n:"BrtNameExt" */ },
  	/*::[*/0x040D/*::]*/: { /* n:"BrtPCDH14" */ },
  	/*::[*/0x040E/*::]*/: { /* n:"BrtBeginPCDCalcMem14", */ T:1 },
  	/*::[*/0x040F/*::]*/: { /* n:"BrtEndPCDCalcMem14", */ T:-1 },
  	/*::[*/0x0410/*::]*/: { /* n:"BrtSXTH14" */ },
  	/*::[*/0x0411/*::]*/: { /* n:"BrtBeginSparklineGroup", */ T:1 },
  	/*::[*/0x0412/*::]*/: { /* n:"BrtEndSparklineGroup", */ T:-1 },
  	/*::[*/0x0413/*::]*/: { /* n:"BrtSparkline" */ },
  	/*::[*/0x0414/*::]*/: { /* n:"BrtSXDI14" */ },
  	/*::[*/0x0415/*::]*/: { /* n:"BrtWsFmtInfoEx14" */ },
  	/*::[*/0x0416/*::]*/: { /* n:"BrtBeginConditionalFormatting14", */ T:1 },
  	/*::[*/0x0417/*::]*/: { /* n:"BrtEndConditionalFormatting14", */ T:-1 },
  	/*::[*/0x0418/*::]*/: { /* n:"BrtBeginCFRule14", */ T:1 },
  	/*::[*/0x0419/*::]*/: { /* n:"BrtEndCFRule14", */ T:-1 },
  	/*::[*/0x041A/*::]*/: { /* n:"BrtCFVO14" */ },
  	/*::[*/0x041B/*::]*/: { /* n:"BrtBeginDatabar14", */ T:1 },
  	/*::[*/0x041C/*::]*/: { /* n:"BrtBeginIconSet14", */ T:1 },
  	/*::[*/0x041D/*::]*/: { /* n:"BrtDVal14", */ f: parse_BrtDVal14 },
  	/*::[*/0x041E/*::]*/: { /* n:"BrtBeginDVals14", */ T:1 },
  	/*::[*/0x041F/*::]*/: { /* n:"BrtColor14" */ },
  	/*::[*/0x0420/*::]*/: { /* n:"BrtBeginSparklines", */ T:1 },
  	/*::[*/0x0421/*::]*/: { /* n:"BrtEndSparklines", */ T:-1 },
  	/*::[*/0x0422/*::]*/: { /* n:"BrtBeginSparklineGroups", */ T:1 },
  	/*::[*/0x0423/*::]*/: { /* n:"BrtEndSparklineGroups", */ T:-1 },
  	/*::[*/0x0425/*::]*/: { /* n:"BrtSXVD14" */ },
  	/*::[*/0x0426/*::]*/: { /* n:"BrtBeginSXView14", */ T:1 },
  	/*::[*/0x0427/*::]*/: { /* n:"BrtEndSXView14", */ T:-1 },
  	/*::[*/0x0428/*::]*/: { /* n:"BrtBeginSXView16", */ T:1 },
  	/*::[*/0x0429/*::]*/: { /* n:"BrtEndSXView16", */ T:-1 },
  	/*::[*/0x042A/*::]*/: { /* n:"BrtBeginPCD14", */ T:1 },
  	/*::[*/0x042B/*::]*/: { /* n:"BrtEndPCD14", */ T:-1 },
  	/*::[*/0x042C/*::]*/: { /* n:"BrtBeginExtConn14", */ T:1 },
  	/*::[*/0x042D/*::]*/: { /* n:"BrtEndExtConn14", */ T:-1 },
  	/*::[*/0x042E/*::]*/: { /* n:"BrtBeginSlicerCacheIDs", */ T:1 },
  	/*::[*/0x042F/*::]*/: { /* n:"BrtEndSlicerCacheIDs", */ T:-1 },
  	/*::[*/0x0430/*::]*/: { /* n:"BrtBeginSlicerCacheID", */ T:1 },
  	/*::[*/0x0431/*::]*/: { /* n:"BrtEndSlicerCacheID", */ T:-1 },
  	/*::[*/0x0433/*::]*/: { /* n:"BrtBeginSlicerCache", */ T:1 },
  	/*::[*/0x0434/*::]*/: { /* n:"BrtEndSlicerCache", */ T:-1 },
  	/*::[*/0x0435/*::]*/: { /* n:"BrtBeginSlicerCacheDef", */ T:1 },
  	/*::[*/0x0436/*::]*/: { /* n:"BrtEndSlicerCacheDef", */ T:-1 },
  	/*::[*/0x0437/*::]*/: { /* n:"BrtBeginSlicersEx", */ T:1 },
  	/*::[*/0x0438/*::]*/: { /* n:"BrtEndSlicersEx", */ T:-1 },
  	/*::[*/0x0439/*::]*/: { /* n:"BrtBeginSlicerEx", */ T:1 },
  	/*::[*/0x043A/*::]*/: { /* n:"BrtEndSlicerEx", */ T:-1 },
  	/*::[*/0x043B/*::]*/: { /* n:"BrtBeginSlicer", */ T:1 },
  	/*::[*/0x043C/*::]*/: { /* n:"BrtEndSlicer", */ T:-1 },
  	/*::[*/0x043D/*::]*/: { /* n:"BrtSlicerCachePivotTables" */ },
  	/*::[*/0x043E/*::]*/: { /* n:"BrtBeginSlicerCacheOlapImpl", */ T:1 },
  	/*::[*/0x043F/*::]*/: { /* n:"BrtEndSlicerCacheOlapImpl", */ T:-1 },
  	/*::[*/0x0440/*::]*/: { /* n:"BrtBeginSlicerCacheLevelsData", */ T:1 },
  	/*::[*/0x0441/*::]*/: { /* n:"BrtEndSlicerCacheLevelsData", */ T:-1 },
  	/*::[*/0x0442/*::]*/: { /* n:"BrtBeginSlicerCacheLevelData", */ T:1 },
  	/*::[*/0x0443/*::]*/: { /* n:"BrtEndSlicerCacheLevelData", */ T:-1 },
  	/*::[*/0x0444/*::]*/: { /* n:"BrtBeginSlicerCacheSiRanges", */ T:1 },
  	/*::[*/0x0445/*::]*/: { /* n:"BrtEndSlicerCacheSiRanges", */ T:-1 },
  	/*::[*/0x0446/*::]*/: { /* n:"BrtBeginSlicerCacheSiRange", */ T:1 },
  	/*::[*/0x0447/*::]*/: { /* n:"BrtEndSlicerCacheSiRange", */ T:-1 },
  	/*::[*/0x0448/*::]*/: { /* n:"BrtSlicerCacheOlapItem" */ },
  	/*::[*/0x0449/*::]*/: { /* n:"BrtBeginSlicerCacheSelections", */ T:1 },
  	/*::[*/0x044A/*::]*/: { /* n:"BrtSlicerCacheSelection" */ },
  	/*::[*/0x044B/*::]*/: { /* n:"BrtEndSlicerCacheSelections", */ T:-1 },
  	/*::[*/0x044C/*::]*/: { /* n:"BrtBeginSlicerCacheNative", */ T:1 },
  	/*::[*/0x044D/*::]*/: { /* n:"BrtEndSlicerCacheNative", */ T:-1 },
  	/*::[*/0x044E/*::]*/: { /* n:"BrtSlicerCacheNativeItem" */ },
  	/*::[*/0x044F/*::]*/: { /* n:"BrtRangeProtection14" */ },
  	/*::[*/0x0450/*::]*/: { /* n:"BrtRangeProtectionIso14" */ },
  	/*::[*/0x0451/*::]*/: { /* n:"BrtCellIgnoreEC14" */ },
  	/*::[*/0x0457/*::]*/: { /* n:"BrtList14" */ },
  	/*::[*/0x0458/*::]*/: { /* n:"BrtCFIcon" */ },
  	/*::[*/0x0459/*::]*/: { /* n:"BrtBeginSlicerCachesPivotCacheIDs", */ T:1 },
  	/*::[*/0x045A/*::]*/: { /* n:"BrtEndSlicerCachesPivotCacheIDs", */ T:-1 },
  	/*::[*/0x045B/*::]*/: { /* n:"BrtBeginSlicers", */ T:1 },
  	/*::[*/0x045C/*::]*/: { /* n:"BrtEndSlicers", */ T:-1 },
  	/*::[*/0x045D/*::]*/: { /* n:"BrtWbProp14" */ },
  	/*::[*/0x045E/*::]*/: { /* n:"BrtBeginSXEdit", */ T:1 },
  	/*::[*/0x045F/*::]*/: { /* n:"BrtEndSXEdit", */ T:-1 },
  	/*::[*/0x0460/*::]*/: { /* n:"BrtBeginSXEdits", */ T:1 },
  	/*::[*/0x0461/*::]*/: { /* n:"BrtEndSXEdits", */ T:-1 },
  	/*::[*/0x0462/*::]*/: { /* n:"BrtBeginSXChange", */ T:1 },
  	/*::[*/0x0463/*::]*/: { /* n:"BrtEndSXChange", */ T:-1 },
  	/*::[*/0x0464/*::]*/: { /* n:"BrtBeginSXChanges", */ T:1 },
  	/*::[*/0x0465/*::]*/: { /* n:"BrtEndSXChanges", */ T:-1 },
  	/*::[*/0x0466/*::]*/: { /* n:"BrtSXTupleItems" */ },
  	/*::[*/0x0468/*::]*/: { /* n:"BrtBeginSlicerStyle", */ T:1 },
  	/*::[*/0x0469/*::]*/: { /* n:"BrtEndSlicerStyle", */ T:-1 },
  	/*::[*/0x046A/*::]*/: { /* n:"BrtSlicerStyleElement" */ },
  	/*::[*/0x046B/*::]*/: { /* n:"BrtBeginStyleSheetExt14", */ T:1 },
  	/*::[*/0x046C/*::]*/: { /* n:"BrtEndStyleSheetExt14", */ T:-1 },
  	/*::[*/0x046D/*::]*/: { /* n:"BrtBeginSlicerCachesPivotCacheID", */ T:1 },
  	/*::[*/0x046E/*::]*/: { /* n:"BrtEndSlicerCachesPivotCacheID", */ T:-1 },
  	/*::[*/0x046F/*::]*/: { /* n:"BrtBeginConditionalFormattings", */ T:1 },
  	/*::[*/0x0470/*::]*/: { /* n:"BrtEndConditionalFormattings", */ T:-1 },
  	/*::[*/0x0471/*::]*/: { /* n:"BrtBeginPCDCalcMemExt", */ T:1 },
  	/*::[*/0x0472/*::]*/: { /* n:"BrtEndPCDCalcMemExt", */ T:-1 },
  	/*::[*/0x0473/*::]*/: { /* n:"BrtBeginPCDCalcMemsExt", */ T:1 },
  	/*::[*/0x0474/*::]*/: { /* n:"BrtEndPCDCalcMemsExt", */ T:-1 },
  	/*::[*/0x0475/*::]*/: { /* n:"BrtPCDField14" */ },
  	/*::[*/0x0476/*::]*/: { /* n:"BrtBeginSlicerStyles", */ T:1 },
  	/*::[*/0x0477/*::]*/: { /* n:"BrtEndSlicerStyles", */ T:-1 },
  	/*::[*/0x0478/*::]*/: { /* n:"BrtBeginSlicerStyleElements", */ T:1 },
  	/*::[*/0x0479/*::]*/: { /* n:"BrtEndSlicerStyleElements", */ T:-1 },
  	/*::[*/0x047A/*::]*/: { /* n:"BrtCFRuleExt" */ },
  	/*::[*/0x047B/*::]*/: { /* n:"BrtBeginSXCondFmt14", */ T:1 },
  	/*::[*/0x047C/*::]*/: { /* n:"BrtEndSXCondFmt14", */ T:-1 },
  	/*::[*/0x047D/*::]*/: { /* n:"BrtBeginSXCondFmts14", */ T:1 },
  	/*::[*/0x047E/*::]*/: { /* n:"BrtEndSXCondFmts14", */ T:-1 },
  	/*::[*/0x0480/*::]*/: { /* n:"BrtBeginSortCond14", */ T:1 },
  	/*::[*/0x0481/*::]*/: { /* n:"BrtEndSortCond14", */ T:-1 },
  	/*::[*/0x0482/*::]*/: { /* n:"BrtEndDVals14", */ T:-1 },
  	/*::[*/0x0483/*::]*/: { /* n:"BrtEndIconSet14", */ T:-1 },
  	/*::[*/0x0484/*::]*/: { /* n:"BrtEndDatabar14", */ T:-1 },
  	/*::[*/0x0485/*::]*/: { /* n:"BrtBeginColorScale14", */ T:1 },
  	/*::[*/0x0486/*::]*/: { /* n:"BrtEndColorScale14", */ T:-1 },
  	/*::[*/0x0487/*::]*/: { /* n:"BrtBeginSxrules14", */ T:1 },
  	/*::[*/0x0488/*::]*/: { /* n:"BrtEndSxrules14", */ T:-1 },
  	/*::[*/0x0489/*::]*/: { /* n:"BrtBeginPRule14", */ T:1 },
  	/*::[*/0x048A/*::]*/: { /* n:"BrtEndPRule14", */ T:-1 },
  	/*::[*/0x048B/*::]*/: { /* n:"BrtBeginPRFilters14", */ T:1 },
  	/*::[*/0x048C/*::]*/: { /* n:"BrtEndPRFilters14", */ T:-1 },
  	/*::[*/0x048D/*::]*/: { /* n:"BrtBeginPRFilter14", */ T:1 },
  	/*::[*/0x048E/*::]*/: { /* n:"BrtEndPRFilter14", */ T:-1 },
  	/*::[*/0x048F/*::]*/: { /* n:"BrtBeginPRFItem14", */ T:1 },
  	/*::[*/0x0490/*::]*/: { /* n:"BrtEndPRFItem14", */ T:-1 },
  	/*::[*/0x0491/*::]*/: { /* n:"BrtBeginCellIgnoreECs14", */ T:1 },
  	/*::[*/0x0492/*::]*/: { /* n:"BrtEndCellIgnoreECs14", */ T:-1 },
  	/*::[*/0x0493/*::]*/: { /* n:"BrtDxf14" */ },
  	/*::[*/0x0494/*::]*/: { /* n:"BrtBeginDxF14s", */ T:1 },
  	/*::[*/0x0495/*::]*/: { /* n:"BrtEndDxf14s", */ T:-1 },
  	/*::[*/0x0499/*::]*/: { /* n:"BrtFilter14" */ },
  	/*::[*/0x049A/*::]*/: { /* n:"BrtBeginCustomFilters14", */ T:1 },
  	/*::[*/0x049C/*::]*/: { /* n:"BrtCustomFilter14" */ },
  	/*::[*/0x049D/*::]*/: { /* n:"BrtIconFilter14" */ },
  	/*::[*/0x049E/*::]*/: { /* n:"BrtPivotCacheConnectionName" */ },
  	/*::[*/0x0800/*::]*/: { /* n:"BrtBeginDecoupledPivotCacheIDs", */ T:1 },
  	/*::[*/0x0801/*::]*/: { /* n:"BrtEndDecoupledPivotCacheIDs", */ T:-1 },
  	/*::[*/0x0802/*::]*/: { /* n:"BrtDecoupledPivotCacheID" */ },
  	/*::[*/0x0803/*::]*/: { /* n:"BrtBeginPivotTableRefs", */ T:1 },
  	/*::[*/0x0804/*::]*/: { /* n:"BrtEndPivotTableRefs", */ T:-1 },
  	/*::[*/0x0805/*::]*/: { /* n:"BrtPivotTableRef" */ },
  	/*::[*/0x0806/*::]*/: { /* n:"BrtSlicerCacheBookPivotTables" */ },
  	/*::[*/0x0807/*::]*/: { /* n:"BrtBeginSxvcells", */ T:1 },
  	/*::[*/0x0808/*::]*/: { /* n:"BrtEndSxvcells", */ T:-1 },
  	/*::[*/0x0809/*::]*/: { /* n:"BrtBeginSxRow", */ T:1 },
  	/*::[*/0x080A/*::]*/: { /* n:"BrtEndSxRow", */ T:-1 },
  	/*::[*/0x080C/*::]*/: { /* n:"BrtPcdCalcMem15" */ },
  	/*::[*/0x0813/*::]*/: { /* n:"BrtQsi15" */ },
  	/*::[*/0x0814/*::]*/: { /* n:"BrtBeginWebExtensions", */ T:1 },
  	/*::[*/0x0815/*::]*/: { /* n:"BrtEndWebExtensions", */ T:-1 },
  	/*::[*/0x0816/*::]*/: { /* n:"BrtWebExtension" */ },
  	/*::[*/0x0817/*::]*/: { /* n:"BrtAbsPath15" */ },
  	/*::[*/0x0818/*::]*/: { /* n:"BrtBeginPivotTableUISettings", */ T:1 },
  	/*::[*/0x0819/*::]*/: { /* n:"BrtEndPivotTableUISettings", */ T:-1 },
  	/*::[*/0x081B/*::]*/: { /* n:"BrtTableSlicerCacheIDs" */ },
  	/*::[*/0x081C/*::]*/: { /* n:"BrtTableSlicerCacheID" */ },
  	/*::[*/0x081D/*::]*/: { /* n:"BrtBeginTableSlicerCache", */ T:1 },
  	/*::[*/0x081E/*::]*/: { /* n:"BrtEndTableSlicerCache", */ T:-1 },
  	/*::[*/0x081F/*::]*/: { /* n:"BrtSxFilter15" */ },
  	/*::[*/0x0820/*::]*/: { /* n:"BrtBeginTimelineCachePivotCacheIDs", */ T:1 },
  	/*::[*/0x0821/*::]*/: { /* n:"BrtEndTimelineCachePivotCacheIDs", */ T:-1 },
  	/*::[*/0x0822/*::]*/: { /* n:"BrtTimelineCachePivotCacheID" */ },
  	/*::[*/0x0823/*::]*/: { /* n:"BrtBeginTimelineCacheIDs", */ T:1 },
  	/*::[*/0x0824/*::]*/: { /* n:"BrtEndTimelineCacheIDs", */ T:-1 },
  	/*::[*/0x0825/*::]*/: { /* n:"BrtBeginTimelineCacheID", */ T:1 },
  	/*::[*/0x0826/*::]*/: { /* n:"BrtEndTimelineCacheID", */ T:-1 },
  	/*::[*/0x0827/*::]*/: { /* n:"BrtBeginTimelinesEx", */ T:1 },
  	/*::[*/0x0828/*::]*/: { /* n:"BrtEndTimelinesEx", */ T:-1 },
  	/*::[*/0x0829/*::]*/: { /* n:"BrtBeginTimelineEx", */ T:1 },
  	/*::[*/0x082A/*::]*/: { /* n:"BrtEndTimelineEx", */ T:-1 },
  	/*::[*/0x082B/*::]*/: { /* n:"BrtWorkBookPr15" */ },
  	/*::[*/0x082C/*::]*/: { /* n:"BrtPCDH15" */ },
  	/*::[*/0x082D/*::]*/: { /* n:"BrtBeginTimelineStyle", */ T:1 },
  	/*::[*/0x082E/*::]*/: { /* n:"BrtEndTimelineStyle", */ T:-1 },
  	/*::[*/0x082F/*::]*/: { /* n:"BrtTimelineStyleElement" */ },
  	/*::[*/0x0830/*::]*/: { /* n:"BrtBeginTimelineStylesheetExt15", */ T:1 },
  	/*::[*/0x0831/*::]*/: { /* n:"BrtEndTimelineStylesheetExt15", */ T:-1 },
  	/*::[*/0x0832/*::]*/: { /* n:"BrtBeginTimelineStyles", */ T:1 },
  	/*::[*/0x0833/*::]*/: { /* n:"BrtEndTimelineStyles", */ T:-1 },
  	/*::[*/0x0834/*::]*/: { /* n:"BrtBeginTimelineStyleElements", */ T:1 },
  	/*::[*/0x0835/*::]*/: { /* n:"BrtEndTimelineStyleElements", */ T:-1 },
  	/*::[*/0x0836/*::]*/: { /* n:"BrtDxf15" */ },
  	/*::[*/0x0837/*::]*/: { /* n:"BrtBeginDxfs15", */ T:1 },
  	/*::[*/0x0838/*::]*/: { /* n:"BrtEndDxfs15", */ T:-1 },
  	/*::[*/0x0839/*::]*/: { /* n:"BrtSlicerCacheHideItemsWithNoData" */ },
  	/*::[*/0x083A/*::]*/: { /* n:"BrtBeginItemUniqueNames", */ T:1 },
  	/*::[*/0x083B/*::]*/: { /* n:"BrtEndItemUniqueNames", */ T:-1 },
  	/*::[*/0x083C/*::]*/: { /* n:"BrtItemUniqueName" */ },
  	/*::[*/0x083D/*::]*/: { /* n:"BrtBeginExtConn15", */ T:1 },
  	/*::[*/0x083E/*::]*/: { /* n:"BrtEndExtConn15", */ T:-1 },
  	/*::[*/0x083F/*::]*/: { /* n:"BrtBeginOledbPr15", */ T:1 },
  	/*::[*/0x0840/*::]*/: { /* n:"BrtEndOledbPr15", */ T:-1 },
  	/*::[*/0x0841/*::]*/: { /* n:"BrtBeginDataFeedPr15", */ T:1 },
  	/*::[*/0x0842/*::]*/: { /* n:"BrtEndDataFeedPr15", */ T:-1 },
  	/*::[*/0x0843/*::]*/: { /* n:"BrtTextPr15" */ },
  	/*::[*/0x0844/*::]*/: { /* n:"BrtRangePr15" */ },
  	/*::[*/0x0845/*::]*/: { /* n:"BrtDbCommand15" */ },
  	/*::[*/0x0846/*::]*/: { /* n:"BrtBeginDbTables15", */ T:1 },
  	/*::[*/0x0847/*::]*/: { /* n:"BrtEndDbTables15", */ T:-1 },
  	/*::[*/0x0848/*::]*/: { /* n:"BrtDbTable15" */ },
  	/*::[*/0x0849/*::]*/: { /* n:"BrtBeginDataModel", */ T:1 },
  	/*::[*/0x084A/*::]*/: { /* n:"BrtEndDataModel", */ T:-1 },
  	/*::[*/0x084B/*::]*/: { /* n:"BrtBeginModelTables", */ T:1 },
  	/*::[*/0x084C/*::]*/: { /* n:"BrtEndModelTables", */ T:-1 },
  	/*::[*/0x084D/*::]*/: { /* n:"BrtModelTable" */ },
  	/*::[*/0x084E/*::]*/: { /* n:"BrtBeginModelRelationships", */ T:1 },
  	/*::[*/0x084F/*::]*/: { /* n:"BrtEndModelRelationships", */ T:-1 },
  	/*::[*/0x0850/*::]*/: { /* n:"BrtModelRelationship" */ },
  	/*::[*/0x0851/*::]*/: { /* n:"BrtBeginECTxtWiz15", */ T:1 },
  	/*::[*/0x0852/*::]*/: { /* n:"BrtEndECTxtWiz15", */ T:-1 },
  	/*::[*/0x0853/*::]*/: { /* n:"BrtBeginECTWFldInfoLst15", */ T:1 },
  	/*::[*/0x0854/*::]*/: { /* n:"BrtEndECTWFldInfoLst15", */ T:-1 },
  	/*::[*/0x0855/*::]*/: { /* n:"BrtBeginECTWFldInfo15", */ T:1 },
  	/*::[*/0x0856/*::]*/: { /* n:"BrtFieldListActiveItem" */ },
  	/*::[*/0x0857/*::]*/: { /* n:"BrtPivotCacheIdVersion" */ },
  	/*::[*/0x0858/*::]*/: { /* n:"BrtSXDI15" */ },
  	/*::[*/0x0859/*::]*/: { /* n:"BrtBeginModelTimeGroupings", */ T:1 },
  	/*::[*/0x085A/*::]*/: { /* n:"BrtEndModelTimeGroupings", */ T:-1 },
  	/*::[*/0x085B/*::]*/: { /* n:"BrtBeginModelTimeGrouping", */ T:1 },
  	/*::[*/0x085C/*::]*/: { /* n:"BrtEndModelTimeGrouping", */ T:-1 },
  	/*::[*/0x085D/*::]*/: { /* n:"BrtModelTimeGroupingCalcCol" */ },
  	/*::[*/0x0C00/*::]*/: { /* n:"BrtUid" */ },
  	/*::[*/0x0C01/*::]*/: { /* n:"BrtRevisionPtr" */ },
  	/*::[*/0x1000/*::]*/: { /* n:"BrtBeginDynamicArrayPr", */ T:1 },
  	/*::[*/0x1001/*::]*/: { /* n:"BrtEndDynamicArrayPr", */ T:-1 },
  	/*::[*/0x138A/*::]*/: { /* n:"BrtBeginRichValueBlock", */ T:1 },
  	/*::[*/0x138B/*::]*/: { /* n:"BrtEndRichValueBlock", */ T:-1 },
  	/*::[*/0x13D9/*::]*/: { /* n:"BrtBeginRichFilters", */ T:1 },
  	/*::[*/0x13DA/*::]*/: { /* n:"BrtEndRichFilters", */ T:-1 },
  	/*::[*/0x13DB/*::]*/: { /* n:"BrtRichFilter" */ },
  	/*::[*/0x13DC/*::]*/: { /* n:"BrtBeginRichFilterColumn", */ T:1 },
  	/*::[*/0x13DD/*::]*/: { /* n:"BrtEndRichFilterColumn", */ T:-1 },
  	/*::[*/0x13DE/*::]*/: { /* n:"BrtBeginCustomRichFilters", */ T:1 },
  	/*::[*/0x13DF/*::]*/: { /* n:"BrtEndCustomRichFilters", */ T:-1 },
  	/*::[*/0x13E0/*::]*/: { /* n:"BrtCustomRichFilter" */ },
  	/*::[*/0x13E1/*::]*/: { /* n:"BrtTop10RichFilter" */ },
  	/*::[*/0x13E2/*::]*/: { /* n:"BrtDynamicRichFilter" */ },
  	/*::[*/0x13E4/*::]*/: { /* n:"BrtBeginRichSortCondition", */ T:1 },
  	/*::[*/0x13E5/*::]*/: { /* n:"BrtEndRichSortCondition", */ T:-1 },
  	/*::[*/0x13E6/*::]*/: { /* n:"BrtRichFilterDateGroupItem" */ },
  	/*::[*/0x13E7/*::]*/: { /* n:"BrtBeginCalcFeatures", */ T:1 },
  	/*::[*/0x13E8/*::]*/: { /* n:"BrtEndCalcFeatures", */ T:-1 },
  	/*::[*/0x13E9/*::]*/: { /* n:"BrtCalcFeature" */ },
  	/*::[*/0x13EB/*::]*/: { /* n:"BrtExternalLinksPr" */ },
  	/*::[*/0xFFFF/*::]*/: { n:"" }
  };

  function write_biff_rec(ba/*:BufArray*/, type/*:number*/, payload, length/*:?number*/)/*:void*/ {
  	var t/*:number*/ = type;
  	if(isNaN(t)) return;
  	var len = length || (payload||[]).length || 0;
  	var o = ba.next(4);
  	o.write_shift(2, t);
  	o.write_shift(2, len);
  	if(/*:: len != null &&*/len > 0 && is_buf(payload)) ba.push(payload);
  }

  function write_biff_continue(ba/*:BufArray*/, type/*:number*/, payload, length/*:?number*/)/*:void*/ {
  	var len = length || (payload||[]).length || 0;
  	if(len <= 8224) return write_biff_rec(ba, type, payload, len);
  	var t = type;
  	if(isNaN(t)) return;
  	var parts = payload.parts || [], sidx = 0;
  	var i = 0, w = 0;
  	while(w + (parts[sidx] || 8224) <= 8224) { w+= (parts[sidx] || 8224); sidx++; }
  	var o = ba.next(4);
  	o.write_shift(2, t);
  	o.write_shift(2, w);
  	ba.push(payload.slice(i, i + w));
  	i += w;
  	while(i < len) {
  		o = ba.next(4);
  		o.write_shift(2, 0x3c); // TODO: figure out correct continue type
  		w = 0;
  		while(w + (parts[sidx] || 8224) <= 8224) { w+= (parts[sidx] || 8224); sidx++; }
  		o.write_shift(2, w);
  		ba.push(payload.slice(i, i+w)); i+= w;
  	}
  }

  function write_BIFF2Cell(out, r/*:number*/, c/*:number*/) {
  	if(!out) out = new_buf(7);
  	out.write_shift(2, r);
  	out.write_shift(2, c);
  	out.write_shift(2, 0);
  	out.write_shift(1, 0);
  	return out;
  }

  function write_BIFF2BERR(r/*:number*/, c/*:number*/, val, t/*:?string*/) {
  	var out = new_buf(9);
  	write_BIFF2Cell(out, r, c);
  	write_Bes(val, t || 'b', out);
  	return out;
  }

  /* TODO: codepage, large strings */
  function write_BIFF2LABEL(r/*:number*/, c/*:number*/, val) {
  	var out = new_buf(8 + 2*val.length);
  	write_BIFF2Cell(out, r, c);
  	out.write_shift(1, val.length);
  	out.write_shift(val.length, val, 'sbcs');
  	return out.l < out.length ? out.slice(0, out.l) : out;
  }

  function write_ws_biff2_cell(ba/*:BufArray*/, cell/*:Cell*/, R/*:number*/, C/*:number*//*::, opts*/) {
  	if(cell.v != null) switch(cell.t) {
  		case 'd': case 'n':
  			var v = cell.t == 'd' ? datenum(parseDate(cell.v)) : cell.v;
  			if((v == (v|0)) && (v >= 0) && (v < 65536))
  				write_biff_rec(ba, 0x0002, write_BIFF2INT(R, C, v));
  			else
  				write_biff_rec(ba, 0x0003, write_BIFF2NUM(R,C, v));
  			return;
  		case 'b': case 'e': write_biff_rec(ba, 0x0005, write_BIFF2BERR(R, C, cell.v, cell.t)); return;
  		/* TODO: codepage, sst */
  		case 's': case 'str':
  			write_biff_rec(ba, 0x0004, write_BIFF2LABEL(R, C, (cell.v||"").slice(0,255)));
  			return;
  	}
  	write_biff_rec(ba, 0x0001, write_BIFF2Cell(null, R, C));
  }

  function write_ws_biff2(ba/*:BufArray*/, ws/*:Worksheet*/, idx/*:number*/, opts/*::, wb:Workbook*/) {
  	var dense = Array.isArray(ws);
  	var range = safe_decode_range(ws['!ref'] || "A1"), ref/*:string*/, rr = "", cols/*:Array<string>*/ = [];
  	if(range.e.c > 0xFF || range.e.r > 0x3FFF) {
  		if(opts.WTF) throw new Error("Range " + (ws['!ref'] || "A1") + " exceeds format limit A1:IV16384");
  		range.e.c = Math.min(range.e.c, 0xFF);
  		range.e.r = Math.min(range.e.c, 0x3FFF);
  		ref = encode_range(range);
  	}
  	for(var R = range.s.r; R <= range.e.r; ++R) {
  		rr = encode_row(R);
  		for(var C = range.s.c; C <= range.e.c; ++C) {
  			if(R === range.s.r) cols[C] = encode_col(C);
  			ref = cols[C] + rr;
  			var cell = dense ? (ws[R]||[])[C] : ws[ref];
  			if(!cell) continue;
  			/* write cell */
  			write_ws_biff2_cell(ba, cell, R, C);
  		}
  	}
  }

  /* Based on test files */
  function write_biff2_buf(wb/*:Workbook*/, opts/*:WriteOpts*/) {
  	var o = opts || {};
  	var ba = buf_array();
  	var idx = 0;
  	for(var i=0;i<wb.SheetNames.length;++i) if(wb.SheetNames[i] == o.sheet) idx=i;
  	if(idx == 0 && !!o.sheet && wb.SheetNames[0] != o.sheet) throw new Error("Sheet not found: " + o.sheet);
  	write_biff_rec(ba, (o.biff == 4 ? 0x0409 : (o.biff == 3 ? 0x0209 : 0x0009)), write_BOF(wb, 0x10, o));
  	/* ... */
  	write_ws_biff2(ba, wb.Sheets[wb.SheetNames[idx]], idx, o);
  	/* ... */
  	write_biff_rec(ba, 0x000A);
  	return ba.end();
  }

  function write_FONTS_biff8(ba, data, opts) {
  	write_biff_rec(ba, 0x0031 /* Font */, write_Font({
  		sz:12,
  		color: {theme:1},
  		name: "Arial",
  		family: 2,
  		scheme: "minor"
  	}, opts));
  }


  function write_FMTS_biff8(ba, NF/*:?SSFTable*/, opts) {
  	if(!NF) return;
  	[[5,8],[23,26],[41,44],[/*63*/50,/*66],[164,*/392]].forEach(function(r) {
  		/*:: if(!NF) return; */
  		for(var i = r[0]; i <= r[1]; ++i) if(NF[i] != null) write_biff_rec(ba, 0x041E /* Format */, write_Format(i, NF[i], opts));
  	});
  }

  function write_FEAT(ba, ws) {
  	/* [MS-XLS] 2.4.112 */
  	var o = new_buf(19);
  	o.write_shift(4, 0x867); o.write_shift(4, 0); o.write_shift(4, 0);
  	o.write_shift(2, 3); o.write_shift(1, 1); o.write_shift(4, 0);
  	write_biff_rec(ba, 0x0867 /* FeatHdr */, o);
  	/* [MS-XLS] 2.4.111 */
  	o = new_buf(39);
  	o.write_shift(4, 0x868); o.write_shift(4, 0); o.write_shift(4, 0);
  	o.write_shift(2, 3); o.write_shift(1, 0); o.write_shift(4, 0);
  	o.write_shift(2, 1); o.write_shift(4, 4); o.write_shift(2, 0);
  	write_Ref8U(safe_decode_range(ws['!ref']||"A1"), o);
  	o.write_shift(4, 4);
  	write_biff_rec(ba, 0x0868 /* Feat */, o);
  }

  function write_CELLXFS_biff8(ba, opts) {
  	for(var i = 0; i < 16; ++i) write_biff_rec(ba, 0x00e0 /* XF */, write_XF({numFmtId:0, style:true}, 0, opts));
  	opts.cellXfs.forEach(function(c) {
  		write_biff_rec(ba, 0x00e0 /* XF */, write_XF(c, 0, opts));
  	});
  }

  function write_ws_biff8_hlinks(ba/*:BufArray*/, ws) {
  	for(var R=0; R<ws['!links'].length; ++R) {
  		var HL = ws['!links'][R];
  		write_biff_rec(ba, 0x01b8 /* HLink */, write_HLink(HL));
  		if(HL[1].Tooltip) write_biff_rec(ba, 0x0800 /* HLinkTooltip */, write_HLinkTooltip(HL));
  	}
  	delete ws['!links'];
  }

  function write_ws_cols_biff8(ba, cols) {
  	if(!cols) return;
  	var cnt = 0;
  	cols.forEach(function(col, idx) {
  		if(++cnt <= 256 && col) {
  			write_biff_rec(ba, 0x007d /* ColInfo */, write_ColInfo(col_obj_w(idx, col), idx));
  		}
  	});
  }

  function write_ws_biff8_cell(ba/*:BufArray*/, cell/*:Cell*/, R/*:number*/, C/*:number*/, opts) {
  	var os = 16 + get_cell_style(opts.cellXfs, cell, opts);
  	if(cell.v == null && !cell.bf) {
  		write_biff_rec(ba, 0x0201 /* Blank */, write_XLSCell(R, C, os));
  		return;
  	}
  	if(cell.bf) write_biff_rec(ba, 0x0006 /* Formula */, write_Formula(cell, R, C, opts, os));
  	else switch(cell.t) {
  		case 'd': case 'n':
  			var v = cell.t == 'd' ? datenum(parseDate(cell.v)) : cell.v;
  			/* TODO: emit RK as appropriate */
  			write_biff_rec(ba, 0x0203 /* Number */, write_Number(R, C, v, os));
  			break;
  		case 'b': case 'e':
  			write_biff_rec(ba, 0x0205 /* BoolErr */, write_BoolErr(R, C, cell.v, os, opts, cell.t));
  			break;
  		/* TODO: codepage, sst */
  		case 's': case 'str':
  			if(opts.bookSST) {
  				var isst = get_sst_id(opts.Strings, cell.v, opts.revStrings);
  				write_biff_rec(ba, 0x00fd /* LabelSst */, write_LabelSst(R, C, isst, os));
  			} else write_biff_rec(ba, 0x0204 /* Label */, write_Label(R, C, (cell.v||"").slice(0,255), os, opts));
  			break;
  		default:
  			write_biff_rec(ba, 0x0201 /* Blank */, write_XLSCell(R, C, os));
  	}
  }

  /* [MS-XLS] 2.1.7.20.5 */
  function write_ws_biff8(idx/*:number*/, opts, wb/*:Workbook*/) {
  	var ba = buf_array();
  	var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
  	var _WB/*:WBWBProps*/ = ((wb||{}).Workbook||{}/*:any*/);
  	var _sheet/*:WBWSProp*/ = ((_WB.Sheets||[])[idx]||{}/*:any*/);
  	var dense = Array.isArray(ws);
  	var b8 = opts.biff == 8;
  	var ref/*:string*/, rr = "", cols/*:Array<string>*/ = [];
  	var range = safe_decode_range(ws['!ref'] || "A1");
  	var MAX_ROWS = b8 ? 65536 : 16384;
  	if(range.e.c > 0xFF || range.e.r >= MAX_ROWS) {
  		if(opts.WTF) throw new Error("Range " + (ws['!ref'] || "A1") + " exceeds format limit A1:IV16384");
  		range.e.c = Math.min(range.e.c, 0xFF);
  		range.e.r = Math.min(range.e.c, MAX_ROWS-1);
  	}

  	write_biff_rec(ba, 0x0809, write_BOF(wb, 0x10, opts));
  	/* [Uncalced] Index */
  	write_biff_rec(ba, 0x000d /* CalcMode */, writeuint16(1));
  	write_biff_rec(ba, 0x000c /* CalcCount */, writeuint16(100));
  	write_biff_rec(ba, 0x000f /* CalcRefMode */, writebool(true));
  	write_biff_rec(ba, 0x0011 /* CalcIter */, writebool(false));
  	write_biff_rec(ba, 0x0010 /* CalcDelta */, write_Xnum(0.001));
  	write_biff_rec(ba, 0x005f /* CalcSaveRecalc */, writebool(true));
  	write_biff_rec(ba, 0x002a /* PrintRowCol */, writebool(false));
  	write_biff_rec(ba, 0x002b /* PrintGrid */, writebool(false));
  	write_biff_rec(ba, 0x0082 /* GridSet */, writeuint16(1));
  	write_biff_rec(ba, 0x0080 /* Guts */, write_Guts([0,0]));
  	/* DefaultRowHeight WsBool [Sync] [LPr] [HorizontalPageBreaks] [VerticalPageBreaks] */
  	/* Header (string) */
  	/* Footer (string) */
  	write_biff_rec(ba, 0x0083 /* HCenter */, writebool(false));
  	write_biff_rec(ba, 0x0084 /* VCenter */, writebool(false));
  	/* ... */
  	if(b8) write_ws_cols_biff8(ba, ws["!cols"]);
  	/* ... */
  	write_biff_rec(ba, 0x200, write_Dimensions(range, opts));
  	/* ... */

  	if(b8) ws['!links'] = [];
  	for(var R = range.s.r; R <= range.e.r; ++R) {
  		rr = encode_row(R);
  		for(var C = range.s.c; C <= range.e.c; ++C) {
  			if(R === range.s.r) cols[C] = encode_col(C);
  			ref = cols[C] + rr;
  			var cell = dense ? (ws[R]||[])[C] : ws[ref];
  			if(!cell) continue;
  			/* write cell */
  			write_ws_biff8_cell(ba, cell, R, C, opts);
  			if(b8 && cell.l) ws['!links'].push([ref, cell.l]);
  		}
  	}
  	var cname/*:string*/ = _sheet.CodeName || _sheet.name || s;
  	/* ... */
  	if(b8) write_biff_rec(ba, 0x023e /* Window2 */, write_Window2((_WB.Views||[])[0]));
  	/* ... */
  	if(b8 && (ws['!merges']||[]).length) write_biff_rec(ba, 0x00e5 /* MergeCells */, write_MergeCells(ws['!merges']));
  	/* [LRng] *QUERYTABLE [PHONETICINFO] CONDFMTS */
  	if(b8) write_ws_biff8_hlinks(ba, ws);
  	/* [DVAL] */
  	write_biff_rec(ba, 0x01ba /* CodeName */, write_XLUnicodeString(cname));
  	/* *WebPub *CellWatch [SheetExt] */
  	if(b8) write_FEAT(ba, ws);
  	/* *FEAT11 *RECORD12 */
  	write_biff_rec(ba, 0x000a /* EOF */);
  	return ba.end();
  }

  /* [MS-XLS] 2.1.7.20.3 */
  function write_biff8_global(wb/*:Workbook*/, bufs, opts/*:WriteOpts*/) {
  	var A = buf_array();
  	var _WB/*:WBWBProps*/ = ((wb||{}).Workbook||{}/*:any*/);
  	var _sheets/*:Array<WBWSProp>*/ = (_WB.Sheets||[]);
  	var _wb/*:WBProps*/ = /*::((*/_WB.WBProps||{/*::CodeName:"ThisWorkbook"*/}/*:: ):any)*/;
  	var b8 = opts.biff == 8, b5 = opts.biff == 5;
  	write_biff_rec(A, 0x0809, write_BOF(wb, 0x05, opts));
  	if(opts.bookType == "xla") write_biff_rec(A, 0x0087 /* Addin */);
  	write_biff_rec(A, 0x00e1 /* InterfaceHdr */, b8 ? writeuint16(0x04b0) : null);
  	write_biff_rec(A, 0x00c1 /* Mms */, writezeroes(2));
  	if(b5) write_biff_rec(A, 0x00bf /* ToolbarHdr */);
  	if(b5) write_biff_rec(A, 0x00c0 /* ToolbarEnd */);
  	write_biff_rec(A, 0x00e2 /* InterfaceEnd */);
  	write_biff_rec(A, 0x005c /* WriteAccess */, write_WriteAccess("SheetJS", opts));
  	/* [FileSharing] */
  	write_biff_rec(A, 0x0042 /* CodePage */, writeuint16(b8 ? 0x04b0 : 0x04E4));
  	/* *2047 Lel */
  	if(b8) write_biff_rec(A, 0x0161 /* DSF */, writeuint16(0));
  	if(b8) write_biff_rec(A, 0x01c0 /* Excel9File */);
  	write_biff_rec(A, 0x013d /* RRTabId */, write_RRTabId(wb.SheetNames.length));
  	if(b8 && wb.vbaraw) write_biff_rec(A, 0x00d3 /* ObProj */);
  	/* [ObNoMacros] */
  	if(b8 && wb.vbaraw) {
  		var cname/*:string*/ = _wb.CodeName || "ThisWorkbook";
  		write_biff_rec(A, 0x01ba /* CodeName */, write_XLUnicodeString(cname));
  	}
  	write_biff_rec(A, 0x009c /* BuiltInFnGroupCount */, writeuint16(0x11));
  	/* *FnGroupName *FnGrp12 */
  	/* *Lbl */
  	/* [OleObjectSize] */
  	write_biff_rec(A, 0x0019 /* WinProtect */, writebool(false));
  	write_biff_rec(A, 0x0012 /* Protect */, writebool(false));
  	write_biff_rec(A, 0x0013 /* Password */, writeuint16(0));
  	if(b8) write_biff_rec(A, 0x01af /* Prot4Rev */, writebool(false));
  	if(b8) write_biff_rec(A, 0x01bc /* Prot4RevPass */, writeuint16(0));
  	write_biff_rec(A, 0x003d /* Window1 */, write_Window1());
  	write_biff_rec(A, 0x0040 /* Backup */, writebool(false));
  	write_biff_rec(A, 0x008d /* HideObj */, writeuint16(0));
  	write_biff_rec(A, 0x0022 /* Date1904 */, writebool(safe1904(wb)=="true"));
  	write_biff_rec(A, 0x000e /* CalcPrecision */, writebool(true));
  	if(b8) write_biff_rec(A, 0x01b7 /* RefreshAll */, writebool(false));
  	write_biff_rec(A, 0x00DA /* BookBool */, writeuint16(0));
  	/* ... */
  	write_FONTS_biff8(A, wb, opts);
  	write_FMTS_biff8(A, wb.SSF, opts);
  	write_CELLXFS_biff8(A, opts);
  	/* ... */
  	if(b8) write_biff_rec(A, 0x0160 /* UsesELFs */, writebool(false));
  	var a = A.end();

  	var C = buf_array();
  	/* METADATA [MTRSettings] [ForceFullCalculation] */
  	if(b8) write_biff_rec(C, 0x008C, write_Country());
  	/* *SUPBOOK *LBL *RTD [RecalcId] *HFPicture *MSODRAWINGGROUP */

  	/* BIFF8: [SST *Continue] ExtSST */
  	if(b8 && opts.Strings) write_biff_continue(C, 0x00FC, write_SST(opts.Strings));

  	/* *WebPub [WOpt] [CrErr] [BookExt] *FeatHdr *DConn [THEME] [CompressPictures] [Compat12] [GUIDTypeLib] */
  	write_biff_rec(C, 0x000A /* EOF */);
  	var c = C.end();

  	var B = buf_array();
  	var blen = 0, j = 0;
  	for(j = 0; j < wb.SheetNames.length; ++j) blen += (b8 ? 12 : 11) + (b8 ? 2 : 1) * wb.SheetNames[j].length;
  	var start = a.length + blen + c.length;
  	for(j = 0; j < wb.SheetNames.length; ++j) {
  		var _sheet/*:WBWSProp*/ = _sheets[j] || ({}/*:any*/);
  		write_biff_rec(B, 0x0085 /* BoundSheet8 */, write_BoundSheet8({pos:start, hs:_sheet.Hidden||0, dt:0, name:wb.SheetNames[j]}, opts));
  		start += bufs[j].length;
  	}
  	/* 1*BoundSheet8 */
  	var b = B.end();
  	if(blen != b.length) throw new Error("BS8 " + blen + " != " + b.length);

  	var out = [];
  	if(a.length) out.push(a);
  	if(b.length) out.push(b);
  	if(c.length) out.push(c);
  	return bconcat(out);
  }

  /* [MS-XLS] 2.1.7.20 Workbook Stream */
  function write_biff8_buf(wb/*:Workbook*/, opts/*:WriteOpts*/) {
  	var o = opts || {};
  	var bufs = [];

  	if(wb && !wb.SSF) {
  		wb.SSF = dup(table_fmt);
  	}
  	if(wb && wb.SSF) {
  		make_ssf(); SSF_load_table(wb.SSF);
  		// $FlowIgnore
  		o.revssf = evert_num(wb.SSF); o.revssf[wb.SSF[65535]] = 0;
  		o.ssf = wb.SSF;
  	}

  	o.Strings = /*::((*/[]/*:: :any):SST)*/; o.Strings.Count = 0; o.Strings.Unique = 0;
  	fix_write_opts(o);

  	o.cellXfs = [];
  	get_cell_style(o.cellXfs, {}, {revssf:{"General":0}});

  	if(!wb.Props) wb.Props = {};

  	for(var i = 0; i < wb.SheetNames.length; ++i) bufs[bufs.length] = write_ws_biff8(i, o, wb);
  	bufs.unshift(write_biff8_global(wb, bufs, o));
  	return bconcat(bufs);
  }

  function write_biff_buf(wb/*:Workbook*/, opts/*:WriteOpts*/) {
  	for(var i = 0; i <= wb.SheetNames.length; ++i) {
  		var ws = wb.Sheets[wb.SheetNames[i]];
  		if(!ws || !ws["!ref"]) continue;
  		var range = decode_range(ws["!ref"]);
  		if(range.e.c > 255) { // note: 255 is IV
  		if(typeof console != "undefined" && console.error) console.error("Worksheet '" + wb.SheetNames[i] + "' extends beyond column IV (255).  Data may be lost.");
  		}
  	}

  	var o = opts || {};
  	switch(o.biff || 2) {
  		case 8: case 5: return write_biff8_buf(wb, opts);
  		case 4: case 3: case 2: return write_biff2_buf(wb, opts);
  	}
  	throw new Error("invalid type " + o.bookType + " for BIFF");
  }
  function make_html_row(ws/*:Worksheet*/, r/*:Range*/, R/*:number*/, o/*:Sheet2HTMLOpts*/)/*:string*/ {
  	var M/*:Array<Range>*/ = (ws['!merges'] ||[]);
  	var oo/*:Array<string>*/ = [];
  	for(var C = r.s.c; C <= r.e.c; ++C) {
  		var RS = 0, CS = 0;
  		for(var j = 0; j < M.length; ++j) {
  			if(M[j].s.r > R || M[j].s.c > C) continue;
  			if(M[j].e.r < R || M[j].e.c < C) continue;
  			if(M[j].s.r < R || M[j].s.c < C) { RS = -1; break; }
  			RS = M[j].e.r - M[j].s.r + 1; CS = M[j].e.c - M[j].s.c + 1; break;
  		}
  		if(RS < 0) continue;
  		var coord = encode_cell({r:R,c:C});
  		var cell = o.dense ? (ws[R]||[])[C] : ws[coord];
  		/* TODO: html entities */
  		var w = (cell && cell.v != null) && (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";
  		var sp = ({}/*:any*/);
  		if(RS > 1) sp.rowspan = RS;
  		if(CS > 1) sp.colspan = CS;
  		if(o.editable) w = '<span contenteditable="true">' + w + '</span>';
  		else if(cell) {
  			sp["data-t"] = cell && cell.t || 'z';
  			if(cell.v != null) sp["data-v"] = cell.v;
  			if(cell.z != null) sp["data-z"] = cell.z;
  			if(cell.l && (cell.l.Target || "#").charAt(0) != "#") w = '<a href="' + cell.l.Target +'">' + w + '</a>';
  		}
  		sp.id = (o.id || "sjs") + "-" + coord;
  		oo.push(writextag('td', w, sp));
  	}
  	var preamble = "<tr>";
  	return preamble + oo.join("") + "</tr>";
  }

  var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
  var HTML_END = '</body></html>';

  function make_html_preamble(ws/*:Worksheet*/, R/*:Range*/, o/*:Sheet2HTMLOpts*/)/*:string*/ {
  	var out/*:Array<string>*/ = [];
  	return out.join("") + '<table' + (o && o.id ? ' id="' + o.id + '"' : "") + '>';
  }

  function sheet_to_html(ws/*:Worksheet*/, opts/*:?Sheet2HTMLOpts*//*, wb:?Workbook*/)/*:string*/ {
  	var o = opts || {};
  	var header = o.header != null ? o.header : HTML_BEGIN;
  	var footer = o.footer != null ? o.footer : HTML_END;
  	var out/*:Array<string>*/ = [header];
  	var r = decode_range(ws['!ref']);
  	o.dense = Array.isArray(ws);
  	out.push(make_html_preamble(ws, r, o));
  	for(var R = r.s.r; R <= r.e.r; ++R) out.push(make_html_row(ws, r, R, o));
  	out.push("</table>" + footer);
  	return out.join("");
  }

  function sheet_add_dom(ws/*:Worksheet*/, table/*:HTMLElement*/, _opts/*:?any*/)/*:Worksheet*/ {
  	var opts = _opts || {};
  	var or_R = 0, or_C = 0;
  	if(opts.origin != null) {
  		if(typeof opts.origin == 'number') or_R = opts.origin;
  		else {
  			var _origin/*:CellAddress*/ = typeof opts.origin == "string" ? decode_cell(opts.origin) : opts.origin;
  			or_R = _origin.r; or_C = _origin.c;
  		}
  	}

  	var rows/*:HTMLCollection<HTMLTableRowElement>*/ = table.getElementsByTagName('tr');
  	var sheetRows = Math.min(opts.sheetRows||10000000, rows.length);
  	var range/*:Range*/ = {s:{r:0,c:0},e:{r:or_R,c:or_C}};
  	if(ws["!ref"]) {
  		var _range/*:Range*/ = decode_range(ws["!ref"]);
  		range.s.r = Math.min(range.s.r, _range.s.r);
  		range.s.c = Math.min(range.s.c, _range.s.c);
  		range.e.r = Math.max(range.e.r, _range.e.r);
  		range.e.c = Math.max(range.e.c, _range.e.c);
  		if(or_R == -1) range.e.r = or_R = _range.e.r + 1;
  	}
  	var merges/*:Array<Range>*/ = [], midx = 0;
  	var rowinfo/*:Array<RowInfo>*/ = ws["!rows"] || (ws["!rows"] = []);
  	var _R = 0, R = 0, _C = 0, C = 0, RS = 0, CS = 0;
  	if(!ws["!cols"]) ws['!cols'] = [];
  	for(; _R < rows.length && R < sheetRows; ++_R) {
  		var row/*:HTMLTableRowElement*/ = rows[_R];
  		if (is_dom_element_hidden(row)) {
  			if (opts.display) continue;
  			rowinfo[R] = {hidden: true};
  		}
  		var elts/*:HTMLCollection<HTMLTableCellElement>*/ = (row.children/*:any*/);
  		for(_C = C = 0; _C < elts.length; ++_C) {
  			var elt/*:HTMLTableCellElement*/ = elts[_C];
  			if (opts.display && is_dom_element_hidden(elt)) continue;
  			var v/*:?string*/ = elt.hasAttribute('data-v') ? elt.getAttribute('data-v') : elt.hasAttribute('v') ? elt.getAttribute('v') : htmldecode(elt.innerHTML);
  			var z/*:?string*/ = elt.getAttribute('data-z') || elt.getAttribute('z');
  			for(midx = 0; midx < merges.length; ++midx) {
  				var m/*:Range*/ = merges[midx];
  				if(m.s.c == C + or_C && m.s.r < R + or_R && R + or_R <= m.e.r) { C = m.e.c+1 - or_C; midx = -1; }
  			}
  			/* TODO: figure out how to extract nonstandard mso- style */
  			CS = +elt.getAttribute("colspan") || 1;
  			if( ((RS = (+elt.getAttribute("rowspan") || 1)))>1 || CS>1) merges.push({s:{r:R + or_R,c:C + or_C},e:{r:R + or_R + (RS||1) - 1, c:C + or_C + (CS||1) - 1}});
  			var o/*:Cell*/ = {t:'s', v:v};
  			var _t/*:string*/ = elt.getAttribute("data-t") || elt.getAttribute("t") || "";
  			if(v != null) {
  				if(v.length == 0) o.t = _t || 'z';
  				else if(opts.raw || v.trim().length == 0 || _t == "s");
  				else if(v === 'TRUE') o = {t:'b', v:true};
  				else if(v === 'FALSE') o = {t:'b', v:false};
  				else if(!isNaN(fuzzynum(v))) o = {t:'n', v:fuzzynum(v)};
  				else if(!isNaN(fuzzydate(v).getDate())) {
  					o = ({t:'d', v:parseDate(v)}/*:any*/);
  					if(!opts.cellDates) o = ({t:'n', v:datenum(o.v)}/*:any*/);
  					o.z = opts.dateNF || table_fmt[14];
  				}
  			}
  			if(o.z === undefined && z != null) o.z = z;
  			/* The first link is used.  Links are assumed to be fully specified.
  			 * TODO: The right way to process relative links is to make a new <a> */
  			var l = "", Aelts = elt.getElementsByTagName("A");
  			if(Aelts && Aelts.length) for(var Aelti = 0; Aelti < Aelts.length; ++Aelti)	if(Aelts[Aelti].hasAttribute("href")) {
  				l = Aelts[Aelti].getAttribute("href"); if(l.charAt(0) != "#") break;
  			}
  			if(l && l.charAt(0) != "#") o.l = ({ Target: l });
  			if(opts.dense) { if(!ws[R + or_R]) ws[R + or_R] = []; ws[R + or_R][C + or_C] = o; }
  			else ws[encode_cell({c:C + or_C, r:R + or_R})] = o;
  			if(range.e.c < C + or_C) range.e.c = C + or_C;
  			C += CS;
  		}
  		++R;
  	}
  	if(merges.length) ws['!merges'] = (ws["!merges"] || []).concat(merges);
  	range.e.r = Math.max(range.e.r, R - 1 + or_R);
  	ws['!ref'] = encode_range(range);
  	if(R >= sheetRows) ws['!fullref'] = encode_range((range.e.r = rows.length-_R+R-1 + or_R,range)); // We can count the real number of rows to parse but we don't to improve the performance
  	return ws;
  }

  function parse_dom_table(table/*:HTMLElement*/, _opts/*:?any*/)/*:Worksheet*/ {
  	var opts = _opts || {};
  	var ws/*:Worksheet*/ = opts.dense ? ([]/*:any*/) : ({}/*:any*/);
  	return sheet_add_dom(ws, table, _opts);
  }

  function table_to_book(table/*:HTMLElement*/, opts/*:?any*/)/*:Workbook*/ {
  	return sheet_to_workbook(parse_dom_table(table, opts), opts);
  }

  function is_dom_element_hidden(element/*:HTMLElement*/)/*:boolean*/ {
  	var display/*:string*/ = '';
  	var get_computed_style/*:?function*/ = get_get_computed_style_function(element);
  	if(get_computed_style) display = get_computed_style(element).getPropertyValue('display');
  	if(!display) display = element.style && element.style.display;
  	return display === 'none';
  }

  /* global getComputedStyle */
  function get_get_computed_style_function(element/*:HTMLElement*/)/*:?function*/ {
  	// The proper getComputedStyle implementation is the one defined in the element window
  	if(element.ownerDocument.defaultView && typeof element.ownerDocument.defaultView.getComputedStyle === 'function') return element.ownerDocument.defaultView.getComputedStyle;
  	// If it is not available, try to get one from the global namespace
  	if(typeof getComputedStyle === 'function') return getComputedStyle;
  	return null;
  }

  /* OpenDocument */
  var write_styles_ods/*:{(wb:any, opts:any):string}*/ = /* @__PURE__ */(function() {
  	var master_styles = [
  		'<office:master-styles>',
  			'<style:master-page style:name="mp1" style:page-layout-name="mp1">',
  				'<style:header/>',
  				'<style:header-left style:display="false"/>',
  				'<style:footer/>',
  				'<style:footer-left style:display="false"/>',
  			'</style:master-page>',
  		'</office:master-styles>'
  	].join("");

  	var payload = '<office:document-styles ' + wxt_helper({
  		'xmlns:office':   "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
  		'xmlns:table':    "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
  		'xmlns:style':    "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
  		'xmlns:text':     "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
  		'xmlns:draw':     "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
  		'xmlns:fo':       "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
  		'xmlns:xlink':    "http://www.w3.org/1999/xlink",
  		'xmlns:dc':       "http://purl.org/dc/elements/1.1/",
  		'xmlns:number':   "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
  		'xmlns:svg':      "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
  		'xmlns:of':       "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
  		'office:version': "1.2"
  	}) + '>' + master_styles + '</office:document-styles>';

  	return function wso(/*::wb, opts*/) {
  		return XML_HEADER + payload;
  	};
  })();
  var write_content_ods/*:{(wb:any, opts:any):string}*/ = /* @__PURE__ */(function() {
  	/* 6.1.2 White Space Characters */
  	var write_text_p = function(text/*:string*/)/*:string*/ {
  		return escapexml(text)
  			.replace(/  +/g, function($$){return '<text:s text:c="'+$$.length+'"/>';})
  			.replace(/\t/g, "<text:tab/>")
  			.replace(/\n/g, "</text:p><text:p>")
  			.replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
  	};

  	var null_cell_xml = '          <table:table-cell />\n';
  	var covered_cell_xml = '          <table:covered-table-cell/>\n';
  	var write_ws = function(ws, wb/*:Workbook*/, i/*:number*//*::, opts*/)/*:string*/ {
  		/* Section 9 Tables */
  		var o/*:Array<string>*/ = [];
  		o.push('      <table:table table:name="' + escapexml(wb.SheetNames[i]) + '" table:style-name="ta1">\n');
  		var R=0,C=0, range = decode_range(ws['!ref']||"A1");
  		var marr/*:Array<Range>*/ = ws['!merges'] || [], mi = 0;
  		var dense = Array.isArray(ws);
  		if(ws["!cols"]) {
  			for(C = 0; C <= range.e.c; ++C) o.push('        <table:table-column' + (ws["!cols"][C] ? ' table:style-name="co' + ws["!cols"][C].ods + '"' : '') + '></table:table-column>\n');
  		}
  		var H = "", ROWS = ws["!rows"]||[];
  		for(R = 0; R < range.s.r; ++R) {
  			H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
  			o.push('        <table:table-row' + H + '></table:table-row>\n');
  		}
  		for(; R <= range.e.r; ++R) {
  			H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
  			o.push('        <table:table-row' + H + '>\n');
  			for(C=0; C < range.s.c; ++C) o.push(null_cell_xml);
  			for(; C <= range.e.c; ++C) {
  				var skip = false, ct = {}, textp = "";
  				for(mi = 0; mi != marr.length; ++mi) {
  					if(marr[mi].s.c > C) continue;
  					if(marr[mi].s.r > R) continue;
  					if(marr[mi].e.c < C) continue;
  					if(marr[mi].e.r < R) continue;
  					if(marr[mi].s.c != C || marr[mi].s.r != R) skip = true;
  					ct['table:number-columns-spanned'] = (marr[mi].e.c - marr[mi].s.c + 1);
  					ct['table:number-rows-spanned'] =    (marr[mi].e.r - marr[mi].s.r + 1);
  					break;
  				}
  				if(skip) { o.push(covered_cell_xml); continue; }
  				var ref = encode_cell({r:R, c:C}), cell = dense ? (ws[R]||[])[C]: ws[ref];
  				if(cell && cell.f) {
  					ct['table:formula'] = escapexml(csf_to_ods_formula(cell.f));
  					if(cell.F) {
  						if(cell.F.slice(0, ref.length) == ref) {
  							var _Fref = decode_range(cell.F);
  							ct['table:number-matrix-columns-spanned'] = (_Fref.e.c - _Fref.s.c + 1);
  							ct['table:number-matrix-rows-spanned'] =    (_Fref.e.r - _Fref.s.r + 1);
  						}
  					}
  				}
  				if(!cell) { o.push(null_cell_xml); continue; }
  				switch(cell.t) {
  					case 'b':
  						textp = (cell.v ? 'TRUE' : 'FALSE');
  						ct['office:value-type'] = "boolean";
  						ct['office:boolean-value'] = (cell.v ? 'true' : 'false');
  						break;
  					case 'n':
  						textp = (cell.w||String(cell.v||0));
  						ct['office:value-type'] = "float";
  						ct['office:value'] = (cell.v||0);
  						break;
  					case 's': case 'str':
  						textp = cell.v == null ? "" : cell.v;
  						ct['office:value-type'] = "string";
  						break;
  					case 'd':
  						textp = (cell.w||(parseDate(cell.v).toISOString()));
  						ct['office:value-type'] = "date";
  						ct['office:date-value'] = (parseDate(cell.v).toISOString());
  						ct['table:style-name'] = "ce1";
  						break;
  					//case 'e':
  					default: o.push(null_cell_xml); continue;
  				}
  				var text_p = write_text_p(textp);
  				if(cell.l && cell.l.Target) {
  					var _tgt = cell.l.Target;
  					_tgt = _tgt.charAt(0) == "#" ? "#" + csf_to_ods_3D(_tgt.slice(1)) : _tgt;
  					// TODO: choose correct parent path format based on link delimiters
  					if(_tgt.charAt(0) != "#" && !_tgt.match(/^\w+:/)) _tgt = '../' + _tgt;
  					text_p = writextag('text:a', text_p, {'xlink:href': _tgt.replace(/&/g, "&amp;")});
  				}
  				o.push('          ' + writextag('table:table-cell', writextag('text:p', text_p, {}), ct) + '\n');
  			}
  			o.push('        </table:table-row>\n');
  		}
  		o.push('      </table:table>\n');
  		return o.join("");
  	};

  	var write_automatic_styles_ods = function(o/*:Array<string>*/, wb) {
  		o.push(' <office:automatic-styles>\n');

  		o.push('  <number:date-style style:name="N37" number:automatic-order="true">\n');
  		o.push('   <number:month number:style="long"/>\n');
  		o.push('   <number:text>/</number:text>\n');
  		o.push('   <number:day number:style="long"/>\n');
  		o.push('   <number:text>/</number:text>\n');
  		o.push('   <number:year/>\n');
  		o.push('  </number:date-style>\n');

  		/* column styles */
  		var cidx = 0;
  		wb.SheetNames.map(function(n) { return wb.Sheets[n]; }).forEach(function(ws) {
  			if(!ws) return;
  			if(ws["!cols"]) {
  				for(var C = 0; C < ws["!cols"].length; ++C) if(ws["!cols"][C]) {
  					var colobj = ws["!cols"][C];
  					if(colobj.width == null && colobj.wpx == null && colobj.wch == null) continue;
  					process_col(colobj);
  					colobj.ods = cidx;
  					var w = ws["!cols"][C].wpx + "px";
  					o.push('  <style:style style:name="co' + cidx + '" style:family="table-column">\n');
  					o.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + w + '"/>\n');
  					o.push('  </style:style>\n');
  					++cidx;
  				}
  			}
  		});

  		/* row styles */
  		var ridx = 0;
  		wb.SheetNames.map(function(n) { return wb.Sheets[n]; }).forEach(function(ws) {
  			if(!ws) return;
  			if(ws["!rows"]) {
  				for(var R = 0; R < ws["!rows"].length; ++R) if(ws["!rows"][R]) {
  					ws["!rows"][R].ods = ridx;
  					var h = ws["!rows"][R].hpx + "px";
  					o.push('  <style:style style:name="ro' + ridx + '" style:family="table-row">\n');
  					o.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + h + '"/>\n');
  					o.push('  </style:style>\n');
  					++ridx;
  				}
  			}
  		});

  		/* table */
  		o.push('  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">\n');
  		o.push('   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>\n');
  		o.push('  </style:style>\n');

  		/* table cells, text */
  		o.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n');

  		/* page-layout */

  		o.push(' </office:automatic-styles>\n');
  	};

  	return function wcx(wb, opts) {
  		var o = [XML_HEADER];
  		/* 3.1.3.2 */
  		var attr = wxt_helper({
  			'xmlns:office':       "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
  			'xmlns:table':        "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
  			'xmlns:style':        "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
  			'xmlns:text':         "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
  			'xmlns:draw':         "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
  			'xmlns:fo':           "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
  			'xmlns:xlink':        "http://www.w3.org/1999/xlink",
  			'xmlns:dc':           "http://purl.org/dc/elements/1.1/",
  			'xmlns:meta':         "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
  			'xmlns:number':       "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
  			'xmlns:presentation': "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
  			'xmlns:svg':          "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
  			'xmlns:chart':        "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
  			'xmlns:dr3d':         "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
  			'xmlns:math':         "http://www.w3.org/1998/Math/MathML",
  			'xmlns:form':         "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
  			'xmlns:script':       "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
  			'xmlns:ooo':          "http://openoffice.org/2004/office",
  			'xmlns:ooow':         "http://openoffice.org/2004/writer",
  			'xmlns:oooc':         "http://openoffice.org/2004/calc",
  			'xmlns:dom':          "http://www.w3.org/2001/xml-events",
  			'xmlns:xforms':       "http://www.w3.org/2002/xforms",
  			'xmlns:xsd':          "http://www.w3.org/2001/XMLSchema",
  			'xmlns:xsi':          "http://www.w3.org/2001/XMLSchema-instance",
  			'xmlns:sheet':        "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
  			'xmlns:rpt':          "http://openoffice.org/2005/report",
  			'xmlns:of':           "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
  			'xmlns:xhtml':        "http://www.w3.org/1999/xhtml",
  			'xmlns:grddl':        "http://www.w3.org/2003/g/data-view#",
  			'xmlns:tableooo':     "http://openoffice.org/2009/table",
  			'xmlns:drawooo':      "http://openoffice.org/2010/draw",
  			'xmlns:calcext':      "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
  			'xmlns:loext':        "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
  			'xmlns:field':        "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
  			'xmlns:formx':        "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
  			'xmlns:css3t':        "http://www.w3.org/TR/css3-text/",
  			'office:version':     "1.2"
  		});

  		var fods = wxt_helper({
  			'xmlns:config':    "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
  			'office:mimetype': "application/vnd.oasis.opendocument.spreadsheet"
  		});

  		if(opts.bookType == "fods") {
  			o.push('<office:document' + attr + fods + '>\n');
  			o.push(write_meta_ods().replace(/office:document-meta/g, "office:meta"));
  			// TODO: settings (equiv of settings.xml for ODS)
  		} else o.push('<office:document-content' + attr  + '>\n');
  		// o.push('  <office:scripts/>\n');
  		write_automatic_styles_ods(o, wb);
  		o.push('  <office:body>\n');
  		o.push('    <office:spreadsheet>\n');
  		for(var i = 0; i != wb.SheetNames.length; ++i) o.push(write_ws(wb.Sheets[wb.SheetNames[i]], wb, i));
  		o.push('    </office:spreadsheet>\n');
  		o.push('  </office:body>\n');
  		if(opts.bookType == "fods") o.push('</office:document>');
  		else o.push('</office:document-content>');
  		return o.join("");
  	};
  })();

  function write_ods(wb/*:any*/, opts/*:any*/) {
  	if(opts.bookType == "fods") return write_content_ods(wb, opts);

  	var zip = zip_new();
  	var f = "";

  	var manifest/*:Array<Array<string> >*/ = [];
  	var rdf/*:Array<[string, string]>*/ = [];

  	/* Part 3 Section 3.3 MIME Media Type */
  	f = "mimetype";
  	zip_add_file(zip, f, "application/vnd.oasis.opendocument.spreadsheet");

  	/* Part 1 Section 2.2 Documents */
  	f = "content.xml";
  	zip_add_file(zip, f, write_content_ods(wb, opts));
  	manifest.push([f, "text/xml"]);
  	rdf.push([f, "ContentFile"]);

  	/* TODO: these are hard-coded styles to satiate excel */
  	f = "styles.xml";
  	zip_add_file(zip, f, write_styles_ods(wb, opts));
  	manifest.push([f, "text/xml"]);
  	rdf.push([f, "StylesFile"]);

  	/* TODO: this is hard-coded to satiate excel */
  	f = "meta.xml";
  	zip_add_file(zip, f, XML_HEADER + write_meta_ods(/*::wb, opts*/));
  	manifest.push([f, "text/xml"]);
  	rdf.push([f, "MetadataFile"]);

  	/* Part 3 Section 6 Metadata Manifest File */
  	f = "manifest.rdf";
  	zip_add_file(zip, f, write_rdf(rdf/*, opts*/));
  	manifest.push([f, "application/rdf+xml"]);

  	/* Part 3 Section 4 Manifest File */
  	f = "META-INF/manifest.xml";
  	zip_add_file(zip, f, write_manifest(manifest/*, opts*/));

  	return zip;
  }

  /*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
  function u8_to_dataview(array) {
    return new DataView(array.buffer, array.byteOffset, array.byteLength);
  }
  function stru8(str) {
    return typeof TextEncoder != "undefined" ? new TextEncoder().encode(str) : s2a(utf8write(str));
  }
  function u8contains(body, search) {
    outer:
      for (var L = 0; L <= body.length - search.length; ++L) {
        for (var j = 0; j < search.length; ++j)
          if (body[L + j] != search[j])
            continue outer;
        return true;
      }
    return false;
  }
  function u8concat(u8a) {
    var len = u8a.reduce(function(acc, x) {
      return acc + x.length;
    }, 0);
    var out = new Uint8Array(len);
    var off = 0;
    u8a.forEach(function(u8) {
      out.set(u8, off);
      off += u8.length;
    });
    return out;
  }
  function writeDecimal128LE(buf, offset, value) {
    var exp = Math.floor(value == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(value))) + 6176 - 20;
    var mantissa = value / Math.pow(10, exp - 6176);
    buf[offset + 15] |= exp >> 7;
    buf[offset + 14] |= (exp & 127) << 1;
    for (var i = 0; mantissa >= 1; ++i, mantissa /= 256)
      buf[offset + i] = mantissa & 255;
    buf[offset + 15] |= value >= 0 ? 0 : 128;
  }
  function parse_varint49(buf, ptr) {
    var l = ptr ? ptr[0] : 0;
    var usz = buf[l] & 127;
    varint:
      if (buf[l++] >= 128) {
        usz |= (buf[l] & 127) << 7;
        if (buf[l++] < 128)
          break varint;
        usz |= (buf[l] & 127) << 14;
        if (buf[l++] < 128)
          break varint;
        usz |= (buf[l] & 127) << 21;
        if (buf[l++] < 128)
          break varint;
        usz += (buf[l] & 127) * Math.pow(2, 28);
        ++l;
        if (buf[l++] < 128)
          break varint;
        usz += (buf[l] & 127) * Math.pow(2, 35);
        ++l;
        if (buf[l++] < 128)
          break varint;
        usz += (buf[l] & 127) * Math.pow(2, 42);
        ++l;
        if (buf[l++] < 128)
          break varint;
      }
    if (ptr)
      ptr[0] = l;
    return usz;
  }
  function write_varint49(v) {
    var usz = new Uint8Array(7);
    usz[0] = v & 127;
    var L = 1;
    sz:
      if (v > 127) {
        usz[L - 1] |= 128;
        usz[L] = v >> 7 & 127;
        ++L;
        if (v <= 16383)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v >> 14 & 127;
        ++L;
        if (v <= 2097151)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v >> 21 & 127;
        ++L;
        if (v <= 268435455)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v / 256 >>> 21 & 127;
        ++L;
        if (v <= 34359738367)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v / 65536 >>> 21 & 127;
        ++L;
        if (v <= 4398046511103)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v / 16777216 >>> 21 & 127;
        ++L;
      }
    return usz.slice(0, L);
  }
  function varint_to_i32(buf) {
    var l = 0, i32 = buf[l] & 127;
    varint:
      if (buf[l++] >= 128) {
        i32 |= (buf[l] & 127) << 7;
        if (buf[l++] < 128)
          break varint;
        i32 |= (buf[l] & 127) << 14;
        if (buf[l++] < 128)
          break varint;
        i32 |= (buf[l] & 127) << 21;
        if (buf[l++] < 128)
          break varint;
        i32 |= (buf[l] & 127) << 28;
      }
    return i32;
  }
  function parse_shallow(buf) {
    var out = [], ptr = [0];
    while (ptr[0] < buf.length) {
      var off = ptr[0];
      var num = parse_varint49(buf, ptr);
      var type = num & 7;
      num = Math.floor(num / 8);
      var len = 0;
      var res;
      if (num == 0)
        break;
      switch (type) {
        case 0:
          {
            var l = ptr[0];
            while (buf[ptr[0]++] >= 128)
              ;
            res = buf.slice(l, ptr[0]);
          }
          break;
        case 5:
          len = 4;
          res = buf.slice(ptr[0], ptr[0] + len);
          ptr[0] += len;
          break;
        case 1:
          len = 8;
          res = buf.slice(ptr[0], ptr[0] + len);
          ptr[0] += len;
          break;
        case 2:
          len = parse_varint49(buf, ptr);
          res = buf.slice(ptr[0], ptr[0] + len);
          ptr[0] += len;
          break;
        case 3:
        case 4:
        default:
          throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));
      }
      var v = { data: res, type: type };
      if (out[num] == null)
        out[num] = [v];
      else
        out[num].push(v);
    }
    return out;
  }
  function write_shallow(proto) {
    var out = [];
    proto.forEach(function(field, idx) {
      field.forEach(function(item) {
        if (!item.data)
          return;
        out.push(write_varint49(idx * 8 + item.type));
        if (item.type == 2)
          out.push(write_varint49(item.data.length));
        out.push(item.data);
      });
    });
    return u8concat(out);
  }
  function parse_iwa_file(buf) {
    var _a;
    var out = [], ptr = [0];
    while (ptr[0] < buf.length) {
      var len = parse_varint49(buf, ptr);
      var ai = parse_shallow(buf.slice(ptr[0], ptr[0] + len));
      ptr[0] += len;
      var res = {
        id: varint_to_i32(ai[1][0].data),
        messages: []
      };
      ai[2].forEach(function(b) {
        var mi = parse_shallow(b.data);
        var fl = varint_to_i32(mi[3][0].data);
        res.messages.push({
          meta: mi,
          data: buf.slice(ptr[0], ptr[0] + fl)
        });
        ptr[0] += fl;
      });
      if ((_a = ai[3]) == null ? void 0 : _a[0])
        res.merge = varint_to_i32(ai[3][0].data) >>> 0 > 0;
      out.push(res);
    }
    return out;
  }
  function write_iwa_file(ias) {
    var bufs = [];
    ias.forEach(function(ia) {
      var ai = [];
      ai[1] = [{ data: write_varint49(ia.id), type: 0 }];
      ai[2] = [];
      if (ia.merge != null)
        ai[3] = [{ data: write_varint49(+!!ia.merge), type: 0 }];
      var midata = [];
      ia.messages.forEach(function(mi) {
        midata.push(mi.data);
        mi.meta[3] = [{ type: 0, data: write_varint49(mi.data.length) }];
        ai[2].push({ data: write_shallow(mi.meta), type: 2 });
      });
      var aipayload = write_shallow(ai);
      bufs.push(write_varint49(aipayload.length));
      bufs.push(aipayload);
      midata.forEach(function(mid) {
        return bufs.push(mid);
      });
    });
    return u8concat(bufs);
  }
  function parse_snappy_chunk(type, buf) {
    if (type != 0)
      throw new Error("Unexpected Snappy chunk type ".concat(type));
    var ptr = [0];
    var usz = parse_varint49(buf, ptr);
    var chunks = [];
    while (ptr[0] < buf.length) {
      var tag = buf[ptr[0]] & 3;
      if (tag == 0) {
        var len = buf[ptr[0]++] >> 2;
        if (len < 60)
          ++len;
        else {
          var c = len - 59;
          len = buf[ptr[0]];
          if (c > 1)
            len |= buf[ptr[0] + 1] << 8;
          if (c > 2)
            len |= buf[ptr[0] + 2] << 16;
          if (c > 3)
            len |= buf[ptr[0] + 3] << 24;
          len >>>= 0;
          len++;
          ptr[0] += c;
        }
        chunks.push(buf.slice(ptr[0], ptr[0] + len));
        ptr[0] += len;
        continue;
      } else {
        var offset = 0, length = 0;
        if (tag == 1) {
          length = (buf[ptr[0]] >> 2 & 7) + 4;
          offset = (buf[ptr[0]++] & 224) << 3;
          offset |= buf[ptr[0]++];
        } else {
          length = (buf[ptr[0]++] >> 2) + 1;
          if (tag == 2) {
            offset = buf[ptr[0]] | buf[ptr[0] + 1] << 8;
            ptr[0] += 2;
          } else {
            offset = (buf[ptr[0]] | buf[ptr[0] + 1] << 8 | buf[ptr[0] + 2] << 16 | buf[ptr[0] + 3] << 24) >>> 0;
            ptr[0] += 4;
          }
        }
        chunks = [u8concat(chunks)];
        if (offset == 0)
          throw new Error("Invalid offset 0");
        if (offset > chunks[0].length)
          throw new Error("Invalid offset beyond length");
        if (length >= offset) {
          chunks.push(chunks[0].slice(-offset));
          length -= offset;
          while (length >= chunks[chunks.length - 1].length) {
            chunks.push(chunks[chunks.length - 1]);
            length -= chunks[chunks.length - 1].length;
          }
        }
        chunks.push(chunks[0].slice(-offset, -offset + length));
      }
    }
    var o = u8concat(chunks);
    if (o.length != usz)
      throw new Error("Unexpected length: ".concat(o.length, " != ").concat(usz));
    return o;
  }
  function decompress_iwa_file(buf) {
    var out = [];
    var l = 0;
    while (l < buf.length) {
      var t = buf[l++];
      var len = buf[l] | buf[l + 1] << 8 | buf[l + 2] << 16;
      l += 3;
      out.push(parse_snappy_chunk(t, buf.slice(l, l + len)));
      l += len;
    }
    if (l !== buf.length)
      throw new Error("data is not a valid framed stream!");
    return u8concat(out);
  }
  function compress_iwa_file(buf) {
    var out = [];
    var l = 0;
    while (l < buf.length) {
      var c = Math.min(buf.length - l, 268435455);
      var frame = new Uint8Array(4);
      out.push(frame);
      var usz = write_varint49(c);
      var L = usz.length;
      out.push(usz);
      if (c <= 60) {
        L++;
        out.push(new Uint8Array([c - 1 << 2]));
      } else if (c <= 256) {
        L += 2;
        out.push(new Uint8Array([240, c - 1 & 255]));
      } else if (c <= 65536) {
        L += 3;
        out.push(new Uint8Array([244, c - 1 & 255, c - 1 >> 8 & 255]));
      } else if (c <= 16777216) {
        L += 4;
        out.push(new Uint8Array([248, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255]));
      } else if (c <= 4294967296) {
        L += 5;
        out.push(new Uint8Array([252, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255, c - 1 >>> 24 & 255]));
      }
      out.push(buf.slice(l, l + c));
      L += c;
      frame[0] = 0;
      frame[1] = L & 255;
      frame[2] = L >> 8 & 255;
      frame[3] = L >> 16 & 255;
      l += c;
    }
    return u8concat(out);
  }
  function write_new_storage(cell, sst) {
    var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;
    out[0] = 5;
    switch (cell.t) {
      case "n":
        out[1] = 2;
        writeDecimal128LE(out, l, cell.v);
        flags |= 1;
        l += 16;
        break;
      case "b":
        out[1] = 6;
        dv.setFloat64(l, cell.v ? 1 : 0, true);
        flags |= 2;
        l += 8;
        break;
      case "s":
        if (sst.indexOf(cell.v) == -1)
          throw new Error("Value ".concat(cell.v, " missing from SST!"));
        out[1] = 3;
        dv.setUint32(l, sst.indexOf(cell.v), true);
        flags |= 8;
        l += 4;
        break;
      default:
        throw "unsupported cell type " + cell.t;
    }
    dv.setUint32(8, flags, true);
    return out.slice(0, l);
  }
  function write_old_storage(cell, sst) {
    var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;
    out[0] = 3;
    switch (cell.t) {
      case "n":
        out[2] = 2;
        dv.setFloat64(l, cell.v, true);
        flags |= 32;
        l += 8;
        break;
      case "b":
        out[2] = 6;
        dv.setFloat64(l, cell.v ? 1 : 0, true);
        flags |= 32;
        l += 8;
        break;
      case "s":
        if (sst.indexOf(cell.v) == -1)
          throw new Error("Value ".concat(cell.v, " missing from SST!"));
        out[2] = 3;
        dv.setUint32(l, sst.indexOf(cell.v), true);
        flags |= 16;
        l += 4;
        break;
      default:
        throw "unsupported cell type " + cell.t;
    }
    dv.setUint32(4, flags, true);
    return out.slice(0, l);
  }
  function parse_TSP_Reference(buf) {
    var pb = parse_shallow(buf);
    return parse_varint49(pb[1][0].data);
  }
  function write_tile_row(tri, data, SST) {
    var _a, _b, _c, _d;
    if (!((_a = tri[6]) == null ? void 0 : _a[0]) || !((_b = tri[7]) == null ? void 0 : _b[0]))
      throw "Mutation only works on post-BNC storages!";
    var wide_offsets = ((_d = (_c = tri[8]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && varint_to_i32(tri[8][0].data) > 0 || false;
    if (wide_offsets)
      throw "Math only works with normal offsets";
    var cnt = 0;
    var dv = u8_to_dataview(tri[7][0].data), last_offset = 0, cell_storage = [];
    var _dv = u8_to_dataview(tri[4][0].data), _last_offset = 0, _cell_storage = [];
    for (var C = 0; C < data.length; ++C) {
      if (data[C] == null) {
        dv.setUint16(C * 2, 65535, true);
        _dv.setUint16(C * 2, 65535);
        continue;
      }
      dv.setUint16(C * 2, last_offset, true);
      _dv.setUint16(C * 2, _last_offset, true);
      var celload, _celload;
      switch (typeof data[C]) {
        case "string":
          celload = write_new_storage({ t: "s", v: data[C] }, SST);
          _celload = write_old_storage({ t: "s", v: data[C] }, SST);
          break;
        case "number":
          celload = write_new_storage({ t: "n", v: data[C] }, SST);
          _celload = write_old_storage({ t: "n", v: data[C] }, SST);
          break;
        case "boolean":
          celload = write_new_storage({ t: "b", v: data[C] }, SST);
          _celload = write_old_storage({ t: "b", v: data[C] }, SST);
          break;
        default:
          throw new Error("Unsupported value " + data[C]);
      }
      cell_storage.push(celload);
      last_offset += celload.length;
      _cell_storage.push(_celload);
      _last_offset += _celload.length;
      ++cnt;
    }
    tri[2][0].data = write_varint49(cnt);
    for (; C < tri[7][0].data.length / 2; ++C) {
      dv.setUint16(C * 2, 65535, true);
      _dv.setUint16(C * 2, 65535, true);
    }
    tri[6][0].data = u8concat(cell_storage);
    tri[3][0].data = u8concat(_cell_storage);
    return cnt;
  }
  function write_numbers_iwa(wb, opts) {
    if (!opts || !opts.numbers)
      throw new Error("Must pass a `numbers` option -- check the README");
    var ws = wb.Sheets[wb.SheetNames[0]];
    if (wb.SheetNames.length > 1)
      console.error("The Numbers writer currently writes only the first table");
    var range = decode_range(ws["!ref"]);
    range.s.r = range.s.c = 0;
    var trunc = false;
    if (range.e.c > 9) {
      trunc = true;
      range.e.c = 9;
    }
    if (range.e.r > 49) {
      trunc = true;
      range.e.r = 49;
    }
    if (trunc)
      console.error("The Numbers writer is currently limited to ".concat(encode_range(range)));
    var data = sheet_to_json(ws, { range: range, header: 1 });
    var SST = ["~Sh33tJ5~"];
    data.forEach(function(row) {
      return row.forEach(function(cell) {
        if (typeof cell == "string")
          SST.push(cell);
      });
    });
    var dependents = {};
    var indices = [];
    var cfb = CFB.read(opts.numbers, { type: "base64" });
    cfb.FileIndex.map(function(fi, idx) {
      return [fi, cfb.FullPaths[idx]];
    }).forEach(function(row) {
      var fi = row[0], fp = row[1];
      if (fi.type != 2)
        return;
      if (!fi.name.match(/\.iwa/))
        return;
      var old_content = fi.content;
      var raw1 = decompress_iwa_file(old_content);
      var x2 = parse_iwa_file(raw1);
      x2.forEach(function(packet2) {
        indices.push(packet2.id);
        dependents[packet2.id] = { deps: [], location: fp, type: varint_to_i32(packet2.messages[0].meta[1][0].data) };
      });
    });
    indices.sort(function(x2, y2) {
      return x2 - y2;
    });
    var indices_varint = indices.filter(function(x2) {
      return x2 > 1;
    }).map(function(x2) {
      return [x2, write_varint49(x2)];
    });
    cfb.FileIndex.map(function(fi, idx) {
      return [fi, cfb.FullPaths[idx]];
    }).forEach(function(row) {
      var fi = row[0]; row[1];
      if (!fi.name.match(/\.iwa/))
        return;
      var x2 = parse_iwa_file(decompress_iwa_file(fi.content));
      x2.forEach(function(ia) {
        ia.messages.forEach(function(m) {
          indices_varint.forEach(function(ivi) {
            if (ia.messages.some(function(mess) {
              return varint_to_i32(mess.meta[1][0].data) != 11006 && u8contains(mess.data, ivi[1]);
            })) {
              dependents[ivi[0]].deps.push(ia.id);
            }
          });
        });
      });
    });
    var entry = CFB.find(cfb, dependents[1].location);
    var x = parse_iwa_file(decompress_iwa_file(entry.content));
    var docroot;
    for (var xi = 0; xi < x.length; ++xi) {
      var packet = x[xi];
      if (packet.id == 1)
        docroot = packet;
    }
    var sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[1][0].data);
    entry = CFB.find(cfb, dependents[sheetrootref].location);
    x = parse_iwa_file(decompress_iwa_file(entry.content));
    for (xi = 0; xi < x.length; ++xi) {
      packet = x[xi];
      if (packet.id == sheetrootref)
        docroot = packet;
    }
    sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
    entry = CFB.find(cfb, dependents[sheetrootref].location);
    x = parse_iwa_file(decompress_iwa_file(entry.content));
    for (xi = 0; xi < x.length; ++xi) {
      packet = x[xi];
      if (packet.id == sheetrootref)
        docroot = packet;
    }
    sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
    entry = CFB.find(cfb, dependents[sheetrootref].location);
    x = parse_iwa_file(decompress_iwa_file(entry.content));
    for (xi = 0; xi < x.length; ++xi) {
      packet = x[xi];
      if (packet.id == sheetrootref)
        docroot = packet;
    }
    var pb = parse_shallow(docroot.messages[0].data);
    {
      pb[6][0].data = write_varint49(range.e.r + 1);
      pb[7][0].data = write_varint49(range.e.c + 1);
      var cruidsref = parse_TSP_Reference(pb[46][0].data);
      var oldbucket = CFB.find(cfb, dependents[cruidsref].location);
      var _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
      {
        for (var j = 0; j < _x.length; ++j) {
          if (_x[j].id == cruidsref)
            break;
        }
        if (_x[j].id != cruidsref)
          throw "Bad ColumnRowUIDMapArchive";
        var cruids = parse_shallow(_x[j].messages[0].data);
        cruids[1] = [];
        cruids[2] = [], cruids[3] = [];
        for (var C = 0; C <= range.e.c; ++C) {
          var uuid = [];
          uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(C + 420690) }];
          cruids[1].push({ type: 2, data: write_shallow(uuid) });
          cruids[2].push({ type: 0, data: write_varint49(C) });
          cruids[3].push({ type: 0, data: write_varint49(C) });
        }
        cruids[4] = [];
        cruids[5] = [], cruids[6] = [];
        for (var R = 0; R <= range.e.r; ++R) {
          uuid = [];
          uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(R + 726270) }];
          cruids[4].push({ type: 2, data: write_shallow(uuid) });
          cruids[5].push({ type: 0, data: write_varint49(R) });
          cruids[6].push({ type: 0, data: write_varint49(R) });
        }
        _x[j].messages[0].data = write_shallow(cruids);
      }
      oldbucket.content = compress_iwa_file(write_iwa_file(_x));
      oldbucket.size = oldbucket.content.length;
      delete pb[46];
      var store = parse_shallow(pb[4][0].data);
      {
        store[7][0].data = write_varint49(range.e.r + 1);
        var row_headers = parse_shallow(store[1][0].data);
        var row_header_ref = parse_TSP_Reference(row_headers[2][0].data);
        oldbucket = CFB.find(cfb, dependents[row_header_ref].location);
        _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
        {
          if (_x[0].id != row_header_ref)
            throw "Bad HeaderStorageBucket";
          var base_bucket = parse_shallow(_x[0].messages[0].data);
          for (R = 0; R < data.length; ++R) {
            var _bucket = parse_shallow(base_bucket[2][0].data);
            _bucket[1][0].data = write_varint49(R);
            _bucket[4][0].data = write_varint49(data[R].length);
            base_bucket[2][R] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
          }
          _x[0].messages[0].data = write_shallow(base_bucket);
        }
        oldbucket.content = compress_iwa_file(write_iwa_file(_x));
        oldbucket.size = oldbucket.content.length;
        var col_header_ref = parse_TSP_Reference(store[2][0].data);
        oldbucket = CFB.find(cfb, dependents[col_header_ref].location);
        _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
        {
          if (_x[0].id != col_header_ref)
            throw "Bad HeaderStorageBucket";
          base_bucket = parse_shallow(_x[0].messages[0].data);
          for (C = 0; C <= range.e.c; ++C) {
            _bucket = parse_shallow(base_bucket[2][0].data);
            _bucket[1][0].data = write_varint49(C);
            _bucket[4][0].data = write_varint49(range.e.r + 1);
            base_bucket[2][C] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
          }
          _x[0].messages[0].data = write_shallow(base_bucket);
        }
        oldbucket.content = compress_iwa_file(write_iwa_file(_x));
        oldbucket.size = oldbucket.content.length;
        var sstref = parse_TSP_Reference(store[4][0].data);
        (function() {
          var sentry = CFB.find(cfb, dependents[sstref].location);
          var sx = parse_iwa_file(decompress_iwa_file(sentry.content));
          var sstroot;
          for (var sxi = 0; sxi < sx.length; ++sxi) {
            var packet2 = sx[sxi];
            if (packet2.id == sstref)
              sstroot = packet2;
          }
          var sstdata = parse_shallow(sstroot.messages[0].data);
          {
            sstdata[3] = [];
            var newsst = [];
            SST.forEach(function(str, i) {
              newsst[1] = [{ type: 0, data: write_varint49(i) }];
              newsst[2] = [{ type: 0, data: write_varint49(1) }];
              newsst[3] = [{ type: 2, data: stru8(str) }];
              sstdata[3].push({ type: 2, data: write_shallow(newsst) });
            });
          }
          sstroot.messages[0].data = write_shallow(sstdata);
          var sy = write_iwa_file(sx);
          var raw32 = compress_iwa_file(sy);
          sentry.content = raw32;
          sentry.size = sentry.content.length;
        })();
        var tile = parse_shallow(store[3][0].data);
        {
          var t = tile[1][0];
          delete tile[2];
          var tl = parse_shallow(t.data);
          {
            var tileref = parse_TSP_Reference(tl[2][0].data);
            (function() {
              var tentry = CFB.find(cfb, dependents[tileref].location);
              var tx = parse_iwa_file(decompress_iwa_file(tentry.content));
              var tileroot;
              for (var sxi = 0; sxi < tx.length; ++sxi) {
                var packet2 = tx[sxi];
                if (packet2.id == tileref)
                  tileroot = packet2;
              }
              var tiledata = parse_shallow(tileroot.messages[0].data);
              {
                delete tiledata[6];
                delete tile[7];
                var rowload = new Uint8Array(tiledata[5][0].data);
                tiledata[5] = [];
                var cnt = 0;
                for (var R2 = 0; R2 <= range.e.r; ++R2) {
                  var tilerow = parse_shallow(rowload);
                  cnt += write_tile_row(tilerow, data[R2], SST);
                  tilerow[1][0].data = write_varint49(R2);
                  tiledata[5].push({ data: write_shallow(tilerow), type: 2 });
                }
                tiledata[1] = [{ type: 0, data: write_varint49(range.e.c + 1) }];
                tiledata[2] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
                tiledata[3] = [{ type: 0, data: write_varint49(cnt) }];
                tiledata[4] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
              }
              tileroot.messages[0].data = write_shallow(tiledata);
              var ty = write_iwa_file(tx);
              var raw32 = compress_iwa_file(ty);
              tentry.content = raw32;
              tentry.size = tentry.content.length;
            })();
          }
          t.data = write_shallow(tl);
        }
        store[3][0].data = write_shallow(tile);
      }
      pb[4][0].data = write_shallow(store);
    }
    docroot.messages[0].data = write_shallow(pb);
    var y = write_iwa_file(x);
    var raw3 = compress_iwa_file(y);
    entry.content = raw3;
    entry.size = entry.content.length;
    return cfb;
  }
  function fix_opts_func(defaults/*:Array<Array<any> >*/)/*:{(o:any):void}*/ {
  	return function fix_opts(opts) {
  		for(var i = 0; i != defaults.length; ++i) {
  			var d = defaults[i];
  			if(opts[d[0]] === undefined) opts[d[0]] = d[1];
  			if(d[2] === 'n') opts[d[0]] = Number(opts[d[0]]);
  		}
  	};
  }

  function fix_write_opts(opts) {
  fix_opts_func([
  	['cellDates', false], /* write date cells with type `d` */

  	['bookSST', false], /* Generate Shared String Table */

  	['bookType', 'xlsx'], /* Type of workbook (xlsx/m/b) */

  	['compression', false], /* Use file compression */

  	['WTF', false] /* WTF mode (throws errors) */
  ])(opts);
  }

  function write_zip(wb/*:Workbook*/, opts/*:WriteOpts*/)/*:ZIP*/ {
  	if(opts.bookType == "ods") return write_ods(wb, opts);
  	if(opts.bookType == "numbers") return write_numbers_iwa(wb, opts);
  	if(opts.bookType == "xlsb") return write_zip_xlsxb(wb, opts);
  	return write_zip_xlsx(wb, opts);
  }

  /* XLSX and XLSB writing are very similar.  Originally they were unified in one
     export function.  This is horrible for tree shaking in the common case (most
     applications need to export files in one format) so this function supports
     both formats while write_zip_xlsx only handles XLSX */
  function write_zip_xlsxb(wb/*:Workbook*/, opts/*:WriteOpts*/)/*:ZIP*/ {
  	_shapeid = 1024;
  	if(wb && !wb.SSF) {
  		wb.SSF = dup(table_fmt);
  	}
  	if(wb && wb.SSF) {
  		make_ssf(); SSF_load_table(wb.SSF);
  		// $FlowIgnore
  		opts.revssf = evert_num(wb.SSF); opts.revssf[wb.SSF[65535]] = 0;
  		opts.ssf = wb.SSF;
  	}
  	opts.rels = {}; opts.wbrels = {};
  	opts.Strings = /*::((*/[]/*:: :any):SST)*/; opts.Strings.Count = 0; opts.Strings.Unique = 0;
  	if(browser_has_Map) opts.revStrings = new Map();
  	else { opts.revStrings = {}; opts.revStrings.foo = []; delete opts.revStrings.foo; }
  	var wbext = opts.bookType == "xlsb" ? "bin" : "xml";
  	var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
  	var ct = new_ct();
  	fix_write_opts(opts = opts || {});
  	var zip = zip_new();
  	var f = "", rId = 0;

  	opts.cellXfs = [];
  	get_cell_style(opts.cellXfs, {}, {revssf:{"General":0}});

  	if(!wb.Props) wb.Props = {};

  	f = "docProps/core.xml";
  	zip_add_file(zip, f, write_core_props(wb.Props, opts));
  	ct.coreprops.push(f);
  	add_rels(opts.rels, 2, f, RELS.CORE_PROPS);

  	/*::if(!wb.Props) throw "unreachable"; */
  	f = "docProps/app.xml";
  	if(wb.Props && wb.Props.SheetNames);
  	else if(!wb.Workbook || !wb.Workbook.Sheets) wb.Props.SheetNames = wb.SheetNames;
  	else {
  		var _sn = [];
  		for(var _i = 0; _i < wb.SheetNames.length; ++_i)
  			if((wb.Workbook.Sheets[_i]||{}).Hidden != 2) _sn.push(wb.SheetNames[_i]);
  		wb.Props.SheetNames = _sn;
  	}
  	wb.Props.Worksheets = wb.Props.SheetNames.length;
  	zip_add_file(zip, f, write_ext_props(wb.Props));
  	ct.extprops.push(f);
  	add_rels(opts.rels, 3, f, RELS.EXT_PROPS);

  	if(wb.Custprops !== wb.Props && keys(wb.Custprops||{}).length > 0) {
  		f = "docProps/custom.xml";
  		zip_add_file(zip, f, write_cust_props(wb.Custprops));
  		ct.custprops.push(f);
  		add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
  	}

  	for(rId=1;rId <= wb.SheetNames.length; ++rId) {
  		var wsrels = {'!id':{}};
  		var ws = wb.Sheets[wb.SheetNames[rId-1]];
  		var _type = (ws || {})["!type"] || "sheet";
  		switch(_type) {
  		case "chart":
  			/* falls through */
  		default:
  			f = "xl/worksheets/sheet" + rId + "." + wbext;
  			zip_add_file(zip, f, write_ws(rId-1, f, opts, wb, wsrels));
  			ct.sheets.push(f);
  			add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
  		}

  		if(ws) {
  			var comments = ws['!comments'];
  			var need_vml = false;
  			var cf = "";
  			if(comments && comments.length > 0) {
  				cf = "xl/comments" + rId + "." + wbext;
  				zip_add_file(zip, cf, write_cmnt(comments, cf));
  				ct.comments.push(cf);
  				add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
  				need_vml = true;
  			}
  			if(ws['!legacy']) {
  				if(need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + (rId) + ".vml", write_comments_vml(rId, ws['!comments']));
  			}
  			delete ws['!comments'];
  			delete ws['!legacy'];
  		}

  		if(wsrels['!id'].rId1) zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
  	}

  	if(opts.Strings != null && opts.Strings.length > 0) {
  		f = "xl/sharedStrings." + wbext;
  		zip_add_file(zip, f, write_sst(opts.Strings, f, opts));
  		ct.strs.push(f);
  		add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
  	}

  	f = "xl/workbook." + wbext;
  	zip_add_file(zip, f, write_wb(wb, f));
  	ct.workbooks.push(f);
  	add_rels(opts.rels, 1, f, RELS.WB);

  	/* TODO: something more intelligent with themes */

  	f = "xl/theme/theme1.xml";
  	zip_add_file(zip, f, write_theme(wb.Themes, opts));
  	ct.themes.push(f);
  	add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);

  	/* TODO: something more intelligent with styles */

  	f = "xl/styles." + wbext;
  	zip_add_file(zip, f, write_sty(wb, f, opts));
  	ct.styles.push(f);
  	add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);

  	if(wb.vbaraw && vbafmt) {
  		f = "xl/vbaProject.bin";
  		zip_add_file(zip, f, wb.vbaraw);
  		ct.vba.push(f);
  		add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
  	}

  	f = "xl/metadata." + wbext;
  	zip_add_file(zip, f, write_xlmeta(f));
  	ct.metadata.push(f);
  	add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);

  	zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
  	zip_add_file(zip, '_rels/.rels', write_rels(opts.rels));
  	zip_add_file(zip, 'xl/_rels/workbook.' + wbext + '.rels', write_rels(opts.wbrels));

  	delete opts.revssf; delete opts.ssf;
  	return zip;
  }

  function write_zip_xlsx(wb/*:Workbook*/, opts/*:WriteOpts*/)/*:ZIP*/ {
  	_shapeid = 1024;
  	if(wb && !wb.SSF) {
  		wb.SSF = dup(table_fmt);
  	}
  	if(wb && wb.SSF) {
  		make_ssf(); SSF_load_table(wb.SSF);
  		// $FlowIgnore
  		opts.revssf = evert_num(wb.SSF); opts.revssf[wb.SSF[65535]] = 0;
  		opts.ssf = wb.SSF;
  	}
  	opts.rels = {}; opts.wbrels = {};
  	opts.Strings = /*::((*/[]/*:: :any):SST)*/; opts.Strings.Count = 0; opts.Strings.Unique = 0;
  	if(browser_has_Map) opts.revStrings = new Map();
  	else { opts.revStrings = {}; opts.revStrings.foo = []; delete opts.revStrings.foo; }
  	var wbext = "xml";
  	var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
  	var ct = new_ct();
  	fix_write_opts(opts = opts || {});
  	var zip = zip_new();
  	var f = "", rId = 0;

  	opts.cellXfs = [];
  	get_cell_style(opts.cellXfs, {}, {revssf:{"General":0}});

  	if(!wb.Props) wb.Props = {};

  	f = "docProps/core.xml";
  	zip_add_file(zip, f, write_core_props(wb.Props, opts));
  	ct.coreprops.push(f);
  	add_rels(opts.rels, 2, f, RELS.CORE_PROPS);

  	/*::if(!wb.Props) throw "unreachable"; */
  	f = "docProps/app.xml";
  	if(wb.Props && wb.Props.SheetNames);
  	else if(!wb.Workbook || !wb.Workbook.Sheets) wb.Props.SheetNames = wb.SheetNames;
  	else {
  		var _sn = [];
  		for(var _i = 0; _i < wb.SheetNames.length; ++_i)
  			if((wb.Workbook.Sheets[_i]||{}).Hidden != 2) _sn.push(wb.SheetNames[_i]);
  		wb.Props.SheetNames = _sn;
  	}
  	wb.Props.Worksheets = wb.Props.SheetNames.length;
  	zip_add_file(zip, f, write_ext_props(wb.Props));
  	ct.extprops.push(f);
  	add_rels(opts.rels, 3, f, RELS.EXT_PROPS);

  	if(wb.Custprops !== wb.Props && keys(wb.Custprops||{}).length > 0) {
  		f = "docProps/custom.xml";
  		zip_add_file(zip, f, write_cust_props(wb.Custprops));
  		ct.custprops.push(f);
  		add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
  	}

  	var people = ["SheetJ5"];
  	opts.tcid = 0;

  	for(rId=1;rId <= wb.SheetNames.length; ++rId) {
  		var wsrels = {'!id':{}};
  		var ws = wb.Sheets[wb.SheetNames[rId-1]];
  		var _type = (ws || {})["!type"] || "sheet";
  		switch(_type) {
  		case "chart":
  			/* falls through */
  		default:
  			f = "xl/worksheets/sheet" + rId + "." + wbext;
  			zip_add_file(zip, f, write_ws_xml(rId-1, opts, wb, wsrels));
  			ct.sheets.push(f);
  			add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
  		}

  		if(ws) {
  			var comments = ws['!comments'];
  			var need_vml = false;
  			var cf = "";
  			if(comments && comments.length > 0) {
  				var needtc = false;
  				comments.forEach(function(carr) {
  					carr[1].forEach(function(c) { if(c.T == true) needtc = true; });
  				});
  				if(needtc) {
  					cf = "xl/threadedComments/threadedComment" + rId + "." + wbext;
  					zip_add_file(zip, cf, write_tcmnt_xml(comments, people, opts));
  					ct.threadedcomments.push(cf);
  					add_rels(wsrels, -1, "../threadedComments/threadedComment" + rId + "." + wbext, RELS.TCMNT);
  				}

  				cf = "xl/comments" + rId + "." + wbext;
  				zip_add_file(zip, cf, write_comments_xml(comments));
  				ct.comments.push(cf);
  				add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
  				need_vml = true;
  			}
  			if(ws['!legacy']) {
  				if(need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + (rId) + ".vml", write_comments_vml(rId, ws['!comments']));
  			}
  			delete ws['!comments'];
  			delete ws['!legacy'];
  		}

  		if(wsrels['!id'].rId1) zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
  	}

  	if(opts.Strings != null && opts.Strings.length > 0) {
  		f = "xl/sharedStrings." + wbext;
  		zip_add_file(zip, f, write_sst_xml(opts.Strings, opts));
  		ct.strs.push(f);
  		add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
  	}

  	f = "xl/workbook." + wbext;
  	zip_add_file(zip, f, write_wb_xml(wb));
  	ct.workbooks.push(f);
  	add_rels(opts.rels, 1, f, RELS.WB);

  	/* TODO: something more intelligent with themes */

  	f = "xl/theme/theme1.xml";
  	zip_add_file(zip, f, write_theme(wb.Themes, opts));
  	ct.themes.push(f);
  	add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);

  	/* TODO: something more intelligent with styles */

  	f = "xl/styles." + wbext;
  	zip_add_file(zip, f, write_sty_xml(wb, opts));
  	ct.styles.push(f);
  	add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);

  	if(wb.vbaraw && vbafmt) {
  		f = "xl/vbaProject.bin";
  		zip_add_file(zip, f, wb.vbaraw);
  		ct.vba.push(f);
  		add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
  	}

  	f = "xl/metadata." + wbext;
  	zip_add_file(zip, f, write_xlmeta_xml());
  	ct.metadata.push(f);
  	add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);

  	if(people.length > 1) {
  		f = "xl/persons/person.xml";
  		zip_add_file(zip, f, write_people_xml(people));
  		ct.people.push(f);
  		add_rels(opts.wbrels, -1, "persons/person.xml", RELS.PEOPLE);
  	}

  	zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
  	zip_add_file(zip, '_rels/.rels', write_rels(opts.rels));
  	zip_add_file(zip, 'xl/_rels/workbook.' + wbext + '.rels', write_rels(opts.wbrels));

  	delete opts.revssf; delete opts.ssf;
  	return zip;
  }

  function firstbyte(f/*:RawData*/,o/*:?TypeOpts*/)/*:Array<number>*/ {
  	var x = "";
  	switch((o||{}).type || "base64") {
  		case 'buffer': return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
  		case 'base64': x = Base64_decode(f.slice(0,12)); break;
  		case 'binary': x = f; break;
  		case 'array':  return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
  		default: throw new Error("Unrecognized type " + (o && o.type || "undefined"));
  	}
  	return [x.charCodeAt(0), x.charCodeAt(1), x.charCodeAt(2), x.charCodeAt(3), x.charCodeAt(4), x.charCodeAt(5), x.charCodeAt(6), x.charCodeAt(7)];
  }
  function write_cfb_ctr(cfb/*:CFBContainer*/, o/*:WriteOpts*/)/*:any*/ {
  	switch(o.type) {
  		case "base64": case "binary": break;
  		case "buffer": case "array": o.type = ""; break;
  		case "file": return write_dl(o.file, CFB.write(cfb, {type:has_buf ? 'buffer' : ""}));
  		case "string": throw new Error("'string' output type invalid for '" + o.bookType + "' files");
  		default: throw new Error("Unrecognized type " + o.type);
  	}
  	return CFB.write(cfb, o);
  }

  /*:: declare var encrypt_agile:any; */
  function write_zip_type(wb/*:Workbook*/, opts/*:?WriteOpts*/)/*:any*/ {
  	var o = dup(opts||{});
  	var z = write_zip(wb, o);
  	return write_zip_denouement(z, o);
  }
  function write_zip_denouement(z/*:any*/, o/*:?WriteOpts*/)/*:any*/ {
  	var oopts = {};
  	var ftype = has_buf ? "nodebuffer" : (typeof Uint8Array !== "undefined" ? "array" : "string");
  	if(o.compression) oopts.compression = 'DEFLATE';
  	if(o.password) oopts.type = ftype;
  	else switch(o.type) {
  		case "base64": oopts.type = "base64"; break;
  		case "binary": oopts.type = "string"; break;
  		case "string": throw new Error("'string' output type invalid for '" + o.bookType + "' files");
  		case "buffer":
  		case "file": oopts.type = ftype; break;
  		default: throw new Error("Unrecognized type " + o.type);
  	}
  	var out = z.FullPaths ? CFB.write(z, {fileType:"zip", type: /*::(*/{"nodebuffer": "buffer", "string": "binary"}/*:: :any)*/[oopts.type] || oopts.type, compression: !!o.compression}) : z.generate(oopts);
  	if(typeof Deno !== "undefined") {
  		if(typeof out == "string") {
  			if(o.type == "binary" || o.type == "base64") return out;
  			out = new Uint8Array(s2ab(out));
  		}
  	}
  /*jshint -W083 */
  	if(o.password && typeof encrypt_agile !== 'undefined') return write_cfb_ctr(encrypt_agile(out, o.password), o); // eslint-disable-line no-undef
  /*jshint +W083 */
  	if(o.type === "file") return write_dl(o.file, out);
  	return o.type == "string" ? utf8read(/*::(*/out/*:: :any)*/) : out;
  }

  function write_cfb_type(wb/*:Workbook*/, opts/*:?WriteOpts*/)/*:any*/ {
  	var o = opts||{};
  	var cfb/*:CFBContainer*/ = write_xlscfb(wb, o);
  	return write_cfb_ctr(cfb, o);
  }

  function write_string_type(out/*:string*/, opts/*:WriteOpts*/, bom/*:?string*/)/*:any*/ {
  	if(!bom) bom = "";
  	var o = bom + out;
  	switch(opts.type) {
  		case "base64": return Base64_encode(utf8write(o));
  		case "binary": return utf8write(o);
  		case "string": return out;
  		case "file": return write_dl(opts.file, o, 'utf8');
  		case "buffer": {
  			if(has_buf) return Buffer_from(o, 'utf8');
  			else if(typeof TextEncoder !== "undefined") return new TextEncoder().encode(o);
  			else return write_string_type(o, {type:'binary'}).split("").map(function(c) { return c.charCodeAt(0); });
  		}
  	}
  	throw new Error("Unrecognized type " + opts.type);
  }

  function write_stxt_type(out/*:string*/, opts/*:WriteOpts*/)/*:any*/ {
  	switch(opts.type) {
  		case "base64": return Base64_encode(out);
  		case "binary": return out;
  		case "string": return out; /* override in sheet_to_txt */
  		case "file": return write_dl(opts.file, out, 'binary');
  		case "buffer": {
  			if(has_buf) return Buffer_from(out, 'binary');
  			else return out.split("").map(function(c) { return c.charCodeAt(0); });
  		}
  	}
  	throw new Error("Unrecognized type " + opts.type);
  }

  /* TODO: test consistency */
  function write_binary_type(out, opts/*:WriteOpts*/)/*:any*/ {
  	switch(opts.type) {
  		case "string":
  		case "base64":
  		case "binary":
  			var bstr = "";
  			// $FlowIgnore
  			for(var i = 0; i < out.length; ++i) bstr += String.fromCharCode(out[i]);
  			return opts.type == 'base64' ? Base64_encode(bstr) : opts.type == 'string' ? utf8read(bstr) : bstr;
  		case "file": return write_dl(opts.file, out);
  		case "buffer": return out;
  		default: throw new Error("Unrecognized type " + opts.type);
  	}
  }

  function writeSync(wb/*:Workbook*/, opts/*:?WriteOpts*/) {
  	reset_cp();
  	check_wb(wb);
  	var o = dup(opts||{});
  	if(o.cellStyles) { o.cellNF = true; o.sheetStubs = true; }
  	if(o.type == "array") { o.type = "binary"; var out/*:string*/ = (writeSync(wb, o)/*:any*/); o.type = "array"; return s2ab(out); }
  	var idx = 0;
  	if(o.sheet) {
  		if(typeof o.sheet == "number") idx = o.sheet;
  		else idx = wb.SheetNames.indexOf(o.sheet);
  		if(!wb.SheetNames[idx]) throw new Error("Sheet not found: " + o.sheet + " : " + (typeof o.sheet));
  	}
  	switch(o.bookType || 'xlsb') {
  		case 'xml':
  		case 'xlml': return write_string_type(write_xlml(wb, o), o);
  		case 'slk':
  		case 'sylk': return write_string_type(SYLK.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
  		case 'htm':
  		case 'html': return write_string_type(sheet_to_html(wb.Sheets[wb.SheetNames[idx]], o), o);
  		case 'txt': return write_stxt_type(sheet_to_txt(wb.Sheets[wb.SheetNames[idx]], o), o);
  		case 'csv': return write_string_type(sheet_to_csv(wb.Sheets[wb.SheetNames[idx]], o), o, "\ufeff");
  		case 'dif': return write_string_type(DIF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
  		case 'dbf': return write_binary_type(DBF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
  		case 'prn': return write_string_type(PRN.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
  		case 'rtf': return write_string_type(RTF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
  		case 'eth': return write_string_type(ETH.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
  		case 'fods': return write_string_type(write_ods(wb, o), o);
  		case 'wk1': return write_binary_type(WK_.sheet_to_wk1(wb.Sheets[wb.SheetNames[idx]], o), o);
  		case 'wk3': return write_binary_type(WK_.book_to_wk3(wb, o), o);
  		case 'biff2': if(!o.biff) o.biff = 2; /* falls through */
  		case 'biff3': if(!o.biff) o.biff = 3; /* falls through */
  		case 'biff4': if(!o.biff) o.biff = 4; return write_binary_type(write_biff_buf(wb, o), o);
  		case 'biff5': if(!o.biff) o.biff = 5; /* falls through */
  		case 'biff8':
  		case 'xla':
  		case 'xls': if(!o.biff) o.biff = 8; return write_cfb_type(wb, o);
  		case 'xlsx':
  		case 'xlsm':
  		case 'xlam':
  		case 'xlsb':
  		case 'numbers':
  		case 'ods': return write_zip_type(wb, o);
  		default: throw new Error ("Unrecognized bookType |" + o.bookType + "|");
  	}
  }

  function resolve_book_type(o/*:WriteFileOpts*/) {
  	if(o.bookType) return;
  	var _BT = {
  		"xls": "biff8",
  		"htm": "html",
  		"slk": "sylk",
  		"socialcalc": "eth",
  		"Sh33tJS": "WTF"
  	};
  	var ext = o.file.slice(o.file.lastIndexOf(".")).toLowerCase();
  	if(ext.match(/^\.[a-z]+$/)) o.bookType = ext.slice(1);
  	o.bookType = _BT[o.bookType] || o.bookType;
  }

  function writeFileSync(wb/*:Workbook*/, filename/*:string*/, opts/*:?WriteFileOpts*/) {
  	var o = opts||{}; o.type = 'file';
  	o.file = filename;
  	resolve_book_type(o);
  	return writeSync(wb, o);
  }
  /*::
  type MJRObject = {
  	row: any;
  	isempty: boolean;
  };
  */
  function make_json_row(sheet/*:Worksheet*/, r/*:Range*/, R/*:number*/, cols/*:Array<string>*/, header/*:number*/, hdr/*:Array<any>*/, dense/*:boolean*/, o/*:Sheet2JSONOpts*/)/*:MJRObject*/ {
  	var rr = encode_row(R);
  	var defval = o.defval, raw = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw");
  	var isempty = true;
  	var row/*:any*/ = (header === 1) ? [] : {};
  	if(header !== 1) {
  		if(Object.defineProperty) try { Object.defineProperty(row, '__rowNum__', {value:R, enumerable:false}); } catch(e) { row.__rowNum__ = R; }
  		else row.__rowNum__ = R;
  	}
  	if(!dense || sheet[R]) for (var C = r.s.c; C <= r.e.c; ++C) {
  		var val = dense ? sheet[R][C] : sheet[cols[C] + rr];
  		if(val === undefined || val.t === undefined) {
  			if(defval === undefined) continue;
  			if(hdr[C] != null) { row[hdr[C]] = defval; }
  			continue;
  		}
  		var v = val.v;
  		switch(val.t){
  			case 'z': if(v == null) break; continue;
  			case 'e': v = (v == 0 ? null : void 0); break;
  			case 's': case 'd': case 'b': case 'n': break;
  			default: throw new Error('unrecognized type ' + val.t);
  		}
  		if(hdr[C] != null) {
  			if(v == null) {
  				if(val.t == "e" && v === null) row[hdr[C]] = null;
  				else if(defval !== undefined) row[hdr[C]] = defval;
  				else if(raw && v === null) row[hdr[C]] = null;
  				else continue;
  			} else {
  				row[hdr[C]] = raw && (val.t !== "n" || (val.t === "n" && o.rawNumbers !== false)) ? v : format_cell(val,v,o);
  			}
  			if(v != null) isempty = false;
  		}
  	}
  	return { row: row, isempty: isempty };
  }


  function sheet_to_json(sheet/*:Worksheet*/, opts/*:?Sheet2JSONOpts*/) {
  	if(sheet == null || sheet["!ref"] == null) return [];
  	var val = {t:'n',v:0}, header = 0, offset = 1, hdr/*:Array<any>*/ = [], v=0, vv="";
  	var r = {s:{r:0,c:0},e:{r:0,c:0}};
  	var o = opts || {};
  	var range = o.range != null ? o.range : sheet["!ref"];
  	if(o.header === 1) header = 1;
  	else if(o.header === "A") header = 2;
  	else if(Array.isArray(o.header)) header = 3;
  	else if(o.header == null) header = 0;
  	switch(typeof range) {
  		case 'string': r = safe_decode_range(range); break;
  		case 'number': r = safe_decode_range(sheet["!ref"]); r.s.r = range; break;
  		default: r = range;
  	}
  	if(header > 0) offset = 0;
  	var rr = encode_row(r.s.r);
  	var cols/*:Array<string>*/ = [];
  	var out/*:Array<any>*/ = [];
  	var outi = 0, counter = 0;
  	var dense = Array.isArray(sheet);
  	var R = r.s.r, C = 0;
  	var header_cnt = {};
  	if(dense && !sheet[R]) sheet[R] = [];
  	var colinfo/*:Array<ColInfo>*/ = o.skipHidden && sheet["!cols"] || [];
  	var rowinfo/*:Array<ColInfo>*/ = o.skipHidden && sheet["!rows"] || [];
  	for(C = r.s.c; C <= r.e.c; ++C) {
  		if(((colinfo[C]||{}).hidden)) continue;
  		cols[C] = encode_col(C);
  		val = dense ? sheet[R][C] : sheet[cols[C] + rr];
  		switch(header) {
  			case 1: hdr[C] = C - r.s.c; break;
  			case 2: hdr[C] = cols[C]; break;
  			case 3: hdr[C] = o.header[C - r.s.c]; break;
  			default:
  				if(val == null) val = {w: "__EMPTY", t: "s"};
  				vv = v = format_cell(val, null, o);
  				counter = header_cnt[v] || 0;
  				if(!counter) header_cnt[v] = 1;
  				else {
  					do { vv = v + "_" + (counter++); } while(header_cnt[vv]); header_cnt[v] = counter;
  					header_cnt[vv] = 1;
  				}
  				hdr[C] = vv;
  		}
  	}
  	for (R = r.s.r + offset; R <= r.e.r; ++R) {
  		if ((rowinfo[R]||{}).hidden) continue;
  		var row = make_json_row(sheet, r, R, cols, header, hdr, dense, o);
  		if((row.isempty === false) || (header === 1 ? o.blankrows !== false : !!o.blankrows)) out[outi++] = row.row;
  	}
  	out.length = outi;
  	return out;
  }

  var qreg = /"/g;
  function make_csv_row(sheet/*:Worksheet*/, r/*:Range*/, R/*:number*/, cols/*:Array<string>*/, fs/*:number*/, rs/*:number*/, FS/*:string*/, o/*:Sheet2CSVOpts*/)/*:?string*/ {
  	var isempty = true;
  	var row/*:Array<string>*/ = [], txt = "", rr = encode_row(R);
  	for(var C = r.s.c; C <= r.e.c; ++C) {
  		if (!cols[C]) continue;
  		var val = o.dense ? (sheet[R]||[])[C]: sheet[cols[C] + rr];
  		if(val == null) txt = "";
  		else if(val.v != null) {
  			isempty = false;
  			txt = ''+(o.rawNumbers && val.t == "n" ? val.v : format_cell(val, null, o));
  			for(var i = 0, cc = 0; i !== txt.length; ++i) if((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34 || o.forceQuotes) {txt = "\"" + txt.replace(qreg, '""') + "\""; break; }
  			if(txt == "ID") txt = '"ID"';
  		} else if(val.f != null && !val.F) {
  			isempty = false;
  			txt = '=' + val.f; if(txt.indexOf(",") >= 0) txt = '"' + txt.replace(qreg, '""') + '"';
  		} else txt = "";
  		/* NOTE: Excel CSV does not support array formulae */
  		row.push(txt);
  	}
  	if(o.blankrows === false && isempty) return null;
  	return row.join(FS);
  }

  function sheet_to_csv(sheet/*:Worksheet*/, opts/*:?Sheet2CSVOpts*/)/*:string*/ {
  	var out/*:Array<string>*/ = [];
  	var o = opts == null ? {} : opts;
  	if(sheet == null || sheet["!ref"] == null) return "";
  	var r = safe_decode_range(sheet["!ref"]);
  	var FS = o.FS !== undefined ? o.FS : ",", fs = FS.charCodeAt(0);
  	var RS = o.RS !== undefined ? o.RS : "\n", rs = RS.charCodeAt(0);
  	var endregex = new RegExp((FS=="|" ? "\\|" : FS)+"+$");
  	var row = "", cols/*:Array<string>*/ = [];
  	o.dense = Array.isArray(sheet);
  	var colinfo/*:Array<ColInfo>*/ = o.skipHidden && sheet["!cols"] || [];
  	var rowinfo/*:Array<ColInfo>*/ = o.skipHidden && sheet["!rows"] || [];
  	for(var C = r.s.c; C <= r.e.c; ++C) if (!((colinfo[C]||{}).hidden)) cols[C] = encode_col(C);
  	var w = 0;
  	for(var R = r.s.r; R <= r.e.r; ++R) {
  		if ((rowinfo[R]||{}).hidden) continue;
  		row = make_csv_row(sheet, r, R, cols, fs, rs, FS, o);
  		if(row == null) { continue; }
  		if(o.strip) row = row.replace(endregex,"");
  		if(row || (o.blankrows !== false)) out.push((w++ ? RS : "") + row);
  	}
  	delete o.dense;
  	return out.join("");
  }

  function sheet_to_txt(sheet/*:Worksheet*/, opts/*:?Sheet2CSVOpts*/) {
  	if(!opts) opts = {}; opts.FS = "\t"; opts.RS = "\n";
  	var s = sheet_to_csv(sheet, opts);
  	return s;
  }

  function sheet_to_formulae(sheet/*:Worksheet*/)/*:Array<string>*/ {
  	var y = "", x, val="";
  	if(sheet == null || sheet["!ref"] == null) return [];
  	var r = safe_decode_range(sheet['!ref']), rr = "", cols/*:Array<string>*/ = [], C;
  	var cmds/*:Array<string>*/ = [];
  	var dense = Array.isArray(sheet);
  	for(C = r.s.c; C <= r.e.c; ++C) cols[C] = encode_col(C);
  	for(var R = r.s.r; R <= r.e.r; ++R) {
  		rr = encode_row(R);
  		for(C = r.s.c; C <= r.e.c; ++C) {
  			y = cols[C] + rr;
  			x = dense ? (sheet[R]||[])[C] : sheet[y];
  			val = "";
  			if(x === undefined) continue;
  			else if(x.F != null) {
  				y = x.F;
  				if(!x.f) continue;
  				val = x.f;
  				if(y.indexOf(":") == -1) y = y + ":" + y;
  			}
  			if(x.f != null) val = x.f;
  			else if(x.t == 'z') continue;
  			else if(x.t == 'n' && x.v != null) val = "" + x.v;
  			else if(x.t == 'b') val = x.v ? "TRUE" : "FALSE";
  			else if(x.w !== undefined) val = "'" + x.w;
  			else if(x.v === undefined) continue;
  			else if(x.t == 's') val = "'" + x.v;
  			else val = ""+x.v;
  			cmds[cmds.length] = y + "=" + val;
  		}
  	}
  	return cmds;
  }

  function sheet_add_json(_ws/*:?Worksheet*/, js/*:Array<any>*/, opts)/*:Worksheet*/ {
  	var o = opts || {};
  	var offset = +!o.skipHeader;
  	var ws/*:Worksheet*/ = _ws || ({}/*:any*/);
  	var _R = 0, _C = 0;
  	if(ws && o.origin != null) {
  		if(typeof o.origin == 'number') _R = o.origin;
  		else {
  			var _origin/*:CellAddress*/ = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
  			_R = _origin.r; _C = _origin.c;
  		}
  	}
  	var cell/*:Cell*/;
  	var range/*:Range*/ = ({s: {c:0, r:0}, e: {c:_C, r:_R + js.length - 1 + offset}}/*:any*/);
  	if(ws['!ref']) {
  		var _range = safe_decode_range(ws['!ref']);
  		range.e.c = Math.max(range.e.c, _range.e.c);
  		range.e.r = Math.max(range.e.r, _range.e.r);
  		if(_R == -1) { _R = _range.e.r + 1; range.e.r = _R + js.length - 1 + offset; }
  	} else {
  		if(_R == -1) { _R = 0; range.e.r = js.length - 1 + offset; }
  	}
  	var hdr/*:Array<string>*/ = o.header || [], C = 0;

  	js.forEach(function (JS, R/*:number*/) {
  		keys(JS).forEach(function(k) {
  			if((C=hdr.indexOf(k)) == -1) hdr[C=hdr.length] = k;
  			var v = JS[k];
  			var t = 'z';
  			var z = "";
  			var ref = encode_cell({c:_C + C,r:_R + R + offset});
  			cell = ws_get_cell_stub(ws, ref);
  			if(v && typeof v === 'object' && !(v instanceof Date)){
  				ws[ref] = v;
  			} else {
  				if(typeof v == 'number') t = 'n';
  				else if(typeof v == 'boolean') t = 'b';
  				else if(typeof v == 'string') t = 's';
  				else if(v instanceof Date) {
  					t = 'd';
  					if(!o.cellDates) { t = 'n'; v = datenum(v); }
  					z = (o.dateNF || table_fmt[14]);
  				}
  				else if(v === null && o.nullError) { t = 'e'; v = 0; }
  				if(!cell) ws[ref] = cell = ({t:t, v:v}/*:any*/);
  				else {
  					cell.t = t; cell.v = v;
  					delete cell.w; delete cell.R;
  					if(z) cell.z = z;
  				}
  				if(z) cell.z = z;
  			}
  		});
  	});
  	range.e.c = Math.max(range.e.c, _C + hdr.length - 1);
  	var __R = encode_row(_R);
  	if(offset) for(C = 0; C < hdr.length; ++C) ws[encode_col(C + _C) + __R] = {t:'s', v:hdr[C]};
  	ws['!ref'] = encode_range(range);
  	return ws;
  }
  function json_to_sheet(js/*:Array<any>*/, opts)/*:Worksheet*/ { return sheet_add_json(null, js, opts); }

  /* get cell, creating a stub if necessary */
  function ws_get_cell_stub(ws/*:Worksheet*/, R, C/*:?number*/)/*:Cell*/ {
  	/* A1 cell address */
  	if(typeof R == "string") {
  		/* dense */
  		if(Array.isArray(ws)) {
  			var RC = decode_cell(R);
  			if(!ws[RC.r]) ws[RC.r] = [];
  			return ws[RC.r][RC.c] || (ws[RC.r][RC.c] = {t:'z'});
  		}
  		return ws[R] || (ws[R] = {t:'z'});
  	}
  	/* cell address object */
  	if(typeof R != "number") return ws_get_cell_stub(ws, encode_cell(R));
  	/* R and C are 0-based indices */
  	return ws_get_cell_stub(ws, encode_cell({r:R,c:C||0}));
  }

  /* find sheet index for given name / validate index */
  function wb_sheet_idx(wb/*:Workbook*/, sh/*:number|string*/) {
  	if(typeof sh == "number") {
  		if(sh >= 0 && wb.SheetNames.length > sh) return sh;
  		throw new Error("Cannot find sheet # " + sh);
  	} else if(typeof sh == "string") {
  		var idx = wb.SheetNames.indexOf(sh);
  		if(idx > -1) return idx;
  		throw new Error("Cannot find sheet name |" + sh + "|");
  	} else throw new Error("Cannot find sheet |" + sh + "|");
  }

  /* simple blank workbook object */
  function book_new()/*:Workbook*/ {
  	return { SheetNames: [], Sheets: {} };
  }

  /* add a worksheet to the end of a given workbook */
  function book_append_sheet(wb/*:Workbook*/, ws/*:Worksheet*/, name/*:?string*/, roll/*:?boolean*/)/*:string*/ {
  	var i = 1;
  	if(!name) for(; i <= 0xFFFF; ++i, name = undefined) if(wb.SheetNames.indexOf(name = "Sheet" + i) == -1) break;
  	if(!name || wb.SheetNames.length >= 0xFFFF) throw new Error("Too many worksheets");
  	if(roll && wb.SheetNames.indexOf(name) >= 0) {
  		var m = name.match(/(^.*?)(\d+)$/);
  		i = m && +m[2] || 0;
  		var root = m && m[1] || name;
  		for(++i; i <= 0xFFFF; ++i) if(wb.SheetNames.indexOf(name = root + i) == -1) break;
  	}
  	check_ws_name(name);
  	if(wb.SheetNames.indexOf(name) >= 0) throw new Error("Worksheet with name |" + name + "| already exists!");

  	wb.SheetNames.push(name);
  	wb.Sheets[name] = ws;
  	return name;
  }

  /* set sheet visibility (visible/hidden/very hidden) */
  function book_set_sheet_visibility(wb/*:Workbook*/, sh/*:number|string*/, vis/*:number*/) {
  	if(!wb.Workbook) wb.Workbook = {};
  	if(!wb.Workbook.Sheets) wb.Workbook.Sheets = [];

  	var idx = wb_sheet_idx(wb, sh);
  	// $FlowIgnore
  	if(!wb.Workbook.Sheets[idx]) wb.Workbook.Sheets[idx] = {};

  	switch(vis) {
  		case 0: case 1: case 2: break;
  		default: throw new Error("Bad sheet visibility setting " + vis);
  	}
  	// $FlowIgnore
  	wb.Workbook.Sheets[idx].Hidden = vis;
  }

  /* set number format */
  function cell_set_number_format(cell/*:Cell*/, fmt/*:string|number*/) {
  	cell.z = fmt;
  	return cell;
  }

  /* set cell hyperlink */
  function cell_set_hyperlink(cell/*:Cell*/, target/*:string*/, tooltip/*:?string*/) {
  	if(!target) {
  		delete cell.l;
  	} else {
  		cell.l = ({ Target: target }/*:Hyperlink*/);
  		if(tooltip) cell.l.Tooltip = tooltip;
  	}
  	return cell;
  }
  function cell_set_internal_link(cell/*:Cell*/, range/*:string*/, tooltip/*:?string*/) { return cell_set_hyperlink(cell, "#" + range, tooltip); }

  /* add to cell comments */
  function cell_add_comment(cell/*:Cell*/, text/*:string*/, author/*:?string*/) {
  	if(!cell.c) cell.c = [];
  	cell.c.push({t:text, a:author||"SheetJS"});
  }

  /* set array formula and flush related cells */
  function sheet_set_array_formula(ws/*:Worksheet*/, range, formula/*:string*/, dynamic/*:boolean*/) {
  	var rng = typeof range != "string" ? range : safe_decode_range(range);
  	var rngstr = typeof range == "string" ? range : encode_range(range);
  	for(var R = rng.s.r; R <= rng.e.r; ++R) for(var C = rng.s.c; C <= rng.e.c; ++C) {
  		var cell = ws_get_cell_stub(ws, R, C);
  		cell.t = 'n';
  		cell.F = rngstr;
  		delete cell.v;
  		if(R == rng.s.r && C == rng.s.c) {
  			cell.f = formula;
  			if(dynamic) cell.D = true;
  		}
  	}
  	return ws;
  }

  var utils/*:any*/ = {
  	encode_col: encode_col,
  	encode_row: encode_row,
  	encode_cell: encode_cell,
  	encode_range: encode_range,
  	decode_col: decode_col,
  	decode_row: decode_row,
  	split_cell: split_cell,
  	decode_cell: decode_cell,
  	decode_range: decode_range,
  	format_cell: format_cell,
  	sheet_add_aoa: sheet_add_aoa,
  	sheet_add_json: sheet_add_json,
  	sheet_add_dom: sheet_add_dom,
  	aoa_to_sheet: aoa_to_sheet,
  	json_to_sheet: json_to_sheet,
  	table_to_sheet: parse_dom_table,
  	table_to_book: table_to_book,
  	sheet_to_csv: sheet_to_csv,
  	sheet_to_txt: sheet_to_txt,
  	sheet_to_json: sheet_to_json,
  	sheet_to_html: sheet_to_html,
  	sheet_to_formulae: sheet_to_formulae,
  	sheet_to_row_object_array: sheet_to_json,
  	sheet_get_cell: ws_get_cell_stub,
  	book_new: book_new,
  	book_append_sheet: book_append_sheet,
  	book_set_sheet_visibility: book_set_sheet_visibility,
  	cell_set_number_format: cell_set_number_format,
  	cell_set_hyperlink: cell_set_hyperlink,
  	cell_set_internal_link: cell_set_internal_link,
  	cell_add_comment: cell_add_comment,
  	sheet_set_array_formula: sheet_set_array_formula,
  	consts: {
  		SHEET_VISIBLE: 0,
  		SHEET_HIDDEN: 1,
  		SHEET_VERY_HIDDEN: 2
  	}
  };

  var Exports = /*#__PURE__*/function () {
    function Exports(ctx) {
      _classCallCheck(this, Exports);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(Exports, [{
      key: "svgStringToNode",
      value: function svgStringToNode(svgString) {
        var parser = new DOMParser();
        var svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
        return svgDoc.documentElement;
      }
    }, {
      key: "scaleSvgNode",
      value: function scaleSvgNode(svg, scale) {
        // get current both width and height of the svg
        var svgWidth = parseFloat(svg.getAttributeNS(null, 'width'));
        var svgHeight = parseFloat(svg.getAttributeNS(null, 'height'));
        // set new width and height based on the scale
        svg.setAttributeNS(null, 'width', svgWidth * scale);
        svg.setAttributeNS(null, 'height', svgHeight * scale);
        svg.setAttributeNS(null, 'viewBox', '0 0 ' + svgWidth + ' ' + svgHeight);
      }
    }, {
      key: "getSvgString",
      value: function getSvgString(_scale) {
        var _this = this;
        return new Promise(function (resolve) {
          var w = _this.w;
          var scale = _scale || w.config.chart.toolbar.export.scale || w.config.chart.toolbar.export.width / w.globals.svgWidth;
          if (!scale) {
            scale = 1; // if no scale is specified, don't scale...
          }
          var width = w.globals.svgWidth * scale;
          var height = w.globals.svgHeight * scale;
          var clonedNode = w.globals.dom.elWrap.cloneNode(true);
          clonedNode.style.width = width + 'px';
          clonedNode.style.height = height + 'px';
          var serializedNode = new XMLSerializer().serializeToString(clonedNode);

          // Check if legend is shown and should be included in export
          var shouldIncludeLegendStyles = w.config.legend.show && w.globals.dom.elLegendWrap && w.globals.dom.elLegendWrap.children.length > 0;

          // Base styles for export
          var exportStyles = "\n        .apexcharts-tooltip, .apexcharts-toolbar, .apexcharts-xaxistooltip, .apexcharts-yaxistooltip, .apexcharts-xcrosshairs, .apexcharts-ycrosshairs, .apexcharts-zoom-rect, .apexcharts-selection-rect {\n          display: none;\n        }\n      ";

          // Add legend styles if legend is shown
          if (shouldIncludeLegendStyles) {
            exportStyles += css_248z$1;
          }
          var svgString = "\n        <svg xmlns=\"http://www.w3.org/2000/svg\"\n          version=\"1.1\"\n          xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n          class=\"apexcharts-svg\"\n          xmlns:data=\"ApexChartsNS\"\n          transform=\"translate(0, 0)\"\n          width=\"".concat(w.globals.svgWidth, "px\" height=\"").concat(w.globals.svgHeight, "px\">\n          <foreignObject width=\"100%\" height=\"100%\">\n            <div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"width:").concat(width, "px; height:").concat(height, "px;\">\n            <style type=\"text/css\">\n              ").concat(exportStyles, "\n            </style>\n              ").concat(serializedNode, "\n            </div>\n          </foreignObject>\n        </svg>\n      ");
          var svgNode = _this.svgStringToNode(svgString);
          if (scale !== 1) {
            // scale the image
            _this.scaleSvgNode(svgNode, scale);
          }
          _this.convertImagesToBase64(svgNode).then(function () {
            svgString = new XMLSerializer().serializeToString(svgNode);
            resolve(svgString.replace(/&nbsp;/g, '&#160;'));
          });
        });
      }
    }, {
      key: "convertImagesToBase64",
      value: function convertImagesToBase64(svgNode) {
        var _this2 = this;
        var images = svgNode.getElementsByTagName('image');
        var promises = Array.from(images).map(function (img) {
          var href = img.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
          if (href && !href.startsWith('data:')) {
            return _this2.getBase64FromUrl(href).then(function (base64) {
              img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', base64);
            }).catch(function (error) {
              console.error('Error converting image to base64:', error);
            });
          }
          return Promise.resolve();
        });
        return Promise.all(promises);
      }
    }, {
      key: "getBase64FromUrl",
      value: function getBase64FromUrl(url) {
        return new Promise(function (resolve, reject) {
          var img = new Image();
          img.crossOrigin = 'Anonymous';
          img.onload = function () {
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            resolve(canvas.toDataURL());
          };
          img.onerror = reject;
          img.src = url;
        });
      }
    }, {
      key: "svgUrl",
      value: function svgUrl() {
        var _this3 = this;
        return new Promise(function (resolve) {
          _this3.getSvgString().then(function (svgData) {
            var svgBlob = new Blob([svgData], {
              type: 'image/svg+xml;charset=utf-8'
            });
            resolve(URL.createObjectURL(svgBlob));
          });
        });
      }
    }, {
      key: "dataURI",
      value: function dataURI(options) {
        var _this4 = this;
        return new Promise(function (resolve) {
          var w = _this4.w;
          var scale = options ? options.scale || options.width / w.globals.svgWidth : 1;
          var canvas = document.createElement('canvas');
          canvas.width = w.globals.svgWidth * scale;
          canvas.height = parseInt(w.globals.dom.elWrap.style.height, 10) * scale; // because of resizeNonAxisCharts

          var canvasBg = w.config.chart.background === 'transparent' || !w.config.chart.background ? '#fff' : w.config.chart.background;
          var ctx = canvas.getContext('2d');
          ctx.fillStyle = canvasBg;
          ctx.fillRect(0, 0, canvas.width * scale, canvas.height * scale);
          _this4.getSvgString(scale).then(function (svgData) {
            var svgUrl = 'data:image/svg+xml,' + encodeURIComponent(svgData);
            var img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = function () {
              ctx.drawImage(img, 0, 0);
              if (canvas.msToBlob) {
                // Microsoft Edge can't navigate to data urls, so we return the blob instead
                var blob = canvas.msToBlob();
                resolve({
                  blob: blob
                });
              } else {
                var imgURI = canvas.toDataURL('image/png');
                resolve({
                  imgURI: imgURI
                });
              }
            };
            img.src = svgUrl;
          });
        });
      }
    }, {
      key: "exportToSVG",
      value: function exportToSVG() {
        var _this5 = this;
        this.svgUrl().then(function (url) {
          _this5.triggerDownload(url, _this5.w.config.chart.toolbar.export.svg.filename, '.svg');
        });
      }
    }, {
      key: "exportToPng",
      value: function exportToPng() {
        var _this6 = this;
        var scale = this.w.config.chart.toolbar.export.scale;
        var width = this.w.config.chart.toolbar.export.width;
        var option = scale ? {
          scale: scale
        } : width ? {
          width: width
        } : undefined;
        this.dataURI(option).then(function (_ref) {
          var imgURI = _ref.imgURI,
            blob = _ref.blob;
          if (blob) {
            navigator.msSaveOrOpenBlob(blob, _this6.w.globals.chartID + '.png');
          } else {
            _this6.triggerDownload(imgURI, _this6.w.config.chart.toolbar.export.png.filename, '.png');
          }
        });
      }
    }, {
      key: "exportToCSV",
      value: function exportToCSV(_ref2) {
        var _this7 = this;
        var series = _ref2.series,
          fileName = _ref2.fileName,
          _ref2$columnDelimiter = _ref2.columnDelimiter,
          columnDelimiter = _ref2$columnDelimiter === void 0 ? ',' : _ref2$columnDelimiter,
          _ref2$lineDelimiter = _ref2.lineDelimiter,
          lineDelimiter = _ref2$lineDelimiter === void 0 ? '\n' : _ref2$lineDelimiter;
        var w = this.w;
        if (!series) series = w.config.series;
        var columns = [];
        var rows = [];
        var result = '';
        var universalBOM = "\uFEFF";
        var gSeries = w.globals.series.map(function (s, i) {
          return w.globals.collapsedSeriesIndices.indexOf(i) === -1 ? s : [];
        });
        var getFormattedCategory = function getFormattedCategory(cat) {
          if (typeof w.config.chart.toolbar.export.csv.categoryFormatter === 'function') {
            return w.config.chart.toolbar.export.csv.categoryFormatter(cat);
          }
          if (w.config.xaxis.type === 'datetime' && String(cat).length >= 10) {
            return new Date(cat).toDateString();
          }
          return Utils$1.isNumber(cat) ? cat : cat.split(columnDelimiter).join('');
        };
        var getFormattedValue = function getFormattedValue(value) {
          return typeof w.config.chart.toolbar.export.csv.valueFormatter === 'function' ? w.config.chart.toolbar.export.csv.valueFormatter(value) : value;
        };
        var seriesMaxDataLength = Math.max.apply(Math, _toConsumableArray(series.map(function (s) {
          return s.data ? s.data.length : 0;
        })));
        var dataFormat = new Data(this.ctx);
        var axesUtils = new AxesUtils(this.ctx);
        var getCat = function getCat(i) {
          var cat = '';

          // pie / donut/ radial
          if (!w.globals.axisCharts) {
            cat = w.config.labels[i];
          } else {
            // xy charts

            // non datetime
            if (w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) {
              if (w.globals.isBarHorizontal) {
                var lbFormatter = w.globals.yLabelFormatters[0];
                var sr = new Series(_this7.ctx);
                var activeSeries = sr.getActiveConfigSeriesIndex();
                cat = lbFormatter(w.globals.labels[i], {
                  seriesIndex: activeSeries,
                  dataPointIndex: i,
                  w: w
                });
              } else {
                cat = axesUtils.getLabel(w.globals.labels, w.globals.timescaleLabels, 0, i).text;
              }
            }

            // datetime, but labels specified in categories or labels
            if (w.config.xaxis.type === 'datetime') {
              if (w.config.xaxis.categories.length) {
                cat = w.config.xaxis.categories[i];
              } else if (w.config.labels.length) {
                cat = w.config.labels[i];
              }
            }
          }

          // let the caller know the current category is null. this can happen for example
          // when dealing with line charts having inconsistent time series data
          if (cat === null) return 'nullvalue';
          if (Array.isArray(cat)) {
            cat = cat.join(' ');
          }
          return Utils$1.isNumber(cat) ? cat : cat.split(columnDelimiter).join('');
        };

        // Fix https://github.com/apexcharts/apexcharts.js/issues/3365
        var getEmptyDataForCsvColumn = function getEmptyDataForCsvColumn() {
          return _toConsumableArray(Array(seriesMaxDataLength)).map(function () {
            return '';
          });
        };
        var handleAxisRowsColumns = function handleAxisRowsColumns(s, sI) {
          if (columns.length && sI === 0) {
            // It's the first series.  Go ahead and create the first row with header information.
            rows.push(columns.join(columnDelimiter));
          }
          if (s.data) {
            // Use the data we have, or generate a properly sized empty array with empty data if some data is missing.
            s.data = s.data.length && s.data || getEmptyDataForCsvColumn();
            for (var i = 0; i < s.data.length; i++) {
              // Reset the columns array so that we can start building columns for this row.
              columns = [];
              var cat = getCat(i);

              // current category is null, let's move on to the next one
              if (cat === 'nullvalue') continue;
              if (!cat) {
                if (dataFormat.isFormatXY()) {
                  cat = series[sI].data[i].x;
                } else if (dataFormat.isFormat2DArray()) {
                  cat = series[sI].data[i] ? series[sI].data[i][0] : '';
                }
              }
              if (sI === 0) {
                // It's the first series.  Also handle the category.
                columns.push(getFormattedCategory(cat));
                for (var ci = 0; ci < w.globals.series.length; ci++) {
                  var _series$ci$data$i;
                  var value = dataFormat.isFormatXY() ? (_series$ci$data$i = series[ci].data[i]) === null || _series$ci$data$i === void 0 ? void 0 : _series$ci$data$i.y : gSeries[ci][i];
                  columns.push(getFormattedValue(value));
                }
              }
              if (w.config.chart.type === 'candlestick' || s.type && s.type === 'candlestick') {
                columns.pop();
                columns.push(w.globals.seriesCandleO[sI][i]);
                columns.push(w.globals.seriesCandleH[sI][i]);
                columns.push(w.globals.seriesCandleL[sI][i]);
                columns.push(w.globals.seriesCandleC[sI][i]);
              }
              if (w.config.chart.type === 'boxPlot' || s.type && s.type === 'boxPlot') {
                columns.pop();
                columns.push(w.globals.seriesCandleO[sI][i]);
                columns.push(w.globals.seriesCandleH[sI][i]);
                columns.push(w.globals.seriesCandleM[sI][i]);
                columns.push(w.globals.seriesCandleL[sI][i]);
                columns.push(w.globals.seriesCandleC[sI][i]);
              }
              if (w.config.chart.type === 'rangeBar') {
                columns.pop();
                columns.push(w.globals.seriesRangeStart[sI][i]);
                columns.push(w.globals.seriesRangeEnd[sI][i]);
              }
              if (columns.length) {
                rows.push(columns.join(columnDelimiter));
              }
            }
          }
        };
        var handleUnequalXValues = function handleUnequalXValues() {
          var categories = new Set();
          var data = {};
          series.forEach(function (s, sI) {
            s === null || s === void 0 ? void 0 : s.data.forEach(function (dataItem) {
              var cat, value;
              if (dataFormat.isFormatXY()) {
                cat = dataItem.x;
                value = dataItem.y;
              } else if (dataFormat.isFormat2DArray()) {
                cat = dataItem[0];
                value = dataItem[1];
              } else {
                return;
              }
              if (!data[cat]) {
                data[cat] = Array(series.length).fill('');
              }
              data[cat][sI] = getFormattedValue(value);
              categories.add(cat);
            });
          });
          if (columns.length) {
            rows.push(columns.join(columnDelimiter));
          }
          Array.from(categories).sort().forEach(function (cat) {
            rows.push([getFormattedCategory(cat), data[cat].join(columnDelimiter)]);
          });
        };
        columns.push(w.config.chart.toolbar.export.csv.headerCategory);
        if (w.config.chart.type === 'boxPlot') {
          columns.push('minimum');
          columns.push('q1');
          columns.push('median');
          columns.push('q3');
          columns.push('maximum');
        } else if (w.config.chart.type === 'candlestick') {
          columns.push('open');
          columns.push('high');
          columns.push('low');
          columns.push('close');
        } else if (w.config.chart.type === 'rangeBar') {
          columns.push('minimum');
          columns.push('maximum');
        } else {
          series.map(function (s, sI) {
            var sname = (s.name ? s.name : "series-".concat(sI)) + '';
            if (w.globals.axisCharts) {
              columns.push(sname.split(columnDelimiter).join('') ? sname.split(columnDelimiter).join('') : "series-".concat(sI));
            }
          });
        }
        if (!w.globals.axisCharts) {
          columns.push(w.config.chart.toolbar.export.csv.headerValue);
          rows.push(columns.join(columnDelimiter));
        }
        if (!w.globals.allSeriesHasEqualX && w.globals.axisCharts && !w.config.xaxis.categories.length && !w.config.labels.length) {
          handleUnequalXValues();
        } else {
          series.map(function (s, sI) {
            if (w.globals.axisCharts) {
              handleAxisRowsColumns(s, sI);
            } else {
              columns = [];
              columns.push(getFormattedCategory(w.globals.labels[sI]));
              columns.push(getFormattedValue(gSeries[sI]));
              rows.push(columns.join(columnDelimiter));
            }
          });
        }
        result += rows.join(lineDelimiter);
        this.triggerDownload('data:text/csv; charset=utf-8,' + encodeURIComponent(universalBOM + result), fileName ? fileName : w.config.chart.toolbar.export.csv.filename, '.csv');
      }
    }, {
      key: "exportToXLS",
      value: function exportToXLS(_ref3) {
        var _this8 = this;
        var series = _ref3.series,
          fileName = _ref3.fileName;
        var w = this.w;
        if (!series) series = w.config.series;
        var data = [];
        var gSeries = w.globals.series.map(function (s, i) {
          return w.globals.collapsedSeriesIndices.indexOf(i) === -1 ? s : [];
        });
        var seriesMaxDataLength = Math.max.apply(Math, _toConsumableArray(series.map(function (s) {
          return s.data ? s.data.length : 0;
        })));
        var dataFormat = new Data(this.ctx);
        var axesUtils = new AxesUtils(this.ctx);
        var getCat = function getCat(i) {
          var cat = '';
          if (!w.globals.axisCharts) {
            cat = w.config.labels[i];
          } else {
            if (w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) {
              if (w.globals.isBarHorizontal) {
                var lbFormatter = w.globals.yLabelFormatters[0];
                var sr = new Series(_this8.ctx);
                var activeSeries = sr.getActiveConfigSeriesIndex();
                cat = lbFormatter(w.globals.labels[i], {
                  seriesIndex: activeSeries,
                  dataPointIndex: i,
                  w: w
                });
              } else {
                cat = axesUtils.getLabel(w.globals.labels, w.globals.timescaleLabels, 0, i).text;
              }
            }
            if (w.config.xaxis.type === 'datetime') {
              if (w.config.xaxis.categories.length) {
                cat = w.config.xaxis.categories[i];
              } else if (w.config.labels.length) {
                cat = w.config.labels[i];
              }
            }
          }
          if (cat === null) return 'nullvalue';
          if (Array.isArray(cat)) cat = cat.join(' ');
          return cat;
        };
        var getEmptyDataForColumn = function getEmptyDataForColumn() {
          return _toConsumableArray(Array(seriesMaxDataLength)).map(function () {
            return '';
          });
        };
        var handleAxisRows = function handleAxisRows(s, sI) {
          if (s.data) {
            s.data = s.data.length && s.data || getEmptyDataForColumn();
            for (var i = 0; i < s.data.length; i++) {
              var cat = getCat(i);
              if (cat === 'nullvalue') continue;
              if (!cat) {
                if (dataFormat.isFormatXY()) {
                  cat = series[sI].data[i].x;
                } else if (dataFormat.isFormat2DArray()) {
                  cat = series[sI].data[i] ? series[sI].data[i][0] : '';
                }
              }
              if (sI === 0) {
                var row = {};
                row[w.config.chart.toolbar.export.csv.headerCategory] = cat;
                for (var ci = 0; ci < w.globals.series.length; ci++) {
                  var _series$ci$data$i2;
                  var sname = series[ci].name ? series[ci].name : "series-".concat(ci);
                  row[sname] = dataFormat.isFormatXY() ? (_series$ci$data$i2 = series[ci].data[i]) === null || _series$ci$data$i2 === void 0 ? void 0 : _series$ci$data$i2.y : gSeries[ci][i];
                }
                data.push(row);
              }
            }
          }
        };
        var handleUnequalXValues = function handleUnequalXValues() {
          var categories = new Set();
          var seriesData = {};
          series.forEach(function (s, sI) {
            s === null || s === void 0 ? void 0 : s.data.forEach(function (dataItem) {
              var cat, value;
              if (dataFormat.isFormatXY()) {
                cat = dataItem.x;
                value = dataItem.y;
              } else if (dataFormat.isFormat2DArray()) {
                cat = dataItem[0];
                value = dataItem[1];
              } else {
                return;
              }
              if (!seriesData[cat]) seriesData[cat] = Array(series.length).fill('');
              seriesData[cat][sI] = value;
              categories.add(cat);
            });
          });
          Array.from(categories).sort().forEach(function (cat) {
            var row = {};
            row[w.config.chart.toolbar.export.csv.headerCategory] = cat;
            series.forEach(function (s, sI) {
              row[s.name || "series-".concat(sI)] = seriesData[cat][sI];
            });
            data.push(row);
          });
        };
        if (!w.globals.allSeriesHasEqualX && w.globals.axisCharts && !w.config.xaxis.categories.length && !w.config.labels.length) {
          handleUnequalXValues();
        } else {
          series.forEach(function (s, sI) {
            if (w.globals.axisCharts) {
              handleAxisRows(s, sI);
            } else {
              var row = {};
              row[w.config.chart.toolbar.export.csv.headerCategory] = w.globals.labels[sI];
              row[s.name || "series-".concat(sI)] = gSeries[sI];
              data.push(row);
            }
          });
        }
        var ws = utils.json_to_sheet(data);
        var wb = utils.book_new();
        utils.book_append_sheet(wb, ws, 'sheet1');
        var fileNameExt = (fileName ? fileName : w.globals.chartID) + '.xlsx';
        writeFileSync(wb, fileNameExt);
      }
    }, {
      key: "triggerDownload",
      value: function triggerDownload(href, filename, ext) {
        var downloadLink = document.createElement('a');
        downloadLink.href = href;
        downloadLink.download = (filename ? filename : this.w.globals.chartID) + ext;
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      }
    }]);
    return Exports;
  }();

  /**
   * ApexCharts XAxis Class for drawing X-Axis.
   *
   * @module XAxis
   **/
  var XAxis = /*#__PURE__*/function () {
    function XAxis(ctx, elgrid) {
      _classCallCheck(this, XAxis);
      this.ctx = ctx;
      this.elgrid = elgrid;
      this.w = ctx.w;
      var w = this.w;
      this.axesUtils = new AxesUtils(ctx);
      this.xaxisLabels = w.globals.labels.slice();
      if (w.globals.timescaleLabels.length > 0 && !w.globals.isBarHorizontal) {
        //  timeline labels are there and chart is not rangeabr timeline
        this.xaxisLabels = w.globals.timescaleLabels.slice();
      }
      if (w.config.xaxis.overwriteCategories) {
        this.xaxisLabels = w.config.xaxis.overwriteCategories;
      }
      this.drawnLabels = [];
      this.drawnLabelsRects = [];
      if (w.config.xaxis.position === 'top') {
        this.offY = 0;
      } else {
        this.offY = w.globals.gridHeight;
      }
      this.offY = this.offY + w.config.xaxis.axisBorder.offsetY;
      this.isCategoryBarHorizontal = w.config.chart.type === 'bar' && w.config.plotOptions.bar.horizontal;
      this.xaxisFontSize = w.config.xaxis.labels.style.fontSize;
      this.xaxisFontFamily = w.config.xaxis.labels.style.fontFamily;
      this.xaxisForeColors = w.config.xaxis.labels.style.colors;
      this.xaxisBorderWidth = w.config.xaxis.axisBorder.width;
      if (this.isCategoryBarHorizontal) {
        this.xaxisBorderWidth = w.config.yaxis[0].axisBorder.width.toString();
      }
      if (String(this.xaxisBorderWidth).indexOf('%') > -1) {
        this.xaxisBorderWidth = w.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100;
      } else {
        this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10);
      }
      this.xaxisBorderHeight = w.config.xaxis.axisBorder.height;

      // For bars, we will only consider single y xais,
      // as we are not providing multiple yaxis for bar charts
      this.yaxis = w.config.yaxis[0];
    }
    _createClass(XAxis, [{
      key: "drawXaxis",
      value: function drawXaxis() {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var elXaxis = graphics.group({
          class: 'apexcharts-xaxis',
          transform: "translate(".concat(w.config.xaxis.offsetX, ", ").concat(w.config.xaxis.offsetY, ")")
        });
        var elXaxisTexts = graphics.group({
          class: 'apexcharts-xaxis-texts-g',
          transform: "translate(".concat(w.globals.translateXAxisX, ", ").concat(w.globals.translateXAxisY, ")")
        });
        elXaxis.add(elXaxisTexts);
        var labels = [];
        for (var i = 0; i < this.xaxisLabels.length; i++) {
          labels.push(this.xaxisLabels[i]);
        }
        this.drawXAxisLabelAndGroup(true, graphics, elXaxisTexts, labels, w.globals.isXNumeric, function (i, colWidth) {
          return colWidth;
        });
        if (w.globals.hasXaxisGroups) {
          var labelsGroup = w.globals.groups;
          labels = [];
          for (var _i = 0; _i < labelsGroup.length; _i++) {
            labels.push(labelsGroup[_i].title);
          }
          var overwriteStyles = {};
          if (w.config.xaxis.group.style) {
            overwriteStyles.xaxisFontSize = w.config.xaxis.group.style.fontSize;
            overwriteStyles.xaxisFontFamily = w.config.xaxis.group.style.fontFamily;
            overwriteStyles.xaxisForeColors = w.config.xaxis.group.style.colors;
            overwriteStyles.fontWeight = w.config.xaxis.group.style.fontWeight;
            overwriteStyles.cssClass = w.config.xaxis.group.style.cssClass;
          }
          this.drawXAxisLabelAndGroup(false, graphics, elXaxisTexts, labels, false, function (i, colWidth) {
            return labelsGroup[i].cols * colWidth;
          }, overwriteStyles);
        }
        if (w.config.xaxis.title.text !== undefined) {
          var elXaxisTitle = graphics.group({
            class: 'apexcharts-xaxis-title'
          });
          var elXAxisTitleText = graphics.drawText({
            x: w.globals.gridWidth / 2 + w.config.xaxis.title.offsetX,
            y: this.offY + parseFloat(this.xaxisFontSize) + (w.config.xaxis.position === 'bottom' ? w.globals.xAxisLabelsHeight : -w.globals.xAxisLabelsHeight - 10) + w.config.xaxis.title.offsetY,
            text: w.config.xaxis.title.text,
            textAnchor: 'middle',
            fontSize: w.config.xaxis.title.style.fontSize,
            fontFamily: w.config.xaxis.title.style.fontFamily,
            fontWeight: w.config.xaxis.title.style.fontWeight,
            foreColor: w.config.xaxis.title.style.color,
            cssClass: 'apexcharts-xaxis-title-text ' + w.config.xaxis.title.style.cssClass
          });
          elXaxisTitle.add(elXAxisTitleText);
          elXaxis.add(elXaxisTitle);
        }
        if (w.config.xaxis.axisBorder.show) {
          var offX = w.globals.barPadForNumericAxis;
          var elHorzLine = graphics.drawLine(w.globals.padHorizontal + w.config.xaxis.axisBorder.offsetX - offX, this.offY, this.xaxisBorderWidth + offX, this.offY, w.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
          if (this.elgrid && this.elgrid.elGridBorders && w.config.grid.show) {
            this.elgrid.elGridBorders.add(elHorzLine);
          } else {
            elXaxis.add(elHorzLine);
          }
        }
        return elXaxis;
      }
    }, {
      key: "drawXAxisLabelAndGroup",
      value: function drawXAxisLabelAndGroup(isLeafGroup, graphics, elXaxisTexts, labels, isXNumeric, colWidthCb) {
        var _this = this;
        var overwriteStyles = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
        var drawnLabels = [];
        var drawnLabelsRects = [];
        var w = this.w;
        var xaxisFontSize = overwriteStyles.xaxisFontSize || this.xaxisFontSize;
        var xaxisFontFamily = overwriteStyles.xaxisFontFamily || this.xaxisFontFamily;
        var xaxisForeColors = overwriteStyles.xaxisForeColors || this.xaxisForeColors;
        var fontWeight = overwriteStyles.fontWeight || w.config.xaxis.labels.style.fontWeight;
        var cssClass = overwriteStyles.cssClass || w.config.xaxis.labels.style.cssClass;
        var colWidth;

        // initial x Position (keep adding column width in the loop)
        var xPos = w.globals.padHorizontal;
        var labelsLen = labels.length;

        /**
         * labelsLen can be different (whether you are drawing x-axis labels or x-axis group labels)
         * hence, we introduce dataPoints to be consistent.
         * Also, in datetime/numeric xaxis, dataPoints can be misleading, so we resort to labelsLen for such xaxis type
         */
        var dataPoints = w.config.xaxis.type === 'category' ? w.globals.dataPoints : labelsLen;

        // when all series are collapsed, fixes #3381
        if (dataPoints === 0 && labelsLen > dataPoints) dataPoints = labelsLen;
        if (isXNumeric) {
          var len = Math.max(Number(w.config.xaxis.tickAmount) || 1, dataPoints > 1 ? dataPoints - 1 : dataPoints);
          colWidth = w.globals.gridWidth / Math.min(len, labelsLen - 1);
          xPos = xPos + colWidthCb(0, colWidth) / 2 + w.config.xaxis.labels.offsetX;
        } else {
          colWidth = w.globals.gridWidth / dataPoints;
          xPos = xPos + colWidthCb(0, colWidth) + w.config.xaxis.labels.offsetX;
        }
        var _loop = function _loop(i) {
          var x = xPos - colWidthCb(i, colWidth) / 2 + w.config.xaxis.labels.offsetX;
          if (i === 0 && labelsLen === 1 && colWidth / 2 === xPos && dataPoints === 1) {
            // single datapoint
            x = w.globals.gridWidth / 2;
          }
          var label = _this.axesUtils.getLabel(labels, w.globals.timescaleLabels, x, i, drawnLabels, xaxisFontSize, isLeafGroup);
          var offsetYCorrection = 28;
          if (w.globals.rotateXLabels && isLeafGroup) {
            offsetYCorrection = 22;
          }
          if (w.config.xaxis.title.text && w.config.xaxis.position === 'top') {
            offsetYCorrection += parseFloat(w.config.xaxis.title.style.fontSize) + 2;
          }
          if (!isLeafGroup) {
            offsetYCorrection = offsetYCorrection + parseFloat(xaxisFontSize) + (w.globals.xAxisLabelsHeight - w.globals.xAxisGroupLabelsHeight) + (w.globals.rotateXLabels ? 10 : 0);
          }
          var isCategoryTickAmounts = typeof w.config.xaxis.tickAmount !== 'undefined' && w.config.xaxis.tickAmount !== 'dataPoints' && w.config.xaxis.type !== 'datetime';
          if (isCategoryTickAmounts) {
            label = _this.axesUtils.checkLabelBasedOnTickamount(i, label, labelsLen);
          } else {
            label = _this.axesUtils.checkForOverflowingLabels(i, label, labelsLen, drawnLabels, drawnLabelsRects);
          }
          var getCatForeColor = function getCatForeColor() {
            return isLeafGroup && w.config.xaxis.convertedCatToNumeric ? xaxisForeColors[w.globals.minX + i - 1] : xaxisForeColors[i];
          };
          if (w.config.xaxis.labels.show) {
            var elText = graphics.drawText({
              x: label.x,
              y: _this.offY + w.config.xaxis.labels.offsetY + offsetYCorrection - (w.config.xaxis.position === 'top' ? w.globals.xAxisHeight + w.config.xaxis.axisTicks.height - 2 : 0),
              text: label.text,
              textAnchor: 'middle',
              fontWeight: label.isBold ? 600 : fontWeight,
              fontSize: xaxisFontSize,
              fontFamily: xaxisFontFamily,
              foreColor: Array.isArray(xaxisForeColors) ? getCatForeColor() : xaxisForeColors,
              isPlainText: false,
              cssClass: (isLeafGroup ? 'apexcharts-xaxis-label ' : 'apexcharts-xaxis-group-label ') + cssClass
            });
            elXaxisTexts.add(elText);
            elText.on('click', function (e) {
              if (typeof w.config.chart.events.xAxisLabelClick === 'function') {
                var opts = Object.assign({}, w, {
                  labelIndex: i
                });
                w.config.chart.events.xAxisLabelClick(e, _this.ctx, opts);
              }
            });
            if (isLeafGroup) {
              var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');
              elTooltipTitle.textContent = Array.isArray(label.text) ? label.text.join(' ') : label.text;
              elText.node.appendChild(elTooltipTitle);
              if (label.text !== '') {
                drawnLabels.push(label.text);
                drawnLabelsRects.push(label);
              }
            }
          }
          if (i < labelsLen - 1) {
            xPos = xPos + colWidthCb(i + 1, colWidth);
          }
        };
        for (var i = 0; i <= labelsLen - 1; i++) {
          _loop(i);
        }
      }

      // this actually becomes the vertical axis (for bar charts)
    }, {
      key: "drawXaxisInversed",
      value: function drawXaxisInversed(realIndex) {
        var _this2 = this;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var translateYAxisX = w.config.yaxis[0].opposite ? w.globals.translateYAxisX[realIndex] : 0;
        var elYaxis = graphics.group({
          class: 'apexcharts-yaxis apexcharts-xaxis-inversed',
          rel: realIndex
        });
        var elYaxisTexts = graphics.group({
          class: 'apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g',
          transform: 'translate(' + translateYAxisX + ', 0)'
        });
        elYaxis.add(elYaxisTexts);
        var colHeight;

        // initial x Position (keep adding column width in the loop)
        var yPos;
        var labels = [];
        if (w.config.yaxis[realIndex].show) {
          for (var i = 0; i < this.xaxisLabels.length; i++) {
            labels.push(this.xaxisLabels[i]);
          }
        }
        colHeight = w.globals.gridHeight / labels.length;
        yPos = -(colHeight / 2.2);
        var lbFormatter = w.globals.yLabelFormatters[0];
        var ylabels = w.config.yaxis[0].labels;
        if (ylabels.show) {
          var _loop2 = function _loop2(_i2) {
            var label = typeof labels[_i2] === 'undefined' ? '' : labels[_i2];
            label = lbFormatter(label, {
              seriesIndex: realIndex,
              dataPointIndex: _i2,
              w: w
            });
            var yColors = _this2.axesUtils.getYAxisForeColor(ylabels.style.colors, realIndex);
            var getForeColor = function getForeColor() {
              return Array.isArray(yColors) ? yColors[_i2] : yColors;
            };
            var multiY = 0;
            if (Array.isArray(label)) {
              multiY = label.length / 2 * parseInt(ylabels.style.fontSize, 10);
            }
            var offsetX = ylabels.offsetX - 15;
            var textAnchor = 'end';
            if (_this2.yaxis.opposite) {
              textAnchor = 'start';
            }
            if (w.config.yaxis[0].labels.align === 'left') {
              offsetX = ylabels.offsetX;
              textAnchor = 'start';
            } else if (w.config.yaxis[0].labels.align === 'center') {
              offsetX = ylabels.offsetX;
              textAnchor = 'middle';
            } else if (w.config.yaxis[0].labels.align === 'right') {
              textAnchor = 'end';
            }
            var elLabel = graphics.drawText({
              x: offsetX,
              y: yPos + colHeight + ylabels.offsetY - multiY,
              text: label,
              textAnchor: textAnchor,
              foreColor: getForeColor(),
              fontSize: ylabels.style.fontSize,
              fontFamily: ylabels.style.fontFamily,
              fontWeight: ylabels.style.fontWeight,
              isPlainText: false,
              cssClass: 'apexcharts-yaxis-label ' + ylabels.style.cssClass,
              maxWidth: ylabels.maxWidth
            });
            elYaxisTexts.add(elLabel);
            elLabel.on('click', function (e) {
              if (typeof w.config.chart.events.xAxisLabelClick === 'function') {
                var opts = Object.assign({}, w, {
                  labelIndex: _i2
                });
                w.config.chart.events.xAxisLabelClick(e, _this2.ctx, opts);
              }
            });
            var elTooltipTitle = document.createElementNS(w.globals.SVGNS, 'title');
            elTooltipTitle.textContent = Array.isArray(label) ? label.join(' ') : label;
            elLabel.node.appendChild(elTooltipTitle);
            if (w.config.yaxis[realIndex].labels.rotate !== 0) {
              var labelRotatingCenter = graphics.rotateAroundCenter(elLabel.node);
              elLabel.node.setAttribute('transform', "rotate(".concat(w.config.yaxis[realIndex].labels.rotate, " 0 ").concat(labelRotatingCenter.y, ")"));
            }
            yPos = yPos + colHeight;
          };
          for (var _i2 = 0; _i2 <= labels.length - 1; _i2++) {
            _loop2(_i2);
          }
        }
        if (w.config.yaxis[0].title.text !== undefined) {
          var elXaxisTitle = graphics.group({
            class: 'apexcharts-yaxis-title apexcharts-xaxis-title-inversed',
            transform: 'translate(' + translateYAxisX + ', 0)'
          });
          var elXAxisTitleText = graphics.drawText({
            x: w.config.yaxis[0].title.offsetX,
            y: w.globals.gridHeight / 2 + w.config.yaxis[0].title.offsetY,
            text: w.config.yaxis[0].title.text,
            textAnchor: 'middle',
            foreColor: w.config.yaxis[0].title.style.color,
            fontSize: w.config.yaxis[0].title.style.fontSize,
            fontWeight: w.config.yaxis[0].title.style.fontWeight,
            fontFamily: w.config.yaxis[0].title.style.fontFamily,
            cssClass: 'apexcharts-yaxis-title-text ' + w.config.yaxis[0].title.style.cssClass
          });
          elXaxisTitle.add(elXAxisTitleText);
          elYaxis.add(elXaxisTitle);
        }
        var offX = 0;
        if (this.isCategoryBarHorizontal && w.config.yaxis[0].opposite) {
          offX = w.globals.gridWidth;
        }
        var axisBorder = w.config.xaxis.axisBorder;
        if (axisBorder.show) {
          var elVerticalLine = graphics.drawLine(w.globals.padHorizontal + axisBorder.offsetX + offX, 1 + axisBorder.offsetY, w.globals.padHorizontal + axisBorder.offsetX + offX, w.globals.gridHeight + axisBorder.offsetY, axisBorder.color, 0);
          if (this.elgrid && this.elgrid.elGridBorders && w.config.grid.show) {
            this.elgrid.elGridBorders.add(elVerticalLine);
          } else {
            elYaxis.add(elVerticalLine);
          }
        }
        if (w.config.yaxis[0].axisTicks.show) {
          this.axesUtils.drawYAxisTicks(offX, labels.length, w.config.yaxis[0].axisBorder, w.config.yaxis[0].axisTicks, 0, colHeight, elYaxis);
        }
        return elYaxis;
      }
    }, {
      key: "drawXaxisTicks",
      value: function drawXaxisTicks(x1, y2, appendToElement) {
        var w = this.w;
        var x2 = x1;
        if (x1 < 0 || x1 - 2 > w.globals.gridWidth) return;
        var y1 = this.offY + w.config.xaxis.axisTicks.offsetY;
        y2 = y2 + y1 + w.config.xaxis.axisTicks.height;
        if (w.config.xaxis.position === 'top') {
          y2 = y1 - w.config.xaxis.axisTicks.height;
        }
        if (w.config.xaxis.axisTicks.show) {
          var graphics = new Graphics(this.ctx);
          var line = graphics.drawLine(x1 + w.config.xaxis.axisTicks.offsetX, y1 + w.config.xaxis.offsetY, x2 + w.config.xaxis.axisTicks.offsetX, y2 + w.config.xaxis.offsetY, w.config.xaxis.axisTicks.color);

          // we are not returning anything, but appending directly to the element passed in param
          appendToElement.add(line);
          line.node.classList.add('apexcharts-xaxis-tick');
        }
      }
    }, {
      key: "getXAxisTicksPositions",
      value: function getXAxisTicksPositions() {
        var w = this.w;
        var xAxisTicksPositions = [];
        var xCount = this.xaxisLabels.length;
        var x1 = w.globals.padHorizontal;
        if (w.globals.timescaleLabels.length > 0) {
          for (var i = 0; i < xCount; i++) {
            x1 = this.xaxisLabels[i].position;
            xAxisTicksPositions.push(x1);
          }
        } else {
          var xCountForCategoryCharts = xCount;
          for (var _i3 = 0; _i3 < xCountForCategoryCharts; _i3++) {
            var x1Count = xCountForCategoryCharts;
            if (w.globals.isXNumeric && w.config.chart.type !== 'bar') {
              x1Count -= 1;
            }
            x1 = x1 + w.globals.gridWidth / x1Count;
            xAxisTicksPositions.push(x1);
          }
        }
        return xAxisTicksPositions;
      }

      // to rotate x-axis labels or to put ... for longer text in xaxis
    }, {
      key: "xAxisLabelCorrections",
      value: function xAxisLabelCorrections() {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var xAxis = w.globals.dom.baseEl.querySelector('.apexcharts-xaxis-texts-g');
        var xAxisTexts = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)');
        var yAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxis-inversed text');
        var xAxisTextsInversed = w.globals.dom.baseEl.querySelectorAll('.apexcharts-xaxis-inversed-texts-g text tspan');
        if (w.globals.rotateXLabels || w.config.xaxis.labels.rotateAlways) {
          for (var xat = 0; xat < xAxisTexts.length; xat++) {
            var textRotatingCenter = graphics.rotateAroundCenter(xAxisTexts[xat]);
            textRotatingCenter.y = textRotatingCenter.y - 1; // + tickWidth/4;
            textRotatingCenter.x = textRotatingCenter.x + 1;
            xAxisTexts[xat].setAttribute('transform', "rotate(".concat(w.config.xaxis.labels.rotate, " ").concat(textRotatingCenter.x, " ").concat(textRotatingCenter.y, ")"));
            xAxisTexts[xat].setAttribute('text-anchor', "end");
            var offsetHeight = 10;
            xAxis.setAttribute('transform', "translate(0, ".concat(-offsetHeight, ")"));
            var tSpan = xAxisTexts[xat].childNodes;
            if (w.config.xaxis.labels.trim) {
              Array.prototype.forEach.call(tSpan, function (ts) {
                graphics.placeTextWithEllipsis(ts, ts.textContent, w.globals.xAxisLabelsHeight - (w.config.legend.position === 'bottom' ? 20 : 10));
              });
            }
          }
        } else {
          (function () {
            var width = w.globals.gridWidth / (w.globals.labels.length + 1);
            for (var _xat = 0; _xat < xAxisTexts.length; _xat++) {
              var _tSpan = xAxisTexts[_xat].childNodes;
              if (w.config.xaxis.labels.trim && w.config.xaxis.type !== 'datetime') {
                Array.prototype.forEach.call(_tSpan, function (ts) {
                  graphics.placeTextWithEllipsis(ts, ts.textContent, width);
                });
              }
            }
          })();
        }
        if (yAxisTextsInversed.length > 0) {
          // truncate rotated y axis in bar chart (x axis)
          var firstLabelPosX = yAxisTextsInversed[yAxisTextsInversed.length - 1].getBBox();
          var lastLabelPosX = yAxisTextsInversed[0].getBBox();
          if (firstLabelPosX.x < -20) {
            yAxisTextsInversed[yAxisTextsInversed.length - 1].parentNode.removeChild(yAxisTextsInversed[yAxisTextsInversed.length - 1]);
          }
          if (lastLabelPosX.x + lastLabelPosX.width > w.globals.gridWidth && !w.globals.isBarHorizontal) {
            yAxisTextsInversed[0].parentNode.removeChild(yAxisTextsInversed[0]);
          }

          // truncate rotated x axis in bar chart (y axis)
          for (var _xat2 = 0; _xat2 < xAxisTextsInversed.length; _xat2++) {
            graphics.placeTextWithEllipsis(xAxisTextsInversed[_xat2], xAxisTextsInversed[_xat2].textContent, w.config.yaxis[0].labels.maxWidth - (w.config.yaxis[0].title.text ? parseFloat(w.config.yaxis[0].title.style.fontSize) * 2 : 0) - 15);
          }
        }
      }

      // renderXAxisBands() {
      //   let w = this.w;

      //   let plotBand = document.createElementNS(w.globals.SVGNS, 'rect')
      //   w.globals.dom.elGraphical.add(plotBand)
      // }
    }]);
    return XAxis;
  }();

  /**
   * ApexCharts Grid Class for drawing Cartesian Grid.
   *
   * @module Grid
   **/
  var Grid = /*#__PURE__*/function () {
    function Grid(ctx) {
      _classCallCheck(this, Grid);
      this.ctx = ctx;
      this.w = ctx.w;
      var w = this.w;
      this.xaxisLabels = w.globals.labels.slice();
      this.axesUtils = new AxesUtils(ctx);
      this.isRangeBar = w.globals.seriesRange.length && w.globals.isBarHorizontal;
      if (w.globals.timescaleLabels.length > 0) {
        //  timescaleLabels labels are there
        this.xaxisLabels = w.globals.timescaleLabels.slice();
      }
    }
    _createClass(Grid, [{
      key: "drawGridArea",
      value: function drawGridArea() {
        var elGrid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        if (!elGrid) {
          elGrid = graphics.group({
            class: 'apexcharts-grid'
          });
        }
        var elVerticalLine = graphics.drawLine(w.globals.padHorizontal, 1, w.globals.padHorizontal, w.globals.gridHeight, 'transparent');
        var elHorzLine = graphics.drawLine(w.globals.padHorizontal, w.globals.gridHeight, w.globals.gridWidth, w.globals.gridHeight, 'transparent');
        elGrid.add(elHorzLine);
        elGrid.add(elVerticalLine);
        return elGrid;
      }
    }, {
      key: "drawGrid",
      value: function drawGrid() {
        var gl = this.w.globals;
        if (gl.axisCharts) {
          var elgrid = this.renderGrid();
          this.drawGridArea(elgrid.el);
          return elgrid;
        }
        return null;
      }
    }, {
      key: "createGridMask",
      value: function createGridMask() {
        var w = this.w;
        var gl = w.globals;
        var graphics = new Graphics(this.ctx);
        var strokeSize = Array.isArray(w.config.stroke.width) ? Math.max.apply(Math, _toConsumableArray(w.config.stroke.width)) : w.config.stroke.width;
        var createClipPath = function createClipPath(id) {
          var clipPath = document.createElementNS(gl.SVGNS, 'clipPath');
          clipPath.setAttribute('id', id);
          return clipPath;
        };
        gl.dom.elGridRectMask = createClipPath("gridRectMask".concat(gl.cuid));
        gl.dom.elGridRectBarMask = createClipPath("gridRectBarMask".concat(gl.cuid));
        gl.dom.elGridRectMarkerMask = createClipPath("gridRectMarkerMask".concat(gl.cuid));
        gl.dom.elForecastMask = createClipPath("forecastMask".concat(gl.cuid));
        gl.dom.elNonForecastMask = createClipPath("nonForecastMask".concat(gl.cuid));
        var hasBar = ['bar', 'rangeBar', 'candlestick', 'boxPlot'].includes(w.config.chart.type) || w.globals.comboBarCount > 0;
        var barWidthLeft = 0;
        var barWidthRight = 0;
        if (hasBar && w.globals.isXNumeric && !w.globals.isBarHorizontal) {
          barWidthLeft = Math.max(w.config.grid.padding.left, gl.barPadForNumericAxis);
          barWidthRight = Math.max(w.config.grid.padding.right, gl.barPadForNumericAxis);
        }
        gl.dom.elGridRect = graphics.drawRect(-strokeSize / 2 - 2, -strokeSize / 2 - 2, gl.gridWidth + strokeSize + 4, gl.gridHeight + strokeSize + 4, 0, '#fff');
        gl.dom.elGridRectBar = graphics.drawRect(-strokeSize / 2 - barWidthLeft - 2, -strokeSize / 2 - 2, gl.gridWidth + strokeSize + barWidthRight + barWidthLeft + 4, gl.gridHeight + strokeSize + 4, 0, '#fff');
        var markerSize = w.globals.markers.largestSize;
        gl.dom.elGridRectMarker = graphics.drawRect(Math.min(-strokeSize / 2 - barWidthLeft - 2, -markerSize), -markerSize, gl.gridWidth + Math.max(strokeSize + barWidthRight + barWidthLeft + 4, markerSize * 2), gl.gridHeight + markerSize * 2, 0, '#fff');
        gl.dom.elGridRectMask.appendChild(gl.dom.elGridRect.node);
        gl.dom.elGridRectBarMask.appendChild(gl.dom.elGridRectBar.node);
        gl.dom.elGridRectMarkerMask.appendChild(gl.dom.elGridRectMarker.node);
        var defs = gl.dom.baseEl.querySelector('defs');
        defs.appendChild(gl.dom.elGridRectMask);
        defs.appendChild(gl.dom.elGridRectBarMask);
        defs.appendChild(gl.dom.elGridRectMarkerMask);
        defs.appendChild(gl.dom.elForecastMask);
        defs.appendChild(gl.dom.elNonForecastMask);
      }
    }, {
      key: "_drawGridLines",
      value: function _drawGridLines(_ref) {
        var i = _ref.i,
          x1 = _ref.x1,
          y1 = _ref.y1,
          x2 = _ref.x2,
          y2 = _ref.y2,
          xCount = _ref.xCount,
          parent = _ref.parent;
        var w = this.w;
        var shouldDraw = function shouldDraw() {
          if (i === 0 && w.globals.skipFirstTimelinelabel) return false;
          if (i === xCount - 1 && w.globals.skipLastTimelinelabel && !w.config.xaxis.labels.formatter) return false;
          if (w.config.chart.type === 'radar') return false;
          return true;
        };
        if (shouldDraw()) {
          if (w.config.grid.xaxis.lines.show) {
            this._drawGridLine({
              i: i,
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2,
              xCount: xCount,
              parent: parent
            });
          }
          var y_2 = 0;
          if (w.globals.hasXaxisGroups && w.config.xaxis.tickPlacement === 'between') {
            var groups = w.globals.groups;
            if (groups) {
              var gacc = 0;
              for (var gi = 0; gacc < i && gi < groups.length; gi++) {
                gacc += groups[gi].cols;
              }
              if (gacc === i) {
                y_2 = w.globals.xAxisLabelsHeight * 0.6;
              }
            }
          }
          var xAxis = new XAxis(this.ctx);
          xAxis.drawXaxisTicks(x1, y_2, w.globals.dom.elGraphical);
        }
      }
    }, {
      key: "_drawGridLine",
      value: function _drawGridLine(_ref2) {
        var i = _ref2.i,
          x1 = _ref2.x1,
          y1 = _ref2.y1,
          x2 = _ref2.x2,
          y2 = _ref2.y2,
          xCount = _ref2.xCount,
          parent = _ref2.parent;
        var w = this.w;
        var isHorzLine = parent.node.classList.contains('apexcharts-gridlines-horizontal');
        var offX = w.globals.barPadForNumericAxis;
        var excludeBorders = y1 === 0 && y2 === 0 || x1 === 0 && x2 === 0 || y1 === w.globals.gridHeight && y2 === w.globals.gridHeight || w.globals.isBarHorizontal && (i === 0 || i === xCount - 1);
        var graphics = new Graphics(this);
        var line = graphics.drawLine(x1 - (isHorzLine ? offX : 0), y1, x2 + (isHorzLine ? offX : 0), y2, w.config.grid.borderColor, w.config.grid.strokeDashArray);
        line.node.classList.add('apexcharts-gridline');
        if (excludeBorders && w.config.grid.show) {
          this.elGridBorders.add(line);
        } else {
          parent.add(line);
        }
      }
    }, {
      key: "_drawGridBandRect",
      value: function _drawGridBandRect(_ref3) {
        var c = _ref3.c,
          x1 = _ref3.x1,
          y1 = _ref3.y1,
          x2 = _ref3.x2,
          y2 = _ref3.y2,
          type = _ref3.type;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var offX = w.globals.barPadForNumericAxis;
        var color = w.config.grid[type].colors[c];
        var rect = graphics.drawRect(x1 - (type === 'row' ? offX : 0), y1, x2 + (type === 'row' ? offX * 2 : 0), y2, 0, color, w.config.grid[type].opacity);
        this.elg.add(rect);
        rect.attr('clip-path', "url(#gridRectMask".concat(w.globals.cuid, ")"));
        rect.node.classList.add("apexcharts-grid-".concat(type));
      }
    }, {
      key: "_drawXYLines",
      value: function _drawXYLines(_ref4) {
        var _this = this;
        var xCount = _ref4.xCount,
          tickAmount = _ref4.tickAmount;
        var w = this.w;
        var datetimeLines = function datetimeLines(_ref5) {
          var xC = _ref5.xC,
            x1 = _ref5.x1,
            y1 = _ref5.y1,
            x2 = _ref5.x2,
            y2 = _ref5.y2;
          for (var i = 0; i < xC; i++) {
            x1 = _this.xaxisLabels[i].position;
            x2 = _this.xaxisLabels[i].position;
            _this._drawGridLines({
              i: i,
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2,
              xCount: xCount,
              parent: _this.elgridLinesV
            });
          }
        };
        var categoryLines = function categoryLines(_ref6) {
          var xC = _ref6.xC,
            x1 = _ref6.x1,
            y1 = _ref6.y1,
            x2 = _ref6.x2,
            y2 = _ref6.y2;
          for (var i = 0; i < xC + (w.globals.isXNumeric ? 0 : 1); i++) {
            if (i === 0 && xC === 1 && w.globals.dataPoints === 1) {
              x1 = w.globals.gridWidth / 2;
              x2 = x1;
            }
            _this._drawGridLines({
              i: i,
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2,
              xCount: xCount,
              parent: _this.elgridLinesV
            });
            x1 += w.globals.gridWidth / (w.globals.isXNumeric ? xC - 1 : xC);
            x2 = x1;
          }
        };
        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {
          var x1 = w.globals.padHorizontal;
          var y1 = 0;
          var x2;
          var y2 = w.globals.gridHeight;
          if (w.globals.timescaleLabels.length) {
            datetimeLines({
              xC: xCount,
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2
            });
          } else {
            if (w.globals.isXNumeric) {
              xCount = w.globals.xAxisScale.result.length;
            }
            categoryLines({
              xC: xCount,
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2
            });
          }
        }
        if (w.config.grid.yaxis.lines.show) {
          var _x = 0;
          var _y = 0;
          var _y2 = 0;
          var _x2 = w.globals.gridWidth;
          var tA = tickAmount + 1;
          if (this.isRangeBar) {
            tA = w.globals.labels.length;
          }
          for (var i = 0; i < tA + (this.isRangeBar ? 1 : 0); i++) {
            this._drawGridLine({
              i: i,
              xCount: tA + (this.isRangeBar ? 1 : 0),
              x1: _x,
              y1: _y,
              x2: _x2,
              y2: _y2,
              parent: this.elgridLinesH
            });
            _y += w.globals.gridHeight / (this.isRangeBar ? tA : tickAmount);
            _y2 = _y;
          }
        }
      }
    }, {
      key: "_drawInvertedXYLines",
      value: function _drawInvertedXYLines(_ref7) {
        var xCount = _ref7.xCount;
        var w = this.w;
        if (w.config.grid.xaxis.lines.show || w.config.xaxis.axisTicks.show) {
          var x1 = w.globals.padHorizontal;
          var y1 = 0;
          var x2;
          var y2 = w.globals.gridHeight;
          for (var i = 0; i < xCount + 1; i++) {
            if (w.config.grid.xaxis.lines.show) {
              this._drawGridLine({
                i: i,
                xCount: xCount + 1,
                x1: x1,
                y1: y1,
                x2: x2,
                y2: y2,
                parent: this.elgridLinesV
              });
            }
            var xAxis = new XAxis(this.ctx);
            xAxis.drawXaxisTicks(x1, 0, w.globals.dom.elGraphical);
            x1 += w.globals.gridWidth / xCount;
            x2 = x1;
          }
        }
        if (w.config.grid.yaxis.lines.show) {
          var _x3 = 0;
          var _y3 = 0;
          var _y4 = 0;
          var _x4 = w.globals.gridWidth;
          for (var _i = 0; _i < w.globals.dataPoints + 1; _i++) {
            this._drawGridLine({
              i: _i,
              xCount: w.globals.dataPoints + 1,
              x1: _x3,
              y1: _y3,
              x2: _x4,
              y2: _y4,
              parent: this.elgridLinesH
            });
            _y3 += w.globals.gridHeight / w.globals.dataPoints;
            _y4 = _y3;
          }
        }
      }
    }, {
      key: "renderGrid",
      value: function renderGrid() {
        var w = this.w;
        var gl = w.globals;
        var graphics = new Graphics(this.ctx);
        this.elg = graphics.group({
          class: 'apexcharts-grid'
        });
        this.elgridLinesH = graphics.group({
          class: 'apexcharts-gridlines-horizontal'
        });
        this.elgridLinesV = graphics.group({
          class: 'apexcharts-gridlines-vertical'
        });
        this.elGridBorders = graphics.group({
          class: 'apexcharts-grid-borders'
        });
        this.elg.add(this.elgridLinesH);
        this.elg.add(this.elgridLinesV);
        if (!w.config.grid.show) {
          this.elgridLinesV.hide();
          this.elgridLinesH.hide();
          this.elGridBorders.hide();
        }
        var gridAxisIndex = 0;
        while (gridAxisIndex < gl.seriesYAxisMap.length && gl.ignoreYAxisIndexes.includes(gridAxisIndex)) {
          gridAxisIndex++;
        }
        if (gridAxisIndex === gl.seriesYAxisMap.length) {
          gridAxisIndex = 0;
        }
        var yTickAmount = gl.yAxisScale[gridAxisIndex].result.length - 1;
        var xCount;
        if (!gl.isBarHorizontal || this.isRangeBar) {
          xCount = this.xaxisLabels.length;
          if (this.isRangeBar) {
            var _gl$yAxisScale, _gl$yAxisScale$gridAx, _gl$yAxisScale$gridAx2;
            yTickAmount = gl.labels.length;
            if (w.config.xaxis.tickAmount && w.config.xaxis.labels.formatter) {
              xCount = w.config.xaxis.tickAmount;
            }
            if (((_gl$yAxisScale = gl.yAxisScale) === null || _gl$yAxisScale === void 0 ? void 0 : (_gl$yAxisScale$gridAx = _gl$yAxisScale[gridAxisIndex]) === null || _gl$yAxisScale$gridAx === void 0 ? void 0 : (_gl$yAxisScale$gridAx2 = _gl$yAxisScale$gridAx.result) === null || _gl$yAxisScale$gridAx2 === void 0 ? void 0 : _gl$yAxisScale$gridAx2.length) > 0 && w.config.xaxis.type !== 'datetime') {
              xCount = gl.yAxisScale[gridAxisIndex].result.length - 1;
            }
          }
          this._drawXYLines({
            xCount: xCount,
            tickAmount: yTickAmount
          });
        } else {
          xCount = yTickAmount;

          // for horizontal bar chart, get the xaxis tickamount
          yTickAmount = gl.xTickAmount;
          this._drawInvertedXYLines({
            xCount: xCount,
            tickAmount: yTickAmount
          });
        }
        this.drawGridBands(xCount, yTickAmount);
        return {
          el: this.elg,
          elGridBorders: this.elGridBorders,
          xAxisTickWidth: gl.gridWidth / xCount
        };
      }
    }, {
      key: "drawGridBands",
      value: function drawGridBands(xCount, tickAmount) {
        var _this2 = this,
          _w$config$grid$row$co,
          _w$config$grid$column;
        var w = this.w;
        var drawBands = function drawBands(type, count, x1, y1, x2, y2) {
          for (var i = 0, c = 0; i < count; i++, c++) {
            if (c >= w.config.grid[type].colors.length) {
              c = 0;
            }
            _this2._drawGridBandRect({
              c: c,
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2,
              type: type
            });
            y1 += w.globals.gridHeight / tickAmount;
          }
        };
        if (((_w$config$grid$row$co = w.config.grid.row.colors) === null || _w$config$grid$row$co === void 0 ? void 0 : _w$config$grid$row$co.length) > 0) {
          drawBands('row', tickAmount, 0, 0, w.globals.gridWidth, w.globals.gridHeight / tickAmount);
        }
        if (((_w$config$grid$column = w.config.grid.column.colors) === null || _w$config$grid$column === void 0 ? void 0 : _w$config$grid$column.length) > 0) {
          var xc = !w.globals.isBarHorizontal && w.config.xaxis.tickPlacement === 'on' && (w.config.xaxis.type === 'category' || w.config.xaxis.convertedCatToNumeric) ? xCount - 1 : xCount;
          if (w.globals.isXNumeric) {
            xc = w.globals.xAxisScale.result.length - 1;
          }
          var x1 = w.globals.padHorizontal;
          var y1 = 0;
          var x2 = w.globals.padHorizontal + w.globals.gridWidth / xc;
          var y2 = w.globals.gridHeight;
          for (var i = 0, c = 0; i < xCount; i++, c++) {
            if (c >= w.config.grid.column.colors.length) {
              c = 0;
            }
            if (w.config.xaxis.type === 'datetime') {
              var _this$xaxisLabels;
              x1 = this.xaxisLabels[i].position;
              x2 = (((_this$xaxisLabels = this.xaxisLabels[i + 1]) === null || _this$xaxisLabels === void 0 ? void 0 : _this$xaxisLabels.position) || w.globals.gridWidth) - this.xaxisLabels[i].position;
            }
            this._drawGridBandRect({
              c: c,
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2,
              type: 'column'
            });
            x1 += w.globals.gridWidth / xc;
          }
        }
      }
    }]);
    return Grid;
  }();

  var Scales = /*#__PURE__*/function () {
    function Scales(ctx) {
      _classCallCheck(this, Scales);
      this.ctx = ctx;
      this.w = ctx.w;
      this.coreUtils = new CoreUtils(this.ctx);
    }

    // http://stackoverflow.com/questions/326679/choosing-an-attractive-linear-scale-for-a-graphs-y-axis
    // This routine creates the Y axis values for a graph.
    _createClass(Scales, [{
      key: "niceScale",
      value: function niceScale(yMin, yMax) {
        var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        // Calculate Min amd Max graphical labels and graph
        // increments.
        //
        // Output will be an array of the Y axis values that
        // encompass the Y values.
        var jsPrecision = 1e-11; // JS precision errors
        var w = this.w;
        var gl = w.globals;
        var axisCnf;
        var maxTicks;
        var gotMin;
        var gotMax;
        if (gl.isBarHorizontal) {
          axisCnf = w.config.xaxis;
          // The most ticks we can fit into the svg chart dimensions
          maxTicks = Math.max((gl.svgWidth - 100) / 25, 2); // Guestimate
        } else {
          axisCnf = w.config.yaxis[index];
          maxTicks = Math.max((gl.svgHeight - 100) / 15, 2);
        }
        if (!Utils$1.isNumber(maxTicks)) {
          maxTicks = 10;
        }
        gotMin = axisCnf.min !== undefined && axisCnf.min !== null;
        gotMax = axisCnf.max !== undefined && axisCnf.min !== null;
        var gotStepSize = axisCnf.stepSize !== undefined && axisCnf.stepSize !== null;
        var gotTickAmount = axisCnf.tickAmount !== undefined && axisCnf.tickAmount !== null;
        var ticks = gotTickAmount ? axisCnf.tickAmount : gl.niceScaleDefaultTicks[Math.min(Math.round(maxTicks / 2), gl.niceScaleDefaultTicks.length - 1)];

        // In case we have a multi axis chart:
        // Ensure subsequent series start with the same tickAmount as series[0],
        // because the tick lines are drawn based on series[0]. This does not
        // override user defined options for any yaxis.
        if (gl.isMultipleYAxis && !gotTickAmount && gl.multiAxisTickAmount > 0) {
          ticks = gl.multiAxisTickAmount;
          gotTickAmount = true;
        }
        if (ticks === 'dataPoints') {
          ticks = gl.dataPoints - 1;
        } else {
          // Ensure ticks is an integer
          ticks = Math.abs(Math.round(ticks));
        }
        if (yMin === Number.MIN_VALUE && yMax === 0 || !Utils$1.isNumber(yMin) && !Utils$1.isNumber(yMax) || yMin === Number.MIN_VALUE && yMax === -Number.MAX_VALUE) {
          // when all values are 0
          yMin = Utils$1.isNumber(axisCnf.min) ? axisCnf.min : 0;
          yMax = Utils$1.isNumber(axisCnf.max) ? axisCnf.max : yMin + ticks;
          gl.allSeriesCollapsed = false;
        }
        if (yMin > yMax) {
          // if somehow due to some wrong config, user sent max less than min,
          // adjust the min/max again
          console.warn('axis.min cannot be greater than axis.max: swapping min and max');
          var temp = yMax;
          yMax = yMin;
          yMin = temp;
        } else if (yMin === yMax) {
          // If yMin and yMax are identical, then
          // adjust the yMin and yMax values to actually
          // make a graph. Also avoids division by zero errors.
          yMin = yMin === 0 ? 0 : yMin - 1; // choose an integer in case yValueDecimals=0
          yMax = yMax === 0 ? 2 : yMax + 1; // choose an integer in case yValueDecimals=0
        }
        var result = [];
        if (ticks < 1) {
          ticks = 1;
        }
        var tiks = ticks;

        // Determine Range
        var range = Math.abs(yMax - yMin);

        // Snap min or max to zero if close
        var proximityRatio = 0.15;
        if (!gotMin && yMin > 0 && yMin / range < proximityRatio) {
          yMin = 0;
          gotMin = true;
        }
        if (!gotMax && yMax < 0 && -yMax / range < proximityRatio) {
          yMax = 0;
          gotMax = true;
        }
        range = Math.abs(yMax - yMin);

        // Calculate a pretty step value based on ticks

        // Initial stepSize
        var stepSize = range / tiks;
        var niceStep = stepSize;
        var mag = Math.floor(Math.log10(niceStep));
        var magPow = Math.pow(10, mag);
        // ceil() is used below in conjunction with the values populating
        // niceScaleAllowedMagMsd[][] to ensure that (niceStep * tiks)
        // produces a range that doesn't clip data points after stretching
        // the raw range out a little to match the prospective new range.
        var magMsd = Math.ceil(niceStep / magPow);
        // See globals.js for info on what niceScaleAllowedMagMsd does
        magMsd = gl.niceScaleAllowedMagMsd[gl.yValueDecimal === 0 ? 0 : 1][magMsd];
        niceStep = magMsd * magPow;

        // Initial stepSize
        stepSize = niceStep;

        // Get step value
        if (gl.isBarHorizontal && axisCnf.stepSize && axisCnf.type !== 'datetime') {
          stepSize = axisCnf.stepSize;
          gotStepSize = true;
        } else if (gotStepSize) {
          stepSize = axisCnf.stepSize;
        }
        if (gotStepSize) {
          if (axisCnf.forceNiceScale) {
            // Check that given stepSize is sane with respect to the range.
            //
            // The user can, by setting forceNiceScale = true,
            // define a stepSize that will be scaled to a useful value before
            // it's checked for consistency.
            //
            // If, for example, the range = 4 and the user defined stepSize = 8
            // (or 8000 or 0.0008, etc), then stepSize is inapplicable as
            // it is. Reducing it to 0.8 will fit with 5 ticks.
            //
            var stepMag = Math.floor(Math.log10(stepSize));
            stepSize *= Math.pow(10, mag - stepMag);
          }
        }

        // Start applying some rules
        if (gotMin && gotMax) {
          var crudeStep = range / tiks;
          // min and max (range) cannot be changed
          if (gotTickAmount) {
            if (gotStepSize) {
              if (Utils$1.mod(range, stepSize) != 0) {
                // stepSize conflicts with range
                var gcdStep = Utils$1.getGCD(stepSize, crudeStep);
                // gcdStep is a multiple of range because crudeStep is a multiple.
                // gcdStep is also a multiple of stepSize, so it partially honoured
                // All three could be equal, which would be very nice
                // if the computed stepSize generates too many ticks they will be
                // reduced later, unless the number is prime, in which case,
                // the chart will display all of them or just one (plus the X axis)
                // depending on svg dimensions. Setting forceNiceScale: true will force
                // the display of at least the default number of ticks.
                if (crudeStep / gcdStep < 10) {
                  stepSize = gcdStep;
                } else {
                  // stepSize conflicts and no reasonable adjustment, but must
                  // honour tickAmount
                  stepSize = crudeStep;
                }
              } else {
                // stepSize fits
                if (Utils$1.mod(stepSize, crudeStep) == 0) {
                  // crudeStep is a multiple of stepSize, or vice versa
                  // but we know that crudeStep will generate tickAmount ticks
                  stepSize = crudeStep;
                } else {
                  // stepSize conflicts with tickAmount
                  // if the user is setting up a multi-axis chart and wants
                  // synced axis ticks then they should not define stepSize
                  // or ensure there is no conflict between any of their options
                  // on any axis.
                  crudeStep = stepSize;
                  // De-prioritizing ticks from now on
                  gotTickAmount = false;
                }
              }
            } else {
              // no user stepSize, honour tickAmount
              stepSize = crudeStep;
            }
          } else {
            // default ticks in use, tiks can change
            if (gotStepSize) {
              if (Utils$1.mod(range, stepSize) == 0) {
                // user stepSize fits
                crudeStep = stepSize;
              } else {
                stepSize = crudeStep;
              }
            } else {
              // no user stepSize
              if (Utils$1.mod(range, stepSize) == 0) {
                // generated nice stepSize fits
                crudeStep = stepSize;
              } else {
                tiks = Math.ceil(range / stepSize);
                crudeStep = range / tiks;
                var _gcdStep = Utils$1.getGCD(range, stepSize);
                if (range / _gcdStep < maxTicks) {
                  crudeStep = _gcdStep;
                }
                stepSize = crudeStep;
              }
            }
          }
          tiks = Math.round(range / stepSize);
        } else {
          // Snap range to ticks
          if (!gotMin && !gotMax) {
            if (gl.isMultipleYAxis && gotTickAmount) {
              // Ensure graph doesn't clip.
              var tMin = stepSize * Math.floor(yMin / stepSize);
              var tMax = tMin + stepSize * tiks;
              if (tMax < yMax) {
                stepSize *= 2;
              }
              yMin = tMin;
              tMax = yMax;
              yMax = yMin + stepSize * tiks;
              // Snap min or max to zero if possible
              range = Math.abs(yMax - yMin);
              if (yMin > 0 && yMin < Math.abs(tMax - yMax)) {
                yMin = 0;
                yMax = stepSize * tiks;
              }
              if (yMax < 0 && -yMax < Math.abs(tMin - yMin)) {
                yMax = 0;
                yMin = -stepSize * tiks;
              }
            } else {
              yMin = stepSize * Math.floor(yMin / stepSize);
              yMax = stepSize * Math.ceil(yMax / stepSize);
            }
          } else if (gotMax) {
            if (gotTickAmount) {
              yMin = yMax - stepSize * tiks;
            } else {
              var yMinPrev = yMin;
              yMin = stepSize * Math.floor(yMin / stepSize);
              if (Math.abs(yMax - yMin) / Utils$1.getGCD(range, stepSize) > maxTicks) {
                // Use default ticks to compute yMin then shrinkwrap
                yMin = yMax - stepSize * ticks;
                yMin += stepSize * Math.floor((yMinPrev - yMin) / stepSize);
              }
            }
          } else if (gotMin) {
            if (gotTickAmount) {
              yMax = yMin + stepSize * tiks;
            } else {
              var yMaxPrev = yMax;
              yMax = stepSize * Math.ceil(yMax / stepSize);
              if (Math.abs(yMax - yMin) / Utils$1.getGCD(range, stepSize) > maxTicks) {
                // Use default ticks to compute yMin then shrinkwrap
                yMax = yMin + stepSize * ticks;
                yMax += stepSize * Math.ceil((yMaxPrev - yMax) / stepSize);
              }
            }
          }
          range = Math.abs(yMax - yMin);
          // Final check and possible adjustment of stepSize to prevent
          // overriding the user's min or max choice.
          stepSize = Utils$1.getGCD(range, stepSize);
          tiks = Math.round(range / stepSize);
        }

        // Shrinkwrap ticks to the range
        if (!gotTickAmount && !(gotMin || gotMax)) {
          tiks = Math.ceil((range - jsPrecision) / (stepSize + jsPrecision));
          // No user tickAmount, or min or max, we are free to adjust to avoid a
          // prime number. This helps when reducing ticks for small svg dimensions.
          if (tiks > 16 && Utils$1.getPrimeFactors(tiks).length < 2) {
            tiks++;
          }
        }

        // Prune tiks down to range if series is all integers. Since tiks > range,
        // range is very low (< 10 or so). Skip this step if gotTickAmount is true
        // because either the user set tickAmount or the chart is multiscale and
        // this axis is not determining the number of grid lines.
        if (!gotTickAmount && axisCnf.forceNiceScale && gl.yValueDecimal === 0 && tiks > range) {
          tiks = range;
          stepSize = Math.round(range / tiks);
        }
        if (tiks > maxTicks && (!(gotTickAmount || gotStepSize) || axisCnf.forceNiceScale)) {
          // Reduce the number of ticks nicely if chart svg dimensions shrink too far.
          // The reduced tick set should always be a subset of the full set.
          //
          // This following products of prime factors method works as follows:
          // We compute the prime factors of the full tick count (tiks), then all the
          // possible products of those factors in order from smallest to biggest,
          // until we find a product P such that: tiks/P < maxTicks.
          //
          // Example:
          // Computing products of the prime factors of 30.
          //
          //   tiks | pf  |  1     2     3      4      5      6  <-- compute order
          //   --------------------------------------------------
          //     30 |  5  |              5             5      5  <-- Multiply all
          //        |  3  |        3            3      3      3  <-- primes in each
          //        |  2  |  2                  2             2  <-- column = P
          //   --------------------------------------------------
          //                15    10     6      5      2      1  <-- tiks/P
          //
          //   tiks = 30 has prime factors [2, 3, 5]
          //   The loop below computes the products [2,3,5,6,15,30].
          //   The last product of P = 2*3*5 is skipped since 30/P = 1.
          //   This yields tiks/P = [15,10,6,5,2,1], checked in order until
          //   tiks/P < maxTicks.
          //
          //   Pros:
          //      1) The ticks in the reduced set are always members of the
          //         full set of ticks.
          //   Cons:
          //      1) None: if tiks is prime, we get all or one, nothing between, so
          //      the worst case is to display all, which is the status quo. Really
          //      only a problem visually for larger tick numbers, say, > 7.
          //
          var pf = Utils$1.getPrimeFactors(tiks);
          var last = pf.length - 1;
          var tt = tiks;
          reduceLoop: for (var xFactors = 0; xFactors < last; xFactors++) {
            for (var lowest = 0; lowest <= last - xFactors; lowest++) {
              var stop = Math.min(lowest + xFactors, last);
              var t = tt;
              var div = 1;
              for (var next = lowest; next <= stop; next++) {
                div *= pf[next];
              }
              t /= div;
              if (t < maxTicks) {
                tt = t;
                break reduceLoop;
              }
            }
          }
          if (tt === tiks) {
            // Could not reduce ticks at all, go all in and display just the
            // X axis and one tick.
            stepSize = range;
          } else {
            stepSize = range / tt;
          }
          tiks = Math.round(range / stepSize);
        }

        // Record final tiks for use by other series that call niceScale().
        // Note: some don't, like logarithmicScale(), etc.
        if (gl.isMultipleYAxis && gl.multiAxisTickAmount == 0 && gl.ignoreYAxisIndexes.indexOf(index) < 0) {
          gl.multiAxisTickAmount = tiks;
        }

        // build Y label array.

        var val = yMin - stepSize;
        // Ensure we don't under/over shoot due to JS precision errors.
        // This also fixes (amongst others):
        // https://github.com/apexcharts/apexcharts.js/issues/430
        var err = stepSize * jsPrecision;
        do {
          val += stepSize;
          result.push(Utils$1.stripNumber(val, 7));
        } while (yMax - val > err);
        return {
          result: result,
          niceMin: result[0],
          niceMax: result[result.length - 1]
        };
      }
    }, {
      key: "linearScale",
      value: function linearScale(yMin, yMax) {
        var ticks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
        var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var step = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
        var range = Math.abs(yMax - yMin);
        var result = [];
        if (yMin === yMax) {
          result = [yMin];
          return {
            result: result,
            niceMin: result[0],
            niceMax: result[result.length - 1]
          };
        }
        ticks = this._adjustTicksForSmallRange(ticks, index, range);
        if (ticks === 'dataPoints') {
          ticks = this.w.globals.dataPoints - 1;
        }
        if (!step) {
          step = range / ticks;
        }
        step = Math.round((step + Number.EPSILON) * 100) / 100;
        if (ticks === Number.MAX_VALUE) {
          ticks = 5;
          step = 1;
        }
        var v = yMin;
        while (ticks >= 0) {
          result.push(v);
          v = Utils$1.preciseAddition(v, step);
          ticks -= 1;
        }
        return {
          result: result,
          niceMin: result[0],
          niceMax: result[result.length - 1]
        };
      }
    }, {
      key: "logarithmicScaleNice",
      value: function logarithmicScaleNice(yMin, yMax, base) {
        // Basic validation to avoid for loop starting at -inf.
        if (yMax <= 0) yMax = Math.max(yMin, base);
        if (yMin <= 0) yMin = Math.min(yMax, base);
        var logs = [];

        // Get powers of base for our max and min
        var logMax = Math.ceil(Math.log(yMax) / Math.log(base) + 1);
        var logMin = Math.floor(Math.log(yMin) / Math.log(base));
        for (var i = logMin; i < logMax; i++) {
          logs.push(Math.pow(base, i));
        }
        return {
          result: logs,
          niceMin: logs[0],
          niceMax: logs[logs.length - 1]
        };
      }
    }, {
      key: "logarithmicScale",
      value: function logarithmicScale(yMin, yMax, base) {
        // Basic validation to avoid for loop starting at -inf.
        if (yMax <= 0) yMax = Math.max(yMin, base);
        if (yMin <= 0) yMin = Math.min(yMax, base);
        var logs = [];

        // Get the logarithmic range.
        var logMax = Math.log(yMax) / Math.log(base);
        var logMin = Math.log(yMin) / Math.log(base);

        // Get the exact logarithmic range.
        // (This is the exact number of multiples of the base there are between yMin and yMax).
        var logRange = logMax - logMin;

        // Round the logarithmic range to get the number of ticks we will create.
        // If the chosen min/max values are multiples of each other WRT the base, this will be neat.
        // If the chosen min/max aren't, we will at least still provide USEFUL ticks.
        var ticks = Math.round(logRange);

        // Get the logarithmic spacing between ticks.
        var logTickSpacing = logRange / ticks;

        // Create as many ticks as there is range in the logs.
        for (var i = 0, logTick = logMin; i < ticks; i++, logTick += logTickSpacing) {
          logs.push(Math.pow(base, logTick));
        }

        // Add a final tick at the yMax.
        logs.push(Math.pow(base, logMax));
        return {
          result: logs,
          niceMin: yMin,
          niceMax: yMax
        };
      }
    }, {
      key: "_adjustTicksForSmallRange",
      value: function _adjustTicksForSmallRange(ticks, index, range) {
        var newTicks = ticks;
        if (typeof index !== 'undefined' && this.w.config.yaxis[index].labels.formatter && this.w.config.yaxis[index].tickAmount === undefined) {
          var formattedVal = Number(this.w.config.yaxis[index].labels.formatter(1));
          if (Utils$1.isNumber(formattedVal) && this.w.globals.yValueDecimal === 0) {
            newTicks = Math.ceil(range);
          }
        }
        return newTicks < ticks ? newTicks : ticks;
      }
    }, {
      key: "setYScaleForIndex",
      value: function setYScaleForIndex(index, minY, maxY) {
        var gl = this.w.globals;
        var cnf = this.w.config;
        var y = gl.isBarHorizontal ? cnf.xaxis : cnf.yaxis[index];
        if (typeof gl.yAxisScale[index] === 'undefined') {
          gl.yAxisScale[index] = [];
        }
        var range = Math.abs(maxY - minY);
        if (y.logarithmic && range <= 5) {
          gl.invalidLogScale = true;
        }
        if (y.logarithmic && range > 5) {
          gl.allSeriesCollapsed = false;
          gl.yAxisScale[index] = y.forceNiceScale ? this.logarithmicScaleNice(minY, maxY, y.logBase) : this.logarithmicScale(minY, maxY, y.logBase);
        } else {
          if (maxY === -Number.MAX_VALUE || !Utils$1.isNumber(maxY) || minY === Number.MAX_VALUE || !Utils$1.isNumber(minY)) {
            // no data in the chart.
            // Either all series collapsed or user passed a blank array.
            // Show the user's yaxis with their scale options but with a range.
            gl.yAxisScale[index] = this.niceScale(Number.MIN_VALUE, 0, index);
          } else {
            // there is some data. Turn off the allSeriesCollapsed flag
            gl.allSeriesCollapsed = false;
            gl.yAxisScale[index] = this.niceScale(minY, maxY, index);
          }
        }
      }
    }, {
      key: "setXScale",
      value: function setXScale(minX, maxX) {
        var w = this.w;
        var gl = w.globals;
        if (maxX === -Number.MAX_VALUE || !Utils$1.isNumber(maxX)) {
          // no data in the chart. Either all series collapsed or user passed a blank array
          gl.xAxisScale = this.linearScale(0, 10, 10);
        } else {
          var ticks = gl.xTickAmount;
          gl.xAxisScale = this.linearScale(minX, maxX, ticks, 0, w.config.xaxis.max === undefined ? w.config.xaxis.stepSize : undefined);
        }
        return gl.xAxisScale;
      }
    }, {
      key: "scaleMultipleYAxes",
      value: function scaleMultipleYAxes() {
        var _this = this;
        var cnf = this.w.config;
        var gl = this.w.globals;
        this.coreUtils.setSeriesYAxisMappings();
        var axisSeriesMap = gl.seriesYAxisMap;
        var minYArr = gl.minYArr;
        var maxYArr = gl.maxYArr;

        // Compute min..max for each yaxis
        gl.allSeriesCollapsed = true;
        gl.barGroups = [];
        axisSeriesMap.forEach(function (axisSeries, ai) {
          var groupNames = [];
          axisSeries.forEach(function (as) {
            var _cnf$series$as;
            var group = (_cnf$series$as = cnf.series[as]) === null || _cnf$series$as === void 0 ? void 0 : _cnf$series$as.group;
            if (groupNames.indexOf(group) < 0) {
              groupNames.push(group);
            }
          });
          if (axisSeries.length > 0) {
            (function () {
              var minY = Number.MAX_VALUE;
              var maxY = -Number.MAX_VALUE;
              var lowestY = minY;
              var highestY = maxY;
              var seriesType;
              var seriesGroupName;
              if (cnf.chart.stacked) {
                (function () {
                  // Series' on this axis with the same group name will be stacked.
                  // Sum series in each group separately
                  var mapSeries = new Array(gl.dataPoints).fill(0);
                  var sumSeries = [];
                  var posSeries = [];
                  var negSeries = [];
                  groupNames.forEach(function () {
                    sumSeries.push(mapSeries.map(function () {
                      return Number.MIN_VALUE;
                    }));
                    posSeries.push(mapSeries.map(function () {
                      return Number.MIN_VALUE;
                    }));
                    negSeries.push(mapSeries.map(function () {
                      return Number.MIN_VALUE;
                    }));
                  });
                  var _loop = function _loop(i) {
                    // Assume chart type but the first series that has a type overrides.
                    if (!seriesType && cnf.series[axisSeries[i]].type) {
                      seriesType = cnf.series[axisSeries[i]].type;
                    }
                    // Sum all series for this yaxis at each corresponding datapoint
                    // For bar and column charts we need to keep positive and negative
                    // values separate, for each group separately.
                    var si = axisSeries[i];
                    if (cnf.series[si].group) {
                      seriesGroupName = cnf.series[si].group;
                    } else {
                      seriesGroupName = 'axis-'.concat(ai);
                    }
                    var collapsed = !(gl.collapsedSeriesIndices.indexOf(si) < 0 && gl.ancillaryCollapsedSeriesIndices.indexOf(si) < 0);
                    if (!collapsed) {
                      gl.allSeriesCollapsed = false;
                      groupNames.forEach(function (gn, gni) {
                        // Undefined group names will be grouped together as their own
                        // group.
                        if (cnf.series[si].group === gn) {
                          for (var j = 0; j < gl.series[si].length; j++) {
                            var val = gl.series[si][j];
                            if (val >= 0) {
                              posSeries[gni][j] += val;
                            } else {
                              negSeries[gni][j] += val;
                            }
                            sumSeries[gni][j] += val;
                            // For non bar-like series' we need these point max/min values.
                            lowestY = Math.min(lowestY, val);
                            highestY = Math.max(highestY, val);
                          }
                        }
                      });
                    }
                    if (seriesType === 'bar' || seriesType === 'column') {
                      gl.barGroups.push(seriesGroupName);
                    }
                  };
                  for (var i = 0; i < axisSeries.length; i++) {
                    _loop(i);
                  }
                  if (!seriesType) {
                    seriesType = cnf.chart.type;
                  }
                  if (seriesType === 'bar' || seriesType === 'column') {
                    groupNames.forEach(function (gn, gni) {
                      minY = Math.min(minY, Math.min.apply(null, negSeries[gni]));
                      maxY = Math.max(maxY, Math.max.apply(null, posSeries[gni]));
                    });
                  } else {
                    groupNames.forEach(function (gn, gni) {
                      lowestY = Math.min(lowestY, Math.min.apply(null, sumSeries[gni]));
                      highestY = Math.max(highestY, Math.max.apply(null, sumSeries[gni]));
                    });
                    minY = lowestY;
                    maxY = highestY;
                  }
                  if (minY === Number.MIN_VALUE && maxY === Number.MIN_VALUE) {
                    // No series data
                    maxY = -Number.MAX_VALUE;
                  }
                })();
              } else {
                for (var i = 0; i < axisSeries.length; i++) {
                  var si = axisSeries[i];
                  minY = Math.min(minY, minYArr[si]);
                  maxY = Math.max(maxY, maxYArr[si]);
                  var collapsed = !(gl.collapsedSeriesIndices.indexOf(si) < 0 && gl.ancillaryCollapsedSeriesIndices.indexOf(si) < 0);
                  if (!collapsed) {
                    gl.allSeriesCollapsed = false;
                  }
                }
              }
              if (cnf.yaxis[ai].min !== undefined) {
                if (typeof cnf.yaxis[ai].min === 'function') {
                  minY = cnf.yaxis[ai].min(minY);
                } else {
                  minY = cnf.yaxis[ai].min;
                }
              }
              if (cnf.yaxis[ai].max !== undefined) {
                if (typeof cnf.yaxis[ai].max === 'function') {
                  maxY = cnf.yaxis[ai].max(maxY);
                } else {
                  maxY = cnf.yaxis[ai].max;
                }
              }
              gl.barGroups = gl.barGroups.filter(function (v, i, a) {
                return a.indexOf(v) === i;
              });
              // Set the scale for this yaxis
              _this.setYScaleForIndex(ai, minY, maxY);
              // Set individual series min and max to nice values
              axisSeries.forEach(function (si) {
                minYArr[si] = gl.yAxisScale[ai].niceMin;
                maxYArr[si] = gl.yAxisScale[ai].niceMax;
              });
            })();
          } else {
            // No series referenced by this yaxis
            _this.setYScaleForIndex(ai, 0, -Number.MAX_VALUE);
          }
        });
      }
    }]);
    return Scales;
  }();

  /**
   * Range is used to generates values between min and max.
   *
   * @module Range
   **/
  var Range = /*#__PURE__*/function () {
    function Range(ctx) {
      _classCallCheck(this, Range);
      this.ctx = ctx;
      this.w = ctx.w;
      this.scales = new Scales(ctx);
    }
    _createClass(Range, [{
      key: "init",
      value: function init() {
        this.setYRange();
        this.setXRange();
        this.setZRange();
      }
    }, {
      key: "getMinYMaxY",
      value: function getMinYMaxY(startingSeriesIndex) {
        var lowestY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;
        var highestY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Number.MAX_VALUE;
        var endingSeriesIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var cnf = this.w.config;
        var gl = this.w.globals;
        var maxY = -Number.MAX_VALUE;
        var minY = Number.MIN_VALUE;
        if (endingSeriesIndex === null) {
          endingSeriesIndex = startingSeriesIndex + 1;
        }
        var series = gl.series;
        var seriesMin = series;
        var seriesMax = series;
        if (cnf.chart.type === 'candlestick') {
          seriesMin = gl.seriesCandleL;
          seriesMax = gl.seriesCandleH;
        } else if (cnf.chart.type === 'boxPlot') {
          seriesMin = gl.seriesCandleO;
          seriesMax = gl.seriesCandleC;
        } else if (gl.isRangeData) {
          seriesMin = gl.seriesRangeStart;
          seriesMax = gl.seriesRangeEnd;
        }
        var autoScaleYaxis = false;
        if (gl.seriesX.length >= endingSeriesIndex) {
          var _gl$brushSource;
          // Eventually brushSource will be set if the current chart is a target.
          // That is, after the appropriate event causes us to update.
          var brush = (_gl$brushSource = gl.brushSource) === null || _gl$brushSource === void 0 ? void 0 : _gl$brushSource.w.config.chart.brush;
          if (cnf.chart.zoom.enabled && cnf.chart.zoom.autoScaleYaxis || brush !== null && brush !== void 0 && brush.enabled && brush !== null && brush !== void 0 && brush.autoScaleYaxis) {
            autoScaleYaxis = true;
          }
        }
        for (var i = startingSeriesIndex; i < endingSeriesIndex; i++) {
          gl.dataPoints = Math.max(gl.dataPoints, series[i].length);
          var seriesType = cnf.series[i].type;
          if (gl.categoryLabels.length) {
            gl.dataPoints = gl.categoryLabels.filter(function (label) {
              return typeof label !== 'undefined';
            }).length;
          }
          if (gl.labels.length && cnf.xaxis.type !== 'datetime' && gl.series.reduce(function (a, c) {
            return a + c.length;
          }, 0) !== 0) {
            // the condition cnf.xaxis.type !== 'datetime' fixes #3897 and #3905
            gl.dataPoints = Math.max(gl.dataPoints, gl.labels.length);
          }
          var firstXIndex = 0;
          var lastXIndex = series[i].length - 1;
          if (autoScaleYaxis) {
            // Scale the Y axis to the min..max within the possibly zoomed X axis domain.
            if (cnf.xaxis.min) {
              for (; firstXIndex < lastXIndex && gl.seriesX[i][firstXIndex] < cnf.xaxis.min; firstXIndex++) {}
            }
            if (cnf.xaxis.max) {
              for (; lastXIndex > firstXIndex && gl.seriesX[i][lastXIndex] > cnf.xaxis.max; lastXIndex--) {}
            }
          }
          for (var j = firstXIndex; j <= lastXIndex && j < gl.series[i].length; j++) {
            var val = series[i][j];
            if (val !== null && Utils$1.isNumber(val)) {
              var _seriesMax$i, _seriesMin$i, _seriesMin$i2, _seriesMin$i3;
              if (typeof ((_seriesMax$i = seriesMax[i]) === null || _seriesMax$i === void 0 ? void 0 : _seriesMax$i[j]) !== 'undefined') {
                maxY = Math.max(maxY, seriesMax[i][j]);
                lowestY = Math.min(lowestY, seriesMax[i][j]);
              }
              if (typeof ((_seriesMin$i = seriesMin[i]) === null || _seriesMin$i === void 0 ? void 0 : _seriesMin$i[j]) !== 'undefined') {
                lowestY = Math.min(lowestY, seriesMin[i][j]);
                highestY = Math.max(highestY, seriesMin[i][j]);
              }

              // These series arrays are dual purpose:
              // Array      : CandleO, CandleH, CandleM, CandleL, CandleC
              // Candlestick: O        H                 L        C
              // Boxplot    : Min      Q1       Median   Q3       Max
              switch (seriesType) {
                case 'candlestick':
                  {
                    if (typeof gl.seriesCandleC[i][j] !== 'undefined') {
                      maxY = Math.max(maxY, gl.seriesCandleH[i][j]);
                      lowestY = Math.min(lowestY, gl.seriesCandleL[i][j]);
                    }
                  }
                  break;
                case 'boxPlot':
                  {
                    if (typeof gl.seriesCandleC[i][j] !== 'undefined') {
                      maxY = Math.max(maxY, gl.seriesCandleC[i][j]);
                      lowestY = Math.min(lowestY, gl.seriesCandleO[i][j]);
                    }
                  }
                  break;
              }

              // there is a combo chart and the specified series in not either
              // candlestick, boxplot, or rangeArea/rangeBar; find the max there.
              if (seriesType && seriesType !== 'candlestick' && seriesType !== 'boxPlot' && seriesType !== 'rangeArea' && seriesType !== 'rangeBar') {
                maxY = Math.max(maxY, gl.series[i][j]);
                lowestY = Math.min(lowestY, gl.series[i][j]);
              }
              if (gl.seriesGoals[i] && gl.seriesGoals[i][j] && Array.isArray(gl.seriesGoals[i][j])) {
                gl.seriesGoals[i][j].forEach(function (g) {
                  maxY = Math.max(maxY, g.value);
                  lowestY = Math.min(lowestY, g.value);
                });
              }
              highestY = maxY;
              val = Utils$1.noExponents(val);
              if (Utils$1.isFloat(val)) {
                gl.yValueDecimal = Math.max(gl.yValueDecimal, val.toString().split('.')[1].length);
              }
              if (minY > ((_seriesMin$i2 = seriesMin[i]) === null || _seriesMin$i2 === void 0 ? void 0 : _seriesMin$i2[j]) && ((_seriesMin$i3 = seriesMin[i]) === null || _seriesMin$i3 === void 0 ? void 0 : _seriesMin$i3[j]) < 0) {
                minY = seriesMin[i][j];
              }
            } else {
              gl.hasNullValues = true;
            }
          }
          if (seriesType === 'bar' || seriesType === 'column') {
            if (minY < 0 && maxY < 0) {
              // all negative values in a bar series, hence make the max to 0
              maxY = 0;
              highestY = Math.max(highestY, 0);
            }
            if (minY === Number.MIN_VALUE) {
              minY = 0;
              lowestY = Math.min(lowestY, 0);
            }
          }
        }
        if (cnf.chart.type === 'rangeBar' && gl.seriesRangeStart.length && gl.isBarHorizontal) {
          minY = lowestY;
        }
        if (cnf.chart.type === 'bar') {
          if (minY < 0 && maxY < 0) {
            // all negative values in a bar chart, hence make the max to 0
            maxY = 0;
          }
          if (minY === Number.MIN_VALUE) {
            minY = 0;
          }
        }
        return {
          minY: minY,
          maxY: maxY,
          lowestY: lowestY,
          highestY: highestY
        };
      }
    }, {
      key: "setYRange",
      value: function setYRange() {
        var gl = this.w.globals;
        var cnf = this.w.config;
        gl.maxY = -Number.MAX_VALUE;
        gl.minY = Number.MIN_VALUE;
        var lowestYInAllSeries = Number.MAX_VALUE;
        var minYMaxY;
        if (gl.isMultipleYAxis) {
          // we need to get minY and maxY for multiple y axis
          lowestYInAllSeries = Number.MAX_VALUE;
          for (var i = 0; i < gl.series.length; i++) {
            minYMaxY = this.getMinYMaxY(i);
            gl.minYArr[i] = minYMaxY.lowestY;
            gl.maxYArr[i] = minYMaxY.highestY;
            lowestYInAllSeries = Math.min(lowestYInAllSeries, minYMaxY.lowestY);
          }
        }

        // and then, get the minY and maxY from all series
        minYMaxY = this.getMinYMaxY(0, lowestYInAllSeries, null, gl.series.length);
        if (cnf.chart.type === 'bar') {
          gl.minY = minYMaxY.minY;
          gl.maxY = minYMaxY.maxY;
        } else {
          gl.minY = minYMaxY.lowestY;
          gl.maxY = minYMaxY.highestY;
        }
        lowestYInAllSeries = minYMaxY.lowestY;
        if (cnf.chart.stacked) {
          this._setStackedMinMax();
        }

        // if the numbers are too big, reduce the range
        // for eg, if number is between 100000-110000, putting 0 as the lowest
        // value is not so good idea. So change the gl.minY for
        // line/area/scatter/candlesticks/boxPlot/vertical rangebar
        if (cnf.chart.type === 'line' || cnf.chart.type === 'area' || cnf.chart.type === 'scatter' || cnf.chart.type === 'candlestick' || cnf.chart.type === 'boxPlot' || cnf.chart.type === 'rangeBar' && !gl.isBarHorizontal) {
          if (gl.minY === Number.MIN_VALUE && lowestYInAllSeries !== -Number.MAX_VALUE && lowestYInAllSeries !== gl.maxY // single value possibility
          ) {
            gl.minY = lowestYInAllSeries;
          }
        } else {
          gl.minY = gl.minY !== Number.MIN_VALUE ? Math.min(minYMaxY.minY, gl.minY) : minYMaxY.minY;
        }
        cnf.yaxis.forEach(function (yaxe, index) {
          // override all min/max values by user defined values (y axis)
          if (yaxe.max !== undefined) {
            if (typeof yaxe.max === 'number') {
              gl.maxYArr[index] = yaxe.max;
            } else if (typeof yaxe.max === 'function') {
              // fixes apexcharts.js/issues/2098
              gl.maxYArr[index] = yaxe.max(gl.isMultipleYAxis ? gl.maxYArr[index] : gl.maxY);
            }

            // gl.maxY is for single y-axis chart, it will be ignored in multi-yaxis
            gl.maxY = gl.maxYArr[index];
          }
          if (yaxe.min !== undefined) {
            if (typeof yaxe.min === 'number') {
              gl.minYArr[index] = yaxe.min;
            } else if (typeof yaxe.min === 'function') {
              // fixes apexcharts.js/issues/2098
              gl.minYArr[index] = yaxe.min(gl.isMultipleYAxis ? gl.minYArr[index] === Number.MIN_VALUE ? 0 : gl.minYArr[index] : gl.minY);
            }
            // gl.minY is for single y-axis chart, it will be ignored in multi-yaxis
            gl.minY = gl.minYArr[index];
          }
        });

        // for horizontal bar charts, we need to check xaxis min/max as user may have specified there
        if (gl.isBarHorizontal) {
          var minmax = ['min', 'max'];
          minmax.forEach(function (m) {
            if (cnf.xaxis[m] !== undefined && typeof cnf.xaxis[m] === 'number') {
              m === 'min' ? gl.minY = cnf.xaxis[m] : gl.maxY = cnf.xaxis[m];
            }
          });
        }
        if (gl.isMultipleYAxis) {
          this.scales.scaleMultipleYAxes();
          gl.minY = lowestYInAllSeries;
        } else {
          this.scales.setYScaleForIndex(0, gl.minY, gl.maxY);
          gl.minY = gl.yAxisScale[0].niceMin;
          gl.maxY = gl.yAxisScale[0].niceMax;
          gl.minYArr[0] = gl.minY;
          gl.maxYArr[0] = gl.maxY;
        }
        gl.barGroups = [];
        gl.lineGroups = [];
        gl.areaGroups = [];
        cnf.series.forEach(function (s) {
          var type = s.type || cnf.chart.type;
          switch (type) {
            case 'bar':
            case 'column':
              gl.barGroups.push(s.group);
              break;
            case 'line':
              gl.lineGroups.push(s.group);
              break;
            case 'area':
              gl.areaGroups.push(s.group);
              break;
          }
        });
        // Uniquify the group names in each stackable chart type.
        gl.barGroups = gl.barGroups.filter(function (v, i, a) {
          return a.indexOf(v) === i;
        });
        gl.lineGroups = gl.lineGroups.filter(function (v, i, a) {
          return a.indexOf(v) === i;
        });
        gl.areaGroups = gl.areaGroups.filter(function (v, i, a) {
          return a.indexOf(v) === i;
        });
        return {
          minY: gl.minY,
          maxY: gl.maxY,
          minYArr: gl.minYArr,
          maxYArr: gl.maxYArr,
          yAxisScale: gl.yAxisScale
        };
      }
    }, {
      key: "setXRange",
      value: function setXRange() {
        var gl = this.w.globals;
        var cnf = this.w.config;
        var isXNumeric = cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'datetime' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided || gl.noLabelsProvided || gl.isXNumeric;
        var getInitialMinXMaxX = function getInitialMinXMaxX() {
          for (var i = 0; i < gl.series.length; i++) {
            if (gl.labels[i]) {
              for (var j = 0; j < gl.labels[i].length; j++) {
                if (gl.labels[i][j] !== null && Utils$1.isNumber(gl.labels[i][j])) {
                  gl.maxX = Math.max(gl.maxX, gl.labels[i][j]);
                  gl.initialMaxX = Math.max(gl.maxX, gl.labels[i][j]);
                  gl.minX = Math.min(gl.minX, gl.labels[i][j]);
                  gl.initialMinX = Math.min(gl.minX, gl.labels[i][j]);
                }
              }
            }
          }
        };
        // minX maxX starts here
        if (gl.isXNumeric) {
          getInitialMinXMaxX();
        }
        if (gl.noLabelsProvided) {
          if (cnf.xaxis.categories.length === 0) {
            gl.maxX = gl.labels[gl.labels.length - 1];
            gl.initialMaxX = gl.labels[gl.labels.length - 1];
            gl.minX = 1;
            gl.initialMinX = 1;
          }
        }
        if (gl.isXNumeric || gl.noLabelsProvided || gl.dataFormatXNumeric) {
          var ticks = 10;
          if (cnf.xaxis.tickAmount === undefined) {
            ticks = Math.round(gl.svgWidth / 150);

            // no labels provided and total number of dataPoints is less than 30
            if (cnf.xaxis.type === 'numeric' && gl.dataPoints < 30) {
              ticks = gl.dataPoints - 1;
            }

            // this check is for when ticks exceeds total datapoints and that would result in duplicate labels
            if (ticks > gl.dataPoints && gl.dataPoints !== 0) {
              ticks = gl.dataPoints - 1;
            }
          } else if (cnf.xaxis.tickAmount === 'dataPoints') {
            if (gl.series.length > 1) {
              ticks = gl.series[gl.maxValsInArrayIndex].length - 1;
            }
            if (gl.isXNumeric) {
              var diff = Math.round(gl.maxX - gl.minX);
              if (diff < 30) {
                // When numeric range is small, show a tick for every integer
                ticks = diff;
              }
            }
          } else {
            ticks = cnf.xaxis.tickAmount;
          }
          gl.xTickAmount = ticks;

          // override all min/max values by user defined values (x axis)
          if (cnf.xaxis.max !== undefined && typeof cnf.xaxis.max === 'number') {
            gl.maxX = cnf.xaxis.max;
          }
          if (cnf.xaxis.min !== undefined && typeof cnf.xaxis.min === 'number') {
            gl.minX = cnf.xaxis.min;
          }

          // if range is provided, adjust the new minX
          if (cnf.xaxis.range !== undefined) {
            gl.minX = gl.maxX - cnf.xaxis.range;
          }
          if (gl.minX !== Number.MAX_VALUE && gl.maxX !== -Number.MAX_VALUE) {
            if (cnf.xaxis.convertedCatToNumeric && !gl.dataFormatXNumeric) {
              var catScale = [];
              for (var i = gl.minX - 1; i < gl.maxX; i++) {
                catScale.push(i + 1);
              }
              gl.xAxisScale = {
                result: catScale,
                niceMin: catScale[0],
                niceMax: catScale[catScale.length - 1]
              };
            } else {
              gl.xAxisScale = this.scales.setXScale(gl.minX, gl.maxX);
            }
          } else {
            gl.xAxisScale = this.scales.linearScale(0, ticks, ticks, 0, cnf.xaxis.stepSize);
            if (gl.noLabelsProvided && gl.labels.length > 0) {
              gl.xAxisScale = this.scales.linearScale(1, gl.labels.length, ticks - 1, 0, cnf.xaxis.stepSize);

              // this is the only place seriesX is again mutated
              gl.seriesX = gl.labels.slice();
            }
          }
          // we will still store these labels as the count for this will be different (to draw grid and labels placement)
          if (isXNumeric) {
            gl.labels = gl.xAxisScale.result.slice();
          }
        }
        if (gl.isBarHorizontal && gl.labels.length) {
          gl.xTickAmount = gl.labels.length;
        }

        // single dataPoint
        this._handleSingleDataPoint();

        // minimum x difference to calculate bar width in numeric bars
        this._getMinXDiff();
        return {
          minX: gl.minX,
          maxX: gl.maxX
        };
      }
    }, {
      key: "setZRange",
      value: function setZRange() {
        // minZ, maxZ starts here
        var gl = this.w.globals;
        if (!gl.isDataXYZ) return;
        for (var i = 0; i < gl.series.length; i++) {
          if (typeof gl.seriesZ[i] !== 'undefined') {
            for (var j = 0; j < gl.seriesZ[i].length; j++) {
              if (gl.seriesZ[i][j] !== null && Utils$1.isNumber(gl.seriesZ[i][j])) {
                gl.maxZ = Math.max(gl.maxZ, gl.seriesZ[i][j]);
                gl.minZ = Math.min(gl.minZ, gl.seriesZ[i][j]);
              }
            }
          }
        }
      }
    }, {
      key: "_handleSingleDataPoint",
      value: function _handleSingleDataPoint() {
        var gl = this.w.globals;
        var cnf = this.w.config;
        if (gl.minX === gl.maxX) {
          var datetimeObj = new DateTime(this.ctx);
          if (cnf.xaxis.type === 'datetime') {
            var newMinX = datetimeObj.getDate(gl.minX);
            if (cnf.xaxis.labels.datetimeUTC) {
              newMinX.setUTCDate(newMinX.getUTCDate() - 2);
            } else {
              newMinX.setDate(newMinX.getDate() - 2);
            }
            gl.minX = new Date(newMinX).getTime();
            var newMaxX = datetimeObj.getDate(gl.maxX);
            if (cnf.xaxis.labels.datetimeUTC) {
              newMaxX.setUTCDate(newMaxX.getUTCDate() + 2);
            } else {
              newMaxX.setDate(newMaxX.getDate() + 2);
            }
            gl.maxX = new Date(newMaxX).getTime();
          } else if (cnf.xaxis.type === 'numeric' || cnf.xaxis.type === 'category' && !gl.noLabelsProvided) {
            gl.minX = gl.minX - 2;
            gl.initialMinX = gl.minX;
            gl.maxX = gl.maxX + 2;
            gl.initialMaxX = gl.maxX;
          }
        }
      }
    }, {
      key: "_getMinXDiff",
      value: function _getMinXDiff() {
        var gl = this.w.globals;
        if (gl.isXNumeric) {
          // get the least x diff if numeric x axis is present
          gl.seriesX.forEach(function (sX, i) {
            if (sX.length) {
              if (sX.length === 1) {
                // a small hack to prevent overlapping multiple bars when there is just 1 datapoint in bar series.
                // fix #811
                sX.push(gl.seriesX[gl.maxValsInArrayIndex][gl.seriesX[gl.maxValsInArrayIndex].length - 1]);
              }

              // fix #983 (clone the array to avoid side effects)
              var seriesX = sX.slice();
              seriesX.sort(function (a, b) {
                return a - b;
              });
              seriesX.forEach(function (s, j) {
                if (j > 0) {
                  var xDiff = s - seriesX[j - 1];
                  if (xDiff > 0) {
                    gl.minXDiff = Math.min(xDiff, gl.minXDiff);
                  }
                }
              });
              if (gl.dataPoints === 1 || gl.minXDiff === Number.MAX_VALUE) {
                // fixes apexcharts.js #1221
                gl.minXDiff = 0.5;
              }
            }
          });
        }
      }
    }, {
      key: "_setStackedMinMax",
      value: function _setStackedMinMax() {
        var _this = this;
        var gl = this.w.globals;
        // for stacked charts, we calculate each series's parallel values.
        // i.e, series[0][j] + series[1][j] .... [series[i.length][j]]
        // and get the max out of it

        if (!gl.series.length) return;
        var seriesGroups = gl.seriesGroups;
        if (!seriesGroups.length) {
          seriesGroups = [this.w.globals.seriesNames.map(function (name) {
            return name;
          })];
        }
        var stackedPoss = {};
        var stackedNegs = {};
        seriesGroups.forEach(function (group) {
          stackedPoss[group] = [];
          stackedNegs[group] = [];
          var indicesOfSeriesInGroup = _this.w.config.series.map(function (serie, si) {
            return group.indexOf(gl.seriesNames[si]) > -1 ? si : null;
          }).filter(function (f) {
            return f !== null;
          });
          indicesOfSeriesInGroup.forEach(function (i) {
            for (var j = 0; j < gl.series[gl.maxValsInArrayIndex].length; j++) {
              var _this$w$config$series, _this$w$config$series2, _this$w$config$series3, _this$w$config$series4;
              if (typeof stackedPoss[group][j] === 'undefined') {
                stackedPoss[group][j] = 0;
                stackedNegs[group][j] = 0;
              }
              var stackSeries = _this.w.config.chart.stacked && !gl.comboCharts || _this.w.config.chart.stacked && gl.comboCharts && (!_this.w.config.chart.stackOnlyBar || ((_this$w$config$series = _this.w.config.series) === null || _this$w$config$series === void 0 ? void 0 : (_this$w$config$series2 = _this$w$config$series[i]) === null || _this$w$config$series2 === void 0 ? void 0 : _this$w$config$series2.type) === 'bar' || ((_this$w$config$series3 = _this.w.config.series) === null || _this$w$config$series3 === void 0 ? void 0 : (_this$w$config$series4 = _this$w$config$series3[i]) === null || _this$w$config$series4 === void 0 ? void 0 : _this$w$config$series4.type) === 'column');
              if (stackSeries) {
                if (gl.series[i][j] !== null && Utils$1.isNumber(gl.series[i][j])) {
                  gl.series[i][j] > 0 ? stackedPoss[group][j] += parseFloat(gl.series[i][j]) + 0.0001 : stackedNegs[group][j] += parseFloat(gl.series[i][j]);
                }
              }
            }
          });
        });
        Object.entries(stackedPoss).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 1),
            key = _ref2[0];
          stackedPoss[key].forEach(function (_, stgi) {
            gl.maxY = Math.max(gl.maxY, stackedPoss[key][stgi]);
            gl.minY = Math.min(gl.minY, stackedNegs[key][stgi]);
          });
        });
      }
    }]);
    return Range;
  }();

  /**
   * ApexCharts YAxis Class for drawing Y-Axis.
   *
   * @module YAxis
   **/
  var YAxis = /*#__PURE__*/function () {
    function YAxis(ctx, elgrid) {
      _classCallCheck(this, YAxis);
      this.ctx = ctx;
      this.elgrid = elgrid;
      this.w = ctx.w;
      var w = this.w;
      this.xaxisFontSize = w.config.xaxis.labels.style.fontSize;
      this.axisFontFamily = w.config.xaxis.labels.style.fontFamily;
      this.xaxisForeColors = w.config.xaxis.labels.style.colors;
      this.isCategoryBarHorizontal = w.config.chart.type === 'bar' && w.config.plotOptions.bar.horizontal;
      this.xAxisoffX = w.config.xaxis.position === 'bottom' ? w.globals.gridHeight : 0;
      this.drawnLabels = [];
      this.axesUtils = new AxesUtils(ctx);
    }
    _createClass(YAxis, [{
      key: "drawYaxis",
      value: function drawYaxis(realIndex) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var yaxisStyle = w.config.yaxis[realIndex].labels.style;
        var yaxisFontSize = yaxisStyle.fontSize,
          yaxisFontFamily = yaxisStyle.fontFamily,
          yaxisFontWeight = yaxisStyle.fontWeight;
        var elYaxis = graphics.group({
          class: 'apexcharts-yaxis',
          rel: realIndex,
          transform: "translate(".concat(w.globals.translateYAxisX[realIndex], ", 0)")
        });
        if (this.axesUtils.isYAxisHidden(realIndex)) return elYaxis;
        var elYaxisTexts = graphics.group({
          class: 'apexcharts-yaxis-texts-g'
        });
        elYaxis.add(elYaxisTexts);
        var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1;
        var labelsDivider = w.globals.gridHeight / tickAmount;
        var lbFormatter = w.globals.yLabelFormatters[realIndex];
        var labels = this.axesUtils.checkForReversedLabels(realIndex, w.globals.yAxisScale[realIndex].result.slice());
        if (w.config.yaxis[realIndex].labels.show) {
          var lY = w.globals.translateY + w.config.yaxis[realIndex].labels.offsetY;
          if (w.globals.isBarHorizontal) lY = 0;else if (w.config.chart.type === 'heatmap') lY -= labelsDivider / 2;
          lY += parseInt(yaxisFontSize, 10) / 3;
          for (var i = tickAmount; i >= 0; i--) {
            var val = lbFormatter(labels[i], i, w);
            var xPad = w.config.yaxis[realIndex].labels.padding;
            if (w.config.yaxis[realIndex].opposite && w.config.yaxis.length !== 0) xPad *= -1;
            var textAnchor = this.getTextAnchor(w.config.yaxis[realIndex].labels.align, w.config.yaxis[realIndex].opposite);
            var yColors = this.axesUtils.getYAxisForeColor(yaxisStyle.colors, realIndex);
            var foreColor = Array.isArray(yColors) ? yColors[i] : yColors;
            var existingYLabels = Utils$1.listToArray(w.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(realIndex, "'] .apexcharts-yaxis-label tspan"))).map(function (label) {
              return label.textContent;
            });
            var label = graphics.drawText({
              x: xPad,
              y: lY,
              text: existingYLabels.includes(val) && !w.config.yaxis[realIndex].labels.showDuplicates ? '' : val,
              textAnchor: textAnchor,
              fontSize: yaxisFontSize,
              fontFamily: yaxisFontFamily,
              fontWeight: yaxisFontWeight,
              maxWidth: w.config.yaxis[realIndex].labels.maxWidth,
              foreColor: foreColor,
              isPlainText: false,
              cssClass: "apexcharts-yaxis-label ".concat(yaxisStyle.cssClass)
            });
            elYaxisTexts.add(label);
            this.addTooltip(label, val);
            if (w.config.yaxis[realIndex].labels.rotate !== 0) {
              this.rotateLabel(graphics, label, firstLabel, w.config.yaxis[realIndex].labels.rotate);
            }
            lY += labelsDivider;
          }
        }
        this.addYAxisTitle(graphics, elYaxis, realIndex);
        this.addAxisBorder(graphics, elYaxis, realIndex, tickAmount, labelsDivider);
        return elYaxis;
      }
    }, {
      key: "getTextAnchor",
      value: function getTextAnchor(align, opposite) {
        if (align === 'left') return 'start';
        if (align === 'center') return 'middle';
        if (align === 'right') return 'end';
        return opposite ? 'start' : 'end';
      }
    }, {
      key: "addTooltip",
      value: function addTooltip(label, val) {
        var elTooltipTitle = document.createElementNS(this.w.globals.SVGNS, 'title');
        elTooltipTitle.textContent = Array.isArray(val) ? val.join(' ') : val;
        label.node.appendChild(elTooltipTitle);
      }
    }, {
      key: "rotateLabel",
      value: function rotateLabel(graphics, label, firstLabel, rotate) {
        var firstLabelCenter = graphics.rotateAroundCenter(firstLabel.node);
        var labelCenter = graphics.rotateAroundCenter(label.node);
        label.node.setAttribute('transform', "rotate(".concat(rotate, " ").concat(firstLabelCenter.x, " ").concat(labelCenter.y, ")"));
      }
    }, {
      key: "addYAxisTitle",
      value: function addYAxisTitle(graphics, elYaxis, realIndex) {
        var w = this.w;
        if (w.config.yaxis[realIndex].title.text !== undefined) {
          var elYaxisTitle = graphics.group({
            class: 'apexcharts-yaxis-title'
          });
          var x = w.config.yaxis[realIndex].opposite ? w.globals.translateYAxisX[realIndex] : 0;
          var elYAxisTitleText = graphics.drawText({
            x: x,
            y: w.globals.gridHeight / 2 + w.globals.translateY + w.config.yaxis[realIndex].title.offsetY,
            text: w.config.yaxis[realIndex].title.text,
            textAnchor: 'end',
            foreColor: w.config.yaxis[realIndex].title.style.color,
            fontSize: w.config.yaxis[realIndex].title.style.fontSize,
            fontWeight: w.config.yaxis[realIndex].title.style.fontWeight,
            fontFamily: w.config.yaxis[realIndex].title.style.fontFamily,
            cssClass: "apexcharts-yaxis-title-text ".concat(w.config.yaxis[realIndex].title.style.cssClass)
          });
          elYaxisTitle.add(elYAxisTitleText);
          elYaxis.add(elYaxisTitle);
        }
      }
    }, {
      key: "addAxisBorder",
      value: function addAxisBorder(graphics, elYaxis, realIndex, tickAmount, labelsDivider) {
        var w = this.w;
        var axisBorder = w.config.yaxis[realIndex].axisBorder;
        var x = 31 + axisBorder.offsetX;
        if (w.config.yaxis[realIndex].opposite) x = -31 - axisBorder.offsetX;
        if (axisBorder.show) {
          var elVerticalLine = graphics.drawLine(x, w.globals.translateY + axisBorder.offsetY - 2, x, w.globals.gridHeight + w.globals.translateY + axisBorder.offsetY + 2, axisBorder.color, 0, axisBorder.width);
          elYaxis.add(elVerticalLine);
        }
        if (w.config.yaxis[realIndex].axisTicks.show) {
          this.axesUtils.drawYAxisTicks(x, tickAmount, axisBorder, w.config.yaxis[realIndex].axisTicks, realIndex, labelsDivider, elYaxis);
        }
      }
    }, {
      key: "drawYaxisInversed",
      value: function drawYaxisInversed(realIndex) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var elXaxis = graphics.group({
          class: 'apexcharts-xaxis apexcharts-yaxis-inversed'
        });
        var elXaxisTexts = graphics.group({
          class: 'apexcharts-xaxis-texts-g',
          transform: "translate(".concat(w.globals.translateXAxisX, ", ").concat(w.globals.translateXAxisY, ")")
        });
        elXaxis.add(elXaxisTexts);
        var tickAmount = w.globals.yAxisScale[realIndex].result.length - 1;
        var labelsDivider = w.globals.gridWidth / tickAmount + 0.1;
        var l = labelsDivider + w.config.xaxis.labels.offsetX;
        var lbFormatter = w.globals.xLabelFormatter;
        var labels = this.axesUtils.checkForReversedLabels(realIndex, w.globals.yAxisScale[realIndex].result.slice());
        var timescaleLabels = w.globals.timescaleLabels;
        if (timescaleLabels.length > 0) {
          this.xaxisLabels = timescaleLabels.slice();
          labels = timescaleLabels.slice();
          tickAmount = labels.length;
        }
        if (w.config.xaxis.labels.show) {
          for (var i = timescaleLabels.length ? 0 : tickAmount; timescaleLabels.length ? i < timescaleLabels.length : i >= 0; timescaleLabels.length ? i++ : i--) {
            var val = lbFormatter(labels[i], i, w);
            var x = w.globals.gridWidth + w.globals.padHorizontal - (l - labelsDivider + w.config.xaxis.labels.offsetX);
            if (timescaleLabels.length) {
              var label = this.axesUtils.getLabel(labels, timescaleLabels, x, i, this.drawnLabels, this.xaxisFontSize);
              x = label.x;
              val = label.text;
              this.drawnLabels.push(label.text);
              if (i === 0 && w.globals.skipFirstTimelinelabel) val = '';
              if (i === labels.length - 1 && w.globals.skipLastTimelinelabel) val = '';
            }
            var elTick = graphics.drawText({
              x: x,
              y: this.xAxisoffX + w.config.xaxis.labels.offsetY + 30 - (w.config.xaxis.position === 'top' ? w.globals.xAxisHeight + w.config.xaxis.axisTicks.height - 2 : 0),
              text: val,
              textAnchor: 'middle',
              foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[realIndex] : this.xaxisForeColors,
              fontSize: this.xaxisFontSize,
              fontFamily: this.xaxisFontFamily,
              fontWeight: w.config.xaxis.labels.style.fontWeight,
              isPlainText: false,
              cssClass: "apexcharts-xaxis-label ".concat(w.config.xaxis.labels.style.cssClass)
            });
            elXaxisTexts.add(elTick);
            elTick.tspan(val);
            this.addTooltip(elTick, val);
            l += labelsDivider;
          }
        }
        this.inversedYAxisTitleText(elXaxis);
        this.inversedYAxisBorder(elXaxis);
        return elXaxis;
      }
    }, {
      key: "inversedYAxisBorder",
      value: function inversedYAxisBorder(parent) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var axisBorder = w.config.xaxis.axisBorder;
        if (axisBorder.show) {
          var lineCorrection = 0;
          if (w.config.chart.type === 'bar' && w.globals.isXNumeric) lineCorrection -= 15;
          var elHorzLine = graphics.drawLine(w.globals.padHorizontal + lineCorrection + axisBorder.offsetX, this.xAxisoffX, w.globals.gridWidth, this.xAxisoffX, axisBorder.color, 0, axisBorder.height);
          if (this.elgrid && this.elgrid.elGridBorders && w.config.grid.show) {
            this.elgrid.elGridBorders.add(elHorzLine);
          } else {
            parent.add(elHorzLine);
          }
        }
      }
    }, {
      key: "inversedYAxisTitleText",
      value: function inversedYAxisTitleText(parent) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        if (w.config.xaxis.title.text !== undefined) {
          var elYaxisTitle = graphics.group({
            class: 'apexcharts-xaxis-title apexcharts-yaxis-title-inversed'
          });
          var elYAxisTitleText = graphics.drawText({
            x: w.globals.gridWidth / 2 + w.config.xaxis.title.offsetX,
            y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(w.config.xaxis.title.style.fontSize) + w.config.xaxis.title.offsetY + 20,
            text: w.config.xaxis.title.text,
            textAnchor: 'middle',
            fontSize: w.config.xaxis.title.style.fontSize,
            fontFamily: w.config.xaxis.title.style.fontFamily,
            fontWeight: w.config.xaxis.title.style.fontWeight,
            foreColor: w.config.xaxis.title.style.color,
            cssClass: "apexcharts-xaxis-title-text ".concat(w.config.xaxis.title.style.cssClass)
          });
          elYaxisTitle.add(elYAxisTitleText);
          parent.add(elYaxisTitle);
        }
      }
    }, {
      key: "yAxisTitleRotate",
      value: function yAxisTitleRotate(realIndex, yAxisOpposite) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var elYAxisLabelsWrap = w.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(realIndex, "'] .apexcharts-yaxis-texts-g"));
        var yAxisLabelsCoord = elYAxisLabelsWrap ? elYAxisLabelsWrap.getBoundingClientRect() : {
          width: 0,
          height: 0
        };
        var yAxisTitle = w.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(realIndex, "'] .apexcharts-yaxis-title text"));
        var yAxisTitleCoord = yAxisTitle ? yAxisTitle.getBoundingClientRect() : {
          width: 0,
          height: 0
        };
        if (yAxisTitle) {
          var x = this.xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite);
          yAxisTitle.setAttribute('x', x.xPos - (yAxisOpposite ? 10 : 0));
          var titleRotatingCenter = graphics.rotateAroundCenter(yAxisTitle);
          yAxisTitle.setAttribute('transform', "rotate(".concat(yAxisOpposite ? w.config.yaxis[realIndex].title.rotate * -1 : w.config.yaxis[realIndex].title.rotate, " ").concat(titleRotatingCenter.x, " ").concat(titleRotatingCenter.y, ")"));
        }
      }
    }, {
      key: "xPaddingForYAxisTitle",
      value: function xPaddingForYAxisTitle(realIndex, yAxisLabelsCoord, yAxisTitleCoord, yAxisOpposite) {
        var w = this.w;
        var x = 0;
        var padd = 10;
        if (w.config.yaxis[realIndex].title.text === undefined || realIndex < 0) {
          return {
            xPos: x,
            padd: 0
          };
        }
        if (yAxisOpposite) {
          x = yAxisLabelsCoord.width + w.config.yaxis[realIndex].title.offsetX + yAxisTitleCoord.width / 2 + padd / 2;
        } else {
          x = yAxisLabelsCoord.width * -1 + w.config.yaxis[realIndex].title.offsetX + padd / 2 + yAxisTitleCoord.width / 2;
          if (w.globals.isBarHorizontal) {
            padd = 25;
            x = yAxisLabelsCoord.width * -1 - w.config.yaxis[realIndex].title.offsetX - padd;
          }
        }
        return {
          xPos: x,
          padd: padd
        };
      }
    }, {
      key: "setYAxisXPosition",
      value: function setYAxisXPosition(yaxisLabelCoords, yTitleCoords) {
        var w = this.w;
        var xLeft = 0;
        var xRight = 0;
        var leftOffsetX = 18;
        var rightOffsetX = 1;
        if (w.config.yaxis.length > 1) this.multipleYs = true;
        w.config.yaxis.forEach(function (yaxe, index) {
          var shouldNotDrawAxis = w.globals.ignoreYAxisIndexes.includes(index) || !yaxe.show || yaxe.floating || yaxisLabelCoords[index].width === 0;
          var axisWidth = yaxisLabelCoords[index].width + yTitleCoords[index].width;
          if (!yaxe.opposite) {
            xLeft = w.globals.translateX - leftOffsetX;
            if (!shouldNotDrawAxis) leftOffsetX += axisWidth + 20;
            w.globals.translateYAxisX[index] = xLeft + yaxe.labels.offsetX;
          } else {
            if (w.globals.isBarHorizontal) {
              xRight = w.globals.gridWidth + w.globals.translateX - 1;
              w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX;
            } else {
              xRight = w.globals.gridWidth + w.globals.translateX + rightOffsetX;
              if (!shouldNotDrawAxis) rightOffsetX += axisWidth + 20;
              w.globals.translateYAxisX[index] = xRight - yaxe.labels.offsetX + 20;
            }
          }
        });
      }
    }, {
      key: "setYAxisTextAlignments",
      value: function setYAxisTextAlignments() {
        var w = this.w;
        var yaxis = Utils$1.listToArray(w.globals.dom.baseEl.getElementsByClassName('apexcharts-yaxis'));
        yaxis.forEach(function (y, index) {
          var yaxe = w.config.yaxis[index];
          if (yaxe && !yaxe.floating && yaxe.labels.align !== undefined) {
            var yAxisInner = w.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(index, "'] .apexcharts-yaxis-texts-g"));
            var yAxisTexts = Utils$1.listToArray(w.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(index, "'] .apexcharts-yaxis-label")));
            var rect = yAxisInner.getBoundingClientRect();
            yAxisTexts.forEach(function (label) {
              label.setAttribute('text-anchor', yaxe.labels.align);
            });
            if (yaxe.labels.align === 'left' && !yaxe.opposite) {
              yAxisInner.setAttribute('transform', "translate(-".concat(rect.width, ", 0)"));
            } else if (yaxe.labels.align === 'center') {
              yAxisInner.setAttribute('transform', "translate(".concat(rect.width / 2 * (!yaxe.opposite ? -1 : 1), ", 0)"));
            } else if (yaxe.labels.align === 'right' && yaxe.opposite) {
              yAxisInner.setAttribute('transform', "translate(".concat(rect.width, ", 0)"));
            }
          }
        });
      }
    }]);
    return YAxis;
  }();

  var Events = /*#__PURE__*/function () {
    function Events(ctx) {
      _classCallCheck(this, Events);
      this.ctx = ctx;
      this.w = ctx.w;
      this.documentEvent = Utils$1.bind(this.documentEvent, this);
    }
    _createClass(Events, [{
      key: "addEventListener",
      value: function addEventListener(name, handler) {
        var w = this.w;
        if (w.globals.events.hasOwnProperty(name)) {
          w.globals.events[name].push(handler);
        } else {
          w.globals.events[name] = [handler];
        }
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(name, handler) {
        var w = this.w;
        if (!w.globals.events.hasOwnProperty(name)) {
          return;
        }
        var index = w.globals.events[name].indexOf(handler);
        if (index !== -1) {
          w.globals.events[name].splice(index, 1);
        }
      }
    }, {
      key: "fireEvent",
      value: function fireEvent(name, args) {
        var w = this.w;
        if (!w.globals.events.hasOwnProperty(name)) {
          return;
        }
        if (!args || !args.length) {
          args = [];
        }
        var evs = w.globals.events[name];
        var l = evs.length;
        for (var i = 0; i < l; i++) {
          evs[i].apply(null, args);
        }
      }
    }, {
      key: "setupEventHandlers",
      value: function setupEventHandlers() {
        var _this = this;
        var w = this.w;
        var me = this.ctx;
        var clickableArea = w.globals.dom.baseEl.querySelector(w.globals.chartClass);
        this.ctx.eventList.forEach(function (event) {
          clickableArea.addEventListener(event, function (e) {
            var capturedSeriesIndex = e.target.getAttribute('i') === null && w.globals.capturedSeriesIndex !== -1 ? w.globals.capturedSeriesIndex : e.target.getAttribute('i');
            var capturedDataPointIndex = e.target.getAttribute('j') === null && w.globals.capturedDataPointIndex !== -1 ? w.globals.capturedDataPointIndex : e.target.getAttribute('j');
            var opts = Object.assign({}, w, {
              seriesIndex: w.globals.axisCharts ? capturedSeriesIndex : 0,
              dataPointIndex: capturedDataPointIndex
            });
            if (e.type === 'mousemove' || e.type === 'touchmove') {
              if (typeof w.config.chart.events.mouseMove === 'function') {
                w.config.chart.events.mouseMove(e, me, opts);
              }
            } else if (e.type === 'mouseleave' || e.type === 'touchleave') {
              if (typeof w.config.chart.events.mouseLeave === 'function') {
                w.config.chart.events.mouseLeave(e, me, opts);
              }
            } else if (e.type === 'mouseup' && e.which === 1 || e.type === 'touchend') {
              if (typeof w.config.chart.events.click === 'function') {
                w.config.chart.events.click(e, me, opts);
              }
              me.ctx.events.fireEvent('click', [e, me, opts]);
            }
          }, {
            capture: false,
            passive: true
          });
        });
        this.ctx.eventList.forEach(function (event) {
          w.globals.dom.baseEl.addEventListener(event, _this.documentEvent, {
            passive: true
          });
        });
        this.ctx.core.setupBrushHandler();
      }
    }, {
      key: "documentEvent",
      value: function documentEvent(e) {
        var w = this.w;
        var target = e.target.className;
        if (e.type === 'click') {
          var elMenu = w.globals.dom.baseEl.querySelector('.apexcharts-menu');
          if (elMenu && elMenu.classList.contains('apexcharts-menu-open') && target !== 'apexcharts-menu-icon') {
            elMenu.classList.remove('apexcharts-menu-open');
          }
        }
        w.globals.clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        w.globals.clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
      }
    }]);
    return Events;
  }();

  var Localization = /*#__PURE__*/function () {
    function Localization(ctx) {
      _classCallCheck(this, Localization);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(Localization, [{
      key: "setCurrentLocaleValues",
      value: function setCurrentLocaleValues(localeName) {
        var locales = this.w.config.chart.locales;

        // check if user has specified locales in global Apex variable
        // if yes - then extend those with local chart's locale
        if (window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0) {
          locales = this.w.config.chart.locales.concat(window.Apex.chart.locales);
        }

        // find the locale from the array of locales which user has set (either by chart.defaultLocale or by calling setLocale() method.)
        var selectedLocale = locales.filter(function (c) {
          return c.name === localeName;
        })[0];
        if (selectedLocale) {
          // create a complete locale object by extending defaults so you don't get undefined errors.
          var ret = Utils$1.extend(en, selectedLocale);

          // store these locale options in global var for ease access
          this.w.globals.locale = ret.options;
        } else {
          throw new Error('Wrong locale name provided. Please make sure you set the correct locale name in options');
        }
      }
    }]);
    return Localization;
  }();

  var Axes = /*#__PURE__*/function () {
    function Axes(ctx) {
      _classCallCheck(this, Axes);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(Axes, [{
      key: "drawAxis",
      value: function drawAxis(type, elgrid) {
        var _this = this;
        var gl = this.w.globals;
        var cnf = this.w.config;
        var xAxis = new XAxis(this.ctx, elgrid);
        var yAxis = new YAxis(this.ctx, elgrid);
        if (gl.axisCharts && type !== 'radar') {
          var elXaxis, elYaxis;
          if (gl.isBarHorizontal) {
            elYaxis = yAxis.drawYaxisInversed(0);
            elXaxis = xAxis.drawXaxisInversed(0);
            gl.dom.elGraphical.add(elXaxis);
            gl.dom.elGraphical.add(elYaxis);
          } else {
            elXaxis = xAxis.drawXaxis();
            gl.dom.elGraphical.add(elXaxis);
            cnf.yaxis.map(function (yaxe, index) {
              if (gl.ignoreYAxisIndexes.indexOf(index) === -1) {
                elYaxis = yAxis.drawYaxis(index);
                gl.dom.Paper.add(elYaxis);
                if (_this.w.config.grid.position === 'back') {
                  var inner = gl.dom.Paper.children()[1];
                  inner.remove();
                  gl.dom.Paper.add(inner);
                }
              }
            });
          }
        }
      }
    }]);
    return Axes;
  }();

  var Crosshairs = /*#__PURE__*/function () {
    function Crosshairs(ctx) {
      _classCallCheck(this, Crosshairs);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(Crosshairs, [{
      key: "drawXCrosshairs",
      value: function drawXCrosshairs() {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var filters = new Filters(this.ctx);
        var crosshairGradient = w.config.xaxis.crosshairs.fill.gradient;
        var crosshairShadow = w.config.xaxis.crosshairs.dropShadow;
        var fillType = w.config.xaxis.crosshairs.fill.type;
        var gradientFrom = crosshairGradient.colorFrom;
        var gradientTo = crosshairGradient.colorTo;
        var opacityFrom = crosshairGradient.opacityFrom;
        var opacityTo = crosshairGradient.opacityTo;
        var stops = crosshairGradient.stops;
        var shadow = 'none';
        var dropShadow = crosshairShadow.enabled;
        var shadowLeft = crosshairShadow.left;
        var shadowTop = crosshairShadow.top;
        var shadowBlur = crosshairShadow.blur;
        var shadowColor = crosshairShadow.color;
        var shadowOpacity = crosshairShadow.opacity;
        var xcrosshairsFill = w.config.xaxis.crosshairs.fill.color;
        if (w.config.xaxis.crosshairs.show) {
          if (fillType === 'gradient') {
            xcrosshairsFill = graphics.drawGradient('vertical', gradientFrom, gradientTo, opacityFrom, opacityTo, null, stops, null);
          }
          var xcrosshairs = graphics.drawRect();
          if (w.config.xaxis.crosshairs.width === 1) {
            // to prevent drawing 2 lines, convert rect to line
            xcrosshairs = graphics.drawLine();
          }
          var gridHeight = w.globals.gridHeight;
          if (!Utils$1.isNumber(gridHeight) || gridHeight < 0) {
            gridHeight = 0;
          }
          var crosshairsWidth = w.config.xaxis.crosshairs.width;
          if (!Utils$1.isNumber(crosshairsWidth) || crosshairsWidth < 0) {
            crosshairsWidth = 0;
          }
          xcrosshairs.attr({
            class: 'apexcharts-xcrosshairs',
            x: 0,
            y: 0,
            y2: gridHeight,
            width: crosshairsWidth,
            height: gridHeight,
            fill: xcrosshairsFill,
            filter: shadow,
            'fill-opacity': w.config.xaxis.crosshairs.opacity,
            stroke: w.config.xaxis.crosshairs.stroke.color,
            'stroke-width': w.config.xaxis.crosshairs.stroke.width,
            'stroke-dasharray': w.config.xaxis.crosshairs.stroke.dashArray
          });
          if (dropShadow) {
            xcrosshairs = filters.dropShadow(xcrosshairs, {
              left: shadowLeft,
              top: shadowTop,
              blur: shadowBlur,
              color: shadowColor,
              opacity: shadowOpacity
            });
          }
          w.globals.dom.elGraphical.add(xcrosshairs);
        }
      }
    }, {
      key: "drawYCrosshairs",
      value: function drawYCrosshairs() {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var crosshair = w.config.yaxis[0].crosshairs;
        var offX = w.globals.barPadForNumericAxis;
        if (w.config.yaxis[0].crosshairs.show) {
          var ycrosshairs = graphics.drawLine(-offX, 0, w.globals.gridWidth + offX, 0, crosshair.stroke.color, crosshair.stroke.dashArray, crosshair.stroke.width);
          ycrosshairs.attr({
            class: 'apexcharts-ycrosshairs'
          });
          w.globals.dom.elGraphical.add(ycrosshairs);
        }

        // draw an invisible crosshair to help in positioning the yaxis tooltip
        var ycrosshairsHidden = graphics.drawLine(-offX, 0, w.globals.gridWidth + offX, 0, crosshair.stroke.color, 0, 0);
        ycrosshairsHidden.attr({
          class: 'apexcharts-ycrosshairs-hidden'
        });
        w.globals.dom.elGraphical.add(ycrosshairsHidden);
      }
    }]);
    return Crosshairs;
  }();

  /**
   * ApexCharts Responsive Class to override options for different screen sizes.
   *
   * @module Responsive
   **/
  var Responsive = /*#__PURE__*/function () {
    function Responsive(ctx) {
      _classCallCheck(this, Responsive);
      this.ctx = ctx;
      this.w = ctx.w;
    }

    // the opts parameter if not null has to be set overriding everything
    // as the opts is set by user externally
    _createClass(Responsive, [{
      key: "checkResponsiveConfig",
      value: function checkResponsiveConfig(opts) {
        var _this = this;
        var w = this.w;
        var cnf = w.config;

        // check if responsive config exists
        if (cnf.responsive.length === 0) return;
        var res = cnf.responsive.slice();
        res.sort(function (a, b) {
          return a.breakpoint > b.breakpoint ? 1 : b.breakpoint > a.breakpoint ? -1 : 0;
        }).reverse();
        var config = new Config({});
        var iterateResponsiveOptions = function iterateResponsiveOptions() {
          var newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var largestBreakpoint = res[0].breakpoint;
          var width = window.innerWidth > 0 ? window.innerWidth : screen.width;
          if (width > largestBreakpoint) {
            var initialConfig = Utils$1.clone(w.globals.initialConfig);
            // Retain state of series in case any have been collapsed
            // (indicated by series.data === [], these series' will be zeroed later
            // enabling stacking to work correctly)
            initialConfig.series = Utils$1.clone(w.config.series);
            var options = CoreUtils.extendArrayProps(config, initialConfig, w);
            newOptions = Utils$1.extend(options, newOptions);
            newOptions = Utils$1.extend(w.config, newOptions);
            _this.overrideResponsiveOptions(newOptions);
          } else {
            for (var i = 0; i < res.length; i++) {
              if (width < res[i].breakpoint) {
                newOptions = CoreUtils.extendArrayProps(config, res[i].options, w);
                newOptions = Utils$1.extend(w.config, newOptions);
                _this.overrideResponsiveOptions(newOptions);
              }
            }
          }
        };
        if (opts) {
          var options = CoreUtils.extendArrayProps(config, opts, w);
          options = Utils$1.extend(w.config, options);
          options = Utils$1.extend(options, opts);
          iterateResponsiveOptions(options);
        } else {
          iterateResponsiveOptions({});
        }
      }
    }, {
      key: "overrideResponsiveOptions",
      value: function overrideResponsiveOptions(newOptions) {
        var newConfig = new Config(newOptions).init({
          responsiveOverride: true
        });
        this.w.config = newConfig;
      }
    }]);
    return Responsive;
  }();

  /**
   * ApexCharts Theme Class for setting the colors and palettes.
   *
   * @module Theme
   **/
  var Theme = /*#__PURE__*/function () {
    function Theme(ctx) {
      _classCallCheck(this, Theme);
      this.ctx = ctx;
      this.w = ctx.w;
      this.colors = [];
      this.isColorFn = false;
      this.isHeatmapDistributed = this.checkHeatmapDistributed();
      this.isBarDistributed = this.checkBarDistributed();
    }
    _createClass(Theme, [{
      key: "checkHeatmapDistributed",
      value: function checkHeatmapDistributed() {
        var _this$w$config = this.w.config,
          chart = _this$w$config.chart,
          plotOptions = _this$w$config.plotOptions;
        return chart.type === 'treemap' && plotOptions.treemap && plotOptions.treemap.distributed || chart.type === 'heatmap' && plotOptions.heatmap && plotOptions.heatmap.distributed;
      }
    }, {
      key: "checkBarDistributed",
      value: function checkBarDistributed() {
        var _this$w$config2 = this.w.config,
          chart = _this$w$config2.chart,
          plotOptions = _this$w$config2.plotOptions;
        return plotOptions.bar && plotOptions.bar.distributed && (chart.type === 'bar' || chart.type === 'rangeBar');
      }
    }, {
      key: "init",
      value: function init() {
        this.setDefaultColors();
      }
    }, {
      key: "setDefaultColors",
      value: function setDefaultColors() {
        var w = this.w;
        var utils = new Utils$1();
        w.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(w.config.theme.mode || 'light'));

        // Create a copy of config.colors array to avoid mutating the original config.colors
        var configColors = _toConsumableArray(w.config.colors || w.config.fill.colors || []);
        w.globals.colors = this.getColors(configColors);
        this.applySeriesColors(w.globals.seriesColors, w.globals.colors);
        if (w.config.theme.monochrome.enabled) {
          w.globals.colors = this.getMonochromeColors(w.config.theme.monochrome, w.globals.series, utils);
        }
        var defaultColors = w.globals.colors.slice();
        this.pushExtraColors(w.globals.colors);
        this.applyColorTypes(['fill', 'stroke'], defaultColors);
        this.applyDataLabelsColors(defaultColors);
        this.applyRadarPolygonsColors();
        this.applyMarkersColors(defaultColors);
      }
    }, {
      key: "getColors",
      value: function getColors(configColors) {
        var _this = this;
        var w = this.w;
        if (!configColors || configColors.length === 0) {
          return this.predefined();
        }
        if (Array.isArray(configColors) && configColors.length > 0 && typeof configColors[0] === 'function') {
          this.isColorFn = true;
          return w.config.series.map(function (s, i) {
            var c = configColors[i] || configColors[0];
            return typeof c === 'function' ? c({
              value: w.globals.axisCharts ? w.globals.series[i][0] || 0 : w.globals.series[i],
              seriesIndex: i,
              dataPointIndex: i,
              w: _this.w
            }) : c;
          });
        }
        return configColors;
      }
    }, {
      key: "applySeriesColors",
      value: function applySeriesColors(seriesColors, globalsColors) {
        seriesColors.forEach(function (c, i) {
          if (c) {
            globalsColors[i] = c;
          }
        });
      }
    }, {
      key: "getMonochromeColors",
      value: function getMonochromeColors(monochrome, series, utils) {
        var color = monochrome.color,
          shadeIntensity = monochrome.shadeIntensity,
          shadeTo = monochrome.shadeTo;
        var glsCnt = this.isBarDistributed || this.isHeatmapDistributed ? series[0].length * series.length : series.length;
        var part = 1 / (glsCnt / shadeIntensity);
        var percent = 0;
        return Array.from({
          length: glsCnt
        }, function () {
          var newColor = shadeTo === 'dark' ? utils.shadeColor(percent * -1, color) : utils.shadeColor(percent, color);
          percent += part;
          return newColor;
        });
      }
    }, {
      key: "applyColorTypes",
      value: function applyColorTypes(colorTypes, defaultColors) {
        var _this2 = this;
        var w = this.w;
        colorTypes.forEach(function (c) {
          w.globals[c].colors = w.config[c].colors === undefined ? _this2.isColorFn ? w.config.colors : defaultColors : w.config[c].colors.slice();
          _this2.pushExtraColors(w.globals[c].colors);
        });
      }
    }, {
      key: "applyDataLabelsColors",
      value: function applyDataLabelsColors(defaultColors) {
        var w = this.w;
        w.globals.dataLabels.style.colors = w.config.dataLabels.style.colors === undefined ? defaultColors : w.config.dataLabels.style.colors.slice();
        this.pushExtraColors(w.globals.dataLabels.style.colors, 50);
      }
    }, {
      key: "applyRadarPolygonsColors",
      value: function applyRadarPolygonsColors() {
        var w = this.w;
        w.globals.radarPolygons.fill.colors = w.config.plotOptions.radar.polygons.fill.colors === undefined ? [w.config.theme.mode === 'dark' ? '#343A3F' : 'none'] : w.config.plotOptions.radar.polygons.fill.colors.slice();
        this.pushExtraColors(w.globals.radarPolygons.fill.colors, 20);
      }
    }, {
      key: "applyMarkersColors",
      value: function applyMarkersColors(defaultColors) {
        var w = this.w;
        w.globals.markers.colors = w.config.markers.colors === undefined ? defaultColors : w.config.markers.colors.slice();
        this.pushExtraColors(w.globals.markers.colors);
      }
    }, {
      key: "pushExtraColors",
      value: function pushExtraColors(colorSeries, length) {
        var distributed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var w = this.w;
        var len = length || w.globals.series.length;
        if (distributed === null) {
          distributed = this.isBarDistributed || this.isHeatmapDistributed || w.config.chart.type === 'heatmap' && w.config.plotOptions.heatmap && w.config.plotOptions.heatmap.colorScale.inverse;
        }
        if (distributed && w.globals.series.length) {
          len = w.globals.series[w.globals.maxValsInArrayIndex].length * w.globals.series.length;
        }
        if (colorSeries.length < len) {
          var diff = len - colorSeries.length;
          for (var i = 0; i < diff; i++) {
            colorSeries.push(colorSeries[i]);
          }
        }
      }
    }, {
      key: "updateThemeOptions",
      value: function updateThemeOptions(options) {
        options.chart = options.chart || {};
        options.tooltip = options.tooltip || {};
        var mode = options.theme.mode;
        var palette = mode === 'dark' ? 'palette4' : mode === 'light' ? 'palette1' : options.theme.palette || 'palette1';
        var foreColor = mode === 'dark' ? '#f6f7f8' : mode === 'light' ? '#373d3f' : options.chart.foreColor || '#373d3f';
        options.tooltip.theme = mode || 'light';
        options.chart.foreColor = foreColor;
        options.theme.palette = palette;
        return options;
      }
    }, {
      key: "predefined",
      value: function predefined() {
        var palette = this.w.config.theme.palette;
        var palettes = this.ctx.constructor.getThemePalettes();
        return palettes[palette] || palettes.palette1;
      }
    }]);
    return Theme;
  }();

  var TitleSubtitle = /*#__PURE__*/function () {
    function TitleSubtitle(ctx) {
      _classCallCheck(this, TitleSubtitle);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(TitleSubtitle, [{
      key: "draw",
      value: function draw() {
        this.drawTitleSubtitle('title');
        this.drawTitleSubtitle('subtitle');
      }
    }, {
      key: "drawTitleSubtitle",
      value: function drawTitleSubtitle(type) {
        var w = this.w;
        var tsConfig = type === 'title' ? w.config.title : w.config.subtitle;
        var x = w.globals.svgWidth / 2;
        var y = tsConfig.offsetY;
        var textAnchor = 'middle';
        if (tsConfig.align === 'left') {
          x = 10;
          textAnchor = 'start';
        } else if (tsConfig.align === 'right') {
          x = w.globals.svgWidth - 10;
          textAnchor = 'end';
        }
        x = x + tsConfig.offsetX;
        y = y + parseInt(tsConfig.style.fontSize, 10) + tsConfig.margin / 2;
        if (tsConfig.text !== undefined) {
          var graphics = new Graphics(this.ctx);
          var titleText = graphics.drawText({
            x: x,
            y: y,
            text: tsConfig.text,
            textAnchor: textAnchor,
            fontSize: tsConfig.style.fontSize,
            fontFamily: tsConfig.style.fontFamily,
            fontWeight: tsConfig.style.fontWeight,
            foreColor: tsConfig.style.color,
            opacity: 1
          });
          titleText.node.setAttribute('class', "apexcharts-".concat(type, "-text"));
          w.globals.dom.Paper.add(titleText);
        }
      }
    }]);
    return TitleSubtitle;
  }();

  var Helpers$3 = /*#__PURE__*/function () {
    function Helpers(dCtx) {
      _classCallCheck(this, Helpers);
      this.w = dCtx.w;
      this.dCtx = dCtx;
    }

    /**
     * Get Chart Title/Subtitle Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/
    _createClass(Helpers, [{
      key: "getTitleSubtitleCoords",
      value: function getTitleSubtitleCoords(type) {
        var w = this.w;
        var width = 0;
        var height = 0;
        var floating = type === 'title' ? w.config.title.floating : w.config.subtitle.floating;
        var el = w.globals.dom.baseEl.querySelector(".apexcharts-".concat(type, "-text"));
        if (el !== null && !floating) {
          var coord = el.getBoundingClientRect();
          width = coord.width;
          height = w.globals.axisCharts ? coord.height + 5 : coord.height;
        }
        return {
          width: width,
          height: height
        };
      }
    }, {
      key: "getLegendsRect",
      value: function getLegendsRect() {
        var w = this.w;
        var elLegendWrap = w.globals.dom.elLegendWrap;
        if (!w.config.legend.height && (w.config.legend.position === 'top' || w.config.legend.position === 'bottom')) {
          // avoid legend to take up all the space
          elLegendWrap.style.maxHeight = w.globals.svgHeight / 2 + 'px';
        }
        var lgRect = Object.assign({}, Utils$1.getBoundingClientRect(elLegendWrap));
        if (elLegendWrap !== null && !w.config.legend.floating && w.config.legend.show) {
          this.dCtx.lgRect = {
            x: lgRect.x,
            y: lgRect.y,
            height: lgRect.height,
            width: lgRect.height === 0 ? 0 : lgRect.width
          };
        } else {
          this.dCtx.lgRect = {
            x: 0,
            y: 0,
            height: 0,
            width: 0
          };
        }

        // if legend takes up all of the chart space, we need to restrict it.
        if (w.config.legend.position === 'left' || w.config.legend.position === 'right') {
          if (this.dCtx.lgRect.width * 1.5 > w.globals.svgWidth) {
            this.dCtx.lgRect.width = w.globals.svgWidth / 1.5;
          }
        }
        return this.dCtx.lgRect;
      }

      /**
       * Get Y Axis Dimensions
       * @memberof Dimensions
       * @return {{width, height}}
       **/
    }, {
      key: "getDatalabelsRect",
      value: function getDatalabelsRect() {
        var _this = this;
        var w = this.w;
        var allLabels = [];
        w.config.series.forEach(function (serie, seriesIndex) {
          serie.data.forEach(function (datum, dataPointIndex) {
            var getText = function getText(v) {
              return w.config.dataLabels.formatter(v, {
                ctx: _this.dCtx.ctx,
                seriesIndex: seriesIndex,
                dataPointIndex: dataPointIndex,
                w: w
              });
            };
            val = getText(w.globals.series[seriesIndex][dataPointIndex]);
            allLabels.push(val);
          });
        });
        var val = Utils$1.getLargestStringFromArr(allLabels);
        var graphics = new Graphics(this.dCtx.ctx);
        var dataLabelsStyle = w.config.dataLabels.style;
        var labelrect = graphics.getTextRects(val, parseInt(dataLabelsStyle.fontSize), dataLabelsStyle.fontFamily);
        return {
          width: labelrect.width * 1.05,
          height: labelrect.height
        };
      }
    }, {
      key: "getLargestStringFromMultiArr",
      value: function getLargestStringFromMultiArr(val, arr) {
        var w = this.w;
        var valArr = val;
        if (w.globals.isMultiLineX) {
          // if the xaxis labels has multiline texts (array)
          var maxArrs = arr.map(function (xl, idx) {
            return Array.isArray(xl) ? xl.length : 1;
          });
          var maxArrLen = Math.max.apply(Math, _toConsumableArray(maxArrs));
          var maxArrIndex = maxArrs.indexOf(maxArrLen);
          valArr = arr[maxArrIndex];
        }
        return valArr;
      }
    }]);
    return Helpers;
  }();

  var DimXAxis = /*#__PURE__*/function () {
    function DimXAxis(dCtx) {
      _classCallCheck(this, DimXAxis);
      this.w = dCtx.w;
      this.dCtx = dCtx;
    }

    /**
     * Get X Axis Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/
    _createClass(DimXAxis, [{
      key: "getxAxisLabelsCoords",
      value: function getxAxisLabelsCoords() {
        var w = this.w;
        var xaxisLabels = w.globals.labels.slice();
        if (w.config.xaxis.convertedCatToNumeric && xaxisLabels.length === 0) {
          xaxisLabels = w.globals.categoryLabels;
        }
        var rect;
        if (w.globals.timescaleLabels.length > 0) {
          var coords = this.getxAxisTimeScaleLabelsCoords();
          rect = {
            width: coords.width,
            height: coords.height
          };
          w.globals.rotateXLabels = false;
        } else {
          this.dCtx.lgWidthForSideLegends = (w.config.legend.position === 'left' || w.config.legend.position === 'right') && !w.config.legend.floating ? this.dCtx.lgRect.width : 0;

          // get the longest string from the labels array and also apply label formatter
          var xlbFormatter = w.globals.xLabelFormatter;
          // prevent changing xaxisLabels to avoid issues in multi-yaxes - fix #522
          var val = Utils$1.getLargestStringFromArr(xaxisLabels);
          var valArr = this.dCtx.dimHelpers.getLargestStringFromMultiArr(val, xaxisLabels);

          // the labels gets changed for bar charts
          if (w.globals.isBarHorizontal) {
            val = w.globals.yAxisScale[0].result.reduce(function (a, b) {
              return a.length > b.length ? a : b;
            }, 0);
            valArr = val;
          }
          var xFormat = new Formatters(this.dCtx.ctx);
          var timestamp = val;
          val = xFormat.xLabelFormat(xlbFormatter, val, timestamp, {
            i: undefined,
            dateFormatter: new DateTime(this.dCtx.ctx).formatDate,
            w: w
          });
          valArr = xFormat.xLabelFormat(xlbFormatter, valArr, timestamp, {
            i: undefined,
            dateFormatter: new DateTime(this.dCtx.ctx).formatDate,
            w: w
          });
          if (w.config.xaxis.convertedCatToNumeric && typeof val === 'undefined' || String(val).trim() === '') {
            val = '1';
            valArr = val;
          }
          var graphics = new Graphics(this.dCtx.ctx);
          var xLabelrect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);
          var xArrLabelrect = xLabelrect;
          if (val !== valArr) {
            xArrLabelrect = graphics.getTextRects(valArr, w.config.xaxis.labels.style.fontSize);
          }
          rect = {
            width: xLabelrect.width >= xArrLabelrect.width ? xLabelrect.width : xArrLabelrect.width,
            height: xLabelrect.height >= xArrLabelrect.height ? xLabelrect.height : xArrLabelrect.height
          };
          if (rect.width * xaxisLabels.length > w.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && w.config.xaxis.labels.rotate !== 0 || w.config.xaxis.labels.rotateAlways) {
            if (!w.globals.isBarHorizontal) {
              w.globals.rotateXLabels = true;
              var getRotatedTextRects = function getRotatedTextRects(text) {
                return graphics.getTextRects(text, w.config.xaxis.labels.style.fontSize, w.config.xaxis.labels.style.fontFamily, "rotate(".concat(w.config.xaxis.labels.rotate, " 0 0)"), false);
              };
              xLabelrect = getRotatedTextRects(val);
              if (val !== valArr) {
                xArrLabelrect = getRotatedTextRects(valArr);
              }
              rect.height = (xLabelrect.height > xArrLabelrect.height ? xLabelrect.height : xArrLabelrect.height) / 1.5;
              rect.width = xLabelrect.width > xArrLabelrect.width ? xLabelrect.width : xArrLabelrect.width;
            }
          } else {
            w.globals.rotateXLabels = false;
          }
        }
        if (!w.config.xaxis.labels.show) {
          rect = {
            width: 0,
            height: 0
          };
        }
        return {
          width: rect.width,
          height: rect.height
        };
      }

      /**
       * Get X Axis Label Group height
       * @memberof Dimensions
       * @return {{width, height}}
       */
    }, {
      key: "getxAxisGroupLabelsCoords",
      value: function getxAxisGroupLabelsCoords() {
        var _w$config$xaxis$group;
        var w = this.w;
        if (!w.globals.hasXaxisGroups) {
          return {
            width: 0,
            height: 0
          };
        }
        var fontSize = ((_w$config$xaxis$group = w.config.xaxis.group.style) === null || _w$config$xaxis$group === void 0 ? void 0 : _w$config$xaxis$group.fontSize) || w.config.xaxis.labels.style.fontSize;
        var xaxisLabels = w.globals.groups.map(function (g) {
          return g.title;
        });
        var rect;

        // prevent changing xaxisLabels to avoid issues in multi-yaxes - fix #522
        var val = Utils$1.getLargestStringFromArr(xaxisLabels);
        var valArr = this.dCtx.dimHelpers.getLargestStringFromMultiArr(val, xaxisLabels);
        var graphics = new Graphics(this.dCtx.ctx);
        var xLabelrect = graphics.getTextRects(val, fontSize);
        var xArrLabelrect = xLabelrect;
        if (val !== valArr) {
          xArrLabelrect = graphics.getTextRects(valArr, fontSize);
        }
        rect = {
          width: xLabelrect.width >= xArrLabelrect.width ? xLabelrect.width : xArrLabelrect.width,
          height: xLabelrect.height >= xArrLabelrect.height ? xLabelrect.height : xArrLabelrect.height
        };
        if (!w.config.xaxis.labels.show) {
          rect = {
            width: 0,
            height: 0
          };
        }
        return {
          width: rect.width,
          height: rect.height
        };
      }

      /**
       * Get X Axis Title Dimensions
       * @memberof Dimensions
       * @return {{width, height}}
       **/
    }, {
      key: "getxAxisTitleCoords",
      value: function getxAxisTitleCoords() {
        var w = this.w;
        var width = 0;
        var height = 0;
        if (w.config.xaxis.title.text !== undefined) {
          var graphics = new Graphics(this.dCtx.ctx);
          var rect = graphics.getTextRects(w.config.xaxis.title.text, w.config.xaxis.title.style.fontSize);
          width = rect.width;
          height = rect.height;
        }
        return {
          width: width,
          height: height
        };
      }
    }, {
      key: "getxAxisTimeScaleLabelsCoords",
      value: function getxAxisTimeScaleLabelsCoords() {
        var w = this.w;
        var rect;
        this.dCtx.timescaleLabels = w.globals.timescaleLabels.slice();
        var labels = this.dCtx.timescaleLabels.map(function (label) {
          return label.value;
        });

        //  get the longest string from the labels array and also apply label formatter to it
        var val = labels.reduce(function (a, b) {
          // if undefined, maybe user didn't pass the datetime(x) values
          if (typeof a === 'undefined') {
            console.error('You have possibly supplied invalid Date format. Please supply a valid JavaScript Date');
            return 0;
          } else {
            return a.length > b.length ? a : b;
          }
        }, 0);
        var graphics = new Graphics(this.dCtx.ctx);
        rect = graphics.getTextRects(val, w.config.xaxis.labels.style.fontSize);
        var totalWidthRotated = rect.width * 1.05 * labels.length;
        if (totalWidthRotated > w.globals.gridWidth && w.config.xaxis.labels.rotate !== 0) {
          w.globals.overlappingXLabels = true;
        }
        return rect;
      }

      // In certain cases, the last labels gets cropped in xaxis.
      // Hence, we add some additional padding based on the label length to avoid the last label being cropped or we don't draw it at all
    }, {
      key: "additionalPaddingXLabels",
      value: function additionalPaddingXLabels(xaxisLabelCoords) {
        var _this = this;
        var w = this.w;
        var gl = w.globals;
        var cnf = w.config;
        var xtype = cnf.xaxis.type;
        var lbWidth = xaxisLabelCoords.width;
        gl.skipLastTimelinelabel = false;
        gl.skipFirstTimelinelabel = false;
        var isBarOpposite = w.config.yaxis[0].opposite && w.globals.isBarHorizontal;
        var isCollapsed = function isCollapsed(i) {
          return gl.collapsedSeriesIndices.indexOf(i) !== -1;
        };
        var rightPad = function rightPad(yaxe) {
          if (_this.dCtx.timescaleLabels && _this.dCtx.timescaleLabels.length) {
            // for timeline labels, we take the last label and check if it exceeds gridWidth
            var firstimescaleLabel = _this.dCtx.timescaleLabels[0];
            var lastTimescaleLabel = _this.dCtx.timescaleLabels[_this.dCtx.timescaleLabels.length - 1];
            var lastLabelPosition = lastTimescaleLabel.position + lbWidth / 1.75 - _this.dCtx.yAxisWidthRight;
            var firstLabelPosition = firstimescaleLabel.position - lbWidth / 1.75 + _this.dCtx.yAxisWidthLeft;
            var lgRightRectWidth = w.config.legend.position === 'right' && _this.dCtx.lgRect.width > 0 ? _this.dCtx.lgRect.width : 0;
            if (lastLabelPosition > gl.svgWidth - gl.translateX - lgRightRectWidth) {
              gl.skipLastTimelinelabel = true;
            }
            if (firstLabelPosition < -((!yaxe.show || yaxe.floating) && (cnf.chart.type === 'bar' || cnf.chart.type === 'candlestick' || cnf.chart.type === 'rangeBar' || cnf.chart.type === 'boxPlot') ? lbWidth / 1.75 : 10)) {
              gl.skipFirstTimelinelabel = true;
            }
          } else if (xtype === 'datetime') {
            // If user has enabled DateTime, but uses own's formatter
            if (_this.dCtx.gridPad.right < lbWidth && !gl.rotateXLabels) {
              gl.skipLastTimelinelabel = true;
            }
          } else if (xtype !== 'datetime') {
            if (_this.dCtx.gridPad.right < lbWidth / 2 - _this.dCtx.yAxisWidthRight && !gl.rotateXLabels && !w.config.xaxis.labels.trim) {
              _this.dCtx.xPadRight = lbWidth / 2 + 1;
            }
          }
        };
        var padYAxe = function padYAxe(yaxe, i) {
          if (cnf.yaxis.length > 1 && isCollapsed(i)) return;
          rightPad(yaxe);
        };
        cnf.yaxis.forEach(function (yaxe, i) {
          if (isBarOpposite) {
            if (_this.dCtx.gridPad.left < lbWidth) {
              _this.dCtx.xPadLeft = lbWidth / 2 + 1;
            }
            _this.dCtx.xPadRight = lbWidth / 2 + 1;
          } else {
            padYAxe(yaxe, i);
          }
        });
      }
    }]);
    return DimXAxis;
  }();

  var DimYAxis = /*#__PURE__*/function () {
    function DimYAxis(dCtx) {
      _classCallCheck(this, DimYAxis);
      this.w = dCtx.w;
      this.dCtx = dCtx;
    }

    /**
     * Get Y Axis Dimensions
     * @memberof Dimensions
     * @return {{width, height}}
     **/
    _createClass(DimYAxis, [{
      key: "getyAxisLabelsCoords",
      value: function getyAxisLabelsCoords() {
        var _this = this;
        var w = this.w;
        var width = 0;
        var height = 0;
        var ret = [];
        var labelPad = 10;
        var axesUtils = new AxesUtils(this.dCtx.ctx);
        w.config.yaxis.map(function (yaxe, index) {
          var formatterArgs = {
            seriesIndex: index,
            dataPointIndex: -1,
            w: w
          };
          var yS = w.globals.yAxisScale[index];
          var yAxisMinWidth = 0;
          if (!axesUtils.isYAxisHidden(index) && yaxe.labels.show && yaxe.labels.minWidth !== undefined) yAxisMinWidth = yaxe.labels.minWidth;
          if (!axesUtils.isYAxisHidden(index) && yaxe.labels.show && yS.result.length) {
            var lbFormatter = w.globals.yLabelFormatters[index];
            var minV = yS.niceMin === Number.MIN_VALUE ? 0 : yS.niceMin;
            var val = yS.result.reduce(function (acc, curr) {
              var _String, _String2;
              return ((_String = String(lbFormatter(acc, formatterArgs))) === null || _String === void 0 ? void 0 : _String.length) > ((_String2 = String(lbFormatter(curr, formatterArgs))) === null || _String2 === void 0 ? void 0 : _String2.length) ? acc : curr;
            }, minV);
            val = lbFormatter(val, formatterArgs);

            // the second parameter -1 is the index of tick which user can use in the formatter
            var valArr = val;

            // if user has specified a custom formatter, and the result is null or empty, we need to discard the formatter and take the value as it is.
            if (typeof val === 'undefined' || val.length === 0) {
              val = yS.niceMax;
            }
            if (w.globals.isBarHorizontal) {
              labelPad = 0;
              var barYaxisLabels = w.globals.labels.slice();

              //  get the longest string from the labels array and also apply label formatter to it
              val = Utils$1.getLargestStringFromArr(barYaxisLabels);
              val = lbFormatter(val, {
                seriesIndex: index,
                dataPointIndex: -1,
                w: w
              });
              valArr = _this.dCtx.dimHelpers.getLargestStringFromMultiArr(val, barYaxisLabels);
            }
            var graphics = new Graphics(_this.dCtx.ctx);
            var rotateStr = 'rotate('.concat(yaxe.labels.rotate, ' 0 0)');
            var rect = graphics.getTextRects(val, yaxe.labels.style.fontSize, yaxe.labels.style.fontFamily, rotateStr, false);
            var arrLabelrect = rect;
            if (val !== valArr) {
              arrLabelrect = graphics.getTextRects(valArr, yaxe.labels.style.fontSize, yaxe.labels.style.fontFamily, rotateStr, false);
            }
            ret.push({
              width: (yAxisMinWidth > arrLabelrect.width || yAxisMinWidth > rect.width ? yAxisMinWidth : arrLabelrect.width > rect.width ? arrLabelrect.width : rect.width) + labelPad,
              height: arrLabelrect.height > rect.height ? arrLabelrect.height : rect.height
            });
          } else {
            ret.push({
              width: width,
              height: height
            });
          }
        });
        return ret;
      }

      /**
       * Get Y Axis Dimensions
       * @memberof Dimensions
       * @return {{width, height}}
       **/
    }, {
      key: "getyAxisTitleCoords",
      value: function getyAxisTitleCoords() {
        var _this2 = this;
        var w = this.w;
        var ret = [];
        w.config.yaxis.map(function (yaxe, index) {
          if (yaxe.show && yaxe.title.text !== undefined) {
            var graphics = new Graphics(_this2.dCtx.ctx);
            var rotateStr = 'rotate('.concat(yaxe.title.rotate, ' 0 0)');
            var rect = graphics.getTextRects(yaxe.title.text, yaxe.title.style.fontSize, yaxe.title.style.fontFamily, rotateStr, false);
            ret.push({
              width: rect.width,
              height: rect.height
            });
          } else {
            ret.push({
              width: 0,
              height: 0
            });
          }
        });
        return ret;
      }
    }, {
      key: "getTotalYAxisWidth",
      value: function getTotalYAxisWidth() {
        var w = this.w;
        var yAxisWidth = 0;
        var yAxisWidthLeft = 0;
        var yAxisWidthRight = 0;
        var padding = w.globals.yAxisScale.length > 1 ? 10 : 0;
        var axesUtils = new AxesUtils(this.dCtx.ctx);
        var isHiddenYAxis = function isHiddenYAxis(index) {
          return w.globals.ignoreYAxisIndexes.indexOf(index) > -1;
        };
        var padForLabelTitle = function padForLabelTitle(coord, index) {
          var floating = w.config.yaxis[index].floating;
          var width = 0;
          if (coord.width > 0 && !floating) {
            width = coord.width + padding;
            if (isHiddenYAxis(index)) {
              width = width - coord.width - padding;
            }
          } else {
            width = floating || axesUtils.isYAxisHidden(index) ? 0 : 5;
          }
          w.config.yaxis[index].opposite ? yAxisWidthRight = yAxisWidthRight + width : yAxisWidthLeft = yAxisWidthLeft + width;
          yAxisWidth = yAxisWidth + width;
        };
        w.globals.yLabelsCoords.map(function (yLabelCoord, index) {
          padForLabelTitle(yLabelCoord, index);
        });
        w.globals.yTitleCoords.map(function (yTitleCoord, index) {
          padForLabelTitle(yTitleCoord, index);
        });
        if (w.globals.isBarHorizontal && !w.config.yaxis[0].floating) {
          yAxisWidth = w.globals.yLabelsCoords[0].width + w.globals.yTitleCoords[0].width + 15;
        }
        this.dCtx.yAxisWidthLeft = yAxisWidthLeft;
        this.dCtx.yAxisWidthRight = yAxisWidthRight;
        return yAxisWidth;
      }
    }]);
    return DimYAxis;
  }();

  var DimGrid = /*#__PURE__*/function () {
    function DimGrid(dCtx) {
      _classCallCheck(this, DimGrid);
      this.w = dCtx.w;
      this.dCtx = dCtx;
    }
    _createClass(DimGrid, [{
      key: "gridPadForColumnsInNumericAxis",
      value: function gridPadForColumnsInNumericAxis(gridWidth) {
        var w = this.w;
        var cnf = w.config,
          gl = w.globals;
        if (gl.noData || gl.collapsedSeries.length + gl.ancillaryCollapsedSeries.length === cnf.series.length) {
          return 0;
        }
        var hasBar = function hasBar(type) {
          return ['bar', 'rangeBar', 'candlestick', 'boxPlot'].includes(type);
        };
        var type = cnf.chart.type;
        var barWidth = 0;
        var seriesLen = hasBar(type) ? cnf.series.length : 1;
        if (gl.comboBarCount > 0) {
          seriesLen = gl.comboBarCount;
        }
        gl.collapsedSeries.forEach(function (c) {
          if (hasBar(c.type)) {
            seriesLen -= 1;
          }
        });
        if (cnf.chart.stacked) {
          seriesLen = 1;
        }
        var barsPresent = hasBar(type) || gl.comboBarCount > 0;
        var xRange = Math.abs(gl.initialMaxX - gl.initialMinX);
        if (barsPresent && gl.isXNumeric && !gl.isBarHorizontal && seriesLen > 0 && xRange !== 0) {
          if (xRange <= 3) {
            xRange = gl.dataPoints;
          }
          var xRatio = xRange / gridWidth;
          var xDivision = gl.minXDiff && gl.minXDiff / xRatio > 0 ? gl.minXDiff / xRatio : 0;
          if (xDivision > gridWidth / 2) {
            xDivision /= 2;
          }
          // Here, barWidth is assumed to be the width occupied by a group of bars.
          // There will be one bar in the group for each series plotted.
          // Note: This version of the following math is different to that over in
          // Helpers.js. Don't assume they should be the same. Over there,
          // xDivision is computed differently and it's used on different charts.
          // They were the same, but the solution to
          // https://github.com/apexcharts/apexcharts.js/issues/4178
          // was to remove the division by seriesLen.
          barWidth = xDivision * parseInt(cnf.plotOptions.bar.columnWidth, 10) / 100;
          if (barWidth < 1) {
            barWidth = 1;
          }
          gl.barPadForNumericAxis = barWidth;
        }
        return barWidth;
      }
    }, {
      key: "gridPadFortitleSubtitle",
      value: function gridPadFortitleSubtitle() {
        var _this = this;
        var w = this.w;
        var gl = w.globals;
        var gridShrinkOffset = this.dCtx.isSparkline || !gl.axisCharts ? 0 : 10;
        var titleSubtitle = ['title', 'subtitle'];
        titleSubtitle.forEach(function (t) {
          if (w.config[t].text !== undefined) {
            gridShrinkOffset += w.config[t].margin;
          } else {
            gridShrinkOffset += _this.dCtx.isSparkline || !gl.axisCharts ? 0 : 5;
          }
        });
        if (w.config.legend.show && w.config.legend.position === 'bottom' && !w.config.legend.floating && !gl.axisCharts) {
          gridShrinkOffset += 10;
        }
        var titleCoords = this.dCtx.dimHelpers.getTitleSubtitleCoords('title');
        var subtitleCoords = this.dCtx.dimHelpers.getTitleSubtitleCoords('subtitle');
        gl.gridHeight -= titleCoords.height + subtitleCoords.height + gridShrinkOffset;
        gl.translateY += titleCoords.height + subtitleCoords.height + gridShrinkOffset;
      }
    }, {
      key: "setGridXPosForDualYAxis",
      value: function setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords) {
        var w = this.w;
        var axesUtils = new AxesUtils(this.dCtx.ctx);
        w.config.yaxis.forEach(function (yaxe, index) {
          if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1 && !yaxe.floating && !axesUtils.isYAxisHidden(index)) {
            if (yaxe.opposite) {
              w.globals.translateX -= yaxisLabelCoords[index].width + yTitleCoords[index].width + parseInt(yaxe.labels.style.fontSize, 10) / 1.2 + 12;
            }

            // fixes apexcharts.js#1599
            if (w.globals.translateX < 2) {
              w.globals.translateX = 2;
            }
          }
        });
      }
    }]);
    return DimGrid;
  }();

  /**
   * ApexCharts Dimensions Class for calculating rects of all elements that are drawn and will be drawn.
   *
   * @module Dimensions
   **/
  var Dimensions = /*#__PURE__*/function () {
    function Dimensions(ctx) {
      _classCallCheck(this, Dimensions);
      this.ctx = ctx;
      this.w = ctx.w;
      this.lgRect = {};
      this.yAxisWidth = 0;
      this.yAxisWidthLeft = 0;
      this.yAxisWidthRight = 0;
      this.xAxisHeight = 0;
      this.isSparkline = this.w.config.chart.sparkline.enabled;
      this.dimHelpers = new Helpers$3(this);
      this.dimYAxis = new DimYAxis(this);
      this.dimXAxis = new DimXAxis(this);
      this.dimGrid = new DimGrid(this);
      this.lgWidthForSideLegends = 0;
      this.gridPad = this.w.config.grid.padding;
      this.xPadRight = 0;
      this.xPadLeft = 0;
    }

    /**
     * @memberof Dimensions
     * @param {object} w - chart context
     **/
    _createClass(Dimensions, [{
      key: "plotCoords",
      value: function plotCoords() {
        var _this = this;
        var w = this.w;
        var gl = w.globals;
        this.lgRect = this.dimHelpers.getLegendsRect();
        this.datalabelsCoords = {
          width: 0,
          height: 0
        };
        var maxStrokeWidth = Array.isArray(w.config.stroke.width) ? Math.max.apply(Math, _toConsumableArray(w.config.stroke.width)) : w.config.stroke.width;
        if (this.isSparkline) {
          if (w.config.markers.discrete.length > 0 || w.config.markers.size > 0) {
            Object.entries(this.gridPad).forEach(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                k = _ref2[0],
                v = _ref2[1];
              _this.gridPad[k] = Math.max(v, _this.w.globals.markers.largestSize / 1.5);
            });
          }
          this.gridPad.top = Math.max(maxStrokeWidth / 2, this.gridPad.top);
          this.gridPad.bottom = Math.max(maxStrokeWidth / 2, this.gridPad.bottom);
        }
        if (gl.axisCharts) {
          // for line / area / scatter / column
          this.setDimensionsForAxisCharts();
        } else {
          // for pie / donuts / circle
          this.setDimensionsForNonAxisCharts();
        }
        this.dimGrid.gridPadFortitleSubtitle();

        // after calculating everything, apply padding set by user
        gl.gridHeight = gl.gridHeight - this.gridPad.top - this.gridPad.bottom;
        gl.gridWidth = gl.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
        var barWidth = this.dimGrid.gridPadForColumnsInNumericAxis(gl.gridWidth);
        gl.gridWidth = gl.gridWidth - barWidth * 2;
        gl.translateX = gl.translateX + this.gridPad.left + this.xPadLeft + (barWidth > 0 ? barWidth : 0);
        gl.translateY = gl.translateY + this.gridPad.top;
      }
    }, {
      key: "setDimensionsForAxisCharts",
      value: function setDimensionsForAxisCharts() {
        var _this2 = this;
        var w = this.w;
        var gl = w.globals;
        var yaxisLabelCoords = this.dimYAxis.getyAxisLabelsCoords();
        var yTitleCoords = this.dimYAxis.getyAxisTitleCoords();
        if (gl.isSlopeChart) {
          this.datalabelsCoords = this.dimHelpers.getDatalabelsRect();
        }
        w.globals.yLabelsCoords = [];
        w.globals.yTitleCoords = [];
        w.config.yaxis.map(function (yaxe, index) {
          // store the labels and titles coords in global vars
          w.globals.yLabelsCoords.push({
            width: yaxisLabelCoords[index].width,
            index: index
          });
          w.globals.yTitleCoords.push({
            width: yTitleCoords[index].width,
            index: index
          });
        });
        this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
        var xaxisLabelCoords = this.dimXAxis.getxAxisLabelsCoords();
        var xaxisGroupLabelCoords = this.dimXAxis.getxAxisGroupLabelsCoords();
        var xtitleCoords = this.dimXAxis.getxAxisTitleCoords();
        this.conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords, xaxisGroupLabelCoords);
        gl.translateXAxisY = w.globals.rotateXLabels ? this.xAxisHeight / 8 : -4;
        gl.translateXAxisX = w.globals.rotateXLabels && w.globals.isXNumeric && w.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0;
        if (w.globals.isBarHorizontal) {
          gl.rotateXLabels = false;
          gl.translateXAxisY = -1 * (parseInt(w.config.xaxis.labels.style.fontSize, 10) / 1.5);
        }
        gl.translateXAxisY = gl.translateXAxisY + w.config.xaxis.labels.offsetY;
        gl.translateXAxisX = gl.translateXAxisX + w.config.xaxis.labels.offsetX;
        var yAxisWidth = this.yAxisWidth;
        var xAxisHeight = this.xAxisHeight;
        gl.xAxisLabelsHeight = this.xAxisHeight - xtitleCoords.height;
        gl.xAxisGroupLabelsHeight = gl.xAxisLabelsHeight - xaxisLabelCoords.height;
        gl.xAxisLabelsWidth = this.xAxisWidth;
        gl.xAxisHeight = this.xAxisHeight;
        var translateY = 10;
        if (w.config.chart.type === 'radar' || this.isSparkline) {
          yAxisWidth = 0;
          xAxisHeight = 0;
        }
        if (this.isSparkline) {
          this.lgRect = {
            height: 0,
            width: 0
          };
        }
        if (this.isSparkline || w.config.chart.type === 'treemap') {
          yAxisWidth = 0;
          xAxisHeight = 0;
          translateY = 0;
        }
        if (!this.isSparkline && w.config.chart.type !== 'treemap') {
          this.dimXAxis.additionalPaddingXLabels(xaxisLabelCoords);
        }
        var legendTopBottom = function legendTopBottom() {
          gl.translateX = yAxisWidth + _this2.datalabelsCoords.width;
          gl.gridHeight = gl.svgHeight - _this2.lgRect.height - xAxisHeight - (!_this2.isSparkline && w.config.chart.type !== 'treemap' ? w.globals.rotateXLabels ? 10 : 15 : 0);
          gl.gridWidth = gl.svgWidth - yAxisWidth - _this2.datalabelsCoords.width * 2;
        };
        if (w.config.xaxis.position === 'top') translateY = gl.xAxisHeight - w.config.xaxis.axisTicks.height - 5;
        switch (w.config.legend.position) {
          case 'bottom':
            gl.translateY = translateY;
            legendTopBottom();
            break;
          case 'top':
            gl.translateY = this.lgRect.height + translateY;
            legendTopBottom();
            break;
          case 'left':
            gl.translateY = translateY;
            gl.translateX = this.lgRect.width + yAxisWidth + this.datalabelsCoords.width;
            gl.gridHeight = gl.svgHeight - xAxisHeight - 12;
            gl.gridWidth = gl.svgWidth - this.lgRect.width - yAxisWidth - this.datalabelsCoords.width * 2;
            break;
          case 'right':
            gl.translateY = translateY;
            gl.translateX = yAxisWidth + this.datalabelsCoords.width;
            gl.gridHeight = gl.svgHeight - xAxisHeight - 12;
            gl.gridWidth = gl.svgWidth - this.lgRect.width - yAxisWidth - this.datalabelsCoords.width * 2 - 5;
            break;
          default:
            throw new Error('Legend position not supported');
        }
        this.dimGrid.setGridXPosForDualYAxis(yTitleCoords, yaxisLabelCoords);

        // after drawing everything, set the Y axis positions
        var objyAxis = new YAxis(this.ctx);
        objyAxis.setYAxisXPosition(yaxisLabelCoords, yTitleCoords);
      }
    }, {
      key: "setDimensionsForNonAxisCharts",
      value: function setDimensionsForNonAxisCharts() {
        var w = this.w;
        var gl = w.globals;
        var cnf = w.config;
        var xPad = 0;
        if (w.config.legend.show && !w.config.legend.floating) {
          xPad = 20;
        }
        var type = cnf.chart.type === 'pie' || cnf.chart.type === 'polarArea' || cnf.chart.type === 'donut' ? 'pie' : 'radialBar';
        var offY = cnf.plotOptions[type].offsetY;
        var offX = cnf.plotOptions[type].offsetX;
        if (!cnf.legend.show || cnf.legend.floating) {
          gl.gridHeight = gl.svgHeight;
          var maxWidth = gl.dom.elWrap.getBoundingClientRect().width;
          gl.gridWidth = Math.min(maxWidth, gl.gridHeight);
          gl.translateY = offY;
          gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;
          return;
        }
        switch (cnf.legend.position) {
          case 'bottom':
            gl.gridHeight = gl.svgHeight - this.lgRect.height;
            gl.gridWidth = gl.svgWidth;
            gl.translateY = offY - 10;
            gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;
            break;
          case 'top':
            gl.gridHeight = gl.svgHeight - this.lgRect.height;
            gl.gridWidth = gl.svgWidth;
            gl.translateY = this.lgRect.height + offY + 10;
            gl.translateX = offX + (gl.svgWidth - gl.gridWidth) / 2;
            break;
          case 'left':
            gl.gridWidth = gl.svgWidth - this.lgRect.width - xPad;
            gl.gridHeight = cnf.chart.height !== 'auto' ? gl.svgHeight : gl.gridWidth;
            gl.translateY = offY;
            gl.translateX = offX + this.lgRect.width + xPad;
            break;
          case 'right':
            gl.gridWidth = gl.svgWidth - this.lgRect.width - xPad - 5;
            gl.gridHeight = cnf.chart.height !== 'auto' ? gl.svgHeight : gl.gridWidth;
            gl.translateY = offY;
            gl.translateX = offX + 10;
            break;
          default:
            throw new Error('Legend position not supported');
        }
      }
    }, {
      key: "conditionalChecksForAxisCoords",
      value: function conditionalChecksForAxisCoords(xaxisLabelCoords, xtitleCoords, xaxisGroupLabelCoords) {
        var w = this.w;
        var xAxisNum = w.globals.hasXaxisGroups ? 2 : 1;
        var baseXAxisHeight = xaxisGroupLabelCoords.height + xaxisLabelCoords.height + xtitleCoords.height;
        var xAxisHeightMultiplicate = w.globals.isMultiLineX ? 1.2 : w.globals.LINE_HEIGHT_RATIO;
        var rotatedXAxisOffset = w.globals.rotateXLabels ? 22 : 10;
        var rotatedXAxisLegendOffset = w.globals.rotateXLabels && w.config.legend.position === 'bottom';
        var additionalOffset = rotatedXAxisLegendOffset ? 10 : 0;
        this.xAxisHeight = baseXAxisHeight * xAxisHeightMultiplicate + xAxisNum * rotatedXAxisOffset + additionalOffset;
        this.xAxisWidth = xaxisLabelCoords.width;
        if (this.xAxisHeight - xtitleCoords.height > w.config.xaxis.labels.maxHeight) {
          this.xAxisHeight = w.config.xaxis.labels.maxHeight;
        }
        if (w.config.xaxis.labels.minHeight && this.xAxisHeight < w.config.xaxis.labels.minHeight) {
          this.xAxisHeight = w.config.xaxis.labels.minHeight;
        }
        if (w.config.xaxis.floating) {
          this.xAxisHeight = 0;
        }
        var minYAxisWidth = 0;
        var maxYAxisWidth = 0;
        w.config.yaxis.forEach(function (y) {
          minYAxisWidth += y.labels.minWidth;
          maxYAxisWidth += y.labels.maxWidth;
        });
        if (this.yAxisWidth < minYAxisWidth) {
          this.yAxisWidth = minYAxisWidth;
        }
        if (this.yAxisWidth > maxYAxisWidth) {
          this.yAxisWidth = maxYAxisWidth;
        }
      }
    }]);
    return Dimensions;
  }();

  var Helpers$2 = /*#__PURE__*/function () {
    function Helpers(lgCtx) {
      _classCallCheck(this, Helpers);
      this.w = lgCtx.w;
      this.lgCtx = lgCtx;
    }
    _createClass(Helpers, [{
      key: "getLegendStyles",
      value: function getLegendStyles() {
        var _this$lgCtx$ctx, _this$lgCtx$ctx$opts, _this$lgCtx$ctx$opts$;
        var stylesheet = document.createElement('style');
        stylesheet.setAttribute('type', 'text/css');
        var nonce = ((_this$lgCtx$ctx = this.lgCtx.ctx) === null || _this$lgCtx$ctx === void 0 ? void 0 : (_this$lgCtx$ctx$opts = _this$lgCtx$ctx.opts) === null || _this$lgCtx$ctx$opts === void 0 ? void 0 : (_this$lgCtx$ctx$opts$ = _this$lgCtx$ctx$opts.chart) === null || _this$lgCtx$ctx$opts$ === void 0 ? void 0 : _this$lgCtx$ctx$opts$.nonce) || this.w.config.chart.nonce;
        if (nonce) {
          stylesheet.setAttribute('nonce', nonce);
        }
        var rule = document.createTextNode(css_248z$1);
        stylesheet.appendChild(rule);
        return stylesheet;
      }
    }, {
      key: "getLegendDimensions",
      value: function getLegendDimensions() {
        var w = this.w;
        var currLegendsWrap = w.globals.dom.baseEl.querySelector('.apexcharts-legend');
        var _currLegendsWrap$getB = currLegendsWrap.getBoundingClientRect(),
          currLegendsWrapWidth = _currLegendsWrap$getB.width,
          currLegendsWrapHeight = _currLegendsWrap$getB.height;
        return {
          clwh: currLegendsWrapHeight,
          clww: currLegendsWrapWidth
        };
      }
    }, {
      key: "appendToForeignObject",
      value: function appendToForeignObject() {
        var gl = this.w.globals;
        if (this.w.config.chart.injectStyleSheet !== false) {
          gl.dom.elLegendForeign.appendChild(this.getLegendStyles());
        }
      }
    }, {
      key: "toggleDataSeries",
      value: function toggleDataSeries(seriesCnt, isHidden) {
        var _this = this;
        var w = this.w;
        if (w.globals.axisCharts || w.config.chart.type === 'radialBar') {
          w.globals.resized = true; // we don't want initial animations again

          var seriesEl = null;
          var realIndex = null;

          // yes, make it null. 1 series will rise at a time
          w.globals.risingSeries = [];
          if (w.globals.axisCharts) {
            seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(seriesCnt, "']"));
            realIndex = parseInt(seriesEl.getAttribute('data:realIndex'), 10);
          } else {
            seriesEl = w.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(seriesCnt + 1, "']"));
            realIndex = parseInt(seriesEl.getAttribute('rel'), 10) - 1;
          }
          if (isHidden) {
            var seriesToMakeVisible = [{
              cs: w.globals.collapsedSeries,
              csi: w.globals.collapsedSeriesIndices
            }, {
              cs: w.globals.ancillaryCollapsedSeries,
              csi: w.globals.ancillaryCollapsedSeriesIndices
            }];
            seriesToMakeVisible.forEach(function (r) {
              _this.riseCollapsedSeries(r.cs, r.csi, realIndex);
            });
          } else {
            this.hideSeries({
              seriesEl: seriesEl,
              realIndex: realIndex
            });
          }
        } else {
          // for non-axis charts i.e pie / donuts
          var _seriesEl = w.globals.dom.Paper.findOne(" .apexcharts-series[rel='".concat(seriesCnt + 1, "'] path"));
          var type = w.config.chart.type;
          if (type === 'pie' || type === 'polarArea' || type === 'donut') {
            var dataLabels = w.config.plotOptions.pie.donut.labels;
            var graphics = new Graphics(this.lgCtx.ctx);
            graphics.pathMouseDown(_seriesEl, null);
            this.lgCtx.ctx.pie.printDataLabelsInner(_seriesEl.node, dataLabels);
          }
          _seriesEl.fire('click');
        }
      }
    }, {
      key: "getSeriesAfterCollapsing",
      value: function getSeriesAfterCollapsing(_ref) {
        var realIndex = _ref.realIndex;
        var w = this.w;
        var gl = w.globals;
        var series = Utils$1.clone(w.config.series);
        if (gl.axisCharts) {
          var yaxis = w.config.yaxis[gl.seriesYAxisReverseMap[realIndex]];
          var collapseData = {
            index: realIndex,
            data: series[realIndex].data.slice(),
            type: series[realIndex].type || w.config.chart.type
          };
          if (yaxis && yaxis.show && yaxis.showAlways) {
            if (gl.ancillaryCollapsedSeriesIndices.indexOf(realIndex) < 0) {
              gl.ancillaryCollapsedSeries.push(collapseData);
              gl.ancillaryCollapsedSeriesIndices.push(realIndex);
            }
          } else {
            if (gl.collapsedSeriesIndices.indexOf(realIndex) < 0) {
              gl.collapsedSeries.push(collapseData);
              gl.collapsedSeriesIndices.push(realIndex);
              var removeIndexOfRising = gl.risingSeries.indexOf(realIndex);
              gl.risingSeries.splice(removeIndexOfRising, 1);
            }
          }
        } else {
          gl.collapsedSeries.push({
            index: realIndex,
            data: series[realIndex]
          });
          gl.collapsedSeriesIndices.push(realIndex);
        }
        gl.allSeriesCollapsed = gl.collapsedSeries.length + gl.ancillaryCollapsedSeries.length === w.config.series.length;
        return this._getSeriesBasedOnCollapsedState(series);
      }
    }, {
      key: "hideSeries",
      value: function hideSeries(_ref2) {
        var seriesEl = _ref2.seriesEl,
          realIndex = _ref2.realIndex;
        var w = this.w;
        var series = this.getSeriesAfterCollapsing({
          realIndex: realIndex
        });
        var seriesChildren = seriesEl.childNodes;
        for (var sc = 0; sc < seriesChildren.length; sc++) {
          if (seriesChildren[sc].classList.contains('apexcharts-series-markers-wrap')) {
            if (seriesChildren[sc].classList.contains('apexcharts-hide')) {
              seriesChildren[sc].classList.remove('apexcharts-hide');
            } else {
              seriesChildren[sc].classList.add('apexcharts-hide');
            }
          }
        }
        this.lgCtx.ctx.updateHelpers._updateSeries(series, w.config.chart.animations.dynamicAnimation.enabled);
      }
    }, {
      key: "riseCollapsedSeries",
      value: function riseCollapsedSeries(collapsedSeries, seriesIndices, realIndex) {
        var w = this.w;
        var series = Utils$1.clone(w.config.series);
        if (collapsedSeries.length > 0) {
          for (var c = 0; c < collapsedSeries.length; c++) {
            if (collapsedSeries[c].index === realIndex) {
              if (w.globals.axisCharts) {
                series[realIndex].data = collapsedSeries[c].data.slice();
              } else {
                series[realIndex] = collapsedSeries[c].data;
              }
              if (typeof series[realIndex] !== 'number') {
                series[realIndex].hidden = false;
              }
              collapsedSeries.splice(c, 1);
              seriesIndices.splice(c, 1);
              w.globals.risingSeries.push(realIndex);
            }
          }
          series = this._getSeriesBasedOnCollapsedState(series);
          this.lgCtx.ctx.updateHelpers._updateSeries(series, w.config.chart.animations.dynamicAnimation.enabled);
        }
      }
    }, {
      key: "_getSeriesBasedOnCollapsedState",
      value: function _getSeriesBasedOnCollapsedState(series) {
        var w = this.w;
        var collapsed = 0;
        if (w.globals.axisCharts) {
          series.forEach(function (s, sI) {
            if (!(w.globals.collapsedSeriesIndices.indexOf(sI) < 0 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(sI) < 0)) {
              series[sI].data = [];
              collapsed++;
            }
          });
        } else {
          series.forEach(function (s, sI) {
            if (!w.globals.collapsedSeriesIndices.indexOf(sI) < 0) {
              series[sI] = 0;
              collapsed++;
            }
          });
        }
        w.globals.allSeriesCollapsed = collapsed === series.length;
        return series;
      }
    }]);
    return Helpers;
  }();

  /**
   * ApexCharts Legend Class to draw legend.
   *
   * @module Legend
   **/
  var Legend = /*#__PURE__*/function () {
    function Legend(ctx) {
      _classCallCheck(this, Legend);
      this.ctx = ctx;
      this.w = ctx.w;
      this.onLegendClick = this.onLegendClick.bind(this);
      this.onLegendHovered = this.onLegendHovered.bind(this);
      this.isBarsDistributed = this.w.config.chart.type === 'bar' && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1;
      this.legendHelpers = new Helpers$2(this);
    }
    _createClass(Legend, [{
      key: "init",
      value: function init() {
        var w = this.w;
        var gl = w.globals;
        var cnf = w.config;
        var showLegendAlways = cnf.legend.showForSingleSeries && gl.series.length === 1 || this.isBarsDistributed || gl.series.length > 1;
        this.legendHelpers.appendToForeignObject();
        if ((showLegendAlways || !gl.axisCharts) && cnf.legend.show) {
          while (gl.dom.elLegendWrap.firstChild) {
            gl.dom.elLegendWrap.removeChild(gl.dom.elLegendWrap.firstChild);
          }
          this.drawLegends();
          if (cnf.legend.position === 'bottom' || cnf.legend.position === 'top') {
            this.legendAlignHorizontal();
          } else if (cnf.legend.position === 'right' || cnf.legend.position === 'left') {
            this.legendAlignVertical();
          }
        }
      }
    }, {
      key: "createLegendMarker",
      value: function createLegendMarker(_ref) {
        var i = _ref.i,
          fillcolor = _ref.fillcolor;
        var w = this.w;
        var elMarker = document.createElement('span');
        elMarker.classList.add('apexcharts-legend-marker');
        var mShape = w.config.legend.markers.shape || w.config.markers.shape;
        var shape = mShape;
        if (Array.isArray(mShape)) {
          shape = mShape[i];
        }
        var mSize = Array.isArray(w.config.legend.markers.size) ? parseFloat(w.config.legend.markers.size[i]) : parseFloat(w.config.legend.markers.size);
        var mOffsetX = Array.isArray(w.config.legend.markers.offsetX) ? parseFloat(w.config.legend.markers.offsetX[i]) : parseFloat(w.config.legend.markers.offsetX);
        var mOffsetY = Array.isArray(w.config.legend.markers.offsetY) ? parseFloat(w.config.legend.markers.offsetY[i]) : parseFloat(w.config.legend.markers.offsetY);
        var mBorderWidth = Array.isArray(w.config.legend.markers.strokeWidth) ? parseFloat(w.config.legend.markers.strokeWidth[i]) : parseFloat(w.config.legend.markers.strokeWidth);
        var mStyle = elMarker.style;
        mStyle.height = (mSize + mBorderWidth) * 2 + 'px';
        mStyle.width = (mSize + mBorderWidth) * 2 + 'px';
        mStyle.left = mOffsetX + 'px';
        mStyle.top = mOffsetY + 'px';
        if (w.config.legend.markers.customHTML) {
          mStyle.background = 'transparent';
          mStyle.color = fillcolor[i];
          if (Array.isArray(w.config.legend.markers.customHTML)) {
            if (w.config.legend.markers.customHTML[i]) {
              elMarker.innerHTML = w.config.legend.markers.customHTML[i]();
            }
          } else {
            elMarker.innerHTML = w.config.legend.markers.customHTML();
          }
        } else {
          var markers = new Markers(this.ctx);
          var markerConfig = markers.getMarkerConfig({
            cssClass: "apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(shape),
            seriesIndex: i,
            strokeWidth: mBorderWidth,
            size: mSize
          });
          var SVGMarker = window.SVG().addTo(elMarker).size('100%', '100%');
          var marker = new Graphics(this.ctx).drawMarker(0, 0, _objectSpread2(_objectSpread2({}, markerConfig), {}, {
            pointFillColor: Array.isArray(fillcolor) ? fillcolor[i] : markerConfig.pointFillColor,
            shape: shape
          }));
          var shapesEls = w.globals.dom.Paper.find('.apexcharts-legend-marker.apexcharts-marker');
          shapesEls.forEach(function (shapeEl) {
            if (shapeEl.node.classList.contains('apexcharts-marker-triangle')) {
              shapeEl.node.style.transform = 'translate(50%, 45%)';
            } else {
              shapeEl.node.style.transform = 'translate(50%, 50%)';
            }
          });
          SVGMarker.add(marker);
        }
        return elMarker;
      }
    }, {
      key: "drawLegends",
      value: function drawLegends() {
        var _this = this;
        var me = this;
        var w = this.w;
        var fontFamily = w.config.legend.fontFamily;
        var legendNames = w.globals.seriesNames;
        var fillcolor = w.config.legend.markers.fillColors ? w.config.legend.markers.fillColors.slice() : w.globals.colors.slice();
        if (w.config.chart.type === 'heatmap') {
          var ranges = w.config.plotOptions.heatmap.colorScale.ranges;
          legendNames = ranges.map(function (colorScale) {
            return colorScale.name ? colorScale.name : colorScale.from + ' - ' + colorScale.to;
          });
          fillcolor = ranges.map(function (color) {
            return color.color;
          });
        } else if (this.isBarsDistributed) {
          legendNames = w.globals.labels.slice();
        }
        if (w.config.legend.customLegendItems.length) {
          legendNames = w.config.legend.customLegendItems;
        }
        var legendFormatter = w.globals.legendFormatter;
        var isLegendInversed = w.config.legend.inverseOrder;
        var legendGroups = [];
        if (w.globals.seriesGroups.length > 1 && w.config.legend.clusterGroupedSeries) {
          w.globals.seriesGroups.forEach(function (_, gi) {
            legendGroups[gi] = document.createElement('div');
            legendGroups[gi].classList.add('apexcharts-legend-group', "apexcharts-legend-group-".concat(gi));
            if (w.config.legend.clusterGroupedSeriesOrientation === 'horizontal') {
              w.globals.dom.elLegendWrap.classList.add('apexcharts-legend-group-horizontal');
            } else {
              legendGroups[gi].classList.add('apexcharts-legend-group-vertical');
            }
          });
        }
        var _loop = function _loop(i) {
          var _w$config$legend$labe;
          var text = legendFormatter(legendNames[i], {
            seriesIndex: i,
            w: w
          });
          var collapsedSeries = false;
          var ancillaryCollapsedSeries = false;
          if (w.globals.collapsedSeries.length > 0) {
            for (var c = 0; c < w.globals.collapsedSeries.length; c++) {
              if (w.globals.collapsedSeries[c].index === i) {
                collapsedSeries = true;
              }
            }
          }
          if (w.globals.ancillaryCollapsedSeriesIndices.length > 0) {
            for (var _c = 0; _c < w.globals.ancillaryCollapsedSeriesIndices.length; _c++) {
              if (w.globals.ancillaryCollapsedSeriesIndices[_c] === i) {
                ancillaryCollapsedSeries = true;
              }
            }
          }
          var elMarker = _this.createLegendMarker({
            i: i,
            fillcolor: fillcolor
          });
          Graphics.setAttrs(elMarker, {
            rel: i + 1,
            'data:collapsed': collapsedSeries || ancillaryCollapsedSeries
          });
          if (collapsedSeries || ancillaryCollapsedSeries) {
            elMarker.classList.add('apexcharts-inactive-legend');
          }
          var elLegend = document.createElement('div');
          var elLegendText = document.createElement('span');
          elLegendText.classList.add('apexcharts-legend-text');
          elLegendText.innerHTML = Array.isArray(text) ? text.join(' ') : text;
          var textColor = w.config.legend.labels.useSeriesColors ? w.globals.colors[i] : Array.isArray(w.config.legend.labels.colors) ? (_w$config$legend$labe = w.config.legend.labels.colors) === null || _w$config$legend$labe === void 0 ? void 0 : _w$config$legend$labe[i] : w.config.legend.labels.colors;
          if (!textColor) {
            textColor = w.config.chart.foreColor;
          }
          elLegendText.style.color = textColor;
          elLegendText.style.fontSize = parseFloat(w.config.legend.fontSize) + 'px';
          elLegendText.style.fontWeight = w.config.legend.fontWeight;
          elLegendText.style.fontFamily = fontFamily || w.config.chart.fontFamily;
          Graphics.setAttrs(elLegendText, {
            rel: i + 1,
            i: i,
            'data:default-text': encodeURIComponent(text),
            'data:collapsed': collapsedSeries || ancillaryCollapsedSeries
          });
          elLegend.appendChild(elMarker);
          elLegend.appendChild(elLegendText);
          var coreUtils = new CoreUtils(_this.ctx);
          if (!w.config.legend.showForZeroSeries) {
            var total = coreUtils.getSeriesTotalByIndex(i);
            if (total === 0 && coreUtils.seriesHaveSameValues(i) && !coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {
              elLegend.classList.add('apexcharts-hidden-zero-series');
            }
          }
          if (!w.config.legend.showForNullSeries) {
            if (coreUtils.isSeriesNull(i) && w.globals.collapsedSeriesIndices.indexOf(i) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(i) === -1) {
              elLegend.classList.add('apexcharts-hidden-null-series');
            }
          }
          if (legendGroups.length) {
            w.globals.seriesGroups.forEach(function (group, gi) {
              var _w$config$series$i;
              if (group.includes((_w$config$series$i = w.config.series[i]) === null || _w$config$series$i === void 0 ? void 0 : _w$config$series$i.name)) {
                w.globals.dom.elLegendWrap.appendChild(legendGroups[gi]);
                legendGroups[gi].appendChild(elLegend);
              }
            });
          } else {
            w.globals.dom.elLegendWrap.appendChild(elLegend);
          }
          w.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(w.config.legend.horizontalAlign));
          w.globals.dom.elLegendWrap.classList.add('apx-legend-position-' + w.config.legend.position);
          elLegend.classList.add('apexcharts-legend-series');
          elLegend.style.margin = "".concat(w.config.legend.itemMargin.vertical, "px ").concat(w.config.legend.itemMargin.horizontal, "px");
          w.globals.dom.elLegendWrap.style.width = w.config.legend.width ? w.config.legend.width + 'px' : '';
          w.globals.dom.elLegendWrap.style.height = w.config.legend.height ? w.config.legend.height + 'px' : '';
          Graphics.setAttrs(elLegend, {
            rel: i + 1,
            seriesName: Utils$1.escapeString(legendNames[i]),
            'data:collapsed': collapsedSeries || ancillaryCollapsedSeries
          });
          if (collapsedSeries || ancillaryCollapsedSeries) {
            elLegend.classList.add('apexcharts-inactive-legend');
          }
          if (!w.config.legend.onItemClick.toggleDataSeries) {
            elLegend.classList.add('apexcharts-no-click');
          }
        };
        for (var i = isLegendInversed ? legendNames.length - 1 : 0; isLegendInversed ? i >= 0 : i <= legendNames.length - 1; isLegendInversed ? i-- : i++) {
          _loop(i);
        }
        w.globals.dom.elWrap.addEventListener('click', me.onLegendClick, true);
        if (w.config.legend.onItemHover.highlightDataSeries && w.config.legend.customLegendItems.length === 0) {
          w.globals.dom.elWrap.addEventListener('mousemove', me.onLegendHovered, true);
          w.globals.dom.elWrap.addEventListener('mouseout', me.onLegendHovered, true);
        }
      }
    }, {
      key: "setLegendWrapXY",
      value: function setLegendWrapXY(offsetX, offsetY) {
        var w = this.w;
        var elLegendWrap = w.globals.dom.elLegendWrap;
        var legendHeight = elLegendWrap.clientHeight;
        var x = 0;
        var y = 0;
        if (w.config.legend.position === 'bottom') {
          y = w.globals.svgHeight - Math.min(legendHeight, w.globals.svgHeight / 2) - 5;
        } else if (w.config.legend.position === 'top') {
          var dim = new Dimensions(this.ctx);
          var titleH = dim.dimHelpers.getTitleSubtitleCoords('title').height;
          var subtitleH = dim.dimHelpers.getTitleSubtitleCoords('subtitle').height;
          y = (titleH > 0 ? titleH - 10 : 0) + (subtitleH > 0 ? subtitleH - 10 : 0);
        }
        elLegendWrap.style.position = 'absolute';
        x = x + offsetX + w.config.legend.offsetX;
        y = y + offsetY + w.config.legend.offsetY;
        elLegendWrap.style.left = x + 'px';
        elLegendWrap.style.top = y + 'px';
        if (w.config.legend.position === 'right') {
          elLegendWrap.style.left = 'auto';
          elLegendWrap.style.right = 25 + w.config.legend.offsetX + 'px';
        }
        var fixedHeigthWidth = ['width', 'height'];
        fixedHeigthWidth.forEach(function (hw) {
          if (elLegendWrap.style[hw]) {
            elLegendWrap.style[hw] = parseInt(w.config.legend[hw], 10) + 'px';
          }
        });
      }
    }, {
      key: "legendAlignHorizontal",
      value: function legendAlignHorizontal() {
        var w = this.w;
        var elLegendWrap = w.globals.dom.elLegendWrap;
        elLegendWrap.style.right = 0;
        var dimensions = new Dimensions(this.ctx);
        var titleRect = dimensions.dimHelpers.getTitleSubtitleCoords('title');
        var subtitleRect = dimensions.dimHelpers.getTitleSubtitleCoords('subtitle');
        var offsetX = 20;
        var offsetY = 0;
        if (w.config.legend.position === 'top') {
          offsetY = titleRect.height + subtitleRect.height + w.config.title.margin + w.config.subtitle.margin - 10;
        }
        this.setLegendWrapXY(offsetX, offsetY);
      }
    }, {
      key: "legendAlignVertical",
      value: function legendAlignVertical() {
        var w = this.w;
        var lRect = this.legendHelpers.getLegendDimensions();
        var offsetY = 20;
        var offsetX = 0;
        if (w.config.legend.position === 'left') {
          offsetX = 20;
        }
        if (w.config.legend.position === 'right') {
          offsetX = w.globals.svgWidth - lRect.clww - 10;
        }
        this.setLegendWrapXY(offsetX, offsetY);
      }
    }, {
      key: "onLegendHovered",
      value: function onLegendHovered(e) {
        var w = this.w;
        var hoverOverLegend = e.target.classList.contains('apexcharts-legend-series') || e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker');
        if (w.config.chart.type !== 'heatmap' && !this.isBarsDistributed) {
          if (!e.target.classList.contains('apexcharts-inactive-legend') && hoverOverLegend) {
            var series = new Series(this.ctx);
            series.toggleSeriesOnHover(e, e.target);
          }
        } else {
          // for heatmap handling
          if (hoverOverLegend) {
            var seriesCnt = parseInt(e.target.getAttribute('rel'), 10) - 1;
            this.ctx.events.fireEvent('legendHover', [this.ctx, seriesCnt, this.w]);
            var _series = new Series(this.ctx);
            _series.highlightRangeInSeries(e, e.target);
          }
        }
      }
    }, {
      key: "onLegendClick",
      value: function onLegendClick(e) {
        var w = this.w;
        if (w.config.legend.customLegendItems.length) return;
        if (e.target.classList.contains('apexcharts-legend-series') || e.target.classList.contains('apexcharts-legend-text') || e.target.classList.contains('apexcharts-legend-marker')) {
          var seriesCnt = parseInt(e.target.getAttribute('rel'), 10) - 1;
          var isHidden = e.target.getAttribute('data:collapsed') === 'true';
          var legendClick = this.w.config.chart.events.legendClick;
          if (typeof legendClick === 'function') {
            legendClick(this.ctx, seriesCnt, this.w);
          }
          this.ctx.events.fireEvent('legendClick', [this.ctx, seriesCnt, this.w]);
          var markerClick = this.w.config.legend.markers.onClick;
          if (typeof markerClick === 'function' && e.target.classList.contains('apexcharts-legend-marker')) {
            markerClick(this.ctx, seriesCnt, this.w);
            this.ctx.events.fireEvent('legendMarkerClick', [this.ctx, seriesCnt, this.w]);
          }

          // for now - just prevent click on heatmap legend - and allow hover only
          var clickAllowed = w.config.chart.type !== 'treemap' && w.config.chart.type !== 'heatmap' && !this.isBarsDistributed;
          if (clickAllowed && w.config.legend.onItemClick.toggleDataSeries) {
            this.legendHelpers.toggleDataSeries(seriesCnt, isHidden);
          }
        }
      }
    }]);
    return Legend;
  }();

  var icoPan = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\">\n    <defs>\n        <path d=\"M0 0h24v24H0z\" id=\"a\"/>\n    </defs>\n    <clipPath id=\"b\">\n        <use overflow=\"visible\" xlink:href=\"#a\"/>\n    </clipPath>\n    <path clip-path=\"url(#b)\" d=\"M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z\"/>\n</svg>";

  var icoZoom = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\">\n    <path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\"/>\n    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n    <path d=\"M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z\"/>\n</svg>";

  var icoReset = "<svg fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z\"/>\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n</svg>";

  var icoZoomIn = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"/>\n</svg>\n";

  var icoZoomOut = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"/>\n</svg>\n";

  var icoSelect = "<svg fill=\"#6E8192\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z\"/>\n</svg>";

  var icoMenu = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path fill=\"none\" d=\"M0 0h24v24H0V0z\"/><path d=\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\"/></svg>";

  /**
   * ApexCharts Toolbar Class for creating toolbar in axis based charts.
   *
   * @module Toolbar
   **/
  var Toolbar = /*#__PURE__*/function () {
    function Toolbar(ctx) {
      _classCallCheck(this, Toolbar);
      this.ctx = ctx;
      this.w = ctx.w;
      var w = this.w;
      this.ev = this.w.config.chart.events;
      this.selectedClass = 'apexcharts-selected';
      this.localeValues = this.w.globals.locale.toolbar;
      this.minX = w.globals.minX;
      this.maxX = w.globals.maxX;
    }
    _createClass(Toolbar, [{
      key: "createToolbar",
      value: function createToolbar() {
        var _this = this;
        var w = this.w;
        var createDiv = function createDiv() {
          return document.createElement('div');
        };
        var elToolbarWrap = createDiv();
        elToolbarWrap.setAttribute('class', 'apexcharts-toolbar');
        elToolbarWrap.style.top = w.config.chart.toolbar.offsetY + 'px';
        elToolbarWrap.style.right = -w.config.chart.toolbar.offsetX + 3 + 'px';
        w.globals.dom.elWrap.appendChild(elToolbarWrap);
        this.elZoom = createDiv();
        this.elZoomIn = createDiv();
        this.elZoomOut = createDiv();
        this.elPan = createDiv();
        this.elSelection = createDiv();
        this.elZoomReset = createDiv();
        this.elMenuIcon = createDiv();
        this.elMenu = createDiv();
        this.elCustomIcons = [];
        this.t = w.config.chart.toolbar.tools;
        if (Array.isArray(this.t.customIcons)) {
          for (var i = 0; i < this.t.customIcons.length; i++) {
            this.elCustomIcons.push(createDiv());
          }
        }
        var toolbarControls = [];
        var appendZoomControl = function appendZoomControl(type, el, ico) {
          var tool = type.toLowerCase();
          if (_this.t[tool] && w.config.chart.zoom.enabled) {
            toolbarControls.push({
              el: el,
              icon: typeof _this.t[tool] === 'string' ? _this.t[tool] : ico,
              title: _this.localeValues[type],
              class: "apexcharts-".concat(tool, "-icon")
            });
          }
        };
        appendZoomControl('zoomIn', this.elZoomIn, icoZoomIn);
        appendZoomControl('zoomOut', this.elZoomOut, icoZoomOut);
        var zoomSelectionCtrls = function zoomSelectionCtrls(z) {
          if (_this.t[z] && w.config.chart[z].enabled) {
            toolbarControls.push({
              el: z === 'zoom' ? _this.elZoom : _this.elSelection,
              icon: typeof _this.t[z] === 'string' ? _this.t[z] : z === 'zoom' ? icoZoom : icoSelect,
              title: _this.localeValues[z === 'zoom' ? 'selectionZoom' : 'selection'],
              class: "apexcharts-".concat(z, "-icon")
            });
          }
        };
        zoomSelectionCtrls('zoom');
        zoomSelectionCtrls('selection');
        if (this.t.pan && w.config.chart.zoom.enabled) {
          toolbarControls.push({
            el: this.elPan,
            icon: typeof this.t.pan === 'string' ? this.t.pan : icoPan,
            title: this.localeValues.pan,
            class: 'apexcharts-pan-icon'
          });
        }
        appendZoomControl('reset', this.elZoomReset, icoReset);
        if (this.t.download) {
          toolbarControls.push({
            el: this.elMenuIcon,
            icon: typeof this.t.download === 'string' ? this.t.download : icoMenu,
            title: this.localeValues.menu,
            class: 'apexcharts-menu-icon'
          });
        }
        for (var _i = 0; _i < this.elCustomIcons.length; _i++) {
          toolbarControls.push({
            el: this.elCustomIcons[_i],
            icon: this.t.customIcons[_i].icon,
            title: this.t.customIcons[_i].title,
            index: this.t.customIcons[_i].index,
            class: 'apexcharts-toolbar-custom-icon ' + this.t.customIcons[_i].class
          });
        }
        toolbarControls.forEach(function (t, index) {
          if (t.index) {
            Utils$1.moveIndexInArray(toolbarControls, index, t.index);
          }
        });
        for (var _i2 = 0; _i2 < toolbarControls.length; _i2++) {
          Graphics.setAttrs(toolbarControls[_i2].el, {
            class: toolbarControls[_i2].class,
            title: toolbarControls[_i2].title
          });
          toolbarControls[_i2].el.innerHTML = toolbarControls[_i2].icon;
          elToolbarWrap.appendChild(toolbarControls[_i2].el);
        }
        this._createHamburgerMenu(elToolbarWrap);
        if (w.globals.zoomEnabled) {
          this.elZoom.classList.add(this.selectedClass);
        } else if (w.globals.panEnabled) {
          this.elPan.classList.add(this.selectedClass);
        } else if (w.globals.selectionEnabled) {
          this.elSelection.classList.add(this.selectedClass);
        }
        this.addToolbarEventListeners();
      }
    }, {
      key: "_createHamburgerMenu",
      value: function _createHamburgerMenu(parent) {
        this.elMenuItems = [];
        parent.appendChild(this.elMenu);
        Graphics.setAttrs(this.elMenu, {
          class: 'apexcharts-menu'
        });
        var menuItems = [{
          name: 'exportSVG',
          title: this.localeValues.exportToSVG
        }, {
          name: 'exportPNG',
          title: this.localeValues.exportToPNG
        }, {
          name: 'exportCSV',
          title: this.localeValues.exportToCSV
        }, {
          name: 'exportXLS',
          title: this.localeValues.exportToXLS
        }];
        for (var i = 0; i < menuItems.length; i++) {
          this.elMenuItems.push(document.createElement('div'));
          this.elMenuItems[i].innerHTML = menuItems[i].title;
          Graphics.setAttrs(this.elMenuItems[i], {
            class: "apexcharts-menu-item ".concat(menuItems[i].name),
            title: menuItems[i].title
          });
          this.elMenu.appendChild(this.elMenuItems[i]);
        }
      }
    }, {
      key: "addToolbarEventListeners",
      value: function addToolbarEventListeners() {
        var _this2 = this;
        this.elZoomReset.addEventListener('click', this.handleZoomReset.bind(this));
        this.elSelection.addEventListener('click', this.toggleZoomSelection.bind(this, 'selection'));
        this.elZoom.addEventListener('click', this.toggleZoomSelection.bind(this, 'zoom'));
        this.elZoomIn.addEventListener('click', this.handleZoomIn.bind(this));
        this.elZoomOut.addEventListener('click', this.handleZoomOut.bind(this));
        this.elPan.addEventListener('click', this.togglePanning.bind(this));
        this.elMenuIcon.addEventListener('click', this.toggleMenu.bind(this));
        this.elMenuItems.forEach(function (m) {
          if (m.classList.contains('exportSVG')) {
            m.addEventListener('click', _this2.handleDownload.bind(_this2, 'svg'));
          } else if (m.classList.contains('exportPNG')) {
            m.addEventListener('click', _this2.handleDownload.bind(_this2, 'png'));
          } else if (m.classList.contains('exportCSV')) {
            m.addEventListener('click', _this2.handleDownload.bind(_this2, 'csv'));
          } else if (m.classList.contains('exportXLS')) {
            m.addEventListener('click', _this2.handleDownload.bind(_this2, 'xls'));
          }
        });
        for (var i = 0; i < this.t.customIcons.length; i++) {
          this.elCustomIcons[i].addEventListener('click', this.t.customIcons[i].click.bind(this, this.ctx, this.ctx.w));
        }
      }
    }, {
      key: "toggleZoomSelection",
      value: function toggleZoomSelection(type) {
        var charts = this.ctx.getSyncedCharts();
        charts.forEach(function (ch) {
          ch.ctx.toolbar.toggleOtherControls();
          var el = type === 'selection' ? ch.ctx.toolbar.elSelection : ch.ctx.toolbar.elZoom;
          var enabledType = type === 'selection' ? 'selectionEnabled' : 'zoomEnabled';
          ch.w.globals[enabledType] = !ch.w.globals[enabledType];
          if (!el.classList.contains(ch.ctx.toolbar.selectedClass)) {
            el.classList.add(ch.ctx.toolbar.selectedClass);
          } else {
            el.classList.remove(ch.ctx.toolbar.selectedClass);
          }
        });
      }
    }, {
      key: "getToolbarIconsReference",
      value: function getToolbarIconsReference() {
        var w = this.w;
        if (!this.elZoom) {
          this.elZoom = w.globals.dom.baseEl.querySelector('.apexcharts-zoom-icon');
        }
        if (!this.elPan) {
          this.elPan = w.globals.dom.baseEl.querySelector('.apexcharts-pan-icon');
        }
        if (!this.elSelection) {
          this.elSelection = w.globals.dom.baseEl.querySelector('.apexcharts-selection-icon');
        }
      }
    }, {
      key: "enableZoomPanFromToolbar",
      value: function enableZoomPanFromToolbar(type) {
        this.toggleOtherControls();
        type === 'pan' ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
        var el = type === 'pan' ? this.elPan : this.elZoom;
        var el2 = type === 'pan' ? this.elZoom : this.elPan;
        if (el) {
          el.classList.add(this.selectedClass);
        }
        if (el2) {
          el2.classList.remove(this.selectedClass);
        }
      }
    }, {
      key: "togglePanning",
      value: function togglePanning() {
        var charts = this.ctx.getSyncedCharts();
        charts.forEach(function (ch) {
          ch.ctx.toolbar.toggleOtherControls();
          ch.w.globals.panEnabled = !ch.w.globals.panEnabled;
          if (!ch.ctx.toolbar.elPan.classList.contains(ch.ctx.toolbar.selectedClass)) {
            ch.ctx.toolbar.elPan.classList.add(ch.ctx.toolbar.selectedClass);
          } else {
            ch.ctx.toolbar.elPan.classList.remove(ch.ctx.toolbar.selectedClass);
          }
        });
      }
    }, {
      key: "toggleOtherControls",
      value: function toggleOtherControls() {
        var _this3 = this;
        var w = this.w;
        w.globals.panEnabled = false;
        w.globals.zoomEnabled = false;
        w.globals.selectionEnabled = false;
        this.getToolbarIconsReference();
        var toggleEls = [this.elPan, this.elSelection, this.elZoom];
        toggleEls.forEach(function (el) {
          if (el) {
            el.classList.remove(_this3.selectedClass);
          }
        });
      }
    }, {
      key: "handleZoomIn",
      value: function handleZoomIn() {
        var w = this.w;
        if (w.globals.isRangeBar) {
          this.minX = w.globals.minY;
          this.maxX = w.globals.maxY;
        }
        var centerX = (this.minX + this.maxX) / 2;
        var newMinX = (this.minX + centerX) / 2;
        var newMaxX = (this.maxX + centerX) / 2;
        var newMinXMaxX = this._getNewMinXMaxX(newMinX, newMaxX);
        if (!w.globals.disableZoomIn) {
          this.zoomUpdateOptions(newMinXMaxX.minX, newMinXMaxX.maxX);
        }
      }
    }, {
      key: "handleZoomOut",
      value: function handleZoomOut() {
        var w = this.w;
        if (w.globals.isRangeBar) {
          this.minX = w.globals.minY;
          this.maxX = w.globals.maxY;
        }

        // avoid zooming out beyond 1000 which may result in NaN values being printed on x-axis
        if (w.config.xaxis.type === 'datetime' && new Date(this.minX).getUTCFullYear() < 1000) {
          return;
        }
        var centerX = (this.minX + this.maxX) / 2;
        var newMinX = this.minX - (centerX - this.minX);
        var newMaxX = this.maxX - (centerX - this.maxX);
        var newMinXMaxX = this._getNewMinXMaxX(newMinX, newMaxX);
        if (!w.globals.disableZoomOut) {
          this.zoomUpdateOptions(newMinXMaxX.minX, newMinXMaxX.maxX);
        }
      }
    }, {
      key: "_getNewMinXMaxX",
      value: function _getNewMinXMaxX(newMinX, newMaxX) {
        var shouldFloor = this.w.config.xaxis.convertedCatToNumeric;
        return {
          minX: shouldFloor ? Math.floor(newMinX) : newMinX,
          maxX: shouldFloor ? Math.floor(newMaxX) : newMaxX
        };
      }
    }, {
      key: "zoomUpdateOptions",
      value: function zoomUpdateOptions(newMinX, newMaxX) {
        var w = this.w;
        if (newMinX === undefined && newMaxX === undefined) {
          this.handleZoomReset();
          return;
        }
        if (w.config.xaxis.convertedCatToNumeric) {
          // in category charts, avoid zooming out beyond min and max
          if (newMinX < 1) {
            newMinX = 1;
            newMaxX = w.globals.dataPoints;
          }
          if (newMaxX - newMinX < 2) {
            return;
          }
        }
        var xaxis = {
          min: newMinX,
          max: newMaxX
        };
        var beforeZoomRange = this.getBeforeZoomRange(xaxis);
        if (beforeZoomRange) {
          xaxis = beforeZoomRange.xaxis;
        }
        var options = {
          xaxis: xaxis
        };
        var yaxis = Utils$1.clone(w.globals.initialConfig.yaxis);
        if (!w.config.chart.group) {
          // if chart in a group, prevent yaxis update here
          // fix issue #650
          options.yaxis = yaxis;
        }
        this.w.globals.zoomed = true;
        this.ctx.updateHelpers._updateOptions(options, false, this.w.config.chart.animations.dynamicAnimation.enabled);
        this.zoomCallback(xaxis, yaxis);
      }
    }, {
      key: "zoomCallback",
      value: function zoomCallback(xaxis, yaxis) {
        if (typeof this.ev.zoomed === 'function') {
          this.ev.zoomed(this.ctx, {
            xaxis: xaxis,
            yaxis: yaxis
          });
          this.ctx.events.fireEvent('zoomed', {
            xaxis: xaxis,
            yaxis: yaxis
          });
        }
      }
    }, {
      key: "getBeforeZoomRange",
      value: function getBeforeZoomRange(xaxis, yaxis) {
        var newRange = null;
        if (typeof this.ev.beforeZoom === 'function') {
          newRange = this.ev.beforeZoom(this, {
            xaxis: xaxis,
            yaxis: yaxis
          });
        }
        return newRange;
      }
    }, {
      key: "toggleMenu",
      value: function toggleMenu() {
        var _this4 = this;
        window.setTimeout(function () {
          if (_this4.elMenu.classList.contains('apexcharts-menu-open')) {
            _this4.elMenu.classList.remove('apexcharts-menu-open');
          } else {
            _this4.elMenu.classList.add('apexcharts-menu-open');
          }
        }, 0);
      }
    }, {
      key: "handleDownload",
      value: function handleDownload(type) {
        var w = this.w;
        var exprt = new Exports(this.ctx);
        switch (type) {
          case 'svg':
            exprt.exportToSVG(this.ctx);
            break;
          case 'png':
            exprt.exportToPng(this.ctx);
            break;
          case 'csv':
            exprt.exportToCSV({
              series: w.config.series,
              columnDelimiter: w.config.chart.toolbar.export.csv.columnDelimiter
            });
            break;
          case 'xls':
            exprt.exportToXLS({
              series: w.config.series
            });
            break;
        }
      }
    }, {
      key: "handleZoomReset",
      value: function handleZoomReset(e) {
        var charts = this.ctx.getSyncedCharts();
        charts.forEach(function (ch) {
          var w = ch.w;

          // forget lastXAxis min/max as reset button isn't resetting the x-axis completely if zoomX is called before
          w.globals.lastXAxis.min = w.globals.initialConfig.xaxis.min;
          w.globals.lastXAxis.max = w.globals.initialConfig.xaxis.max;
          ch.updateHelpers.revertDefaultAxisMinMax();
          if (typeof w.config.chart.events.beforeResetZoom === 'function') {
            // here, user get an option to control xaxis and yaxis when resetZoom is called
            // at this point, whatever is returned from w.config.chart.events.beforeResetZoom
            // is set as the new xaxis/yaxis min/max
            var resetZoomRange = w.config.chart.events.beforeResetZoom(ch, w);
            if (resetZoomRange) {
              ch.updateHelpers.revertDefaultAxisMinMax(resetZoomRange);
            }
          }
          if (typeof w.config.chart.events.zoomed === 'function') {
            ch.ctx.toolbar.zoomCallback({
              min: w.config.xaxis.min,
              max: w.config.xaxis.max
            });
          }
          w.globals.zoomed = false;

          // if user has some series collapsed before hitting zoom reset button,
          // those series should stay collapsed
          var series = ch.ctx.series.emptyCollapsedSeries(Utils$1.clone(w.globals.initialSeries));
          ch.updateHelpers._updateSeries(series, w.config.chart.animations.dynamicAnimation.enabled);
        });
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.elZoom = null;
        this.elZoomIn = null;
        this.elZoomOut = null;
        this.elPan = null;
        this.elSelection = null;
        this.elZoomReset = null;
        this.elMenuIcon = null;
      }
    }]);
    return Toolbar;
  }();

  /**
   * ApexCharts Zoom Class for handling zooming and panning on axes based charts.
   *
   * @module ZoomPanSelection
   **/
  var ZoomPanSelection = /*#__PURE__*/function (_Toolbar) {
    _inherits(ZoomPanSelection, _Toolbar);
    var _super = _createSuper(ZoomPanSelection);
    function ZoomPanSelection(ctx) {
      var _this;
      _classCallCheck(this, ZoomPanSelection);
      _this = _super.call(this, ctx);
      _this.ctx = ctx;
      _this.w = ctx.w;
      _this.dragged = false;
      _this.graphics = new Graphics(_this.ctx);
      _this.eventList = ['mousedown', 'mouseleave', 'mousemove', 'touchstart', 'touchmove', 'mouseup', 'touchend', 'wheel'];
      _this.clientX = 0;
      _this.clientY = 0;
      _this.startX = 0;
      _this.endX = 0;
      _this.dragX = 0;
      _this.startY = 0;
      _this.endY = 0;
      _this.dragY = 0;
      _this.moveDirection = 'none';
      _this.debounceTimer = null;
      _this.debounceDelay = 100;
      _this.wheelDelay = 400;
      return _this;
    }
    _createClass(ZoomPanSelection, [{
      key: "init",
      value: function init(_ref) {
        var _this2 = this;
        var xyRatios = _ref.xyRatios;
        var w = this.w;
        var me = this;
        this.xyRatios = xyRatios;
        this.zoomRect = this.graphics.drawRect(0, 0, 0, 0);
        this.selectionRect = this.graphics.drawRect(0, 0, 0, 0);
        this.gridRect = w.globals.dom.baseEl.querySelector('.apexcharts-grid');
        this.constraints = new Box(0, 0, w.globals.gridWidth, w.globals.gridHeight);
        this.zoomRect.node.classList.add('apexcharts-zoom-rect');
        this.selectionRect.node.classList.add('apexcharts-selection-rect');
        w.globals.dom.Paper.add(this.zoomRect);
        w.globals.dom.Paper.add(this.selectionRect);
        if (w.config.chart.selection.type === 'x') {
          this.slDraggableRect = this.selectionRect.draggable({
            minX: 0,
            minY: 0,
            maxX: w.globals.gridWidth,
            maxY: w.globals.gridHeight
          }).on('dragmove.namespace', this.selectionDragging.bind(this, 'dragging'));
        } else if (w.config.chart.selection.type === 'y') {
          this.slDraggableRect = this.selectionRect.draggable({
            minX: 0,
            maxX: w.globals.gridWidth
          }).on('dragmove.namespace', this.selectionDragging.bind(this, 'dragging'));
        } else {
          this.slDraggableRect = this.selectionRect.draggable().on('dragmove.namespace', this.selectionDragging.bind(this, 'dragging'));
        }
        this.preselectedSelection();
        this.hoverArea = w.globals.dom.baseEl.querySelector("".concat(w.globals.chartClass, " .apexcharts-svg"));
        this.hoverArea.classList.add('apexcharts-zoomable');
        this.eventList.forEach(function (event) {
          _this2.hoverArea.addEventListener(event, me.svgMouseEvents.bind(me, xyRatios), {
            capture: false,
            passive: true
          });
        });
        if (w.config.chart.zoom.enabled && w.config.chart.zoom.allowMouseWheelZoom) {
          this.hoverArea.addEventListener('wheel', me.mouseWheelEvent.bind(me), {
            capture: false,
            passive: false
          });
        }
      }

      // remove the event listeners which were previously added on hover area
    }, {
      key: "destroy",
      value: function destroy() {
        if (this.slDraggableRect) {
          this.slDraggableRect.draggable(false);
          this.slDraggableRect.off();
          this.selectionRect.off();
        }
        this.selectionRect = null;
        this.zoomRect = null;
        this.gridRect = null;
      }
    }, {
      key: "svgMouseEvents",
      value: function svgMouseEvents(xyRatios, e) {
        var w = this.w;
        var toolbar = this.ctx.toolbar;
        var zoomtype = w.globals.zoomEnabled ? w.config.chart.zoom.type : w.config.chart.selection.type;
        var autoSelected = w.config.chart.toolbar.autoSelected;
        if (e.shiftKey) {
          this.shiftWasPressed = true;
          toolbar.enableZoomPanFromToolbar(autoSelected === 'pan' ? 'zoom' : 'pan');
        } else {
          if (this.shiftWasPressed) {
            toolbar.enableZoomPanFromToolbar(autoSelected);
            this.shiftWasPressed = false;
          }
        }
        if (!e.target) return;
        var tc = e.target.classList;
        var pc;
        if (e.target.parentNode && e.target.parentNode !== null) {
          pc = e.target.parentNode.classList;
        }
        var falsePositives = tc.contains('apexcharts-legend-marker') || tc.contains('apexcharts-legend-text') || pc && pc.contains('apexcharts-toolbar');
        if (falsePositives) return;
        this.clientX = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientX : e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
        this.clientY = e.type === 'touchmove' || e.type === 'touchstart' ? e.touches[0].clientY : e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;
        if (e.type === 'mousedown' && e.which === 1 || e.type === 'touchstart') {
          var gridRectDim = this.gridRect.getBoundingClientRect();
          this.startX = this.clientX - gridRectDim.left - w.globals.barPadForNumericAxis;
          this.startY = this.clientY - gridRectDim.top;
          this.dragged = false;
          this.w.globals.mousedown = true;
        }
        if (e.type === 'mousemove' && e.which === 1 || e.type === 'touchmove') {
          this.dragged = true;
          if (w.globals.panEnabled) {
            w.globals.selection = null;
            if (this.w.globals.mousedown) {
              this.panDragging({
                context: this,
                zoomtype: zoomtype,
                xyRatios: xyRatios
              });
            }
          } else {
            if (this.w.globals.mousedown && w.globals.zoomEnabled || this.w.globals.mousedown && w.globals.selectionEnabled) {
              this.selection = this.selectionDrawing({
                context: this,
                zoomtype: zoomtype
              });
            }
          }
        }
        if (e.type === 'mouseup' || e.type === 'touchend' || e.type === 'mouseleave') {
          this.handleMouseUp({
            zoomtype: zoomtype
          });
        }
        this.makeSelectionRectDraggable();
      }
    }, {
      key: "handleMouseUp",
      value: function handleMouseUp(_ref2) {
        var _this$gridRect;
        var zoomtype = _ref2.zoomtype,
          isResized = _ref2.isResized;
        var w = this.w;
        // we will be calling getBoundingClientRect on each mousedown/mousemove/mouseup
        var gridRectDim = (_this$gridRect = this.gridRect) === null || _this$gridRect === void 0 ? void 0 : _this$gridRect.getBoundingClientRect();
        if (gridRectDim && (this.w.globals.mousedown || isResized)) {
          // user released the drag, now do all the calculations
          this.endX = this.clientX - gridRectDim.left - w.globals.barPadForNumericAxis;
          this.endY = this.clientY - gridRectDim.top;
          this.dragX = Math.abs(this.endX - this.startX);
          this.dragY = Math.abs(this.endY - this.startY);
          if (w.globals.zoomEnabled || w.globals.selectionEnabled) {
            this.selectionDrawn({
              context: this,
              zoomtype: zoomtype
            });
          }

          // if (w.globals.panEnabled && w.config.xaxis.convertedCatToNumeric) {
          //   this.delayedPanScrolled()
          // }
        }
        if (w.globals.zoomEnabled) {
          this.hideSelectionRect(this.selectionRect);
        }
        this.dragged = false;
        this.w.globals.mousedown = false;
      }
    }, {
      key: "mouseWheelEvent",
      value: function mouseWheelEvent(e) {
        var _this3 = this;
        var w = this.w;
        e.preventDefault();
        var now = Date.now();

        // Execute immediately if it's the first action or enough time has passed
        if (now - w.globals.lastWheelExecution > this.wheelDelay) {
          this.executeMouseWheelZoom(e);
          w.globals.lastWheelExecution = now;
        }
        if (this.debounceTimer) clearTimeout(this.debounceTimer);
        this.debounceTimer = setTimeout(function () {
          if (now - w.globals.lastWheelExecution > _this3.wheelDelay) {
            _this3.executeMouseWheelZoom(e);
            w.globals.lastWheelExecution = now;
          }
        }, this.debounceDelay);
      }
    }, {
      key: "executeMouseWheelZoom",
      value: function executeMouseWheelZoom(e) {
        var _this$gridRect2;
        var w = this.w;
        this.minX = w.globals.isRangeBar ? w.globals.minY : w.globals.minX;
        this.maxX = w.globals.isRangeBar ? w.globals.maxY : w.globals.maxX;

        // Calculate the relative position of the mouse on the chart
        var gridRectDim = (_this$gridRect2 = this.gridRect) === null || _this$gridRect2 === void 0 ? void 0 : _this$gridRect2.getBoundingClientRect();
        if (!gridRectDim) return;
        var mouseX = (e.clientX - gridRectDim.left) / gridRectDim.width;
        var currentMinX = this.minX;
        var currentMaxX = this.maxX;
        var totalX = currentMaxX - currentMinX;

        // Determine zoom factor
        var zoomFactorIn = 0.5;
        var zoomFactorOut = 1.5;
        var zoomRange;
        var newMinX, newMaxX;
        if (e.deltaY < 0) {
          // Zoom In
          zoomRange = zoomFactorIn * totalX;
          var midPoint = currentMinX + mouseX * totalX;
          newMinX = midPoint - zoomRange / 2;
          newMaxX = midPoint + zoomRange / 2;
        } else {
          // Zoom Out
          zoomRange = zoomFactorOut * totalX;
          newMinX = currentMinX - zoomRange / 2;
          newMaxX = currentMaxX + zoomRange / 2;
        }

        // Constrain within original chart bounds
        if (!w.globals.isRangeBar) {
          newMinX = Math.max(newMinX, w.globals.initialMinX);
          newMaxX = Math.min(newMaxX, w.globals.initialMaxX);

          // Ensure minimum range
          var minRange = (w.globals.initialMaxX - w.globals.initialMinX) * 0.01;
          if (newMaxX - newMinX < minRange) {
            var _midPoint = (newMinX + newMaxX) / 2;
            newMinX = _midPoint - minRange / 2;
            newMaxX = _midPoint + minRange / 2;
          }
        }
        var newMinXMaxX = this._getNewMinXMaxX(newMinX, newMaxX);

        // Apply zoom if valid
        if (!isNaN(newMinXMaxX.minX) && !isNaN(newMinXMaxX.maxX)) {
          this.zoomUpdateOptions(newMinXMaxX.minX, newMinXMaxX.maxX);
        }
      }
    }, {
      key: "makeSelectionRectDraggable",
      value: function makeSelectionRectDraggable() {
        var _this4 = this;
        var w = this.w;
        if (!this.selectionRect) return;
        var rectDim = this.selectionRect.node.getBoundingClientRect();
        if (rectDim.width > 0 && rectDim.height > 0) {
          this.selectionRect.select(false).resize(false);
          this.selectionRect.select({
            createRot: function createRot() {},
            updateRot: function updateRot() {},
            createHandle: function createHandle(group, p, index, pointArr, handleName) {
              if (handleName === 'l' || handleName === 'r') return group.circle(8).css({
                'stroke-width': 1,
                stroke: '#333',
                fill: '#fff'
              });
              return group.circle(0);
            },
            updateHandle: function updateHandle(group, p) {
              return group.center(p[0], p[1]);
            }
          }).resize().on('resize', function () {
            var zoomtype = w.globals.zoomEnabled ? w.config.chart.zoom.type : w.config.chart.selection.type;
            _this4.handleMouseUp({
              zoomtype: zoomtype,
              isResized: true
            });
          });
        }
      }
    }, {
      key: "preselectedSelection",
      value: function preselectedSelection() {
        var w = this.w;
        var xyRatios = this.xyRatios;
        if (!w.globals.zoomEnabled) {
          if (typeof w.globals.selection !== 'undefined' && w.globals.selection !== null) {
            this.drawSelectionRect(_objectSpread2(_objectSpread2({}, w.globals.selection), {}, {
              translateX: w.globals.translateX,
              translateY: w.globals.translateY
            }));
          } else {
            if (w.config.chart.selection.xaxis.min !== undefined && w.config.chart.selection.xaxis.max !== undefined) {
              var x = (w.config.chart.selection.xaxis.min - w.globals.minX) / xyRatios.xRatio;
              var width = w.globals.gridWidth - (w.globals.maxX - w.config.chart.selection.xaxis.max) / xyRatios.xRatio - x;
              if (w.globals.isRangeBar) {
                // rangebars put datetime data in y axis
                x = (w.config.chart.selection.xaxis.min - w.globals.yAxisScale[0].niceMin) / xyRatios.invertedYRatio;
                width = (w.config.chart.selection.xaxis.max - w.config.chart.selection.xaxis.min) / xyRatios.invertedYRatio;
              }
              var selectionRect = {
                x: x,
                y: 0,
                width: width,
                height: w.globals.gridHeight,
                translateX: w.globals.translateX,
                translateY: w.globals.translateY,
                selectionEnabled: true
              };
              this.drawSelectionRect(selectionRect);
              this.makeSelectionRectDraggable();
              if (typeof w.config.chart.events.selection === 'function') {
                w.config.chart.events.selection(this.ctx, {
                  xaxis: {
                    min: w.config.chart.selection.xaxis.min,
                    max: w.config.chart.selection.xaxis.max
                  },
                  yaxis: {}
                });
              }
            }
          }
        }
      }
    }, {
      key: "drawSelectionRect",
      value: function drawSelectionRect(_ref3) {
        var x = _ref3.x,
          y = _ref3.y,
          width = _ref3.width,
          height = _ref3.height,
          _ref3$translateX = _ref3.translateX,
          translateX = _ref3$translateX === void 0 ? 0 : _ref3$translateX,
          _ref3$translateY = _ref3.translateY,
          translateY = _ref3$translateY === void 0 ? 0 : _ref3$translateY;
        var w = this.w;
        var zoomRect = this.zoomRect;
        var selectionRect = this.selectionRect;
        if (this.dragged || w.globals.selection !== null) {
          var scalingAttrs = {
            transform: 'translate(' + translateX + ', ' + translateY + ')'
          };

          // change styles based on zoom or selection
          // zoom is Enabled and user has dragged, so draw blue rect
          if (w.globals.zoomEnabled && this.dragged) {
            if (width < 0) width = 1; // fixes apexcharts.js#1168
            zoomRect.attr({
              x: x,
              y: y,
              width: width,
              height: height,
              fill: w.config.chart.zoom.zoomedArea.fill.color,
              'fill-opacity': w.config.chart.zoom.zoomedArea.fill.opacity,
              stroke: w.config.chart.zoom.zoomedArea.stroke.color,
              'stroke-width': w.config.chart.zoom.zoomedArea.stroke.width,
              'stroke-opacity': w.config.chart.zoom.zoomedArea.stroke.opacity
            });
            Graphics.setAttrs(zoomRect.node, scalingAttrs);
          }

          // selection is enabled
          if (w.globals.selectionEnabled) {
            selectionRect.attr({
              x: x,
              y: y,
              width: width > 0 ? width : 0,
              height: height > 0 ? height : 0,
              fill: w.config.chart.selection.fill.color,
              'fill-opacity': w.config.chart.selection.fill.opacity,
              stroke: w.config.chart.selection.stroke.color,
              'stroke-width': w.config.chart.selection.stroke.width,
              'stroke-dasharray': w.config.chart.selection.stroke.dashArray,
              'stroke-opacity': w.config.chart.selection.stroke.opacity
            });
            Graphics.setAttrs(selectionRect.node, scalingAttrs);
          }
        }
      }
    }, {
      key: "hideSelectionRect",
      value: function hideSelectionRect(rect) {
        if (rect) {
          rect.attr({
            x: 0,
            y: 0,
            width: 0,
            height: 0
          });
        }
      }
    }, {
      key: "selectionDrawing",
      value: function selectionDrawing(_ref4) {
        var context = _ref4.context,
          zoomtype = _ref4.zoomtype;
        var w = this.w;
        var me = context;
        var gridRectDim = this.gridRect.getBoundingClientRect();
        var startX = me.startX - 1;
        var startY = me.startY;
        var inversedX = false;
        var inversedY = false;
        var left = me.clientX - gridRectDim.left - w.globals.barPadForNumericAxis;
        var top = me.clientY - gridRectDim.top;
        var selectionWidth = left - startX;
        var selectionHeight = top - startY;
        var selectionRect = {
          translateX: w.globals.translateX,
          translateY: w.globals.translateY
        };
        if (Math.abs(selectionWidth + startX) > w.globals.gridWidth) {
          // user dragged the mouse outside drawing area to the right
          selectionWidth = w.globals.gridWidth - startX;
        } else if (left < 0) {
          // user dragged the mouse outside drawing area to the left
          selectionWidth = startX;
        }

        // inverse selection X
        if (startX > left) {
          inversedX = true;
          selectionWidth = Math.abs(selectionWidth);
        }

        // inverse selection Y
        if (startY > top) {
          inversedY = true;
          selectionHeight = Math.abs(selectionHeight);
        }
        if (zoomtype === 'x') {
          selectionRect = {
            x: inversedX ? startX - selectionWidth : startX,
            y: 0,
            width: selectionWidth,
            height: w.globals.gridHeight
          };
        } else if (zoomtype === 'y') {
          selectionRect = {
            x: 0,
            y: inversedY ? startY - selectionHeight : startY,
            width: w.globals.gridWidth,
            height: selectionHeight
          };
        } else {
          selectionRect = {
            x: inversedX ? startX - selectionWidth : startX,
            y: inversedY ? startY - selectionHeight : startY,
            width: selectionWidth,
            height: selectionHeight
          };
        }
        selectionRect = _objectSpread2(_objectSpread2({}, selectionRect), {}, {
          translateX: w.globals.translateX,
          translateY: w.globals.translateY
        });
        me.drawSelectionRect(selectionRect);
        me.selectionDragging('resizing');
        return selectionRect;
      }
    }, {
      key: "selectionDragging",
      value: function selectionDragging(type, e) {
        var _this5 = this;
        var w = this.w;
        if (!e) return;
        e.preventDefault();
        var _e$detail = e.detail,
          handler = _e$detail.handler,
          box = _e$detail.box;
        var x = box.x,
          y = box.y;
        if (x < this.constraints.x) {
          x = this.constraints.x;
        }
        if (y < this.constraints.y) {
          y = this.constraints.y;
        }
        if (box.x2 > this.constraints.x2) {
          x = this.constraints.x2 - box.w;
        }
        if (box.y2 > this.constraints.y2) {
          y = this.constraints.y2 - box.h;
        }
        handler.move(x, y);
        var xyRatios = this.xyRatios;
        var selRect = this.selectionRect;
        var timerInterval = 0;
        if (type === 'resizing') {
          timerInterval = 30;
        }

        // update selection when selection rect is dragged
        var getSelAttr = function getSelAttr(attr) {
          return parseFloat(selRect.node.getAttribute(attr));
        };
        var draggedProps = {
          x: getSelAttr('x'),
          y: getSelAttr('y'),
          width: getSelAttr('width'),
          height: getSelAttr('height')
        };
        w.globals.selection = draggedProps;
        // update selection ends

        if (typeof w.config.chart.events.selection === 'function' && w.globals.selectionEnabled) {
          // a small debouncer is required when resizing to avoid freezing the chart
          clearTimeout(this.w.globals.selectionResizeTimer);
          this.w.globals.selectionResizeTimer = window.setTimeout(function () {
            var gridRectDim = _this5.gridRect.getBoundingClientRect();
            var selectionRect = selRect.node.getBoundingClientRect();
            var minX, maxX, minY, maxY;
            if (!w.globals.isRangeBar) {
              // normal XY charts
              minX = w.globals.xAxisScale.niceMin + (selectionRect.left - gridRectDim.left) * xyRatios.xRatio;
              maxX = w.globals.xAxisScale.niceMin + (selectionRect.right - gridRectDim.left) * xyRatios.xRatio;
              minY = w.globals.yAxisScale[0].niceMin + (gridRectDim.bottom - selectionRect.bottom) * xyRatios.yRatio[0];
              maxY = w.globals.yAxisScale[0].niceMax - (selectionRect.top - gridRectDim.top) * xyRatios.yRatio[0];
            } else {
              // rangeBars use y for datetime
              minX = w.globals.yAxisScale[0].niceMin + (selectionRect.left - gridRectDim.left) * xyRatios.invertedYRatio;
              maxX = w.globals.yAxisScale[0].niceMin + (selectionRect.right - gridRectDim.left) * xyRatios.invertedYRatio;
              minY = 0;
              maxY = 1;
            }
            var xyAxis = {
              xaxis: {
                min: minX,
                max: maxX
              },
              yaxis: {
                min: minY,
                max: maxY
              }
            };
            w.config.chart.events.selection(_this5.ctx, xyAxis);
            if (w.config.chart.brush.enabled && w.config.chart.events.brushScrolled !== undefined) {
              w.config.chart.events.brushScrolled(_this5.ctx, xyAxis);
            }
          }, timerInterval);
        }
      }
    }, {
      key: "selectionDrawn",
      value: function selectionDrawn(_ref5) {
        var context = _ref5.context,
          zoomtype = _ref5.zoomtype;
        var w = this.w;
        var me = context;
        var xyRatios = this.xyRatios;
        var toolbar = this.ctx.toolbar;

        // Use boundingRect for final selection area
        var selRect = w.globals.zoomEnabled ? me.zoomRect.node.getBoundingClientRect() : me.selectionRect.node.getBoundingClientRect();
        var gridRectDim = me.gridRect.getBoundingClientRect();

        // Local coords in the chart's grid
        var localStartX = selRect.left - gridRectDim.left - w.globals.barPadForNumericAxis;
        var localEndX = selRect.right - gridRectDim.left - w.globals.barPadForNumericAxis;
        var localStartY = selRect.top - gridRectDim.top;
        var localEndY = selRect.bottom - gridRectDim.top;

        // Convert those local coords to actual data values
        var xLowestValue, xHighestValue;
        if (!w.globals.isRangeBar) {
          xLowestValue = w.globals.xAxisScale.niceMin + localStartX * xyRatios.xRatio;
          xHighestValue = w.globals.xAxisScale.niceMin + localEndX * xyRatios.xRatio;
        } else {
          xLowestValue = w.globals.yAxisScale[0].niceMin + localStartX * xyRatios.invertedYRatio;
          xHighestValue = w.globals.yAxisScale[0].niceMin + localEndX * xyRatios.invertedYRatio;
        }

        // For Y values, pick from the first y-axis, but handle multi-axis
        var yHighestValue = [];
        var yLowestValue = [];
        w.config.yaxis.forEach(function (yaxe, index) {
          // pick whichever series is mapped to this y-axis
          var seriesIndex = w.globals.seriesYAxisMap[index][0];
          var highestVal = w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[seriesIndex] * localStartY;
          var lowestVal = w.globals.yAxisScale[index].niceMax - xyRatios.yRatio[seriesIndex] * localEndY;
          yHighestValue.push(highestVal);
          yLowestValue.push(lowestVal);
        });

        // Only apply if user actually dragged far enough to consider it a selection
        if (me.dragged && (me.dragX > 10 || me.dragY > 10) && xLowestValue !== xHighestValue) {
          if (w.globals.zoomEnabled) {
            var yaxis = Utils$1.clone(w.globals.initialConfig.yaxis);
            var xaxis = Utils$1.clone(w.globals.initialConfig.xaxis);
            w.globals.zoomed = true;
            if (w.config.xaxis.convertedCatToNumeric) {
              xLowestValue = Math.floor(xLowestValue);
              xHighestValue = Math.floor(xHighestValue);
              if (xLowestValue < 1) {
                xLowestValue = 1;
                xHighestValue = w.globals.dataPoints;
              }
              if (xHighestValue - xLowestValue < 2) {
                xHighestValue = xLowestValue + 1;
              }
            }
            if (zoomtype === 'xy' || zoomtype === 'x') {
              xaxis = {
                min: xLowestValue,
                max: xHighestValue
              };
            }
            if (zoomtype === 'xy' || zoomtype === 'y') {
              yaxis.forEach(function (yaxe, index) {
                yaxis[index].min = yLowestValue[index];
                yaxis[index].max = yHighestValue[index];
              });
            }
            if (toolbar) {
              var beforeZoomRange = toolbar.getBeforeZoomRange(xaxis, yaxis);
              if (beforeZoomRange) {
                xaxis = beforeZoomRange.xaxis ? beforeZoomRange.xaxis : xaxis;
                yaxis = beforeZoomRange.yaxis ? beforeZoomRange.yaxis : yaxis;
              }
            }
            var options = {
              xaxis: xaxis
            };
            if (!w.config.chart.group) {
              // if chart in a group, prevent yaxis update here
              // fix issue #650
              options.yaxis = yaxis;
            }
            me.ctx.updateHelpers._updateOptions(options, false, me.w.config.chart.animations.dynamicAnimation.enabled);
            if (typeof w.config.chart.events.zoomed === 'function') {
              toolbar.zoomCallback(xaxis, yaxis);
            }
          } else if (w.globals.selectionEnabled) {
            var _yaxis = null;
            var _xaxis = null;
            _xaxis = {
              min: xLowestValue,
              max: xHighestValue
            };
            if (zoomtype === 'xy' || zoomtype === 'y') {
              _yaxis = Utils$1.clone(w.config.yaxis);
              _yaxis.forEach(function (yaxe, index) {
                _yaxis[index].min = yLowestValue[index];
                _yaxis[index].max = yHighestValue[index];
              });
            }
            w.globals.selection = me.selection;
            if (typeof w.config.chart.events.selection === 'function') {
              w.config.chart.events.selection(me.ctx, {
                xaxis: _xaxis,
                yaxis: _yaxis
              });
            }
          }
        }
      }
    }, {
      key: "panDragging",
      value: function panDragging(_ref6) {
        var context = _ref6.context;
        var w = this.w;
        var me = context;

        // check to make sure there is data to compare against
        if (typeof w.globals.lastClientPosition.x !== 'undefined') {
          // get the change from last position to this position
          var deltaX = w.globals.lastClientPosition.x - me.clientX;
          var deltaY = w.globals.lastClientPosition.y - me.clientY;

          // check which direction had the highest amplitude
          if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX > 0) {
            this.moveDirection = 'left';
          } else if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX < 0) {
            this.moveDirection = 'right';
          } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY > 0) {
            this.moveDirection = 'up';
          } else if (Math.abs(deltaY) > Math.abs(deltaX) && deltaY < 0) {
            this.moveDirection = 'down';
          }
        }

        // set the new last position to the current for next time (to get the position of drag)
        w.globals.lastClientPosition = {
          x: me.clientX,
          y: me.clientY
        };
        var xLowestValue = w.globals.isRangeBar ? w.globals.minY : w.globals.minX;
        var xHighestValue = w.globals.isRangeBar ? w.globals.maxY : w.globals.maxX;

        // removed delayedPanScrolled as it doesn't seem to cause bugs anymore in convertedCatToNumeric
        // if (!w.config.xaxis.convertedCatToNumeric) {
        me.panScrolled(xLowestValue, xHighestValue);
        // }
      }

      // delayedPanScrolled() {
      //   const w = this.w

      //   let newMinX = w.globals.minX
      //   let newMaxX = w.globals.maxX
      //   const centerX = (w.globals.maxX - w.globals.minX) / 2

      //   if (this.moveDirection === 'left') {
      //     newMinX = w.globals.minX + centerX
      //     newMaxX = w.globals.maxX + centerX
      //   } else if (this.moveDirection === 'right') {
      //     newMinX = w.globals.minX - centerX
      //     newMaxX = w.globals.maxX - centerX
      //   }

      //   newMinX = Math.floor(newMinX)
      //   newMaxX = Math.floor(newMaxX)
      //   this.updateScrolledChart(
      //     { xaxis: { min: newMinX, max: newMaxX } },
      //     newMinX,
      //     newMaxX
      //   )
      // }
    }, {
      key: "panScrolled",
      value: function panScrolled(xLowestValue, xHighestValue) {
        var w = this.w;
        var xyRatios = this.xyRatios;
        var yaxis = Utils$1.clone(w.globals.initialConfig.yaxis);
        var xRatio = xyRatios.xRatio;
        var minX = w.globals.minX;
        var maxX = w.globals.maxX;
        if (w.globals.isRangeBar) {
          xRatio = xyRatios.invertedYRatio;
          minX = w.globals.minY;
          maxX = w.globals.maxY;
        }
        if (this.moveDirection === 'left') {
          xLowestValue = minX + w.globals.gridWidth / 15 * xRatio;
          xHighestValue = maxX + w.globals.gridWidth / 15 * xRatio;
        } else if (this.moveDirection === 'right') {
          xLowestValue = minX - w.globals.gridWidth / 15 * xRatio;
          xHighestValue = maxX - w.globals.gridWidth / 15 * xRatio;
        }
        if (!w.globals.isRangeBar) {
          if (xLowestValue < w.globals.initialMinX || xHighestValue > w.globals.initialMaxX) {
            xLowestValue = minX;
            xHighestValue = maxX;
          }
        }
        var xaxis = {
          min: xLowestValue,
          max: xHighestValue
        };
        var options = {
          xaxis: xaxis
        };
        if (!w.config.chart.group) {
          // if chart in a group, prevent yaxis update here
          // fix issue #650
          options.yaxis = yaxis;
        }
        this.updateScrolledChart(options, xLowestValue, xHighestValue);
      }
    }, {
      key: "updateScrolledChart",
      value: function updateScrolledChart(options, xLowestValue, xHighestValue) {
        var w = this.w;
        this.ctx.updateHelpers._updateOptions(options, false, false);
        if (typeof w.config.chart.events.scrolled === 'function') {
          var args = {
            xaxis: {
              min: xLowestValue,
              max: xHighestValue
            }
          };
          w.config.chart.events.scrolled(this.ctx, args);
          this.ctx.events.fireEvent('scrolled', args);
        }
      }
    }]);
    return ZoomPanSelection;
  }(Toolbar);

  /**
   * ApexCharts Tooltip.Utils Class to support Tooltip functionality.
   *
   * @module Tooltip.Utils
   **/
  var Utils = /*#__PURE__*/function () {
    function Utils(tooltipContext) {
      _classCallCheck(this, Utils);
      this.w = tooltipContext.w;
      this.ttCtx = tooltipContext;
      this.ctx = tooltipContext.ctx;
    }

    /**
     ** When hovering over series, you need to capture which series is being hovered on.
     ** This function will return both capturedseries index as well as inner index of that series
     * @memberof Utils
     * @param {object}
     * - hoverArea = the rect on which user hovers
     * - elGrid = dimensions of the hover rect (it can be different than hoverarea)
     */
    _createClass(Utils, [{
      key: "getNearestValues",
      value: function getNearestValues(_ref) {
        var hoverArea = _ref.hoverArea,
          elGrid = _ref.elGrid,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
        var w = this.w;
        var seriesBound = elGrid.getBoundingClientRect();
        var hoverWidth = seriesBound.width;
        var hoverHeight = seriesBound.height;
        var xDivisor = hoverWidth / (w.globals.dataPoints - 1);
        var yDivisor = hoverHeight / w.globals.dataPoints;
        var hasBars = this.hasBars();
        if ((w.globals.comboCharts || hasBars) && !w.config.xaxis.convertedCatToNumeric) {
          xDivisor = hoverWidth / w.globals.dataPoints;
        }
        var hoverX = clientX - seriesBound.left - w.globals.barPadForNumericAxis;
        var hoverY = clientY - seriesBound.top;
        var notInRect = hoverX < 0 || hoverY < 0 || hoverX > hoverWidth || hoverY > hoverHeight;
        if (notInRect) {
          hoverArea.classList.remove('hovering-zoom');
          hoverArea.classList.remove('hovering-pan');
        } else {
          if (w.globals.zoomEnabled) {
            hoverArea.classList.remove('hovering-pan');
            hoverArea.classList.add('hovering-zoom');
          } else if (w.globals.panEnabled) {
            hoverArea.classList.remove('hovering-zoom');
            hoverArea.classList.add('hovering-pan');
          }
        }
        var j = Math.round(hoverX / xDivisor);
        var jHorz = Math.floor(hoverY / yDivisor);
        if (hasBars && !w.config.xaxis.convertedCatToNumeric) {
          j = Math.ceil(hoverX / xDivisor);
          j = j - 1;
        }
        var capturedSeries = null;
        var closest = null;
        var seriesXValArr = w.globals.seriesXvalues.map(function (seriesXVal) {
          return seriesXVal.filter(function (s) {
            return Utils$1.isNumber(s);
          });
        });
        var seriesYValArr = w.globals.seriesYvalues.map(function (seriesYVal) {
          return seriesYVal.filter(function (s) {
            return Utils$1.isNumber(s);
          });
        });

        // if X axis type is not category and tooltip is not shared, then we need to find the cursor position and get the nearest value
        if (w.globals.isXNumeric) {
          // Change origin of cursor position so that we can compute the relative nearest point to the cursor on our chart
          // we only need to scale because all points are relative to the bounds.left and bounds.top => origin is virtually (0, 0)
          var chartGridEl = this.ttCtx.getElGrid();
          var chartGridElBoundingRect = chartGridEl.getBoundingClientRect();
          var transformedHoverX = hoverX * (chartGridElBoundingRect.width / hoverWidth);
          var transformedHoverY = hoverY * (chartGridElBoundingRect.height / hoverHeight);
          closest = this.closestInMultiArray(transformedHoverX, transformedHoverY, seriesXValArr, seriesYValArr);
          capturedSeries = closest.index;
          j = closest.j;
          if (capturedSeries !== null && w.globals.hasNullValues) {
            // initial push, it should be a little smaller than the 1st val
            seriesXValArr = w.globals.seriesXvalues[capturedSeries];
            closest = this.closestInArray(transformedHoverX, seriesXValArr);
            j = closest.j;
          }
        }
        w.globals.capturedSeriesIndex = capturedSeries === null ? -1 : capturedSeries;
        if (!j || j < 1) j = 0;
        if (w.globals.isBarHorizontal) {
          w.globals.capturedDataPointIndex = jHorz;
        } else {
          w.globals.capturedDataPointIndex = j;
        }
        return {
          capturedSeries: capturedSeries,
          j: w.globals.isBarHorizontal ? jHorz : j,
          hoverX: hoverX,
          hoverY: hoverY
        };
      }
    }, {
      key: "getFirstActiveXArray",
      value: function getFirstActiveXArray(Xarrays) {
        var w = this.w;
        var activeIndex = 0;
        var firstActiveSeriesIndex = Xarrays.map(function (xarr, index) {
          return xarr.length > 0 ? index : -1;
        });
        for (var a = 0; a < firstActiveSeriesIndex.length; a++) {
          if (firstActiveSeriesIndex[a] !== -1 && w.globals.collapsedSeriesIndices.indexOf(a) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(a) === -1) {
            activeIndex = firstActiveSeriesIndex[a];
            break;
          }
        }
        return activeIndex;
      }
    }, {
      key: "closestInMultiArray",
      value: function closestInMultiArray(hoverX, hoverY, Xarrays, Yarrays) {
        var w = this.w;

        // Determine which series are active (not collapsed)
        var isActiveSeries = function isActiveSeries(seriesIndex) {
          return w.globals.collapsedSeriesIndices.indexOf(seriesIndex) === -1 && w.globals.ancillaryCollapsedSeriesIndices.indexOf(seriesIndex) === -1;
        };
        var closestDist = Infinity;
        var closestSeriesIndex = null;
        var closestPointIndex = null;

        // Iterate through all series and points to find the closest (x,y) to (hoverX, hoverY)
        for (var i = 0; i < Xarrays.length; i++) {
          if (!isActiveSeries(i)) {
            continue;
          }
          var xArr = Xarrays[i];
          var yArr = Yarrays[i];
          var len = Math.min(xArr.length, yArr.length);
          for (var j = 0; j < len; j++) {
            var xVal = xArr[j];
            var distX = hoverX - xVal;
            var dist = Math.sqrt(distX * distX);
            if (!w.globals.allSeriesHasEqualX) {
              var yVal = yArr[j];
              var distY = hoverY - yVal;
              dist = Math.sqrt(distX * distX + distY * distY);
            }
            if (dist < closestDist) {
              closestDist = dist;
              closestSeriesIndex = i;
              closestPointIndex = j;
            }
          }
        }
        return {
          index: closestSeriesIndex,
          j: closestPointIndex
        };
      }
    }, {
      key: "closestInArray",
      value: function closestInArray(val, arr) {
        var curr = arr[0];
        var currIndex = null;
        var diff = Math.abs(val - curr);
        for (var i = 0; i < arr.length; i++) {
          var newdiff = Math.abs(val - arr[i]);
          if (newdiff < diff) {
            diff = newdiff;
            currIndex = i;
          }
        }
        return {
          j: currIndex
        };
      }

      /**
       * When there are multiple series, it is possible to have different x values for each series.
       * But it may be possible in those multiple series, that there is same x value for 2 or more
       * series.
       * @memberof Utils
       * @param {int}
       * - j = is the inner index of series -> (series[i][j])
       * @return {bool}
       */
    }, {
      key: "isXoverlap",
      value: function isXoverlap(j) {
        var w = this.w;
        var xSameForAllSeriesJArr = [];
        var seriesX = w.globals.seriesX.filter(function (s) {
          return typeof s[0] !== 'undefined';
        });
        if (seriesX.length > 0) {
          for (var i = 0; i < seriesX.length - 1; i++) {
            if (typeof seriesX[i][j] !== 'undefined' && typeof seriesX[i + 1][j] !== 'undefined') {
              if (seriesX[i][j] !== seriesX[i + 1][j]) {
                xSameForAllSeriesJArr.push('unEqual');
              }
            }
          }
        }
        if (xSameForAllSeriesJArr.length === 0) {
          return true;
        }
        return false;
      }
    }, {
      key: "isInitialSeriesSameLen",
      value: function isInitialSeriesSameLen() {
        var sameLen = true;
        var initialSeries = this.w.globals.initialSeries;
        for (var i = 0; i < initialSeries.length - 1; i++) {
          if (initialSeries[i].data.length !== initialSeries[i + 1].data.length) {
            sameLen = false;
            break;
          }
        }
        return sameLen;
      }
    }, {
      key: "getBarsHeight",
      value: function getBarsHeight(allbars) {
        var bars = _toConsumableArray(allbars);
        var totalHeight = bars.reduce(function (acc, bar) {
          return acc + bar.getBBox().height;
        }, 0);
        return totalHeight;
      }
    }, {
      key: "getElMarkers",
      value: function getElMarkers(capturedSeries) {
        // The selector .apexcharts-series-markers-wrap > * includes marker groups for which the
        // .apexcharts-series-markers class is not added due to null values or discrete markers
        if (typeof capturedSeries == 'number') {
          return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(capturedSeries, "'] .apexcharts-series-markers-wrap > *"));
        }
        return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers-wrap > *');
      }
    }, {
      key: "getAllMarkers",
      value: function getAllMarkers() {
        var _this = this;
        var filterCollapsed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        // first get all marker parents. This parent class contains series-index
        // which helps to sort the markers as they are dynamic
        var markersWraps = this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers-wrap');
        markersWraps = _toConsumableArray(markersWraps);
        if (filterCollapsed) {
          markersWraps = markersWraps.filter(function (m) {
            var realIndex = Number(m.getAttribute('data:realIndex'));
            return _this.w.globals.collapsedSeriesIndices.indexOf(realIndex) === -1;
          });
        }
        markersWraps.sort(function (a, b) {
          var indexA = Number(a.getAttribute('data:realIndex'));
          var indexB = Number(b.getAttribute('data:realIndex'));
          return indexB < indexA ? 1 : indexB > indexA ? -1 : 0;
        });
        var markers = [];
        markersWraps.forEach(function (m) {
          markers.push(m.querySelector('.apexcharts-marker'));
        });
        return markers;
      }
    }, {
      key: "hasMarkers",
      value: function hasMarkers(capturedSeries) {
        var markers = this.getElMarkers(capturedSeries);
        return markers.length > 0;
      }
    }, {
      key: "getPathFromPoint",
      value: function getPathFromPoint(point, size) {
        var cx = Number(point.getAttribute('cx'));
        var cy = Number(point.getAttribute('cy'));
        var shape = point.getAttribute('shape');
        return new Graphics(this.ctx).getMarkerPath(cx, cy, shape, size);
      }
    }, {
      key: "getElBars",
      value: function getElBars() {
        return this.w.globals.dom.baseEl.querySelectorAll('.apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series');
      }
    }, {
      key: "hasBars",
      value: function hasBars() {
        var bars = this.getElBars();
        return bars.length > 0;
      }
    }, {
      key: "getHoverMarkerSize",
      value: function getHoverMarkerSize(index) {
        var w = this.w;
        var hoverSize = w.config.markers.hover.size;
        if (hoverSize === undefined) {
          hoverSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;
        }
        return hoverSize;
      }
    }, {
      key: "toggleAllTooltipSeriesGroups",
      value: function toggleAllTooltipSeriesGroups(state) {
        var w = this.w;
        var ttCtx = this.ttCtx;
        if (ttCtx.allTooltipSeriesGroups.length === 0) {
          ttCtx.allTooltipSeriesGroups = w.globals.dom.baseEl.querySelectorAll('.apexcharts-tooltip-series-group');
        }
        var allTooltipSeriesGroups = ttCtx.allTooltipSeriesGroups;
        for (var i = 0; i < allTooltipSeriesGroups.length; i++) {
          if (state === 'enable') {
            allTooltipSeriesGroups[i].classList.add('apexcharts-active');
            allTooltipSeriesGroups[i].style.display = w.config.tooltip.items.display;
          } else {
            allTooltipSeriesGroups[i].classList.remove('apexcharts-active');
            allTooltipSeriesGroups[i].style.display = 'none';
          }
        }
      }
    }]);
    return Utils;
  }();

  /**
   * ApexCharts Tooltip.Labels Class to draw texts on the tooltip.
   * This file deals with printing actual text on the tooltip.
   *
   * @module Tooltip.Labels
   **/
  var Labels = /*#__PURE__*/function () {
    function Labels(tooltipContext) {
      _classCallCheck(this, Labels);
      this.w = tooltipContext.w;
      this.ctx = tooltipContext.ctx;
      this.ttCtx = tooltipContext;
      this.tooltipUtil = new Utils(tooltipContext);
    }
    _createClass(Labels, [{
      key: "drawSeriesTexts",
      value: function drawSeriesTexts(_ref) {
        var _ref$shared = _ref.shared,
          shared = _ref$shared === void 0 ? true : _ref$shared,
          ttItems = _ref.ttItems,
          _ref$i = _ref.i,
          i = _ref$i === void 0 ? 0 : _ref$i,
          _ref$j = _ref.j,
          j = _ref$j === void 0 ? null : _ref$j,
          y1 = _ref.y1,
          y2 = _ref.y2,
          e = _ref.e;
        var w = this.w;
        if (w.config.tooltip.custom !== undefined) {
          this.handleCustomTooltip({
            i: i,
            j: j,
            y1: y1,
            y2: y2,
            w: w
          });
        } else {
          this.toggleActiveInactiveSeries(shared, i);
        }
        var values = this.getValuesToPrint({
          i: i,
          j: j
        });
        this.printLabels({
          i: i,
          j: j,
          values: values,
          ttItems: ttItems,
          shared: shared,
          e: e
        });

        // Re-calculate tooltip dimensions now that we have drawn the text
        var tooltipEl = this.ttCtx.getElTooltip();
        this.ttCtx.tooltipRect.ttWidth = tooltipEl.getBoundingClientRect().width;
        this.ttCtx.tooltipRect.ttHeight = tooltipEl.getBoundingClientRect().height;
      }
    }, {
      key: "printLabels",
      value: function printLabels(_ref2) {
        var _this = this;
        var i = _ref2.i,
          j = _ref2.j,
          values = _ref2.values,
          ttItems = _ref2.ttItems,
          shared = _ref2.shared,
          e = _ref2.e;
        var w = this.w;
        var val;
        var goalVals = [];
        var hasGoalValues = function hasGoalValues(gi) {
          return w.globals.seriesGoals[gi] && w.globals.seriesGoals[gi][j] && Array.isArray(w.globals.seriesGoals[gi][j]);
        };
        var xVal = values.xVal,
          zVal = values.zVal,
          xAxisTTVal = values.xAxisTTVal;
        var seriesName = '';
        var pColor = w.globals.colors[i]; // The pColor here is for the markers inside tooltip
        if (j !== null && w.config.plotOptions.bar.distributed) {
          pColor = w.globals.colors[j];
        }
        var _loop = function _loop(t, inverset) {
          var f = _this.getFormatters(i);
          seriesName = _this.getSeriesName({
            fn: f.yLbTitleFormatter,
            index: i,
            seriesIndex: i,
            j: j
          });
          if (w.config.chart.type === 'treemap') {
            seriesName = f.yLbTitleFormatter(String(w.config.series[i].data[j].x), {
              series: w.globals.series,
              seriesIndex: i,
              dataPointIndex: j,
              w: w
            });
          }
          var tIndex = w.config.tooltip.inverseOrder ? inverset : t;
          if (w.globals.axisCharts) {
            var getValBySeriesIndex = function getValBySeriesIndex(index) {
              if (w.globals.isRangeData) {
                var _w$globals$seriesRang, _w$globals$seriesRang2, _w$globals$seriesRang3, _w$globals$seriesRang4;
                return f.yLbFormatter((_w$globals$seriesRang = w.globals.seriesRangeStart) === null || _w$globals$seriesRang === void 0 ? void 0 : (_w$globals$seriesRang2 = _w$globals$seriesRang[index]) === null || _w$globals$seriesRang2 === void 0 ? void 0 : _w$globals$seriesRang2[j], {
                  series: w.globals.seriesRangeStart,
                  seriesIndex: index,
                  dataPointIndex: j,
                  w: w
                }) + ' - ' + f.yLbFormatter((_w$globals$seriesRang3 = w.globals.seriesRangeEnd) === null || _w$globals$seriesRang3 === void 0 ? void 0 : (_w$globals$seriesRang4 = _w$globals$seriesRang3[index]) === null || _w$globals$seriesRang4 === void 0 ? void 0 : _w$globals$seriesRang4[j], {
                  series: w.globals.seriesRangeEnd,
                  seriesIndex: index,
                  dataPointIndex: j,
                  w: w
                });
              }
              return f.yLbFormatter(w.globals.series[index][j], {
                series: w.globals.series,
                seriesIndex: index,
                dataPointIndex: j,
                w: w
              });
            };
            if (shared) {
              f = _this.getFormatters(tIndex);
              seriesName = _this.getSeriesName({
                fn: f.yLbTitleFormatter,
                index: tIndex,
                seriesIndex: i,
                j: j
              });
              pColor = w.globals.colors[tIndex];
              val = getValBySeriesIndex(tIndex);
              if (hasGoalValues(tIndex)) {
                goalVals = w.globals.seriesGoals[tIndex][j].map(function (goal) {
                  return {
                    attrs: goal,
                    val: f.yLbFormatter(goal.value, {
                      seriesIndex: tIndex,
                      dataPointIndex: j,
                      w: w
                    })
                  };
                });
              }
            } else {
              var _e$target;
              // get a color from a hover area (if it's a line pattern then get from a first line)
              var targetFill = e === null || e === void 0 ? void 0 : (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.getAttribute('fill');
              if (targetFill) {
                if (targetFill.indexOf('url') !== -1) {
                  // pattern fill
                  if (targetFill.indexOf('Pattern') !== -1) {
                    pColor = w.globals.dom.baseEl.querySelector(targetFill.substr(4).slice(0, -1)).childNodes[0].getAttribute('stroke');
                  }
                } else {
                  pColor = targetFill;
                }
              }
              val = getValBySeriesIndex(i);
              if (hasGoalValues(i) && Array.isArray(w.globals.seriesGoals[i][j])) {
                goalVals = w.globals.seriesGoals[i][j].map(function (goal) {
                  return {
                    attrs: goal,
                    val: f.yLbFormatter(goal.value, {
                      seriesIndex: i,
                      dataPointIndex: j,
                      w: w
                    })
                  };
                });
              }
            }
          }

          // for pie / donuts
          if (j === null) {
            val = f.yLbFormatter(w.globals.series[i], _objectSpread2(_objectSpread2({}, w), {}, {
              seriesIndex: i,
              dataPointIndex: i
            }));
          }
          _this.DOMHandling({
            i: i,
            t: tIndex,
            j: j,
            ttItems: ttItems,
            values: {
              val: val,
              goalVals: goalVals,
              xVal: xVal,
              xAxisTTVal: xAxisTTVal,
              zVal: zVal
            },
            seriesName: seriesName,
            shared: shared,
            pColor: pColor
          });
        };
        for (var t = 0, inverset = w.globals.series.length - 1; t < w.globals.series.length; t++, inverset--) {
          _loop(t, inverset);
        }
      }
    }, {
      key: "getFormatters",
      value: function getFormatters(i) {
        var w = this.w;
        var yLbFormatter = w.globals.yLabelFormatters[i];
        var yLbTitleFormatter;
        if (w.globals.ttVal !== undefined) {
          if (Array.isArray(w.globals.ttVal)) {
            yLbFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].formatter;
            yLbTitleFormatter = w.globals.ttVal[i] && w.globals.ttVal[i].title && w.globals.ttVal[i].title.formatter;
          } else {
            yLbFormatter = w.globals.ttVal.formatter;
            if (typeof w.globals.ttVal.title.formatter === 'function') {
              yLbTitleFormatter = w.globals.ttVal.title.formatter;
            }
          }
        } else {
          yLbTitleFormatter = w.config.tooltip.y.title.formatter;
        }
        if (typeof yLbFormatter !== 'function') {
          if (w.globals.yLabelFormatters[0]) {
            yLbFormatter = w.globals.yLabelFormatters[0];
          } else {
            yLbFormatter = function yLbFormatter(label) {
              return label;
            };
          }
        }
        if (typeof yLbTitleFormatter !== 'function') {
          yLbTitleFormatter = function yLbTitleFormatter(label) {
            // refrence used from line: 966 in Options.js
            return label ? label + ': ' : '';
          };
        }
        return {
          yLbFormatter: yLbFormatter,
          yLbTitleFormatter: yLbTitleFormatter
        };
      }
    }, {
      key: "getSeriesName",
      value: function getSeriesName(_ref3) {
        var fn = _ref3.fn,
          index = _ref3.index,
          seriesIndex = _ref3.seriesIndex,
          j = _ref3.j;
        var w = this.w;
        return fn(String(w.globals.seriesNames[index]), {
          series: w.globals.series,
          seriesIndex: seriesIndex,
          dataPointIndex: j,
          w: w
        });
      }
    }, {
      key: "DOMHandling",
      value: function DOMHandling(_ref4) {
        _ref4.i;
          var t = _ref4.t,
          j = _ref4.j,
          ttItems = _ref4.ttItems,
          values = _ref4.values,
          seriesName = _ref4.seriesName,
          shared = _ref4.shared,
          pColor = _ref4.pColor;
        var w = this.w;
        var ttCtx = this.ttCtx;
        var val = values.val,
          goalVals = values.goalVals,
          xVal = values.xVal,
          xAxisTTVal = values.xAxisTTVal,
          zVal = values.zVal;
        var ttItemsChildren = null;
        ttItemsChildren = ttItems[t].children;
        if (w.config.tooltip.fillSeriesColor) {
          ttItems[t].style.backgroundColor = pColor;
          ttItemsChildren[0].style.display = 'none';
        }
        if (ttCtx.showTooltipTitle) {
          if (ttCtx.tooltipTitle === null) {
            // get it once if null, and store it in class property
            ttCtx.tooltipTitle = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip-title');
          }
          ttCtx.tooltipTitle.innerHTML = xVal;
        }

        // if xaxis tooltip is constructed, we need to replace the innerHTML
        if (ttCtx.isXAxisTooltipEnabled) {
          ttCtx.xaxisTooltipText.innerHTML = xAxisTTVal !== '' ? xAxisTTVal : xVal;
        }
        var ttYLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-y-label');
        if (ttYLabel) {
          ttYLabel.innerHTML = seriesName ? seriesName : '';
        }
        var ttYVal = ttItems[t].querySelector('.apexcharts-tooltip-text-y-value');
        if (ttYVal) {
          ttYVal.innerHTML = typeof val !== 'undefined' ? val : '';
        }
        if (ttItemsChildren[0] && ttItemsChildren[0].classList.contains('apexcharts-tooltip-marker')) {
          if (w.config.tooltip.marker.fillColors && Array.isArray(w.config.tooltip.marker.fillColors)) {
            pColor = w.config.tooltip.marker.fillColors[t];
          }
          if (w.config.tooltip.fillSeriesColor) {
            ttItemsChildren[0].style.backgroundColor = pColor;
          } else {
            ttItemsChildren[0].style.color = pColor;
          }
        }
        if (!w.config.tooltip.marker.show) {
          ttItemsChildren[0].style.display = 'none';
        }
        var ttGLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-goals-label');
        var ttGVal = ttItems[t].querySelector('.apexcharts-tooltip-text-goals-value');
        if (goalVals.length && w.globals.seriesGoals[t]) {
          var createGoalsHtml = function createGoalsHtml() {
            var gLabels = '<div>';
            var gVals = '<div>';
            goalVals.forEach(function (goal, gi) {
              gLabels += " <div style=\"display: flex\"><span class=\"apexcharts-tooltip-marker\" style=\"background-color: ".concat(goal.attrs.strokeColor, "; height: 3px; border-radius: 0; top: 5px;\"></span> ").concat(goal.attrs.name, "</div>");
              gVals += "<div>".concat(goal.val, "</div>");
            });
            ttGLabel.innerHTML = gLabels + "</div>";
            ttGVal.innerHTML = gVals + "</div>";
          };
          if (shared) {
            if (w.globals.seriesGoals[t][j] && Array.isArray(w.globals.seriesGoals[t][j])) {
              createGoalsHtml();
            } else {
              ttGLabel.innerHTML = '';
              ttGVal.innerHTML = '';
            }
          } else {
            createGoalsHtml();
          }
        } else {
          ttGLabel.innerHTML = '';
          ttGVal.innerHTML = '';
        }
        if (zVal !== null) {
          var ttZLabel = ttItems[t].querySelector('.apexcharts-tooltip-text-z-label');
          ttZLabel.innerHTML = w.config.tooltip.z.title;
          var ttZVal = ttItems[t].querySelector('.apexcharts-tooltip-text-z-value');
          ttZVal.innerHTML = typeof zVal !== 'undefined' ? zVal : '';
        }
        if (shared && ttItemsChildren[0]) {
          // hide when no Val or series collapsed
          if (w.config.tooltip.hideEmptySeries) {
            var ttItemMarker = ttItems[t].querySelector('.apexcharts-tooltip-marker');
            var ttItemText = ttItems[t].querySelector('.apexcharts-tooltip-text');
            if (parseFloat(val) == 0) {
              ttItemMarker.style.display = 'none';
              ttItemText.style.display = 'none';
            } else {
              ttItemMarker.style.display = 'block';
              ttItemText.style.display = 'block';
            }
          }
          if (typeof val === 'undefined' || val === null || w.globals.ancillaryCollapsedSeriesIndices.indexOf(t) > -1 || w.globals.collapsedSeriesIndices.indexOf(t) > -1 || Array.isArray(ttCtx.tConfig.enabledOnSeries) && ttCtx.tConfig.enabledOnSeries.indexOf(t) === -1) {
            ttItemsChildren[0].parentNode.style.display = 'none';
          } else {
            ttItemsChildren[0].parentNode.style.display = w.config.tooltip.items.display;
          }
        } else {
          if (Array.isArray(ttCtx.tConfig.enabledOnSeries) && ttCtx.tConfig.enabledOnSeries.indexOf(t) === -1) {
            ttItemsChildren[0].parentNode.style.display = 'none';
          }
        }
      }
    }, {
      key: "toggleActiveInactiveSeries",
      value: function toggleActiveInactiveSeries(shared, i) {
        var w = this.w;
        if (shared) {
          // make all tooltips active
          this.tooltipUtil.toggleAllTooltipSeriesGroups('enable');
        } else {
          // disable all tooltip text groups
          this.tooltipUtil.toggleAllTooltipSeriesGroups('disable');

          // enable the first tooltip text group
          var firstTooltipSeriesGroup = w.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(i));
          if (firstTooltipSeriesGroup) {
            firstTooltipSeriesGroup.classList.add('apexcharts-active');
            firstTooltipSeriesGroup.style.display = w.config.tooltip.items.display;
          }
        }
      }
    }, {
      key: "getValuesToPrint",
      value: function getValuesToPrint(_ref5) {
        var i = _ref5.i,
          j = _ref5.j;
        var w = this.w;
        var filteredSeriesX = this.ctx.series.filteredSeriesX();
        var xVal = '';
        var xAxisTTVal = '';
        var zVal = null;
        var val = null;
        var customFormatterOpts = {
          series: w.globals.series,
          seriesIndex: i,
          dataPointIndex: j,
          w: w
        };
        var zFormatter = w.globals.ttZFormatter;
        if (j === null) {
          val = w.globals.series[i];
        } else {
          if (w.globals.isXNumeric && w.config.chart.type !== 'treemap') {
            xVal = filteredSeriesX[i][j];
            if (filteredSeriesX[i].length === 0) {
              // a series (possibly the first one) might be collapsed, so get the next active index
              var firstActiveSeriesIndex = this.tooltipUtil.getFirstActiveXArray(filteredSeriesX);
              xVal = filteredSeriesX[firstActiveSeriesIndex][j];
            }
          } else {
            var dataFormat = new Data(this.ctx);
            if (dataFormat.isFormatXY()) {
              xVal = typeof w.config.series[i].data[j] !== 'undefined' ? w.config.series[i].data[j].x : '';
            } else {
              xVal = typeof w.globals.labels[j] !== 'undefined' ? w.globals.labels[j] : '';
            }
          }
        }
        var bufferXVal = xVal;
        if (w.globals.isXNumeric && w.config.xaxis.type === 'datetime') {
          var xFormat = new Formatters(this.ctx);
          xVal = xFormat.xLabelFormat(w.globals.ttKeyFormatter, bufferXVal, bufferXVal, {
            i: undefined,
            dateFormatter: new DateTime(this.ctx).formatDate,
            w: this.w
          });
        } else {
          if (w.globals.isBarHorizontal) {
            xVal = w.globals.yLabelFormatters[0](bufferXVal, customFormatterOpts);
          } else {
            xVal = w.globals.xLabelFormatter(bufferXVal, customFormatterOpts);
          }
        }

        // override default x-axis formatter with tooltip formatter
        if (w.config.tooltip.x.formatter !== undefined) {
          xVal = w.globals.ttKeyFormatter(bufferXVal, customFormatterOpts);
        }
        if (w.globals.seriesZ.length > 0 && w.globals.seriesZ[i].length > 0) {
          zVal = zFormatter(w.globals.seriesZ[i][j], w);
        }
        if (typeof w.config.xaxis.tooltip.formatter === 'function') {
          xAxisTTVal = w.globals.xaxisTooltipFormatter(bufferXVal, customFormatterOpts);
        } else {
          xAxisTTVal = xVal;
        }
        return {
          val: Array.isArray(val) ? val.join(' ') : val,
          xVal: Array.isArray(xVal) ? xVal.join(' ') : xVal,
          xAxisTTVal: Array.isArray(xAxisTTVal) ? xAxisTTVal.join(' ') : xAxisTTVal,
          zVal: zVal
        };
      }
    }, {
      key: "handleCustomTooltip",
      value: function handleCustomTooltip(_ref6) {
        var i = _ref6.i,
          j = _ref6.j,
          y1 = _ref6.y1,
          y2 = _ref6.y2,
          w = _ref6.w;
        var tooltipEl = this.ttCtx.getElTooltip();
        var fn = w.config.tooltip.custom;
        if (Array.isArray(fn) && fn[i]) {
          fn = fn[i];
        }
        var customTooltip = fn({
          ctx: this.ctx,
          series: w.globals.series,
          seriesIndex: i,
          dataPointIndex: j,
          y1: y1,
          y2: y2,
          w: w
        });
        if (typeof customTooltip === 'string' || typeof customTooltip === 'number') {
          tooltipEl.innerHTML = customTooltip;
        } else if (customTooltip instanceof Element || typeof customTooltip.nodeName === 'string') {
          tooltipEl.innerHTML = '';
          tooltipEl.appendChild(customTooltip.cloneNode(true));
        }
      }
    }]);
    return Labels;
  }();

  /**
   * ApexCharts Tooltip.Position Class to move the tooltip based on x and y position.
   *
   * @module Tooltip.Position
   **/
  var Position = /*#__PURE__*/function () {
    function Position(tooltipContext) {
      _classCallCheck(this, Position);
      this.ttCtx = tooltipContext;
      this.ctx = tooltipContext.ctx;
      this.w = tooltipContext.w;
    }

    /**
     * This will move the crosshair (the vertical/horz line that moves along with mouse)
     * Along with this, this function also calls the xaxisMove function
     * @memberof Position
     * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair
     */
    _createClass(Position, [{
      key: "moveXCrosshairs",
      value: function moveXCrosshairs(cx) {
        var j = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var ttCtx = this.ttCtx;
        var w = this.w;
        var xcrosshairs = ttCtx.getElXCrosshairs();
        var x = cx - ttCtx.xcrosshairsWidth / 2;
        var tickAmount = w.globals.labels.slice().length;
        if (j !== null) {
          x = w.globals.gridWidth / tickAmount * j;
        }
        if (xcrosshairs !== null && !w.globals.isBarHorizontal) {
          xcrosshairs.setAttribute('x', x);
          xcrosshairs.setAttribute('x1', x);
          xcrosshairs.setAttribute('x2', x);
          xcrosshairs.setAttribute('y2', w.globals.gridHeight);
          xcrosshairs.classList.add('apexcharts-active');
        }
        if (x < 0) {
          x = 0;
        }
        if (x > w.globals.gridWidth) {
          x = w.globals.gridWidth;
        }
        if (ttCtx.isXAxisTooltipEnabled) {
          var tx = x;
          if (w.config.xaxis.crosshairs.width === 'tickWidth' || w.config.xaxis.crosshairs.width === 'barWidth') {
            tx = x + ttCtx.xcrosshairsWidth / 2;
          }
          this.moveXAxisTooltip(tx);
        }
      }

      /**
       * This will move the crosshair (the vertical/horz line that moves along with mouse)
       * Along with this, this function also calls the xaxisMove function
       * @memberof Position
       * @param {int} - cx = point's x position, wherever point's x is, you need to move crosshair
       */
    }, {
      key: "moveYCrosshairs",
      value: function moveYCrosshairs(cy) {
        var ttCtx = this.ttCtx;
        if (ttCtx.ycrosshairs !== null) {
          Graphics.setAttrs(ttCtx.ycrosshairs, {
            y1: cy,
            y2: cy
          });
        }
        if (ttCtx.ycrosshairsHidden !== null) {
          Graphics.setAttrs(ttCtx.ycrosshairsHidden, {
            y1: cy,
            y2: cy
          });
        }
      }

      /**
       ** AxisTooltip is the small rectangle which appears on x axis with x value, when user moves
       * @memberof Position
       * @param {int} - cx = point's x position, wherever point's x is, you need to move
       */
    }, {
      key: "moveXAxisTooltip",
      value: function moveXAxisTooltip(cx) {
        var w = this.w;
        var ttCtx = this.ttCtx;
        if (ttCtx.xaxisTooltip !== null && ttCtx.xcrosshairsWidth !== 0) {
          ttCtx.xaxisTooltip.classList.add('apexcharts-active');
          var cy = ttCtx.xaxisOffY + w.config.xaxis.tooltip.offsetY + w.globals.translateY + 1 + w.config.xaxis.offsetY;
          var xaxisTTText = ttCtx.xaxisTooltip.getBoundingClientRect();
          var xaxisTTTextWidth = xaxisTTText.width;
          cx = cx - xaxisTTTextWidth / 2;
          if (!isNaN(cx)) {
            cx = cx + w.globals.translateX;
            var textRect = 0;
            var graphics = new Graphics(this.ctx);
            textRect = graphics.getTextRects(ttCtx.xaxisTooltipText.innerHTML);
            ttCtx.xaxisTooltipText.style.minWidth = textRect.width + 'px';
            ttCtx.xaxisTooltip.style.left = cx + 'px';
            ttCtx.xaxisTooltip.style.top = cy + 'px';
          }
        }
      }
    }, {
      key: "moveYAxisTooltip",
      value: function moveYAxisTooltip(index) {
        var w = this.w;
        var ttCtx = this.ttCtx;
        if (ttCtx.yaxisTTEls === null) {
          ttCtx.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');
        }
        var ycrosshairsHiddenRectY1 = parseInt(ttCtx.ycrosshairsHidden.getAttribute('y1'), 10);
        var cy = w.globals.translateY + ycrosshairsHiddenRectY1;
        var yAxisTTRect = ttCtx.yaxisTTEls[index].getBoundingClientRect();
        var yAxisTTHeight = yAxisTTRect.height;
        var cx = w.globals.translateYAxisX[index] - 2;
        if (w.config.yaxis[index].opposite) {
          cx = cx - yAxisTTRect.width;
        }
        cy = cy - yAxisTTHeight / 2;
        if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1 && cy > 0 && cy < w.globals.gridHeight) {
          ttCtx.yaxisTTEls[index].classList.add('apexcharts-active');
          ttCtx.yaxisTTEls[index].style.top = cy + 'px';
          ttCtx.yaxisTTEls[index].style.left = cx + w.config.yaxis[index].tooltip.offsetX + 'px';
        } else {
          ttCtx.yaxisTTEls[index].classList.remove('apexcharts-active');
        }
      }

      /**
       ** moves the whole tooltip by changing x, y attrs
       * @memberof Position
       * @param {int} - cx = point's x position, wherever point's x is, you need to move tooltip
       * @param {int} - cy = point's y position, wherever point's y is, you need to move tooltip
       * @param {int} - markerSize = point's size
       */
    }, {
      key: "moveTooltip",
      value: function moveTooltip(cx, cy) {
        var markerSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var w = this.w;
        var ttCtx = this.ttCtx;
        var tooltipEl = ttCtx.getElTooltip();
        var tooltipRect = ttCtx.tooltipRect;
        var pointSize = markerSize !== null ? parseFloat(markerSize) : 1;
        var x = parseFloat(cx) + pointSize + 5;
        var y = parseFloat(cy) + pointSize / 2; // - tooltipRect.ttHeight / 2

        if (x > w.globals.gridWidth / 2) {
          x = x - tooltipRect.ttWidth - pointSize - 10;
        }
        if (x > w.globals.gridWidth - tooltipRect.ttWidth - 10) {
          x = w.globals.gridWidth - tooltipRect.ttWidth;
        }
        if (x < -20) {
          x = -20;
        }
        if (w.config.tooltip.followCursor) {
          var elGrid = ttCtx.getElGrid();
          var seriesBound = elGrid.getBoundingClientRect();
          x = ttCtx.e.clientX - seriesBound.left;
          if (x > w.globals.gridWidth / 2) {
            x = x - ttCtx.tooltipRect.ttWidth;
          }
          y = ttCtx.e.clientY + w.globals.translateY - seriesBound.top;
          if (y > w.globals.gridHeight / 2) {
            y = y - ttCtx.tooltipRect.ttHeight;
          }
        } else {
          if (!w.globals.isBarHorizontal) {
            if (tooltipRect.ttHeight / 2 + y > w.globals.gridHeight) {
              y = w.globals.gridHeight - tooltipRect.ttHeight + w.globals.translateY;
            }
          }
        }
        if (!isNaN(x)) {
          x = x + w.globals.translateX;
          tooltipEl.style.left = x + 'px';
          tooltipEl.style.top = y + 'px';
        }
      }
    }, {
      key: "moveMarkers",
      value: function moveMarkers(i, j) {
        var w = this.w;
        var ttCtx = this.ttCtx;
        if (w.globals.markers.size[i] > 0) {
          var allPoints = w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(i, "'] .apexcharts-marker"));
          for (var p = 0; p < allPoints.length; p++) {
            if (parseInt(allPoints[p].getAttribute('rel'), 10) === j) {
              ttCtx.marker.resetPointsSize();
              ttCtx.marker.enlargeCurrentPoint(j, allPoints[p]);
            }
          }
        } else {
          ttCtx.marker.resetPointsSize();
          this.moveDynamicPointOnHover(j, i);
        }
      }

      // This function is used when you need to show markers/points only on hover -
      // DIFFERENT X VALUES in multiple series
    }, {
      key: "moveDynamicPointOnHover",
      value: function moveDynamicPointOnHover(j, capturedSeries) {
        var _pointsArr$capturedSe, _pointsArr$capturedSe2;
        var w = this.w;
        var ttCtx = this.ttCtx;
        var cx = 0;
        var cy = 0;
        var graphics = new Graphics(this.ctx);
        var pointsArr = w.globals.pointsArray;
        var hoverSize = ttCtx.tooltipUtil.getHoverMarkerSize(capturedSeries);
        var serType = w.config.series[capturedSeries].type;
        if (serType && (serType === 'column' || serType === 'candlestick' || serType === 'boxPlot')) {
          // fix error mentioned in #811
          return;
        }
        cx = (_pointsArr$capturedSe = pointsArr[capturedSeries][j]) === null || _pointsArr$capturedSe === void 0 ? void 0 : _pointsArr$capturedSe[0];
        cy = ((_pointsArr$capturedSe2 = pointsArr[capturedSeries][j]) === null || _pointsArr$capturedSe2 === void 0 ? void 0 : _pointsArr$capturedSe2[1]) || 0;
        var point = w.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(capturedSeries, "'] .apexcharts-series-markers path"));
        if (point && cy < w.globals.gridHeight && cy > 0) {
          var shape = point.getAttribute('shape');
          var path = graphics.getMarkerPath(cx, cy, shape, hoverSize * 1.5);
          point.setAttribute('d', path);
        }
        this.moveXCrosshairs(cx);
        if (!ttCtx.fixedTooltip) {
          this.moveTooltip(cx, cy, hoverSize);
        }
      }

      // This function is used when you need to show markers/points only on hover -
      // SAME X VALUES in multiple series
    }, {
      key: "moveDynamicPointsOnHover",
      value: function moveDynamicPointsOnHover(j) {
        var ttCtx = this.ttCtx;
        var w = ttCtx.w;
        var cx = 0;
        var cy = 0;
        var activeSeries = 0;
        var pointsArr = w.globals.pointsArray;
        var series = new Series(this.ctx);
        var graphics = new Graphics(this.ctx);
        activeSeries = series.getActiveConfigSeriesIndex('asc', ['line', 'area', 'scatter', 'bubble']);
        var hoverSize = ttCtx.tooltipUtil.getHoverMarkerSize(activeSeries);
        if (pointsArr[activeSeries]) {
          cx = pointsArr[activeSeries][j][0];
          cy = pointsArr[activeSeries][j][1];
        }
        if (isNaN(cx)) {
          return;
        }
        var points = ttCtx.tooltipUtil.getAllMarkers();
        if (points.length) {
          for (var p = 0; p < w.globals.series.length; p++) {
            var pointArr = pointsArr[p];
            if (w.globals.comboCharts) {
              // in a combo chart, if column charts are present, markers will not match with the number of series, hence this patch to push a null value in points array
              if (typeof pointArr === 'undefined') {
                // nodelist to array
                points.splice(p, 0, null);
              }
            }
            if (pointArr && pointArr.length) {
              var pcy = pointsArr[p][j][1];
              var pcy2 = void 0;
              points[p].setAttribute('cx', cx);
              var shape = points[p].getAttribute('shape');
              if (w.config.chart.type === 'rangeArea' && !w.globals.comboCharts) {
                var rangeStartIndex = j + w.globals.series[p].length;
                pcy2 = pointsArr[p][rangeStartIndex][1];
                var pcyDiff = Math.abs(pcy - pcy2) / 2;
                pcy = pcy - pcyDiff;
              }
              if (pcy !== null && !isNaN(pcy) && pcy < w.globals.gridHeight + hoverSize && pcy + hoverSize > 0) {
                var path = graphics.getMarkerPath(cx, pcy, shape, hoverSize);
                points[p].setAttribute('d', path);
              } else {
                points[p].setAttribute('d', '');
              }
            }
          }
        }
        this.moveXCrosshairs(cx);
        if (!ttCtx.fixedTooltip) {
          this.moveTooltip(cx, cy || w.globals.gridHeight, hoverSize);
        }
      }
    }, {
      key: "moveStickyTooltipOverBars",
      value: function moveStickyTooltipOverBars(j, capturedSeries) {
        var w = this.w;
        var ttCtx = this.ttCtx;
        var barLen = w.globals.columnSeries ? w.globals.columnSeries.length : w.globals.series.length;
        if (w.config.chart.stacked) {
          barLen = w.globals.barGroups.length;
        }
        var i = barLen >= 2 && barLen % 2 === 0 ? Math.floor(barLen / 2) : Math.floor(barLen / 2) + 1;
        if (w.globals.isBarHorizontal) {
          var series = new Series(this.ctx);
          i = series.getActiveConfigSeriesIndex('desc') + 1;
        }
        var jBar = w.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(i, "'] path[j='").concat(j, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(i, "'] path[j='").concat(j, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(i, "'] path[j='").concat(j, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(i, "'] path[j='").concat(j, "']"));
        if (!jBar && typeof capturedSeries === 'number') {
          // Try with captured series index
          jBar = w.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(capturedSeries, "'] path[j='").concat(j, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(capturedSeries, "'] path[j='").concat(j, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(capturedSeries, "'] path[j='").concat(j, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(capturedSeries, "'] path[j='").concat(j, "']"));
        }
        var bcx = jBar ? parseFloat(jBar.getAttribute('cx')) : 0;
        var bcy = jBar ? parseFloat(jBar.getAttribute('cy')) : 0;
        var bw = jBar ? parseFloat(jBar.getAttribute('barWidth')) : 0;
        var elGrid = ttCtx.getElGrid();
        var seriesBound = elGrid.getBoundingClientRect();
        var isBoxOrCandle = jBar && (jBar.classList.contains('apexcharts-candlestick-area') || jBar.classList.contains('apexcharts-boxPlot-area'));
        if (w.globals.isXNumeric) {
          if (jBar && !isBoxOrCandle) {
            bcx = bcx - (barLen % 2 !== 0 ? bw / 2 : 0);
          }
          if (jBar &&
          // fixes apexcharts.js#2354
          isBoxOrCandle) {
            bcx = bcx - bw / 2;
          }
        } else {
          if (!w.globals.isBarHorizontal) {
            bcx = ttCtx.xAxisTicksPositions[j - 1] + ttCtx.dataPointsDividedWidth / 2;
            if (isNaN(bcx)) {
              bcx = ttCtx.xAxisTicksPositions[j] - ttCtx.dataPointsDividedWidth / 2;
            }
          }
        }
        if (!w.globals.isBarHorizontal) {
          if (w.config.tooltip.followCursor) {
            bcy = ttCtx.e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2;
          } else {
            if (bcy + ttCtx.tooltipRect.ttHeight + 15 > w.globals.gridHeight) {
              bcy = w.globals.gridHeight;
            }
          }
        } else {
          bcy = bcy - ttCtx.tooltipRect.ttHeight;
        }
        if (!w.globals.isBarHorizontal) {
          this.moveXCrosshairs(bcx);
        }
        if (!ttCtx.fixedTooltip) {
          this.moveTooltip(bcx, bcy || w.globals.gridHeight);
        }
      }
    }]);
    return Position;
  }();

  /**
   * ApexCharts Tooltip.Marker Class to draw texts on the tooltip.
   * This file deals with the markers that appear near tooltip in line/area charts.
   * These markers helps the user to associate the data-points and the values
   * that are shown in the tooltip
   *
   * @module Tooltip.Marker
   **/
  var Marker = /*#__PURE__*/function () {
    function Marker(tooltipContext) {
      _classCallCheck(this, Marker);
      this.w = tooltipContext.w;
      this.ttCtx = tooltipContext;
      this.ctx = tooltipContext.ctx;
      this.tooltipPosition = new Position(tooltipContext);
    }
    _createClass(Marker, [{
      key: "drawDynamicPoints",
      value: function drawDynamicPoints() {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var marker = new Markers(this.ctx);
        var elsSeries = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');
        elsSeries = _toConsumableArray(elsSeries);
        if (w.config.chart.stacked) {
          elsSeries.sort(function (a, b) {
            return parseFloat(a.getAttribute('data:realIndex')) - parseFloat(b.getAttribute('data:realIndex'));
          });
        }
        for (var i = 0; i < elsSeries.length; i++) {
          var pointsMain = elsSeries[i].querySelector(".apexcharts-series-markers-wrap");
          if (pointsMain !== null) {
            // it can be null as we have tooltips in donut/bar charts
            var point = void 0;
            var PointClasses = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
            if ((w.config.chart.type === 'line' || w.config.chart.type === 'area') && !w.globals.comboCharts && !w.config.tooltip.intersect) {
              PointClasses += ' no-pointer-events';
            }
            var elPointOptions = marker.getMarkerConfig({
              cssClass: PointClasses,
              seriesIndex: Number(pointsMain.getAttribute('data:realIndex')) // fixes apexcharts/apexcharts.js #1427
            });
            point = graphics.drawMarker(0, 0, elPointOptions);
            point.node.setAttribute('default-marker-size', 0);
            var elPointsG = document.createElementNS(w.globals.SVGNS, 'g');
            elPointsG.classList.add('apexcharts-series-markers');
            elPointsG.appendChild(point.node);
            pointsMain.appendChild(elPointsG);
          }
        }
      }
    }, {
      key: "enlargeCurrentPoint",
      value: function enlargeCurrentPoint(rel, point) {
        var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var w = this.w;
        if (w.config.chart.type !== 'bubble') {
          this.newPointSize(rel, point);
        }
        var cx = point.getAttribute('cx');
        var cy = point.getAttribute('cy');
        if (x !== null && y !== null) {
          cx = x;
          cy = y;
        }
        this.tooltipPosition.moveXCrosshairs(cx);
        if (!this.fixedTooltip) {
          if (w.config.chart.type === 'radar') {
            var elGrid = this.ttCtx.getElGrid();
            var seriesBound = elGrid.getBoundingClientRect();
            cx = this.ttCtx.e.clientX - seriesBound.left;
          }
          this.tooltipPosition.moveTooltip(cx, cy, w.config.markers.hover.size);
        }
      }
    }, {
      key: "enlargePoints",
      value: function enlargePoints(j) {
        var w = this.w;
        var me = this;
        var ttCtx = this.ttCtx;
        var col = j;
        var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');
        var newSize = w.config.markers.hover.size;
        for (var p = 0; p < points.length; p++) {
          var rel = points[p].getAttribute('rel');
          var index = points[p].getAttribute('index');
          if (newSize === undefined) {
            newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;
          }
          if (col === parseInt(rel, 10)) {
            me.newPointSize(col, points[p]);
            var cx = points[p].getAttribute('cx');
            var cy = points[p].getAttribute('cy');
            me.tooltipPosition.moveXCrosshairs(cx);
            if (!ttCtx.fixedTooltip) {
              me.tooltipPosition.moveTooltip(cx, cy, newSize);
            }
          } else {
            me.oldPointSize(points[p]);
          }
        }
      }
    }, {
      key: "newPointSize",
      value: function newPointSize(rel, point) {
        var w = this.w;
        var newSize = w.config.markers.hover.size;
        var elPoint = rel === 0 ? point.parentNode.firstChild : point.parentNode.lastChild;
        if (elPoint.getAttribute('default-marker-size') !== '0') {
          var index = parseInt(elPoint.getAttribute('index'), 10);
          if (newSize === undefined) {
            newSize = w.globals.markers.size[index] + w.config.markers.hover.sizeOffset;
          }
          if (newSize < 0) {
            newSize = 0;
          }
          var path = this.ttCtx.tooltipUtil.getPathFromPoint(point, newSize);
          point.setAttribute('d', path);
        }
      }
    }, {
      key: "oldPointSize",
      value: function oldPointSize(point) {
        var size = parseFloat(point.getAttribute('default-marker-size'));
        var path = this.ttCtx.tooltipUtil.getPathFromPoint(point, size);
        point.setAttribute('d', path);
      }
    }, {
      key: "resetPointsSize",
      value: function resetPointsSize() {
        var w = this.w;
        var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker');
        for (var p = 0; p < points.length; p++) {
          var size = parseFloat(points[p].getAttribute('default-marker-size'));
          if (Utils$1.isNumber(size) && size > 0) {
            var path = this.ttCtx.tooltipUtil.getPathFromPoint(points[p], size);
            points[p].setAttribute('d', path);
          } else {
            points[p].setAttribute('d', 'M0,0');
          }
        }
      }
    }]);
    return Marker;
  }();

  /**
   * ApexCharts Tooltip.Intersect Class.
   * This file deals with functions related to intersecting tooltips
   * (tooltips that appear when user hovers directly over a data-point whether)
   *
   * @module Tooltip.Intersect
   **/
  var Intersect = /*#__PURE__*/function () {
    function Intersect(tooltipContext) {
      _classCallCheck(this, Intersect);
      this.w = tooltipContext.w;
      var w = this.w;
      this.ttCtx = tooltipContext;
      this.isVerticalGroupedRangeBar = !w.globals.isBarHorizontal && w.config.chart.type === 'rangeBar' && w.config.plotOptions.bar.rangeBarGroupRows;
    }

    // a helper function to get an element's attribute value
    _createClass(Intersect, [{
      key: "getAttr",
      value: function getAttr(e, attr) {
        return parseFloat(e.target.getAttribute(attr));
      }

      // handle tooltip for heatmaps and treemaps
    }, {
      key: "handleHeatTreeTooltip",
      value: function handleHeatTreeTooltip(_ref) {
        var e = _ref.e,
          opt = _ref.opt,
          x = _ref.x,
          y = _ref.y,
          type = _ref.type;
        var ttCtx = this.ttCtx;
        var w = this.w;
        if (e.target.classList.contains("apexcharts-".concat(type, "-rect"))) {
          var i = this.getAttr(e, 'i');
          var j = this.getAttr(e, 'j');
          var cx = this.getAttr(e, 'cx');
          var cy = this.getAttr(e, 'cy');
          var width = this.getAttr(e, 'width');
          var height = this.getAttr(e, 'height');
          ttCtx.tooltipLabels.drawSeriesTexts({
            ttItems: opt.ttItems,
            i: i,
            j: j,
            shared: false,
            e: e
          });
          w.globals.capturedSeriesIndex = i;
          w.globals.capturedDataPointIndex = j;
          x = cx + ttCtx.tooltipRect.ttWidth / 2 + width;
          y = cy + ttCtx.tooltipRect.ttHeight / 2 - height / 2;
          ttCtx.tooltipPosition.moveXCrosshairs(cx + width / 2);
          if (x > w.globals.gridWidth / 2) {
            x = cx - ttCtx.tooltipRect.ttWidth / 2 + width;
          }
          if (ttCtx.w.config.tooltip.followCursor) {
            var seriesBound = w.globals.dom.elWrap.getBoundingClientRect();
            x = w.globals.clientX - seriesBound.left - (x > w.globals.gridWidth / 2 ? ttCtx.tooltipRect.ttWidth : 0);
            y = w.globals.clientY - seriesBound.top - (y > w.globals.gridHeight / 2 ? ttCtx.tooltipRect.ttHeight : 0);
          }
        }
        return {
          x: x,
          y: y
        };
      }

      /**
       * handle tooltips for line/area/scatter charts where tooltip.intersect is true
       * when user hovers over the marker directly, this function is executed
       */
    }, {
      key: "handleMarkerTooltip",
      value: function handleMarkerTooltip(_ref2) {
        var e = _ref2.e,
          opt = _ref2.opt,
          x = _ref2.x,
          y = _ref2.y;
        var w = this.w;
        var ttCtx = this.ttCtx;
        var i;
        var j;
        if (e.target.classList.contains('apexcharts-marker')) {
          var cx = parseInt(opt.paths.getAttribute('cx'), 10);
          var cy = parseInt(opt.paths.getAttribute('cy'), 10);
          var val = parseFloat(opt.paths.getAttribute('val'));
          j = parseInt(opt.paths.getAttribute('rel'), 10);
          i = parseInt(opt.paths.parentNode.parentNode.parentNode.getAttribute('rel'), 10) - 1;
          if (ttCtx.intersect) {
            var el = Utils$1.findAncestor(opt.paths, 'apexcharts-series');
            if (el) {
              i = parseInt(el.getAttribute('data:realIndex'), 10);
            }
          }
          ttCtx.tooltipLabels.drawSeriesTexts({
            ttItems: opt.ttItems,
            i: i,
            j: j,
            shared: ttCtx.showOnIntersect ? false : w.config.tooltip.shared,
            e: e
          });
          if (e.type === 'mouseup') {
            ttCtx.markerClick(e, i, j);
          }
          w.globals.capturedSeriesIndex = i;
          w.globals.capturedDataPointIndex = j;
          x = cx;
          y = cy + w.globals.translateY - ttCtx.tooltipRect.ttHeight * 1.4;
          if (ttCtx.w.config.tooltip.followCursor) {
            var elGrid = ttCtx.getElGrid();
            var seriesBound = elGrid.getBoundingClientRect();
            y = ttCtx.e.clientY + w.globals.translateY - seriesBound.top;
          }
          if (val < 0) {
            y = cy;
          }
          ttCtx.marker.enlargeCurrentPoint(j, opt.paths, x, y);
        }
        return {
          x: x,
          y: y
        };
      }

      /**
       * handle tooltips for bar/column charts
       */
    }, {
      key: "handleBarTooltip",
      value: function handleBarTooltip(_ref3) {
        var e = _ref3.e,
          opt = _ref3.opt;
        var w = this.w;
        var ttCtx = this.ttCtx;
        var tooltipEl = ttCtx.getElTooltip();
        var bx = 0;
        var x = 0;
        var y = 0;
        var i = 0;
        var strokeWidth;
        var barXY = this.getBarTooltipXY({
          e: e,
          opt: opt
        });
        if (barXY.j === null && barXY.barHeight === 0 && barXY.barWidth === 0) {
          return; // bar was not hovered and didn't receive correct coords
        }
        i = barXY.i;
        var j = barXY.j;
        w.globals.capturedSeriesIndex = i;
        w.globals.capturedDataPointIndex = j;
        if (w.globals.isBarHorizontal && ttCtx.tooltipUtil.hasBars() || !w.config.tooltip.shared) {
          x = barXY.x;
          y = barXY.y;
          strokeWidth = Array.isArray(w.config.stroke.width) ? w.config.stroke.width[i] : w.config.stroke.width;
          bx = x;
        } else {
          if (!w.globals.comboCharts && !w.config.tooltip.shared) {
            // todo: re-check this condition as it's always 0
            bx = bx / 2;
          }
        }

        // y is NaN, make it touch the bottom of grid area
        if (isNaN(y)) {
          y = w.globals.svgHeight - ttCtx.tooltipRect.ttHeight;
        }
        parseInt(opt.paths.parentNode.getAttribute('data:realIndex'), 10);
        if (x + ttCtx.tooltipRect.ttWidth > w.globals.gridWidth) {
          x = x - ttCtx.tooltipRect.ttWidth;
        } else if (x < 0) {
          x = 0;
        }
        if (ttCtx.w.config.tooltip.followCursor) {
          var elGrid = ttCtx.getElGrid();
          var seriesBound = elGrid.getBoundingClientRect();
          y = ttCtx.e.clientY - seriesBound.top;
        }

        // if tooltip is still null, querySelector
        if (ttCtx.tooltip === null) {
          ttCtx.tooltip = w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');
        }
        if (!w.config.tooltip.shared) {
          if (w.globals.comboBarCount > 0) {
            ttCtx.tooltipPosition.moveXCrosshairs(bx + strokeWidth / 2);
          } else {
            ttCtx.tooltipPosition.moveXCrosshairs(bx);
          }
        }

        // move tooltip here
        if (!ttCtx.fixedTooltip && (!w.config.tooltip.shared || w.globals.isBarHorizontal && ttCtx.tooltipUtil.hasBars())) {
          y = y + w.globals.translateY - ttCtx.tooltipRect.ttHeight / 2;
          tooltipEl.style.left = x + w.globals.translateX + 'px';
          tooltipEl.style.top = y + 'px';
        }
      }
    }, {
      key: "getBarTooltipXY",
      value: function getBarTooltipXY(_ref4) {
        var _this = this;
        var e = _ref4.e,
          opt = _ref4.opt;
        var w = this.w;
        var j = null;
        var ttCtx = this.ttCtx;
        var i = 0;
        var x = 0;
        var y = 0;
        var barWidth = 0;
        var barHeight = 0;
        var cl = e.target.classList;
        if (cl.contains('apexcharts-bar-area') || cl.contains('apexcharts-candlestick-area') || cl.contains('apexcharts-boxPlot-area') || cl.contains('apexcharts-rangebar-area')) {
          var bar = e.target;
          var barRect = bar.getBoundingClientRect();
          var seriesBound = opt.elGrid.getBoundingClientRect();
          var bh = barRect.height;
          barHeight = barRect.height;
          var bw = barRect.width;
          var cx = parseInt(bar.getAttribute('cx'), 10);
          var cy = parseInt(bar.getAttribute('cy'), 10);
          barWidth = parseFloat(bar.getAttribute('barWidth'));
          var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
          j = parseInt(bar.getAttribute('j'), 10);
          i = parseInt(bar.parentNode.getAttribute('rel'), 10) - 1;
          var y1 = bar.getAttribute('data-range-y1');
          var y2 = bar.getAttribute('data-range-y2');
          if (w.globals.comboCharts) {
            i = parseInt(bar.parentNode.getAttribute('data:realIndex'), 10);
          }
          var handleXForColumns = function handleXForColumns(x) {
            if (w.globals.isXNumeric) {
              x = cx - bw / 2;
            } else {
              if (_this.isVerticalGroupedRangeBar) {
                x = cx + bw / 2;
              } else {
                x = cx - ttCtx.dataPointsDividedWidth + bw / 2;
              }
            }
            return x;
          };
          var handleYForBars = function handleYForBars() {
            return cy - ttCtx.dataPointsDividedHeight + bh / 2 - ttCtx.tooltipRect.ttHeight / 2;
          };
          ttCtx.tooltipLabels.drawSeriesTexts({
            ttItems: opt.ttItems,
            i: i,
            j: j,
            y1: y1 ? parseInt(y1, 10) : null,
            y2: y2 ? parseInt(y2, 10) : null,
            shared: ttCtx.showOnIntersect ? false : w.config.tooltip.shared,
            e: e
          });
          if (w.config.tooltip.followCursor) {
            if (w.globals.isBarHorizontal) {
              x = clientX - seriesBound.left + 15;
              y = handleYForBars();
            } else {
              x = handleXForColumns(x);
              y = e.clientY - seriesBound.top - ttCtx.tooltipRect.ttHeight / 2 - 15;
            }
          } else {
            if (w.globals.isBarHorizontal) {
              x = cx;
              if (x < ttCtx.xyRatios.baseLineInvertedY) {
                x = cx - ttCtx.tooltipRect.ttWidth;
              }
              y = handleYForBars();
            } else {
              x = handleXForColumns(x);
              y = cy; // - ttCtx.tooltipRect.ttHeight / 2 + 10
            }
          }
        }
        return {
          x: x,
          y: y,
          barHeight: barHeight,
          barWidth: barWidth,
          i: i,
          j: j
        };
      }
    }]);
    return Intersect;
  }();

  /**
   * ApexCharts Tooltip.AxesTooltip Class.
   * This file deals with the x-axis and y-axis tooltips.
   *
   * @module Tooltip.AxesTooltip
   **/
  var AxesTooltip = /*#__PURE__*/function () {
    function AxesTooltip(tooltipContext) {
      _classCallCheck(this, AxesTooltip);
      this.w = tooltipContext.w;
      this.ttCtx = tooltipContext;
    }

    /**
     * This method adds the secondary tooltip which appears below x axis
     * @memberof Tooltip
     **/
    _createClass(AxesTooltip, [{
      key: "drawXaxisTooltip",
      value: function drawXaxisTooltip() {
        var w = this.w;
        var ttCtx = this.ttCtx;
        var isBottom = w.config.xaxis.position === 'bottom';
        ttCtx.xaxisOffY = isBottom ? w.globals.gridHeight + 1 : -w.globals.xAxisHeight - w.config.xaxis.axisTicks.height + 3;
        var tooltipCssClass = isBottom ? 'apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom' : 'apexcharts-xaxistooltip apexcharts-xaxistooltip-top';
        var renderTo = w.globals.dom.elWrap;
        if (ttCtx.isXAxisTooltipEnabled) {
          var xaxisTooltip = w.globals.dom.baseEl.querySelector('.apexcharts-xaxistooltip');
          if (xaxisTooltip === null) {
            ttCtx.xaxisTooltip = document.createElement('div');
            ttCtx.xaxisTooltip.setAttribute('class', tooltipCssClass + ' apexcharts-theme-' + w.config.tooltip.theme);
            renderTo.appendChild(ttCtx.xaxisTooltip);
            ttCtx.xaxisTooltipText = document.createElement('div');
            ttCtx.xaxisTooltipText.classList.add('apexcharts-xaxistooltip-text');
            ttCtx.xaxisTooltipText.style.fontFamily = w.config.xaxis.tooltip.style.fontFamily || w.config.chart.fontFamily;
            ttCtx.xaxisTooltipText.style.fontSize = w.config.xaxis.tooltip.style.fontSize;
            ttCtx.xaxisTooltip.appendChild(ttCtx.xaxisTooltipText);
          }
        }
      }

      /**
       * This method adds the secondary tooltip which appears below x axis
       * @memberof Tooltip
       **/
    }, {
      key: "drawYaxisTooltip",
      value: function drawYaxisTooltip() {
        var w = this.w;
        var ttCtx = this.ttCtx;
        for (var i = 0; i < w.config.yaxis.length; i++) {
          var isRight = w.config.yaxis[i].opposite || w.config.yaxis[i].crosshairs.opposite;
          ttCtx.yaxisOffX = isRight ? w.globals.gridWidth + 1 : 1;
          var tooltipCssClass = isRight ? "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, " apexcharts-yaxistooltip-right") : "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, " apexcharts-yaxistooltip-left");
          var renderTo = w.globals.dom.elWrap;
          var yaxisTooltip = w.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i));
          if (yaxisTooltip === null) {
            ttCtx.yaxisTooltip = document.createElement('div');
            ttCtx.yaxisTooltip.setAttribute('class', tooltipCssClass + ' apexcharts-theme-' + w.config.tooltip.theme);
            renderTo.appendChild(ttCtx.yaxisTooltip);
            if (i === 0) ttCtx.yaxisTooltipText = [];
            ttCtx.yaxisTooltipText[i] = document.createElement('div');
            ttCtx.yaxisTooltipText[i].classList.add('apexcharts-yaxistooltip-text');
            ttCtx.yaxisTooltip.appendChild(ttCtx.yaxisTooltipText[i]);
          }
        }
      }

      /**
       * @memberof Tooltip
       **/
    }, {
      key: "setXCrosshairWidth",
      value: function setXCrosshairWidth() {
        var w = this.w;
        var ttCtx = this.ttCtx;

        // set xcrosshairs width
        var xcrosshairs = ttCtx.getElXCrosshairs();
        ttCtx.xcrosshairsWidth = parseInt(w.config.xaxis.crosshairs.width, 10);
        if (!w.globals.comboCharts) {
          if (w.config.xaxis.crosshairs.width === 'tickWidth') {
            var count = w.globals.labels.length;
            ttCtx.xcrosshairsWidth = w.globals.gridWidth / count;
          } else if (w.config.xaxis.crosshairs.width === 'barWidth') {
            var bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');
            if (bar !== null) {
              var barWidth = parseFloat(bar.getAttribute('barWidth'));
              ttCtx.xcrosshairsWidth = barWidth;
            } else {
              ttCtx.xcrosshairsWidth = 1;
            }
          }
        } else {
          var _bar = w.globals.dom.baseEl.querySelector('.apexcharts-bar-area');
          if (_bar !== null && w.config.xaxis.crosshairs.width === 'barWidth') {
            var _barWidth = parseFloat(_bar.getAttribute('barWidth'));
            ttCtx.xcrosshairsWidth = _barWidth;
          } else {
            if (w.config.xaxis.crosshairs.width === 'tickWidth') {
              var _count = w.globals.labels.length;
              ttCtx.xcrosshairsWidth = w.globals.gridWidth / _count;
            }
          }
        }
        if (w.globals.isBarHorizontal) {
          ttCtx.xcrosshairsWidth = 0;
        }
        if (xcrosshairs !== null && ttCtx.xcrosshairsWidth > 0) {
          xcrosshairs.setAttribute('width', ttCtx.xcrosshairsWidth);
        }
      }
    }, {
      key: "handleYCrosshair",
      value: function handleYCrosshair() {
        var w = this.w;
        var ttCtx = this.ttCtx;

        // set ycrosshairs height
        ttCtx.ycrosshairs = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs');
        ttCtx.ycrosshairsHidden = w.globals.dom.baseEl.querySelector('.apexcharts-ycrosshairs-hidden');
      }
    }, {
      key: "drawYaxisTooltipText",
      value: function drawYaxisTooltipText(index, clientY, xyRatios) {
        var ttCtx = this.ttCtx;
        var w = this.w;
        var gl = w.globals;
        var yAxisSeriesArr = gl.seriesYAxisMap[index];
        if (ttCtx.yaxisTooltips[index] && yAxisSeriesArr.length > 0) {
          var lbFormatter = gl.yLabelFormatters[index];
          var elGrid = ttCtx.getElGrid();
          var seriesBound = elGrid.getBoundingClientRect();

          // We can use the index of any series referenced by the Yaxis
          // because they will all return the same value.
          var seriesIndex = yAxisSeriesArr[0];
          var translationsIndex = 0;
          if (xyRatios.yRatio.length > 1) {
            translationsIndex = seriesIndex;
          }
          var hoverY = (clientY - seriesBound.top) * xyRatios.yRatio[translationsIndex];
          var height = gl.maxYArr[seriesIndex] - gl.minYArr[seriesIndex];
          var val = gl.minYArr[seriesIndex] + (height - hoverY);
          if (w.config.yaxis[index].reversed) {
            val = gl.maxYArr[seriesIndex] - (height - hoverY);
          }
          ttCtx.tooltipPosition.moveYCrosshairs(clientY - seriesBound.top);
          ttCtx.yaxisTooltipText[index].innerHTML = lbFormatter(val);
          ttCtx.tooltipPosition.moveYAxisTooltip(index);
        }
      }
    }]);
    return AxesTooltip;
  }();

  /**
   * ApexCharts Core Tooltip Class to handle the tooltip generation.
   *
   * @module Tooltip
   **/
  var Tooltip = /*#__PURE__*/function () {
    function Tooltip(ctx) {
      _classCallCheck(this, Tooltip);
      this.ctx = ctx;
      this.w = ctx.w;
      var w = this.w;
      this.tConfig = w.config.tooltip;
      this.tooltipUtil = new Utils(this);
      this.tooltipLabels = new Labels(this);
      this.tooltipPosition = new Position(this);
      this.marker = new Marker(this);
      this.intersect = new Intersect(this);
      this.axesTooltip = new AxesTooltip(this);
      this.showOnIntersect = this.tConfig.intersect;
      this.showTooltipTitle = this.tConfig.x.show;
      this.fixedTooltip = this.tConfig.fixed.enabled;
      this.xaxisTooltip = null;
      this.yaxisTTEls = null;
      this.isBarShared = !w.globals.isBarHorizontal && this.tConfig.shared;
      this.lastHoverTime = Date.now();
    }
    _createClass(Tooltip, [{
      key: "getElTooltip",
      value: function getElTooltip(ctx) {
        if (!ctx) ctx = this;
        if (!ctx.w.globals.dom.baseEl) return null;
        return ctx.w.globals.dom.baseEl.querySelector('.apexcharts-tooltip');
      }
    }, {
      key: "getElXCrosshairs",
      value: function getElXCrosshairs() {
        return this.w.globals.dom.baseEl.querySelector('.apexcharts-xcrosshairs');
      }
    }, {
      key: "getElGrid",
      value: function getElGrid() {
        return this.w.globals.dom.baseEl.querySelector('.apexcharts-grid');
      }
    }, {
      key: "drawTooltip",
      value: function drawTooltip(xyRatios) {
        var w = this.w;
        this.xyRatios = xyRatios;
        this.isXAxisTooltipEnabled = w.config.xaxis.tooltip.enabled && w.globals.axisCharts;
        this.yaxisTooltips = w.config.yaxis.map(function (y, i) {
          return y.show && y.tooltip.enabled && w.globals.axisCharts ? true : false;
        });
        this.allTooltipSeriesGroups = [];
        if (!w.globals.axisCharts) {
          this.showTooltipTitle = false;
        }
        var tooltipEl = document.createElement('div');
        tooltipEl.classList.add('apexcharts-tooltip');
        if (w.config.tooltip.cssClass) {
          tooltipEl.classList.add(w.config.tooltip.cssClass);
        }
        tooltipEl.classList.add("apexcharts-theme-".concat(this.tConfig.theme || 'light'));
        w.globals.dom.elWrap.appendChild(tooltipEl);
        if (w.globals.axisCharts) {
          this.axesTooltip.drawXaxisTooltip();
          this.axesTooltip.drawYaxisTooltip();
          this.axesTooltip.setXCrosshairWidth();
          this.axesTooltip.handleYCrosshair();
          var xAxis = new XAxis(this.ctx);
          this.xAxisTicksPositions = xAxis.getXAxisTicksPositions();
        }

        // we forcefully set intersect true for these conditions
        if ((w.globals.comboCharts || this.tConfig.intersect || w.config.chart.type === 'rangeBar') && !this.tConfig.shared) {
          this.showOnIntersect = true;
        }
        if (w.config.markers.size === 0 || w.globals.markers.largestSize === 0) {
          // when user don't want to show points all the time, but only on when hovering on series
          this.marker.drawDynamicPoints(this);
        }

        // no visible series, exit
        if (w.globals.collapsedSeries.length === w.globals.series.length) return;
        this.dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;
        this.dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;
        if (this.showTooltipTitle) {
          this.tooltipTitle = document.createElement('div');
          this.tooltipTitle.classList.add('apexcharts-tooltip-title');
          this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || w.config.chart.fontFamily;
          this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize;
          tooltipEl.appendChild(this.tooltipTitle);
        }
        var ttItemsCnt = w.globals.series.length; // whether shared or not, default is shared
        if ((w.globals.xyCharts || w.globals.comboCharts) && this.tConfig.shared) {
          if (!this.showOnIntersect) {
            ttItemsCnt = w.globals.series.length;
          } else {
            ttItemsCnt = 1;
          }
        }
        this.legendLabels = w.globals.dom.baseEl.querySelectorAll('.apexcharts-legend-text');
        this.ttItems = this.createTTElements(ttItemsCnt);
        this.addSVGEvents();
      }
    }, {
      key: "createTTElements",
      value: function createTTElements(ttItemsCnt) {
        var _this = this;
        var w = this.w;
        var ttItems = [];
        var tooltipEl = this.getElTooltip();
        var _loop = function _loop(i) {
          var gTxt = document.createElement('div');
          gTxt.classList.add('apexcharts-tooltip-series-group', "apexcharts-tooltip-series-group-".concat(i));
          gTxt.style.order = w.config.tooltip.inverseOrder ? ttItemsCnt - i : i + 1;
          var point = document.createElement('span');
          point.classList.add('apexcharts-tooltip-marker');
          if (w.config.tooltip.fillSeriesColor) {
            point.style.backgroundColor = w.globals.colors[i];
          } else {
            point.style.color = w.globals.colors[i];
          }
          var mShape = w.config.markers.shape;
          var shape = mShape;
          if (Array.isArray(mShape)) {
            shape = mShape[i];
          }
          point.setAttribute('shape', shape);
          gTxt.appendChild(point);
          var gYZ = document.createElement('div');
          gYZ.classList.add('apexcharts-tooltip-text');
          gYZ.style.fontFamily = _this.tConfig.style.fontFamily || w.config.chart.fontFamily;
          gYZ.style.fontSize = _this.tConfig.style.fontSize;
          ['y', 'goals', 'z'].forEach(function (g) {
            var gValText = document.createElement('div');
            gValText.classList.add("apexcharts-tooltip-".concat(g, "-group"));
            var txtLabel = document.createElement('span');
            txtLabel.classList.add("apexcharts-tooltip-text-".concat(g, "-label"));
            gValText.appendChild(txtLabel);
            var txtValue = document.createElement('span');
            txtValue.classList.add("apexcharts-tooltip-text-".concat(g, "-value"));
            gValText.appendChild(txtValue);
            gYZ.appendChild(gValText);
          });
          gTxt.appendChild(gYZ);
          tooltipEl.appendChild(gTxt);
          ttItems.push(gTxt);
        };
        for (var i = 0; i < ttItemsCnt; i++) {
          _loop(i);
        }
        return ttItems;
      }
    }, {
      key: "addSVGEvents",
      value: function addSVGEvents() {
        var w = this.w;
        var type = w.config.chart.type;
        var tooltipEl = this.getElTooltip();
        var commonBar = !!(type === 'bar' || type === 'candlestick' || type === 'boxPlot' || type === 'rangeBar');
        var chartWithmarkers = type === 'area' || type === 'line' || type === 'scatter' || type === 'bubble' || type === 'radar';
        var hoverArea = w.globals.dom.Paper.node;
        var elGrid = this.getElGrid();
        if (elGrid) {
          this.seriesBound = elGrid.getBoundingClientRect();
        }
        var tooltipY = [];
        var tooltipX = [];
        var seriesHoverParams = {
          hoverArea: hoverArea,
          elGrid: elGrid,
          tooltipEl: tooltipEl,
          tooltipY: tooltipY,
          tooltipX: tooltipX,
          ttItems: this.ttItems
        };
        var points;
        if (w.globals.axisCharts) {
          if (chartWithmarkers) {
            points = w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker");
          } else if (commonBar) {
            points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area');
          } else if (type === 'heatmap' || type === 'treemap') {
            points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap');
          }
          if (points && points.length) {
            for (var p = 0; p < points.length; p++) {
              tooltipY.push(points[p].getAttribute('cy'));
              tooltipX.push(points[p].getAttribute('cx'));
            }
          }
        }
        var validSharedChartTypes = w.globals.xyCharts && !this.showOnIntersect || w.globals.comboCharts && !this.showOnIntersect || commonBar && this.tooltipUtil.hasBars() && this.tConfig.shared;
        if (validSharedChartTypes) {
          this.addPathsEventListeners([hoverArea], seriesHoverParams);
        } else if (commonBar && !w.globals.comboCharts || chartWithmarkers && this.showOnIntersect) {
          this.addDatapointEventsListeners(seriesHoverParams);
        } else if (!w.globals.axisCharts || type === 'heatmap' || type === 'treemap') {
          var seriesAll = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series');
          this.addPathsEventListeners(seriesAll, seriesHoverParams);
        }
        if (this.showOnIntersect) {
          var lineAreaPoints = w.globals.dom.baseEl.querySelectorAll('.apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker');
          if (lineAreaPoints.length > 0) {
            // if we find any lineSeries, addEventListeners for them
            this.addPathsEventListeners(lineAreaPoints, seriesHoverParams);
          }

          // combo charts may have bars, so add event listeners here too
          if (this.tooltipUtil.hasBars() && !this.tConfig.shared) {
            this.addDatapointEventsListeners(seriesHoverParams);
          }
        }
      }
    }, {
      key: "drawFixedTooltipRect",
      value: function drawFixedTooltipRect() {
        var w = this.w;
        var tooltipEl = this.getElTooltip();
        var tooltipRect = tooltipEl.getBoundingClientRect();
        var ttWidth = tooltipRect.width + 10;
        var ttHeight = tooltipRect.height + 10;
        var x = this.tConfig.fixed.offsetX;
        var y = this.tConfig.fixed.offsetY;
        var fixed = this.tConfig.fixed.position.toLowerCase();
        if (fixed.indexOf('right') > -1) {
          x = x + w.globals.svgWidth - ttWidth + 10;
        }
        if (fixed.indexOf('bottom') > -1) {
          y = y + w.globals.svgHeight - ttHeight - 10;
        }
        tooltipEl.style.left = x + 'px';
        tooltipEl.style.top = y + 'px';
        return {
          x: x,
          y: y,
          ttWidth: ttWidth,
          ttHeight: ttHeight
        };
      }
    }, {
      key: "addDatapointEventsListeners",
      value: function addDatapointEventsListeners(seriesHoverParams) {
        var w = this.w;
        var points = w.globals.dom.baseEl.querySelectorAll('.apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area');
        this.addPathsEventListeners(points, seriesHoverParams);
      }
    }, {
      key: "addPathsEventListeners",
      value: function addPathsEventListeners(paths, opts) {
        var self = this;
        var _loop2 = function _loop2(p) {
          var extendedOpts = {
            paths: paths[p],
            tooltipEl: opts.tooltipEl,
            tooltipY: opts.tooltipY,
            tooltipX: opts.tooltipX,
            elGrid: opts.elGrid,
            hoverArea: opts.hoverArea,
            ttItems: opts.ttItems
          };
          var events = ['mousemove', 'mouseup', 'touchmove', 'mouseout', 'touchend'];
          events.map(function (ev) {
            return paths[p].addEventListener(ev, self.onSeriesHover.bind(self, extendedOpts), {
              capture: false,
              passive: true
            });
          });
        };
        for (var p = 0; p < paths.length; p++) {
          _loop2(p);
        }
      }

      /*
       ** Check to see if the tooltips should be updated based on a mouse / touch event
       */
    }, {
      key: "onSeriesHover",
      value: function onSeriesHover(opt, e) {
        var _this2 = this;
        // If a user is moving their mouse quickly, don't bother updating the tooltip every single frame

        var targetDelay = 20;
        var timeSinceLastUpdate = Date.now() - this.lastHoverTime;
        if (timeSinceLastUpdate >= targetDelay) {
          // The tooltip was last updated over 100ms ago - redraw it even if the user is still moving their
          // mouse so they get some feedback that their moves are being registered
          this.seriesHover(opt, e);
        } else {
          // The tooltip was last updated less than 100ms ago
          // Cancel any other delayed draw, so we don't show stale data
          clearTimeout(this.seriesHoverTimeout);

          // Schedule the next draw so that it happens about 100ms after the last update
          this.seriesHoverTimeout = setTimeout(function () {
            _this2.seriesHover(opt, e);
          }, targetDelay - timeSinceLastUpdate);
        }
      }

      /*
       ** The actual series hover function
       */
    }, {
      key: "seriesHover",
      value: function seriesHover(opt, e) {
        var _this3 = this;
        this.lastHoverTime = Date.now();
        var chartGroups = [];
        var w = this.w;

        // if user has more than one charts in group, we need to sync
        if (w.config.chart.group) {
          chartGroups = this.ctx.getGroupedCharts();
        }
        if (w.globals.axisCharts && (w.globals.minX === -Infinity && w.globals.maxX === Infinity || w.globals.dataPoints === 0)) {
          return;
        }
        if (chartGroups.length) {
          chartGroups.forEach(function (ch) {
            var tooltipEl = _this3.getElTooltip(ch);
            var newOpts = {
              paths: opt.paths,
              tooltipEl: tooltipEl,
              tooltipY: opt.tooltipY,
              tooltipX: opt.tooltipX,
              elGrid: opt.elGrid,
              hoverArea: opt.hoverArea,
              ttItems: ch.w.globals.tooltip.ttItems
            };

            // all the charts should have the same minX and maxX (same xaxis) for multiple tooltips to work correctly
            if (ch.w.globals.minX === _this3.w.globals.minX && ch.w.globals.maxX === _this3.w.globals.maxX) {
              ch.w.globals.tooltip.seriesHoverByContext({
                chartCtx: ch,
                ttCtx: ch.w.globals.tooltip,
                opt: newOpts,
                e: e
              });
            }
          });
        } else {
          this.seriesHoverByContext({
            chartCtx: this.ctx,
            ttCtx: this.w.globals.tooltip,
            opt: opt,
            e: e
          });
        }
      }
    }, {
      key: "seriesHoverByContext",
      value: function seriesHoverByContext(_ref) {
        var chartCtx = _ref.chartCtx,
          ttCtx = _ref.ttCtx,
          opt = _ref.opt,
          e = _ref.e;
        var w = chartCtx.w;
        var tooltipEl = this.getElTooltip(chartCtx);
        if (!tooltipEl) return;

        // tooltipRect is calculated on every mousemove, because the text is dynamic
        ttCtx.tooltipRect = {
          x: 0,
          y: 0,
          ttWidth: tooltipEl.getBoundingClientRect().width,
          ttHeight: tooltipEl.getBoundingClientRect().height
        };
        ttCtx.e = e;

        // highlight the current hovered bars
        if (ttCtx.tooltipUtil.hasBars() && !w.globals.comboCharts && !ttCtx.isBarShared) {
          if (this.tConfig.onDatasetHover.highlightDataSeries) {
            var series = new Series(chartCtx);
            series.toggleSeriesOnHover(e, e.target.parentNode);
          }
        }
        if (w.globals.axisCharts) {
          ttCtx.axisChartsTooltips({
            e: e,
            opt: opt,
            tooltipRect: ttCtx.tooltipRect
          });
        } else {
          // non-plot charts i.e pie/donut/circle
          ttCtx.nonAxisChartsTooltips({
            e: e,
            opt: opt,
            tooltipRect: ttCtx.tooltipRect
          });
        }
        if (ttCtx.fixedTooltip) {
          ttCtx.drawFixedTooltipRect();
        }
      }

      // tooltip handling for line/area/bar/columns/scatter
    }, {
      key: "axisChartsTooltips",
      value: function axisChartsTooltips(_ref2) {
        var e = _ref2.e,
          opt = _ref2.opt;
        var w = this.w;
        var x, y;
        var seriesBound = opt.elGrid.getBoundingClientRect();
        var clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        var clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
        this.clientY = clientY;
        this.clientX = clientX;
        w.globals.capturedSeriesIndex = -1;
        w.globals.capturedDataPointIndex = -1;
        if (clientY < seriesBound.top || clientY > seriesBound.top + seriesBound.height) {
          this.handleMouseOut(opt);
          return;
        }
        if (Array.isArray(this.tConfig.enabledOnSeries) && !w.config.tooltip.shared) {
          var index = parseInt(opt.paths.getAttribute('index'), 10);
          if (this.tConfig.enabledOnSeries.indexOf(index) < 0) {
            this.handleMouseOut(opt);
            return;
          }
        }
        var tooltipEl = this.getElTooltip();
        var xcrosshairs = this.getElXCrosshairs();
        var syncedCharts = [];
        if (w.config.chart.group) {
          // we need to fallback to sticky tooltip in case charts are synced
          syncedCharts = this.ctx.getSyncedCharts();
        }
        var isStickyTooltip = w.globals.xyCharts || w.config.chart.type === 'bar' && !w.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || w.globals.comboCharts && this.tooltipUtil.hasBars();
        if (e.type === 'mousemove' || e.type === 'touchmove' || e.type === 'mouseup') {
          // there is no series to hover over
          if (w.globals.collapsedSeries.length + w.globals.ancillaryCollapsedSeries.length === w.globals.series.length) {
            return;
          }
          if (xcrosshairs !== null) {
            xcrosshairs.classList.add('apexcharts-active');
          }
          var hasYAxisTooltip = this.yaxisTooltips.filter(function (b) {
            return b === true;
          });
          if (this.ycrosshairs !== null && hasYAxisTooltip.length) {
            this.ycrosshairs.classList.add('apexcharts-active');
          }
          if (isStickyTooltip && !this.showOnIntersect || syncedCharts.length > 1) {
            this.handleStickyTooltip(e, clientX, clientY, opt);
          } else {
            if (w.config.chart.type === 'heatmap' || w.config.chart.type === 'treemap') {
              var markerXY = this.intersect.handleHeatTreeTooltip({
                e: e,
                opt: opt,
                x: x,
                y: y,
                type: w.config.chart.type
              });
              x = markerXY.x;
              y = markerXY.y;
              tooltipEl.style.left = x + 'px';
              tooltipEl.style.top = y + 'px';
            } else {
              if (this.tooltipUtil.hasBars()) {
                this.intersect.handleBarTooltip({
                  e: e,
                  opt: opt
                });
              }
              if (this.tooltipUtil.hasMarkers()) {
                // intersect - line/area/scatter/bubble
                this.intersect.handleMarkerTooltip({
                  e: e,
                  opt: opt,
                  x: x,
                  y: y
                });
              }
            }
          }
          if (this.yaxisTooltips.length) {
            for (var yt = 0; yt < w.config.yaxis.length; yt++) {
              this.axesTooltip.drawYaxisTooltipText(yt, clientY, this.xyRatios);
            }
          }
          w.globals.dom.baseEl.classList.add('apexcharts-tooltip-active');
          opt.tooltipEl.classList.add('apexcharts-active');
        } else if (e.type === 'mouseout' || e.type === 'touchend') {
          this.handleMouseOut(opt);
        }
      }

      // tooltip handling for pie/donuts
    }, {
      key: "nonAxisChartsTooltips",
      value: function nonAxisChartsTooltips(_ref3) {
        var e = _ref3.e,
          opt = _ref3.opt,
          tooltipRect = _ref3.tooltipRect;
        var w = this.w;
        var rel = opt.paths.getAttribute('rel');
        var tooltipEl = this.getElTooltip();
        var seriesBound = w.globals.dom.elWrap.getBoundingClientRect();
        if (e.type === 'mousemove' || e.type === 'touchmove') {
          w.globals.dom.baseEl.classList.add('apexcharts-tooltip-active');
          tooltipEl.classList.add('apexcharts-active');
          this.tooltipLabels.drawSeriesTexts({
            ttItems: opt.ttItems,
            i: parseInt(rel, 10) - 1,
            shared: false
          });
          var x = w.globals.clientX - seriesBound.left - tooltipRect.ttWidth / 2;
          var y = w.globals.clientY - seriesBound.top - tooltipRect.ttHeight - 10;
          tooltipEl.style.left = x + 'px';
          tooltipEl.style.top = y + 'px';
          if (w.config.legend.tooltipHoverFormatter) {
            var legendFormatter = w.config.legend.tooltipHoverFormatter;
            var i = rel - 1;
            var legendName = this.legendLabels[i].getAttribute('data:default-text');
            var text = legendFormatter(legendName, {
              seriesIndex: i,
              dataPointIndex: i,
              w: w
            });
            this.legendLabels[i].innerHTML = text;
          }
        } else if (e.type === 'mouseout' || e.type === 'touchend') {
          tooltipEl.classList.remove('apexcharts-active');
          w.globals.dom.baseEl.classList.remove('apexcharts-tooltip-active');
          if (w.config.legend.tooltipHoverFormatter) {
            this.legendLabels.forEach(function (l) {
              var defaultText = l.getAttribute('data:default-text');
              l.innerHTML = decodeURIComponent(defaultText);
            });
          }
        }
      }
    }, {
      key: "handleStickyTooltip",
      value: function handleStickyTooltip(e, clientX, clientY, opt) {
        var w = this.w;
        var capj = this.tooltipUtil.getNearestValues({
          context: this,
          hoverArea: opt.hoverArea,
          elGrid: opt.elGrid,
          clientX: clientX,
          clientY: clientY
        });
        var j = capj.j;
        var capturedSeries = capj.capturedSeries;
        if (w.globals.collapsedSeriesIndices.includes(capturedSeries)) capturedSeries = null;
        var bounds = opt.elGrid.getBoundingClientRect();
        if (capj.hoverX < 0 || capj.hoverX > bounds.width) {
          this.handleMouseOut(opt);
          return;
        }
        if (capturedSeries !== null) {
          this.handleStickyCapturedSeries(e, capturedSeries, opt, j);
        } else {
          // couldn't capture any series. check if shared X is same,
          // if yes, draw a grouped tooltip
          if (this.tooltipUtil.isXoverlap(j) || w.globals.isBarHorizontal) {
            var firstVisibleSeries = w.globals.series.findIndex(function (s, i) {
              return !w.globals.collapsedSeriesIndices.includes(i);
            });
            this.create(e, this, firstVisibleSeries, j, opt.ttItems);
          }
        }
      }
    }, {
      key: "handleStickyCapturedSeries",
      value: function handleStickyCapturedSeries(e, capturedSeries, opt, j) {
        var w = this.w;
        if (!this.tConfig.shared) {
          var ignoreNull = w.globals.series[capturedSeries][j] === null;
          if (ignoreNull) {
            this.handleMouseOut(opt);
            return;
          }
        }
        if (typeof w.globals.series[capturedSeries][j] !== 'undefined') {
          if (this.tConfig.shared && this.tooltipUtil.isXoverlap(j) && this.tooltipUtil.isInitialSeriesSameLen()) {
            this.create(e, this, capturedSeries, j, opt.ttItems);
          } else {
            this.create(e, this, capturedSeries, j, opt.ttItems, false);
          }
        } else {
          if (this.tooltipUtil.isXoverlap(j)) {
            var firstVisibleSeries = w.globals.series.findIndex(function (s, i) {
              return !w.globals.collapsedSeriesIndices.includes(i);
            });
            this.create(e, this, firstVisibleSeries, j, opt.ttItems);
          }
        }
      }
    }, {
      key: "deactivateHoverFilter",
      value: function deactivateHoverFilter() {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var allPaths = w.globals.dom.Paper.find(".apexcharts-bar-area");
        for (var b = 0; b < allPaths.length; b++) {
          graphics.pathMouseLeave(allPaths[b]);
        }
      }
    }, {
      key: "handleMouseOut",
      value: function handleMouseOut(opt) {
        var w = this.w;
        var xcrosshairs = this.getElXCrosshairs();
        w.globals.dom.baseEl.classList.remove('apexcharts-tooltip-active');
        opt.tooltipEl.classList.remove('apexcharts-active');
        this.deactivateHoverFilter();
        if (w.config.chart.type !== 'bubble') {
          this.marker.resetPointsSize();
        }
        if (xcrosshairs !== null) {
          xcrosshairs.classList.remove('apexcharts-active');
        }
        if (this.ycrosshairs !== null) {
          this.ycrosshairs.classList.remove('apexcharts-active');
        }
        if (this.isXAxisTooltipEnabled) {
          this.xaxisTooltip.classList.remove('apexcharts-active');
        }
        if (this.yaxisTooltips.length) {
          if (this.yaxisTTEls === null) {
            this.yaxisTTEls = w.globals.dom.baseEl.querySelectorAll('.apexcharts-yaxistooltip');
          }
          for (var i = 0; i < this.yaxisTTEls.length; i++) {
            this.yaxisTTEls[i].classList.remove('apexcharts-active');
          }
        }
        if (w.config.legend.tooltipHoverFormatter) {
          this.legendLabels.forEach(function (l) {
            var defaultText = l.getAttribute('data:default-text');
            l.innerHTML = decodeURIComponent(defaultText);
          });
        }
      }
    }, {
      key: "markerClick",
      value: function markerClick(e, seriesIndex, dataPointIndex) {
        var w = this.w;
        if (typeof w.config.chart.events.markerClick === 'function') {
          w.config.chart.events.markerClick(e, this.ctx, {
            seriesIndex: seriesIndex,
            dataPointIndex: dataPointIndex,
            w: w
          });
        }
        this.ctx.events.fireEvent('markerClick', [e, this.ctx, {
          seriesIndex: seriesIndex,
          dataPointIndex: dataPointIndex,
          w: w
        }]);
      }
    }, {
      key: "create",
      value: function create(e, context, capturedSeries, j, ttItems) {
        var _w$globals$seriesRang, _w$globals$seriesRang2, _w$globals$seriesRang3, _w$globals$seriesRang4, _w$globals$seriesRang5, _w$globals$seriesRang6, _w$globals$seriesRang7, _w$globals$seriesRang8, _w$globals$seriesRang9, _w$globals$seriesRang10, _w$globals$seriesRang11, _w$globals$seriesRang12, _w$globals$seriesRang13, _w$globals$seriesRang14, _w$globals$seriesRang15, _w$globals$seriesRang16;
        var shared = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
        var w = this.w;
        var ttCtx = context;
        if (e.type === 'mouseup') {
          this.markerClick(e, capturedSeries, j);
        }
        if (shared === null) shared = this.tConfig.shared;
        var hasMarkers = this.tooltipUtil.hasMarkers(capturedSeries);
        var bars = this.tooltipUtil.getElBars();
        var handlePoints = function handlePoints() {
          if (w.globals.markers.largestSize > 0) {
            ttCtx.marker.enlargePoints(j);
          } else {
            ttCtx.tooltipPosition.moveDynamicPointsOnHover(j);
          }
        };
        if (w.config.legend.tooltipHoverFormatter) {
          var legendFormatter = w.config.legend.tooltipHoverFormatter;
          var els = Array.from(this.legendLabels);

          // reset all legend values first
          els.forEach(function (l) {
            var legendName = l.getAttribute('data:default-text');
            l.innerHTML = decodeURIComponent(legendName);
          });

          // for irregular time series
          for (var i = 0; i < els.length; i++) {
            var l = els[i];
            var lsIndex = parseInt(l.getAttribute('i'), 10);
            var legendName = decodeURIComponent(l.getAttribute('data:default-text'));
            var text = legendFormatter(legendName, {
              seriesIndex: shared ? lsIndex : capturedSeries,
              dataPointIndex: j,
              w: w
            });
            if (!shared) {
              l.innerHTML = lsIndex === capturedSeries ? text : legendName;
              if (capturedSeries === lsIndex) {
                break;
              }
            } else {
              l.innerHTML = w.globals.collapsedSeriesIndices.indexOf(lsIndex) < 0 ? text : legendName;
            }
          }
        }
        var commonSeriesTextsParams = _objectSpread2(_objectSpread2({
          ttItems: ttItems,
          i: capturedSeries,
          j: j
        }, typeof ((_w$globals$seriesRang = w.globals.seriesRange) === null || _w$globals$seriesRang === void 0 ? void 0 : (_w$globals$seriesRang2 = _w$globals$seriesRang[capturedSeries]) === null || _w$globals$seriesRang2 === void 0 ? void 0 : (_w$globals$seriesRang3 = _w$globals$seriesRang2[j]) === null || _w$globals$seriesRang3 === void 0 ? void 0 : (_w$globals$seriesRang4 = _w$globals$seriesRang3.y[0]) === null || _w$globals$seriesRang4 === void 0 ? void 0 : _w$globals$seriesRang4.y1) !== 'undefined' && {
          y1: (_w$globals$seriesRang5 = w.globals.seriesRange) === null || _w$globals$seriesRang5 === void 0 ? void 0 : (_w$globals$seriesRang6 = _w$globals$seriesRang5[capturedSeries]) === null || _w$globals$seriesRang6 === void 0 ? void 0 : (_w$globals$seriesRang7 = _w$globals$seriesRang6[j]) === null || _w$globals$seriesRang7 === void 0 ? void 0 : (_w$globals$seriesRang8 = _w$globals$seriesRang7.y[0]) === null || _w$globals$seriesRang8 === void 0 ? void 0 : _w$globals$seriesRang8.y1
        }), typeof ((_w$globals$seriesRang9 = w.globals.seriesRange) === null || _w$globals$seriesRang9 === void 0 ? void 0 : (_w$globals$seriesRang10 = _w$globals$seriesRang9[capturedSeries]) === null || _w$globals$seriesRang10 === void 0 ? void 0 : (_w$globals$seriesRang11 = _w$globals$seriesRang10[j]) === null || _w$globals$seriesRang11 === void 0 ? void 0 : (_w$globals$seriesRang12 = _w$globals$seriesRang11.y[0]) === null || _w$globals$seriesRang12 === void 0 ? void 0 : _w$globals$seriesRang12.y2) !== 'undefined' && {
          y2: (_w$globals$seriesRang13 = w.globals.seriesRange) === null || _w$globals$seriesRang13 === void 0 ? void 0 : (_w$globals$seriesRang14 = _w$globals$seriesRang13[capturedSeries]) === null || _w$globals$seriesRang14 === void 0 ? void 0 : (_w$globals$seriesRang15 = _w$globals$seriesRang14[j]) === null || _w$globals$seriesRang15 === void 0 ? void 0 : (_w$globals$seriesRang16 = _w$globals$seriesRang15.y[0]) === null || _w$globals$seriesRang16 === void 0 ? void 0 : _w$globals$seriesRang16.y2
        });
        if (shared) {
          ttCtx.tooltipLabels.drawSeriesTexts(_objectSpread2(_objectSpread2({}, commonSeriesTextsParams), {}, {
            shared: this.showOnIntersect ? false : this.tConfig.shared
          }));
          if (hasMarkers) {
            handlePoints();
          } else if (this.tooltipUtil.hasBars()) {
            this.barSeriesHeight = this.tooltipUtil.getBarsHeight(bars);
            if (this.barSeriesHeight > 0) {
              // hover state, activate snap filter
              var graphics = new Graphics(this.ctx);
              var paths = w.globals.dom.Paper.find(".apexcharts-bar-area[j='".concat(j, "']"));

              // de-activate first
              this.deactivateHoverFilter();
              var points = ttCtx.tooltipUtil.getAllMarkers(true);
              if (points.length && !this.barSeriesHeight) {
                handlePoints();
              }
              ttCtx.tooltipPosition.moveStickyTooltipOverBars(j, capturedSeries);
              for (var b = 0; b < paths.length; b++) {
                graphics.pathMouseEnter(paths[b]);
              }
            }
          }
        } else {
          ttCtx.tooltipLabels.drawSeriesTexts(_objectSpread2({
            shared: false
          }, commonSeriesTextsParams));
          if (this.tooltipUtil.hasBars()) {
            ttCtx.tooltipPosition.moveStickyTooltipOverBars(j, capturedSeries);
          }
          if (hasMarkers) {
            ttCtx.tooltipPosition.moveMarkers(capturedSeries, j);
          }
        }
      }
    }]);
    return Tooltip;
  }();

  var BarDataLabels = /*#__PURE__*/function () {
    function BarDataLabels(barCtx) {
      _classCallCheck(this, BarDataLabels);
      this.w = barCtx.w;
      this.barCtx = barCtx;
      this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter;
      if (!this.totalFormatter) {
        this.totalFormatter = this.w.config.dataLabels.formatter;
      }
    }
    /** handleBarDataLabels is used to calculate the positions for the data-labels
     * It also sets the element's data attr for bars and calls drawCalculatedBarDataLabels()
     * After calculating, it also calls the function to draw data labels
     * @memberof Bar
     * @param {object} {barProps} most of the bar properties used throughout the bar
     * drawing function
     * @return {object} dataLabels node-element which you can append later
     **/
    _createClass(BarDataLabels, [{
      key: "handleBarDataLabels",
      value: function handleBarDataLabels(opts) {
        var x = opts.x,
          y = opts.y,
          y1 = opts.y1,
          y2 = opts.y2,
          i = opts.i,
          j = opts.j,
          realIndex = opts.realIndex,
          columnGroupIndex = opts.columnGroupIndex,
          series = opts.series,
          barHeight = opts.barHeight,
          barWidth = opts.barWidth,
          barXPosition = opts.barXPosition,
          barYPosition = opts.barYPosition,
          visibleSeries = opts.visibleSeries;
        var w = this.w;
        var graphics = new Graphics(this.barCtx.ctx);
        var strokeWidth = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[realIndex] : this.barCtx.strokeWidth;
        var bcx;
        var bcy;
        if (w.globals.isXNumeric && !w.globals.isBarHorizontal) {
          bcx = x + parseFloat(barWidth * (visibleSeries + 1));
          bcy = y + parseFloat(barHeight * (visibleSeries + 1)) - strokeWidth;
        } else {
          bcx = x + parseFloat(barWidth * visibleSeries);
          bcy = y + parseFloat(barHeight * visibleSeries);
        }
        var dataLabels = null;
        var totalDataLabels = null;
        var dataLabelsX = x;
        var dataLabelsY = y;
        var dataLabelsPos = {};
        var dataLabelsConfig = w.config.dataLabels;
        var barDataLabelsConfig = this.barCtx.barOptions.dataLabels;
        var barTotalDataLabelsConfig = this.barCtx.barOptions.dataLabels.total;
        if (typeof barYPosition !== 'undefined' && this.barCtx.isRangeBar) {
          bcy = barYPosition;
          dataLabelsY = barYPosition;
        }
        if (typeof barXPosition !== 'undefined' && this.barCtx.isVerticalGroupedRangeBar) {
          bcx = barXPosition;
          dataLabelsX = barXPosition;
        }
        var offX = dataLabelsConfig.offsetX;
        var offY = dataLabelsConfig.offsetY;
        var textRects = {
          width: 0,
          height: 0
        };
        if (w.config.dataLabels.enabled) {
          var yLabel = w.globals.series[i][j];
          textRects = graphics.getTextRects(w.config.dataLabels.formatter ? w.config.dataLabels.formatter(yLabel, _objectSpread2(_objectSpread2({}, w), {}, {
            seriesIndex: i,
            dataPointIndex: j,
            w: w
          })) : w.globals.yLabelFormatters[0](yLabel), parseFloat(dataLabelsConfig.style.fontSize));
        }
        var params = {
          x: x,
          y: y,
          i: i,
          j: j,
          realIndex: realIndex,
          columnGroupIndex: columnGroupIndex,
          bcx: bcx,
          bcy: bcy,
          barHeight: barHeight,
          barWidth: barWidth,
          textRects: textRects,
          strokeWidth: strokeWidth,
          dataLabelsX: dataLabelsX,
          dataLabelsY: dataLabelsY,
          dataLabelsConfig: dataLabelsConfig,
          barDataLabelsConfig: barDataLabelsConfig,
          barTotalDataLabelsConfig: barTotalDataLabelsConfig,
          offX: offX,
          offY: offY
        };
        if (this.barCtx.isHorizontal) {
          dataLabelsPos = this.calculateBarsDataLabelsPosition(params);
        } else {
          dataLabelsPos = this.calculateColumnsDataLabelsPosition(params);
        }
        dataLabels = this.drawCalculatedDataLabels({
          x: dataLabelsPos.dataLabelsX,
          y: dataLabelsPos.dataLabelsY,
          val: this.barCtx.isRangeBar ? [y1, y2] : w.config.chart.stackType === '100%' ? series[realIndex][j] : w.globals.series[realIndex][j],
          i: realIndex,
          j: j,
          barWidth: barWidth,
          barHeight: barHeight,
          textRects: textRects,
          dataLabelsConfig: dataLabelsConfig
        });
        if (w.config.chart.stacked && barTotalDataLabelsConfig.enabled) {
          totalDataLabels = this.drawTotalDataLabels({
            x: dataLabelsPos.totalDataLabelsX,
            y: dataLabelsPos.totalDataLabelsY,
            barWidth: barWidth,
            barHeight: barHeight,
            realIndex: realIndex,
            textAnchor: dataLabelsPos.totalDataLabelsAnchor,
            val: this.getStackedTotalDataLabel({
              realIndex: realIndex,
              j: j
            }),
            dataLabelsConfig: dataLabelsConfig,
            barTotalDataLabelsConfig: barTotalDataLabelsConfig
          });
        }
        return {
          dataLabelsPos: dataLabelsPos,
          dataLabels: dataLabels,
          totalDataLabels: totalDataLabels
        };
      }
    }, {
      key: "getStackedTotalDataLabel",
      value: function getStackedTotalDataLabel(_ref) {
        var realIndex = _ref.realIndex,
          j = _ref.j;
        var w = this.w;
        var val = this.barCtx.stackedSeriesTotals[j];
        if (this.totalFormatter) {
          val = this.totalFormatter(val, _objectSpread2(_objectSpread2({}, w), {}, {
            seriesIndex: realIndex,
            dataPointIndex: j,
            w: w
          }));
        }
        return val;
      }
    }, {
      key: "calculateColumnsDataLabelsPosition",
      value: function calculateColumnsDataLabelsPosition(opts) {
        var _this = this;
        var w = this.w;
        var i = opts.i,
          j = opts.j,
          realIndex = opts.realIndex;
          opts.columnGroupIndex;
          var y = opts.y,
          bcx = opts.bcx,
          barWidth = opts.barWidth,
          barHeight = opts.barHeight,
          textRects = opts.textRects,
          dataLabelsX = opts.dataLabelsX,
          dataLabelsY = opts.dataLabelsY,
          dataLabelsConfig = opts.dataLabelsConfig,
          barDataLabelsConfig = opts.barDataLabelsConfig,
          barTotalDataLabelsConfig = opts.barTotalDataLabelsConfig,
          strokeWidth = opts.strokeWidth,
          offX = opts.offX,
          offY = opts.offY;
        var totalDataLabelsY;
        var totalDataLabelsX;
        var totalDataLabelsAnchor = 'middle';
        var totalDataLabelsBcx = bcx;
        barHeight = Math.abs(barHeight);
        var vertical = w.config.plotOptions.bar.dataLabels.orientation === 'vertical';
        var _this$barCtx$barHelpe = this.barCtx.barHelpers.getZeroValueEncounters({
            i: i,
            j: j
          }),
          zeroEncounters = _this$barCtx$barHelpe.zeroEncounters;
        bcx = bcx - strokeWidth / 2;
        var dataPointsDividedWidth = w.globals.gridWidth / w.globals.dataPoints;
        if (this.barCtx.isVerticalGroupedRangeBar) {
          dataLabelsX += barWidth / 2;
        } else {
          if (w.globals.isXNumeric) {
            dataLabelsX = bcx - barWidth / 2 + offX;
          } else {
            dataLabelsX = bcx - dataPointsDividedWidth + barWidth / 2 + offX;
          }
          if (!w.config.chart.stacked && zeroEncounters > 0 && w.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
            dataLabelsX -= barWidth * zeroEncounters;
          }
        }
        if (vertical) {
          var offsetDLX = 2;
          dataLabelsX = dataLabelsX + textRects.height / 2 - strokeWidth / 2 - offsetDLX;
        }
        var valIsNegative = w.globals.series[i][j] < 0;
        var newY = y;
        if (this.barCtx.isReversed) {
          newY = y + (valIsNegative ? barHeight : -barHeight);
        }
        switch (barDataLabelsConfig.position) {
          case 'center':
            if (vertical) {
              if (valIsNegative) {
                dataLabelsY = newY - barHeight / 2 + offY;
              } else {
                dataLabelsY = newY + barHeight / 2 - offY;
              }
            } else {
              if (valIsNegative) {
                dataLabelsY = newY - barHeight / 2 + textRects.height / 2 + offY;
              } else {
                dataLabelsY = newY + barHeight / 2 + textRects.height / 2 - offY;
              }
            }
            break;
          case 'bottom':
            if (vertical) {
              if (valIsNegative) {
                dataLabelsY = newY - barHeight + offY;
              } else {
                dataLabelsY = newY + barHeight - offY;
              }
            } else {
              if (valIsNegative) {
                dataLabelsY = newY - barHeight + textRects.height + strokeWidth + offY;
              } else {
                dataLabelsY = newY + barHeight - textRects.height / 2 + strokeWidth - offY;
              }
            }
            break;
          case 'top':
            if (vertical) {
              if (valIsNegative) {
                dataLabelsY = newY + offY;
              } else {
                dataLabelsY = newY - offY;
              }
            } else {
              if (valIsNegative) {
                dataLabelsY = newY - textRects.height / 2 - offY;
              } else {
                dataLabelsY = newY + textRects.height + offY;
              }
            }
            break;
        }
        var lowestPrevY = newY;
        w.globals.seriesGroups.forEach(function (sg) {
          var _this$barCtx$sg$join;
          (_this$barCtx$sg$join = _this.barCtx[sg.join(',')]) === null || _this$barCtx$sg$join === void 0 ? void 0 : _this$barCtx$sg$join.prevY.forEach(function (arr) {
            if (valIsNegative) {
              lowestPrevY = Math.max(arr[j], lowestPrevY);
            } else {
              lowestPrevY = Math.min(arr[j], lowestPrevY);
            }
          });
        });
        if (this.barCtx.lastActiveBarSerieIndex === realIndex && barTotalDataLabelsConfig.enabled) {
          var ADDITIONAL_OFFY = 18;
          var graphics = new Graphics(this.barCtx.ctx);
          var totalLabeltextRects = graphics.getTextRects(this.getStackedTotalDataLabel({
            realIndex: realIndex,
            j: j
          }), dataLabelsConfig.fontSize);
          if (valIsNegative) {
            totalDataLabelsY = lowestPrevY - totalLabeltextRects.height / 2 - offY - barTotalDataLabelsConfig.offsetY + ADDITIONAL_OFFY;
          } else {
            totalDataLabelsY = lowestPrevY + totalLabeltextRects.height + offY + barTotalDataLabelsConfig.offsetY - ADDITIONAL_OFFY;
          }

          // width divided into equal parts
          var xDivision = dataPointsDividedWidth;
          totalDataLabelsX = totalDataLabelsBcx + (w.globals.isXNumeric ? -barWidth * w.globals.barGroups.length / 2 : w.globals.barGroups.length * barWidth / 2 - (w.globals.barGroups.length - 1) * barWidth - xDivision) + barTotalDataLabelsConfig.offsetX;
        }
        if (!w.config.chart.stacked) {
          if (dataLabelsY < 0) {
            dataLabelsY = 0 + strokeWidth;
          } else if (dataLabelsY + textRects.height / 3 > w.globals.gridHeight) {
            dataLabelsY = w.globals.gridHeight - strokeWidth;
          }
        }
        return {
          bcx: bcx,
          bcy: y,
          dataLabelsX: dataLabelsX,
          dataLabelsY: dataLabelsY,
          totalDataLabelsX: totalDataLabelsX,
          totalDataLabelsY: totalDataLabelsY,
          totalDataLabelsAnchor: totalDataLabelsAnchor
        };
      }
    }, {
      key: "calculateBarsDataLabelsPosition",
      value: function calculateBarsDataLabelsPosition(opts) {
        var _this2 = this;
        var w = this.w;
        var x = opts.x,
          i = opts.i,
          j = opts.j,
          realIndex = opts.realIndex,
          bcy = opts.bcy,
          barHeight = opts.barHeight,
          barWidth = opts.barWidth,
          textRects = opts.textRects,
          dataLabelsX = opts.dataLabelsX,
          strokeWidth = opts.strokeWidth,
          dataLabelsConfig = opts.dataLabelsConfig,
          barDataLabelsConfig = opts.barDataLabelsConfig,
          barTotalDataLabelsConfig = opts.barTotalDataLabelsConfig,
          offX = opts.offX,
          offY = opts.offY;
        var dataPointsDividedHeight = w.globals.gridHeight / w.globals.dataPoints;
        var _this$barCtx$barHelpe2 = this.barCtx.barHelpers.getZeroValueEncounters({
            i: i,
            j: j
          }),
          zeroEncounters = _this$barCtx$barHelpe2.zeroEncounters;
        barWidth = Math.abs(barWidth);
        var dataLabelsY = bcy - (this.barCtx.isRangeBar ? 0 : dataPointsDividedHeight) + barHeight / 2 + textRects.height / 2 + offY - 3;
        if (!w.config.chart.stacked && zeroEncounters > 0 && w.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
          dataLabelsY -= barHeight * zeroEncounters;
        }
        var totalDataLabelsX;
        var totalDataLabelsY;
        var totalDataLabelsAnchor = 'start';
        var valIsNegative = w.globals.series[i][j] < 0;
        var newX = x;
        if (this.barCtx.isReversed) {
          newX = x + (valIsNegative ? -barWidth : barWidth);
          totalDataLabelsAnchor = valIsNegative ? 'start' : 'end';
        }
        switch (barDataLabelsConfig.position) {
          case 'center':
            if (valIsNegative) {
              dataLabelsX = newX + barWidth / 2 - offX;
            } else {
              dataLabelsX = Math.max(textRects.width / 2, newX - barWidth / 2) + offX;
            }
            break;
          case 'bottom':
            if (valIsNegative) {
              dataLabelsX = newX + barWidth - strokeWidth - offX;
            } else {
              dataLabelsX = newX - barWidth + strokeWidth + offX;
            }
            break;
          case 'top':
            if (valIsNegative) {
              dataLabelsX = newX - strokeWidth - offX;
            } else {
              dataLabelsX = newX - strokeWidth + offX;
            }
            break;
        }
        var lowestPrevX = newX;
        w.globals.seriesGroups.forEach(function (sg) {
          var _this2$barCtx$sg$join;
          (_this2$barCtx$sg$join = _this2.barCtx[sg.join(',')]) === null || _this2$barCtx$sg$join === void 0 ? void 0 : _this2$barCtx$sg$join.prevX.forEach(function (arr) {
            if (valIsNegative) {
              lowestPrevX = Math.min(arr[j], lowestPrevX);
            } else {
              lowestPrevX = Math.max(arr[j], lowestPrevX);
            }
          });
        });
        if (this.barCtx.lastActiveBarSerieIndex === realIndex && barTotalDataLabelsConfig.enabled) {
          var graphics = new Graphics(this.barCtx.ctx);
          var totalLabeltextRects = graphics.getTextRects(this.getStackedTotalDataLabel({
            realIndex: realIndex,
            j: j
          }), dataLabelsConfig.fontSize);
          if (valIsNegative) {
            totalDataLabelsX = lowestPrevX - strokeWidth - offX - barTotalDataLabelsConfig.offsetX;
            totalDataLabelsAnchor = 'end';
          } else {
            totalDataLabelsX = lowestPrevX + offX + barTotalDataLabelsConfig.offsetX + (this.barCtx.isReversed ? -(barWidth + strokeWidth) : strokeWidth);
          }
          totalDataLabelsY = dataLabelsY - textRects.height / 2 + totalLabeltextRects.height / 2 + barTotalDataLabelsConfig.offsetY + strokeWidth;
          if (w.globals.barGroups.length > 1) {
            totalDataLabelsY = totalDataLabelsY - w.globals.barGroups.length / 2 * (barHeight / 2);
          }
        }
        if (!w.config.chart.stacked) {
          if (dataLabelsConfig.textAnchor === 'start') {
            if (dataLabelsX - textRects.width < 0) {
              dataLabelsX = valIsNegative ? textRects.width + strokeWidth : strokeWidth;
            } else if (dataLabelsX + textRects.width > w.globals.gridWidth) {
              dataLabelsX = valIsNegative ? w.globals.gridWidth - strokeWidth : w.globals.gridWidth - textRects.width - strokeWidth;
            }
          } else if (dataLabelsConfig.textAnchor === 'middle') {
            if (dataLabelsX - textRects.width / 2 < 0) {
              dataLabelsX = textRects.width / 2 + strokeWidth;
            } else if (dataLabelsX + textRects.width / 2 > w.globals.gridWidth) {
              dataLabelsX = w.globals.gridWidth - textRects.width / 2 - strokeWidth;
            }
          } else if (dataLabelsConfig.textAnchor === 'end') {
            if (dataLabelsX < 1) {
              dataLabelsX = textRects.width + strokeWidth;
            } else if (dataLabelsX + 1 > w.globals.gridWidth) {
              dataLabelsX = w.globals.gridWidth - textRects.width - strokeWidth;
            }
          }
        }
        return {
          bcx: x,
          bcy: bcy,
          dataLabelsX: dataLabelsX,
          dataLabelsY: dataLabelsY,
          totalDataLabelsX: totalDataLabelsX,
          totalDataLabelsY: totalDataLabelsY,
          totalDataLabelsAnchor: totalDataLabelsAnchor
        };
      }
    }, {
      key: "drawCalculatedDataLabels",
      value: function drawCalculatedDataLabels(_ref2) {
        var x = _ref2.x,
          y = _ref2.y,
          val = _ref2.val,
          i = _ref2.i,
          j = _ref2.j,
          textRects = _ref2.textRects,
          barHeight = _ref2.barHeight,
          barWidth = _ref2.barWidth,
          dataLabelsConfig = _ref2.dataLabelsConfig;
        var w = this.w;
        var rotate = 'rotate(0)';
        if (w.config.plotOptions.bar.dataLabels.orientation === 'vertical') rotate = "rotate(-90, ".concat(x, ", ").concat(y, ")");
        var dataLabels = new DataLabels(this.barCtx.ctx);
        var graphics = new Graphics(this.barCtx.ctx);
        var formatter = dataLabelsConfig.formatter;
        var elDataLabelsWrap = null;
        var isSeriesNotCollapsed = w.globals.collapsedSeriesIndices.indexOf(i) > -1;
        if (dataLabelsConfig.enabled && !isSeriesNotCollapsed) {
          elDataLabelsWrap = graphics.group({
            class: 'apexcharts-data-labels',
            transform: rotate
          });
          var text = '';
          if (typeof val !== 'undefined') {
            text = formatter(val, _objectSpread2(_objectSpread2({}, w), {}, {
              seriesIndex: i,
              dataPointIndex: j,
              w: w
            }));
          }
          if (!val && w.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
            text = '';
          }
          var valIsNegative = w.globals.series[i][j] < 0;
          var position = w.config.plotOptions.bar.dataLabels.position;
          if (w.config.plotOptions.bar.dataLabels.orientation === 'vertical') {
            if (position === 'top') {
              if (valIsNegative) dataLabelsConfig.textAnchor = 'end';else dataLabelsConfig.textAnchor = 'start';
            }
            if (position === 'center') {
              dataLabelsConfig.textAnchor = 'middle';
            }
            if (position === 'bottom') {
              if (valIsNegative) dataLabelsConfig.textAnchor = 'end';else dataLabelsConfig.textAnchor = 'start';
            }
          }
          if (this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) {
            // hide the datalabel if it cannot fit into the rect
            var txRect = graphics.getTextRects(text, parseFloat(dataLabelsConfig.style.fontSize));
            if (barWidth < txRect.width) {
              text = '';
            }
          }
          if (w.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) {
            // if there is not enough space to draw the label in the bar/column rect, check hideOverflowingLabels property to prevent overflowing on wrong rect
            // Note: This issue is only seen in stacked charts
            if (this.barCtx.isHorizontal) {
              if (textRects.width / 1.6 > Math.abs(barWidth)) {
                text = '';
              }
            } else {
              if (textRects.height / 1.6 > Math.abs(barHeight)) {
                text = '';
              }
            }
          }
          var modifiedDataLabelsConfig = _objectSpread2({}, dataLabelsConfig);
          if (this.barCtx.isHorizontal) {
            if (val < 0) {
              if (dataLabelsConfig.textAnchor === 'start') {
                modifiedDataLabelsConfig.textAnchor = 'end';
              } else if (dataLabelsConfig.textAnchor === 'end') {
                modifiedDataLabelsConfig.textAnchor = 'start';
              }
            }
          }
          dataLabels.plotDataLabelsText({
            x: x,
            y: y,
            text: text,
            i: i,
            j: j,
            parent: elDataLabelsWrap,
            dataLabelsConfig: modifiedDataLabelsConfig,
            alwaysDrawDataLabel: true,
            offsetCorrection: true
          });
        }
        return elDataLabelsWrap;
      }
    }, {
      key: "drawTotalDataLabels",
      value: function drawTotalDataLabels(_ref3) {
        var x = _ref3.x,
          y = _ref3.y,
          val = _ref3.val,
          realIndex = _ref3.realIndex,
          textAnchor = _ref3.textAnchor,
          barTotalDataLabelsConfig = _ref3.barTotalDataLabelsConfig;
        this.w;
        var graphics = new Graphics(this.barCtx.ctx);
        var totalDataLabelText;
        if (barTotalDataLabelsConfig.enabled && typeof x !== 'undefined' && typeof y !== 'undefined' && this.barCtx.lastActiveBarSerieIndex === realIndex) {
          totalDataLabelText = graphics.drawText({
            x: x,
            y: y,
            foreColor: barTotalDataLabelsConfig.style.color,
            text: val,
            textAnchor: textAnchor,
            fontFamily: barTotalDataLabelsConfig.style.fontFamily,
            fontSize: barTotalDataLabelsConfig.style.fontSize,
            fontWeight: barTotalDataLabelsConfig.style.fontWeight
          });
        }
        return totalDataLabelText;
      }
    }]);
    return BarDataLabels;
  }();

  var Helpers$1 = /*#__PURE__*/function () {
    function Helpers(barCtx) {
      _classCallCheck(this, Helpers);
      this.w = barCtx.w;
      this.barCtx = barCtx;
    }
    _createClass(Helpers, [{
      key: "initVariables",
      value: function initVariables(series) {
        var w = this.w;
        this.barCtx.series = series;
        this.barCtx.totalItems = 0;
        this.barCtx.seriesLen = 0;
        this.barCtx.visibleI = -1; // visible Series
        this.barCtx.visibleItems = 1; // number of visible bars after user zoomed in/out

        for (var sl = 0; sl < series.length; sl++) {
          if (series[sl].length > 0) {
            this.barCtx.seriesLen = this.barCtx.seriesLen + 1;
            this.barCtx.totalItems += series[sl].length;
          }
          if (w.globals.isXNumeric) {
            // get max visible items
            for (var _j = 0; _j < series[sl].length; _j++) {
              if (w.globals.seriesX[sl][_j] > w.globals.minX && w.globals.seriesX[sl][_j] < w.globals.maxX) {
                this.barCtx.visibleItems++;
              }
            }
          } else {
            this.barCtx.visibleItems = w.globals.dataPoints;
          }
        }
        this.arrBorderRadius = this.createBorderRadiusArr(w.globals.series);
        if (Utils$1.isSafari()) {
          // https://github.com/apexcharts/apexcharts.js/issues/4996
          // to temporarily fix the above issue, border radius is disabled
          this.arrBorderRadius = this.arrBorderRadius.map(function (brArr) {
            return brArr.map(function (_) {
              return 'none';
            });
          });
        }
        if (this.barCtx.seriesLen === 0) {
          // A small adjustment when combo charts are used
          this.barCtx.seriesLen = 1;
        }
        this.barCtx.zeroSerieses = [];
        if (!w.globals.comboCharts) {
          this.checkZeroSeries({
            series: series
          });
        }
      }
    }, {
      key: "initialPositions",
      value: function initialPositions(realIndex) {
        var w = this.w;
        var x, y, yDivision, xDivision, barHeight, barWidth, zeroH, zeroW;
        var dataPoints = w.globals.dataPoints;
        if (this.barCtx.isRangeBar) {
          // timeline rangebar chart
          dataPoints = w.globals.labels.length;
        }
        var seriesLen = this.barCtx.seriesLen;
        if (w.config.plotOptions.bar.rangeBarGroupRows) {
          seriesLen = 1;
        }
        if (this.barCtx.isHorizontal) {
          // height divided into equal parts
          yDivision = w.globals.gridHeight / dataPoints;
          barHeight = yDivision / seriesLen;
          if (w.globals.isXNumeric) {
            yDivision = w.globals.gridHeight / this.barCtx.totalItems;
            barHeight = yDivision / this.barCtx.seriesLen;
          }
          barHeight = barHeight * parseInt(this.barCtx.barOptions.barHeight, 10) / 100;
          if (String(this.barCtx.barOptions.barHeight).indexOf('%') === -1) {
            barHeight = parseInt(this.barCtx.barOptions.barHeight, 10);
          }
          zeroW = this.barCtx.baseLineInvertedY + w.globals.padHorizontal + (this.barCtx.isReversed ? w.globals.gridWidth : 0) - (this.barCtx.isReversed ? this.barCtx.baseLineInvertedY * 2 : 0);
          if (this.barCtx.isFunnel) {
            zeroW = w.globals.gridWidth / 2;
          }
          y = (yDivision - barHeight * this.barCtx.seriesLen) / 2;
        } else {
          // width divided into equal parts
          xDivision = w.globals.gridWidth / this.barCtx.visibleItems;
          if (w.config.xaxis.convertedCatToNumeric) {
            xDivision = w.globals.gridWidth / w.globals.dataPoints;
          }
          barWidth = xDivision / seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100;
          if (w.globals.isXNumeric) {
            // max barwidth should be equal to minXDiff to avoid overlap
            var xRatio = this.barCtx.xRatio;
            if (w.globals.minXDiff && w.globals.minXDiff !== 0.5 && w.globals.minXDiff / xRatio > 0) {
              xDivision = w.globals.minXDiff / xRatio;
            }
            barWidth = xDivision / seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100;
            if (barWidth < 1) {
              barWidth = 1;
            }
          }
          if (String(this.barCtx.barOptions.columnWidth).indexOf('%') === -1) {
            barWidth = parseInt(this.barCtx.barOptions.columnWidth, 10);
          }
          zeroH = w.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? w.globals.gridHeight : 0) + (this.barCtx.isReversed ? this.barCtx.baseLineY[this.barCtx.translationsIndex] * 2 : 0);
          if (w.globals.isXNumeric) {
            var xForNumericX = this.barCtx.getBarXForNumericXAxis({
              x: x,
              j: 0,
              realIndex: realIndex,
              barWidth: barWidth
            });
            x = xForNumericX.x;
          } else {
            x = w.globals.padHorizontal + Utils$1.noExponents(xDivision - barWidth * this.barCtx.seriesLen) / 2;
          }
        }
        w.globals.barHeight = barHeight;
        w.globals.barWidth = barWidth;
        return {
          x: x,
          y: y,
          yDivision: yDivision,
          xDivision: xDivision,
          barHeight: barHeight,
          barWidth: barWidth,
          zeroH: zeroH,
          zeroW: zeroW
        };
      }
    }, {
      key: "initializeStackedPrevVars",
      value: function initializeStackedPrevVars(ctx) {
        var w = ctx.w;
        w.globals.seriesGroups.forEach(function (group) {
          if (!ctx[group]) ctx[group] = {};
          ctx[group].prevY = [];
          ctx[group].prevX = [];
          ctx[group].prevYF = [];
          ctx[group].prevXF = [];
          ctx[group].prevYVal = [];
          ctx[group].prevXVal = [];
        });
      }
    }, {
      key: "initializeStackedXYVars",
      value: function initializeStackedXYVars(ctx) {
        var w = ctx.w;
        w.globals.seriesGroups.forEach(function (group) {
          if (!ctx[group]) ctx[group] = {};
          ctx[group].xArrj = [];
          ctx[group].xArrjF = [];
          ctx[group].xArrjVal = [];
          ctx[group].yArrj = [];
          ctx[group].yArrjF = [];
          ctx[group].yArrjVal = [];
        });
      }
    }, {
      key: "getPathFillColor",
      value: function getPathFillColor(series, i, j, realIndex) {
        var _w$config$series$i$da, _w$config$series$i$da2, _w$config$series$i$da3, _w$config$series$i$da4;
        var w = this.w;
        var fill = this.barCtx.ctx.fill;
        var fillColor = null;
        var seriesNumber = this.barCtx.barOptions.distributed ? j : i;
        var useRangeColor = false;
        if (this.barCtx.barOptions.colors.ranges.length > 0) {
          var colorRange = this.barCtx.barOptions.colors.ranges;
          colorRange.map(function (range) {
            if (series[i][j] >= range.from && series[i][j] <= range.to) {
              fillColor = range.color;
              useRangeColor = true;
            }
          });
        }
        var pathFill = fill.fillPath({
          seriesNumber: this.barCtx.barOptions.distributed ? seriesNumber : realIndex,
          dataPointIndex: j,
          color: fillColor,
          value: series[i][j],
          fillConfig: (_w$config$series$i$da = w.config.series[i].data[j]) === null || _w$config$series$i$da === void 0 ? void 0 : _w$config$series$i$da.fill,
          fillType: (_w$config$series$i$da2 = w.config.series[i].data[j]) !== null && _w$config$series$i$da2 !== void 0 && (_w$config$series$i$da3 = _w$config$series$i$da2.fill) !== null && _w$config$series$i$da3 !== void 0 && _w$config$series$i$da3.type ? (_w$config$series$i$da4 = w.config.series[i].data[j]) === null || _w$config$series$i$da4 === void 0 ? void 0 : _w$config$series$i$da4.fill.type : Array.isArray(w.config.fill.type) ? w.config.fill.type[realIndex] : w.config.fill.type
        });
        return {
          color: pathFill,
          useRangeColor: useRangeColor
        };
      }
    }, {
      key: "getStrokeWidth",
      value: function getStrokeWidth(i, j, realIndex) {
        var strokeWidth = 0;
        var w = this.w;
        if (typeof this.barCtx.series[i][j] === 'undefined' || this.barCtx.series[i][j] === null || w.config.chart.type === 'bar' && !this.barCtx.series[i][j]) {
          this.barCtx.isNullValue = true;
        } else {
          this.barCtx.isNullValue = false;
        }
        if (w.config.stroke.show) {
          if (!this.barCtx.isNullValue) {
            strokeWidth = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[realIndex] : this.barCtx.strokeWidth;
          }
        }
        return strokeWidth;
      }
    }, {
      key: "createBorderRadiusArr",
      value: function createBorderRadiusArr(series) {
        var _series$;
        var w = this.w;
        var alwaysApplyRadius = !this.w.config.chart.stacked || w.config.plotOptions.bar.borderRadius <= 0;
        var numSeries = series.length;
        var numColumns = ((_series$ = series[0]) === null || _series$ === void 0 ? void 0 : _series$.length) | 0;
        var output = Array.from({
          length: numSeries
        }, function () {
          return Array(numColumns).fill(alwaysApplyRadius ? 'top' : 'none');
        });
        if (alwaysApplyRadius) return output;
        for (var _j2 = 0; _j2 < numColumns; _j2++) {
          var positiveIndices = [];
          var negativeIndices = [];
          var nonZeroCount = 0;

          // Collect positive and negative indices
          for (var i = 0; i < numSeries; i++) {
            var value = series[i][_j2];
            if (value > 0) {
              positiveIndices.push(i);
              nonZeroCount++;
            } else if (value < 0) {
              negativeIndices.push(i);
              nonZeroCount++;
            }
          }
          if (positiveIndices.length > 0 && negativeIndices.length === 0) {
            // Only positive values in this column
            if (positiveIndices.length === 1) {
              // Single positive value
              output[positiveIndices[0]][_j2] = 'both';
            } else {
              // Multiple positive values
              var firstPositiveIndex = positiveIndices[0];
              var lastPositiveIndex = positiveIndices[positiveIndices.length - 1];
              var _iterator = _createForOfIteratorHelper(positiveIndices),
                _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var _i2 = _step.value;
                  if (_i2 === firstPositiveIndex) {
                    output[_i2][_j2] = 'bottom';
                  } else if (_i2 === lastPositiveIndex) {
                    output[_i2][_j2] = 'top';
                  } else {
                    output[_i2][_j2] = 'none';
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }
          } else if (negativeIndices.length > 0 && positiveIndices.length === 0) {
            // Only negative values in this column
            if (negativeIndices.length === 1) {
              // Single negative value
              output[negativeIndices[0]][_j2] = 'both';
            } else {
              // Multiple negative values
              var highestNegativeIndex = Math.max.apply(Math, negativeIndices);
              var lowestNegativeIndex = Math.min.apply(Math, negativeIndices);
              var _iterator2 = _createForOfIteratorHelper(negativeIndices),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var _i3 = _step2.value;
                  if (_i3 === highestNegativeIndex) {
                    output[_i3][_j2] = 'bottom'; // Closest to axis
                  } else if (_i3 === lowestNegativeIndex) {
                    output[_i3][_j2] = 'top'; // Farthest from axis
                  } else {
                    output[_i3][_j2] = 'none';
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          } else if (positiveIndices.length > 0 && negativeIndices.length > 0) {
            // Mixed positive and negative values
            // Assign 'top' to the last positive bar
            var _lastPositiveIndex = positiveIndices[positiveIndices.length - 1];
            var _iterator3 = _createForOfIteratorHelper(positiveIndices),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _i4 = _step3.value;
                if (_i4 === _lastPositiveIndex) {
                  output[_i4][_j2] = 'top';
                } else {
                  output[_i4][_j2] = 'none';
                }
              }
              // Assign 'bottom' to the highest negative index (closest to axis)
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            var _highestNegativeIndex = Math.max.apply(Math, negativeIndices);
            var _iterator4 = _createForOfIteratorHelper(negativeIndices),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var _i5 = _step4.value;
                if (_i5 === _highestNegativeIndex) {
                  output[_i5][_j2] = 'bottom';
                } else {
                  output[_i5][_j2] = 'none';
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          } else if (nonZeroCount === 1) {
            // Only one non-zero value (either positive or negative)
            var index = positiveIndices[0] || negativeIndices[0];
            output[index][_j2] = 'both';
          }
        }
        return output;
      }
    }, {
      key: "barBackground",
      value: function barBackground(_ref) {
        var j = _ref.j,
          i = _ref.i,
          x1 = _ref.x1,
          x2 = _ref.x2,
          y1 = _ref.y1,
          y2 = _ref.y2,
          elSeries = _ref.elSeries;
        var w = this.w;
        var graphics = new Graphics(this.barCtx.ctx);
        var sr = new Series(this.barCtx.ctx);
        var activeSeriesIndex = sr.getActiveConfigSeriesIndex();
        if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && activeSeriesIndex === i) {
          if (j >= this.barCtx.barOptions.colors.backgroundBarColors.length) {
            j %= this.barCtx.barOptions.colors.backgroundBarColors.length;
          }
          var bcolor = this.barCtx.barOptions.colors.backgroundBarColors[j];
          var rect = graphics.drawRect(typeof x1 !== 'undefined' ? x1 : 0, typeof y1 !== 'undefined' ? y1 : 0, typeof x2 !== 'undefined' ? x2 : w.globals.gridWidth, typeof y2 !== 'undefined' ? y2 : w.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, bcolor, this.barCtx.barOptions.colors.backgroundBarOpacity);
          elSeries.add(rect);
          rect.node.classList.add('apexcharts-backgroundBar');
        }
      }
    }, {
      key: "getColumnPaths",
      value: function getColumnPaths(_ref2) {
        var _w$config$series$real;
        var barWidth = _ref2.barWidth,
          barXPosition = _ref2.barXPosition,
          y1 = _ref2.y1,
          y2 = _ref2.y2,
          strokeWidth = _ref2.strokeWidth,
          isReversed = _ref2.isReversed,
          series = _ref2.series,
          seriesGroup = _ref2.seriesGroup,
          realIndex = _ref2.realIndex,
          i = _ref2.i,
          j = _ref2.j,
          w = _ref2.w;
        var graphics = new Graphics(this.barCtx.ctx);
        strokeWidth = Array.isArray(strokeWidth) ? strokeWidth[realIndex] : strokeWidth;
        if (!strokeWidth) strokeWidth = 0;
        var bW = barWidth;
        var bXP = barXPosition;
        if ((_w$config$series$real = w.config.series[realIndex].data[j]) !== null && _w$config$series$real !== void 0 && _w$config$series$real.columnWidthOffset) {
          bXP = barXPosition - w.config.series[realIndex].data[j].columnWidthOffset / 2;
          bW = barWidth + w.config.series[realIndex].data[j].columnWidthOffset;
        }

        // Center the stroke on the coordinates
        var strokeCenter = strokeWidth / 2;
        var x1 = bXP + strokeCenter;
        var x2 = bXP + bW - strokeCenter;
        var direction = (series[i][j] >= 0 ? 1 : -1) * (isReversed ? -1 : 1);

        // append tiny pixels to avoid exponentials (which cause issues in border-radius)
        y1 += 0.001 - strokeCenter * direction;
        y2 += 0.001 + strokeCenter * direction;
        var pathTo = graphics.move(x1, y1);
        var pathFrom = graphics.move(x1, y1);
        var sl = graphics.line(x2, y1);
        if (w.globals.previousPaths.length > 0) {
          pathFrom = this.barCtx.getPreviousPath(realIndex, j, false);
        }
        pathTo = pathTo + graphics.line(x1, y2) + graphics.line(x2, y2) + sl + (w.config.plotOptions.bar.borderRadiusApplication === 'around' || this.arrBorderRadius[realIndex][j] === 'both' ? ' Z' : ' z');

        // the lines in pathFrom are repeated to equal it to the points of pathTo
        // this is to avoid weird animation (bug in svg.js)
        pathFrom = pathFrom + graphics.line(x1, y1) + sl + sl + sl + sl + sl + graphics.line(x1, y1) + (w.config.plotOptions.bar.borderRadiusApplication === 'around' || this.arrBorderRadius[realIndex][j] === 'both' ? ' Z' : ' z');
        if (this.arrBorderRadius[realIndex][j] !== 'none') {
          pathTo = graphics.roundPathCorners(pathTo, w.config.plotOptions.bar.borderRadius);
        }
        if (w.config.chart.stacked) {
          var _ctx = this.barCtx;
          _ctx = this.barCtx[seriesGroup];
          _ctx.yArrj.push(y2 - strokeCenter * direction);
          _ctx.yArrjF.push(Math.abs(y1 - y2 + strokeWidth * direction));
          _ctx.yArrjVal.push(this.barCtx.series[i][j]);
        }
        return {
          pathTo: pathTo,
          pathFrom: pathFrom
        };
      }
    }, {
      key: "getBarpaths",
      value: function getBarpaths(_ref3) {
        var _w$config$series$real2;
        var barYPosition = _ref3.barYPosition,
          barHeight = _ref3.barHeight,
          x1 = _ref3.x1,
          x2 = _ref3.x2,
          strokeWidth = _ref3.strokeWidth,
          isReversed = _ref3.isReversed,
          series = _ref3.series,
          seriesGroup = _ref3.seriesGroup,
          realIndex = _ref3.realIndex,
          i = _ref3.i,
          j = _ref3.j,
          w = _ref3.w;
        var graphics = new Graphics(this.barCtx.ctx);
        strokeWidth = Array.isArray(strokeWidth) ? strokeWidth[realIndex] : strokeWidth;
        if (!strokeWidth) strokeWidth = 0;
        var bYP = barYPosition;
        var bH = barHeight;
        if ((_w$config$series$real2 = w.config.series[realIndex].data[j]) !== null && _w$config$series$real2 !== void 0 && _w$config$series$real2.barHeightOffset) {
          bYP = barYPosition - w.config.series[realIndex].data[j].barHeightOffset / 2;
          bH = barHeight + w.config.series[realIndex].data[j].barHeightOffset;
        }

        // Center the stroke on the coordinates
        var strokeCenter = strokeWidth / 2;
        var y1 = bYP + strokeCenter;
        var y2 = bYP + bH - strokeCenter;
        var direction = (series[i][j] >= 0 ? 1 : -1) * (isReversed ? -1 : 1);

        // append tiny pixels to avoid exponentials (which cause issues in border-radius)
        x1 += 0.001 + strokeCenter * direction;
        x2 += 0.001 - strokeCenter * direction;
        var pathTo = graphics.move(x1, y1);
        var pathFrom = graphics.move(x1, y1);
        if (w.globals.previousPaths.length > 0) {
          pathFrom = this.barCtx.getPreviousPath(realIndex, j, false);
        }
        var sl = graphics.line(x1, y2);
        pathTo = pathTo + graphics.line(x2, y1) + graphics.line(x2, y2) + sl + (w.config.plotOptions.bar.borderRadiusApplication === 'around' || this.arrBorderRadius[realIndex][j] === 'both' ? ' Z' : ' z');
        pathFrom = pathFrom + graphics.line(x1, y1) + sl + sl + sl + sl + sl + graphics.line(x1, y1) + (w.config.plotOptions.bar.borderRadiusApplication === 'around' || this.arrBorderRadius[realIndex][j] === 'both' ? ' Z' : ' z');
        if (this.arrBorderRadius[realIndex][j] !== 'none') {
          pathTo = graphics.roundPathCorners(pathTo, w.config.plotOptions.bar.borderRadius);
        }
        if (w.config.chart.stacked) {
          var _ctx = this.barCtx;
          _ctx = this.barCtx[seriesGroup];
          _ctx.xArrj.push(x2 + strokeCenter * direction);
          _ctx.xArrjF.push(Math.abs(x1 - x2 - strokeWidth * direction));
          _ctx.xArrjVal.push(this.barCtx.series[i][j]);
        }
        return {
          pathTo: pathTo,
          pathFrom: pathFrom
        };
      }
    }, {
      key: "checkZeroSeries",
      value: function checkZeroSeries(_ref4) {
        var series = _ref4.series;
        var w = this.w;
        for (var zs = 0; zs < series.length; zs++) {
          var total = 0;
          for (var zsj = 0; zsj < series[w.globals.maxValsInArrayIndex].length; zsj++) {
            total += series[zs][zsj];
          }
          if (total === 0) {
            this.barCtx.zeroSerieses.push(zs);
          }
        }
      }
    }, {
      key: "getXForValue",
      value: function getXForValue(value, zeroW) {
        var zeroPositionForNull = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var xForVal = zeroPositionForNull ? zeroW : null;
        if (typeof value !== 'undefined' && value !== null) {
          xForVal = zeroW + value / this.barCtx.invertedYRatio - (this.barCtx.isReversed ? value / this.barCtx.invertedYRatio : 0) * 2;
        }
        return xForVal;
      }
    }, {
      key: "getYForValue",
      value: function getYForValue(value, zeroH, translationsIndex) {
        var zeroPositionForNull = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var yForVal = zeroPositionForNull ? zeroH : null;
        if (typeof value !== 'undefined' && value !== null) {
          yForVal = zeroH - value / this.barCtx.yRatio[translationsIndex] + (this.barCtx.isReversed ? value / this.barCtx.yRatio[translationsIndex] : 0) * 2;
        }
        return yForVal;
      }
    }, {
      key: "getGoalValues",
      value: function getGoalValues(type, zeroW, zeroH, i, j, translationsIndex) {
        var _this = this;
        var w = this.w;
        var goals = [];
        var pushGoal = function pushGoal(value, attrs) {
          var _goals$push;
          goals.push((_goals$push = {}, _defineProperty(_goals$push, type, type === 'x' ? _this.getXForValue(value, zeroW, false) : _this.getYForValue(value, zeroH, translationsIndex, false)), _defineProperty(_goals$push, "attrs", attrs), _goals$push));
        };
        if (w.globals.seriesGoals[i] && w.globals.seriesGoals[i][j] && Array.isArray(w.globals.seriesGoals[i][j])) {
          w.globals.seriesGoals[i][j].forEach(function (goal) {
            pushGoal(goal.value, goal);
          });
        }
        if (this.barCtx.barOptions.isDumbbell && w.globals.seriesRange.length) {
          var colors = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : w.globals.colors;
          var commonAttrs = {
            strokeHeight: type === 'x' ? 0 : w.globals.markers.size[i],
            strokeWidth: type === 'x' ? w.globals.markers.size[i] : 0,
            strokeDashArray: 0,
            strokeLineCap: 'round',
            strokeColor: Array.isArray(colors[i]) ? colors[i][0] : colors[i]
          };
          pushGoal(w.globals.seriesRangeStart[i][j], commonAttrs);
          pushGoal(w.globals.seriesRangeEnd[i][j], _objectSpread2(_objectSpread2({}, commonAttrs), {}, {
            strokeColor: Array.isArray(colors[i]) ? colors[i][1] : colors[i]
          }));
        }
        return goals;
      }
    }, {
      key: "drawGoalLine",
      value: function drawGoalLine(_ref5) {
        var barXPosition = _ref5.barXPosition,
          barYPosition = _ref5.barYPosition,
          goalX = _ref5.goalX,
          goalY = _ref5.goalY,
          barWidth = _ref5.barWidth,
          barHeight = _ref5.barHeight;
        var graphics = new Graphics(this.barCtx.ctx);
        var lineGroup = graphics.group({
          className: 'apexcharts-bar-goals-groups'
        });
        lineGroup.node.classList.add('apexcharts-element-hidden');
        this.barCtx.w.globals.delayedElements.push({
          el: lineGroup.node
        });
        lineGroup.attr('clip-path', "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
        var line = null;
        if (this.barCtx.isHorizontal) {
          if (Array.isArray(goalX)) {
            goalX.forEach(function (goal) {
              // Need a tiny margin of 1 each side so goals don't disappear at extremeties
              if (goal.x >= -1 && goal.x <= graphics.w.globals.gridWidth + 1) {
                var sHeight = typeof goal.attrs.strokeHeight !== 'undefined' ? goal.attrs.strokeHeight : barHeight / 2;
                var y = barYPosition + sHeight + barHeight / 2;
                line = graphics.drawLine(goal.x, y - sHeight * 2, goal.x, y, goal.attrs.strokeColor ? goal.attrs.strokeColor : undefined, goal.attrs.strokeDashArray, goal.attrs.strokeWidth ? goal.attrs.strokeWidth : 2, goal.attrs.strokeLineCap);
                lineGroup.add(line);
              }
            });
          }
        } else {
          if (Array.isArray(goalY)) {
            goalY.forEach(function (goal) {
              // Need a tiny margin of 1 each side so goals don't disappear at extremeties
              if (goal.y >= -1 && goal.y <= graphics.w.globals.gridHeight + 1) {
                var sWidth = typeof goal.attrs.strokeWidth !== 'undefined' ? goal.attrs.strokeWidth : barWidth / 2;
                var x = barXPosition + sWidth + barWidth / 2;
                line = graphics.drawLine(x - sWidth * 2, goal.y, x, goal.y, goal.attrs.strokeColor ? goal.attrs.strokeColor : undefined, goal.attrs.strokeDashArray, goal.attrs.strokeHeight ? goal.attrs.strokeHeight : 2, goal.attrs.strokeLineCap);
                lineGroup.add(line);
              }
            });
          }
        }
        return lineGroup;
      }
    }, {
      key: "drawBarShadow",
      value: function drawBarShadow(_ref6) {
        var prevPaths = _ref6.prevPaths,
          currPaths = _ref6.currPaths,
          color = _ref6.color;
        var w = this.w;
        var prevX2 = prevPaths.x,
          prevX1 = prevPaths.x1,
          prevY1 = prevPaths.barYPosition;
        var currX2 = currPaths.x,
          currX1 = currPaths.x1,
          currY1 = currPaths.barYPosition;
        var prevY2 = prevY1 + currPaths.barHeight;
        var graphics = new Graphics(this.barCtx.ctx);
        var utils = new Utils$1();
        var shadowPath = graphics.move(prevX1, prevY2) + graphics.line(prevX2, prevY2) + graphics.line(currX2, currY1) + graphics.line(currX1, currY1) + graphics.line(prevX1, prevY2) + (w.config.plotOptions.bar.borderRadiusApplication === 'around' || this.arrBorderRadius[realIndex][j] === 'both' ? ' Z' : ' z');
        return graphics.drawPath({
          d: shadowPath,
          fill: utils.shadeColor(0.5, Utils$1.rgb2hex(color)),
          stroke: 'none',
          strokeWidth: 0,
          fillOpacity: 1,
          classes: 'apexcharts-bar-shadow apexcharts-decoration-element'
        });
      }
    }, {
      key: "getZeroValueEncounters",
      value: function getZeroValueEncounters(_ref7) {
        var _w$globals$columnSeri;
        var i = _ref7.i,
          j = _ref7.j;
        var w = this.w;
        var nonZeroColumns = 0;
        var zeroEncounters = 0;
        var seriesIndices = w.config.plotOptions.bar.horizontal ? w.globals.series.map(function (_, _i) {
          return _i;
        }) : ((_w$globals$columnSeri = w.globals.columnSeries) === null || _w$globals$columnSeri === void 0 ? void 0 : _w$globals$columnSeri.i.map(function (_i) {
          return _i;
        })) || [];
        seriesIndices.forEach(function (_si) {
          var val = w.globals.seriesPercent[_si][j];
          if (val) {
            nonZeroColumns++;
          }
          if (_si < i && val === 0) {
            zeroEncounters++;
          }
        });
        return {
          nonZeroColumns: nonZeroColumns,
          zeroEncounters: zeroEncounters
        };
      }
    }, {
      key: "getGroupIndex",
      value: function getGroupIndex(seriesIndex) {
        var w = this.w;
        // groupIndex is the index of group buckets (group1, group2, ...)
        var groupIndex = w.globals.seriesGroups.findIndex(function (group) {
          return (
            // w.config.series[i].name may be undefined, so use
            // w.globals.seriesNames[i], which has default names for those
            // series. w.globals.seriesGroups[] uses the same default naming.
            group.indexOf(w.globals.seriesNames[seriesIndex]) > -1
          );
        });
        // We need the column groups to be indexable as 0,1,2,... for their
        // positioning relative to each other.
        var cGI = this.barCtx.columnGroupIndices;
        var columnGroupIndex = cGI.indexOf(groupIndex);
        if (columnGroupIndex < 0) {
          cGI.push(groupIndex);
          columnGroupIndex = cGI.length - 1;
        }
        return {
          groupIndex: groupIndex,
          columnGroupIndex: columnGroupIndex
        };
      }
    }]);
    return Helpers;
  }();

  /**
   * ApexCharts Bar Class responsible for drawing both Columns and Bars.
   *
   * @module Bar
   **/
  var Bar = /*#__PURE__*/function () {
    function Bar(ctx, xyRatios) {
      _classCallCheck(this, Bar);
      this.ctx = ctx;
      this.w = ctx.w;
      var w = this.w;
      this.barOptions = w.config.plotOptions.bar;
      this.isHorizontal = this.barOptions.horizontal;
      this.strokeWidth = w.config.stroke.width;
      this.isNullValue = false;
      this.isRangeBar = w.globals.seriesRange.length && this.isHorizontal;
      this.isVerticalGroupedRangeBar = !w.globals.isBarHorizontal && w.globals.seriesRange.length && w.config.plotOptions.bar.rangeBarGroupRows;
      this.isFunnel = this.barOptions.isFunnel;
      this.xyRatios = xyRatios;
      if (this.xyRatios !== null) {
        this.xRatio = xyRatios.xRatio;
        this.yRatio = xyRatios.yRatio;
        this.invertedXRatio = xyRatios.invertedXRatio;
        this.invertedYRatio = xyRatios.invertedYRatio;
        this.baseLineY = xyRatios.baseLineY;
        this.baseLineInvertedY = xyRatios.baseLineInvertedY;
      }
      this.yaxisIndex = 0;
      this.translationsIndex = 0;
      this.seriesLen = 0;
      this.pathArr = [];
      var ser = new Series(this.ctx);
      this.lastActiveBarSerieIndex = ser.getActiveConfigSeriesIndex('desc', ['bar', 'column']);
      this.columnGroupIndices = [];
      var barSeriesIndices = ser.getBarSeriesIndices();
      var coreUtils = new CoreUtils(this.ctx);
      this.stackedSeriesTotals = coreUtils.getStackedSeriesTotals(this.w.config.series.map(function (s, i) {
        return barSeriesIndices.indexOf(i) === -1 ? i : -1;
      }).filter(function (s) {
        return s !== -1;
      }));
      this.barHelpers = new Helpers$1(this);
    }

    /** primary draw method which is called on bar object
     * @memberof Bar
     * @param {array} series - user supplied series values
     * @param {int} seriesIndex - the index by which series will be drawn on the svg
     * @return {node} element which is supplied to parent chart draw method for appending
     **/
    _createClass(Bar, [{
      key: "draw",
      value: function draw(series, seriesIndex) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var coreUtils = new CoreUtils(this.ctx, w);
        series = coreUtils.getLogSeries(series);
        this.series = series;
        this.yRatio = coreUtils.getLogYRatios(this.yRatio);
        this.barHelpers.initVariables(series);
        var ret = graphics.group({
          class: 'apexcharts-bar-series apexcharts-plot-series'
        });
        if (w.config.dataLabels.enabled) {
          if (this.totalItems > this.barOptions.dataLabels.maxItems) {
            console.warn('WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts');
          }
        }
        for (var i = 0, bc = 0; i < series.length; i++, bc++) {
          var x = void 0,
            y = void 0,
            xDivision = void 0,
            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)
            yDivision = void 0,
            // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)
            zeroH = void 0,
            // zeroH is the baseline where 0 meets y axis
            zeroW = void 0; // zeroW is the baseline where 0 meets x axis

          var yArrj = []; // hold y values of current iterating series
          var xArrj = []; // hold x values of current iterating series

          var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;
          var _this$barHelpers$getG = this.barHelpers.getGroupIndex(realIndex),
            columnGroupIndex = _this$barHelpers$getG.columnGroupIndex;

          // el to which series will be drawn
          var elSeries = graphics.group({
            class: "apexcharts-series",
            rel: i + 1,
            seriesName: Utils$1.escapeString(w.globals.seriesNames[realIndex]),
            'data:realIndex': realIndex
          });
          this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);
          if (series[i].length > 0) {
            this.visibleI = this.visibleI + 1;
          }
          var barHeight = 0;
          var barWidth = 0;
          if (this.yRatio.length > 1) {
            this.yaxisIndex = w.globals.seriesYAxisReverseMap[realIndex];
            this.translationsIndex = realIndex;
          }
          var translationsIndex = this.translationsIndex;
          this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed;
          var initPositions = this.barHelpers.initialPositions(realIndex);
          y = initPositions.y;
          barHeight = initPositions.barHeight;
          yDivision = initPositions.yDivision;
          zeroW = initPositions.zeroW;
          x = initPositions.x;
          barWidth = initPositions.barWidth;
          xDivision = initPositions.xDivision;
          zeroH = initPositions.zeroH;
          if (!this.isHorizontal) {
            xArrj.push(x + barWidth / 2);
          }

          // eldatalabels
          var elDataLabelsWrap = graphics.group({
            class: 'apexcharts-datalabels',
            'data:realIndex': realIndex
          });
          w.globals.delayedElements.push({
            el: elDataLabelsWrap.node
          });
          elDataLabelsWrap.node.classList.add('apexcharts-element-hidden');
          var elGoalsMarkers = graphics.group({
            class: 'apexcharts-bar-goals-markers'
          });
          var elBarShadows = graphics.group({
            class: 'apexcharts-bar-shadows'
          });
          w.globals.delayedElements.push({
            el: elBarShadows.node
          });
          elBarShadows.node.classList.add('apexcharts-element-hidden');
          for (var j = 0; j < series[i].length; j++) {
            var strokeWidth = this.barHelpers.getStrokeWidth(i, j, realIndex);
            var paths = null;
            var pathsParams = {
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                translationsIndex: translationsIndex,
                bc: bc
              },
              x: x,
              y: y,
              strokeWidth: strokeWidth,
              elSeries: elSeries
            };
            if (this.isHorizontal) {
              paths = this.drawBarPaths(_objectSpread2(_objectSpread2({}, pathsParams), {}, {
                barHeight: barHeight,
                zeroW: zeroW,
                yDivision: yDivision
              }));
              barWidth = this.series[i][j] / this.invertedYRatio;
            } else {
              paths = this.drawColumnPaths(_objectSpread2(_objectSpread2({}, pathsParams), {}, {
                xDivision: xDivision,
                barWidth: barWidth,
                zeroH: zeroH
              }));
              barHeight = this.series[i][j] / this.yRatio[translationsIndex];
            }
            var pathFill = this.barHelpers.getPathFillColor(series, i, j, realIndex);
            if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && j > 0) {
              var _pathFill$color;
              var barShadow = this.barHelpers.drawBarShadow({
                color: typeof pathFill.color === 'string' && ((_pathFill$color = pathFill.color) === null || _pathFill$color === void 0 ? void 0 : _pathFill$color.indexOf('url')) === -1 ? pathFill.color : Utils$1.hexToRgba(w.globals.colors[i]),
                prevPaths: this.pathArr[this.pathArr.length - 1],
                currPaths: paths
              });
              elBarShadows.add(barShadow);
              if (w.config.chart.dropShadow.enabled) {
                var filters = new Filters(this.ctx);
                filters.dropShadow(barShadow, w.config.chart.dropShadow, realIndex);
              }
            }
            this.pathArr.push(paths);
            var barGoalLine = this.barHelpers.drawGoalLine({
              barXPosition: paths.barXPosition,
              barYPosition: paths.barYPosition,
              goalX: paths.goalX,
              goalY: paths.goalY,
              barHeight: barHeight,
              barWidth: barWidth
            });
            if (barGoalLine) {
              elGoalsMarkers.add(barGoalLine);
            }
            y = paths.y;
            x = paths.x;

            // push current X
            if (j > 0) {
              xArrj.push(x + barWidth / 2);
            }
            yArrj.push(y);
            this.renderSeries(_objectSpread2(_objectSpread2({
              realIndex: realIndex,
              pathFill: pathFill.color
            }, pathFill.useRangeColor ? {
              lineFill: pathFill.color
            } : {}), {}, {
              j: j,
              i: i,
              columnGroupIndex: columnGroupIndex,
              pathFrom: paths.pathFrom,
              pathTo: paths.pathTo,
              strokeWidth: strokeWidth,
              elSeries: elSeries,
              x: x,
              y: y,
              series: series,
              barHeight: Math.abs(paths.barHeight ? paths.barHeight : barHeight),
              barWidth: Math.abs(paths.barWidth ? paths.barWidth : barWidth),
              elDataLabelsWrap: elDataLabelsWrap,
              elGoalsMarkers: elGoalsMarkers,
              elBarShadows: elBarShadows,
              visibleSeries: this.visibleI,
              type: 'bar'
            }));
          }

          // push all x val arrays into main xArr
          w.globals.seriesXvalues[realIndex] = xArrj;
          w.globals.seriesYvalues[realIndex] = yArrj;
          ret.add(elSeries);
        }
        return ret;
      }
    }, {
      key: "renderSeries",
      value: function renderSeries(_ref) {
        var realIndex = _ref.realIndex,
          pathFill = _ref.pathFill,
          lineFill = _ref.lineFill,
          j = _ref.j,
          i = _ref.i,
          columnGroupIndex = _ref.columnGroupIndex,
          pathFrom = _ref.pathFrom,
          pathTo = _ref.pathTo,
          strokeWidth = _ref.strokeWidth,
          elSeries = _ref.elSeries,
          x = _ref.x,
          y = _ref.y,
          y1 = _ref.y1,
          y2 = _ref.y2,
          series = _ref.series,
          barHeight = _ref.barHeight,
          barWidth = _ref.barWidth,
          barXPosition = _ref.barXPosition,
          barYPosition = _ref.barYPosition,
          elDataLabelsWrap = _ref.elDataLabelsWrap,
          elGoalsMarkers = _ref.elGoalsMarkers,
          elBarShadows = _ref.elBarShadows,
          visibleSeries = _ref.visibleSeries,
          type = _ref.type,
          classes = _ref.classes;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var skipDrawing = false;
        if (!lineFill) {
          // if user provided a function in colors, we need to eval here
          // Note: the position of this function logic (ex. stroke: { colors: ["",function(){}] }) i.e array index 1 depicts the realIndex/seriesIndex.
          var fetchColor = function fetchColor(i) {
            var exp = w.config.stroke.colors;
            var c;
            if (Array.isArray(exp) && exp.length > 0) {
              c = exp[i];
              if (!c) c = '';
              if (typeof c === 'function') {
                return c({
                  value: w.globals.series[i][j],
                  dataPointIndex: j,
                  w: w
                });
              }
            }
            return c;
          };
          var checkAvailableColor = typeof w.globals.stroke.colors[realIndex] === 'function' ? fetchColor(realIndex) : w.globals.stroke.colors[realIndex];

          /* fix apexcharts#341 */
          lineFill = this.barOptions.distributed ? w.globals.stroke.colors[j] : checkAvailableColor;
        }
        var barDataLabels = new BarDataLabels(this);
        var dataLabelsObj = barDataLabels.handleBarDataLabels({
          x: x,
          y: y,
          y1: y1,
          y2: y2,
          i: i,
          j: j,
          series: series,
          realIndex: realIndex,
          columnGroupIndex: columnGroupIndex,
          barHeight: barHeight,
          barWidth: barWidth,
          barXPosition: barXPosition,
          barYPosition: barYPosition,
          visibleSeries: visibleSeries
        });
        if (!w.globals.isBarHorizontal) {
          if (dataLabelsObj.dataLabelsPos.dataLabelsX + Math.max(barWidth, w.globals.barPadForNumericAxis) < 0 || dataLabelsObj.dataLabelsPos.dataLabelsX - Math.max(barWidth, w.globals.barPadForNumericAxis) > w.globals.gridWidth) {
            skipDrawing = true;
          }
        }
        if (w.config.series[i].data[j] && w.config.series[i].data[j].strokeColor) {
          lineFill = w.config.series[i].data[j].strokeColor;
        }
        if (this.isNullValue) {
          pathFill = 'none';
        }
        var delay = j / w.config.chart.animations.animateGradually.delay * (w.config.chart.animations.speed / w.globals.dataPoints) / 2.4;
        if (!skipDrawing) {
          var renderedPath = graphics.renderPaths({
            i: i,
            j: j,
            realIndex: realIndex,
            pathFrom: pathFrom,
            pathTo: pathTo,
            stroke: lineFill,
            strokeWidth: strokeWidth,
            strokeLineCap: w.config.stroke.lineCap,
            fill: pathFill,
            animationDelay: delay,
            initialSpeed: w.config.chart.animations.speed,
            dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,
            className: "apexcharts-".concat(type, "-area ").concat(classes),
            chartType: type
          });
          renderedPath.attr('clip-path', "url(#gridRectBarMask".concat(w.globals.cuid, ")"));
          var forecast = w.config.forecastDataPoints;
          if (forecast.count > 0) {
            if (j >= w.globals.dataPoints - forecast.count) {
              renderedPath.node.setAttribute('stroke-dasharray', forecast.dashArray);
              renderedPath.node.setAttribute('stroke-width', forecast.strokeWidth);
              renderedPath.node.setAttribute('fill-opacity', forecast.fillOpacity);
            }
          }
          if (typeof y1 !== 'undefined' && typeof y2 !== 'undefined') {
            renderedPath.attr('data-range-y1', y1);
            renderedPath.attr('data-range-y2', y2);
          }
          var filters = new Filters(this.ctx);
          filters.setSelectionFilter(renderedPath, realIndex, j);
          elSeries.add(renderedPath);
          renderedPath.attr({
            cy: dataLabelsObj.dataLabelsPos.bcy,
            cx: dataLabelsObj.dataLabelsPos.bcx,
            j: j,
            val: w.globals.series[i][j],
            barHeight: barHeight,
            barWidth: barWidth
          });
          if (dataLabelsObj.dataLabels !== null) {
            elDataLabelsWrap.add(dataLabelsObj.dataLabels);
          }
          if (dataLabelsObj.totalDataLabels) {
            elDataLabelsWrap.add(dataLabelsObj.totalDataLabels);
          }
          elSeries.add(elDataLabelsWrap);
          if (elGoalsMarkers) {
            elSeries.add(elGoalsMarkers);
          }
          if (elBarShadows) {
            elSeries.add(elBarShadows);
          }
        }
        return elSeries;
      }
    }, {
      key: "drawBarPaths",
      value: function drawBarPaths(_ref2) {
        var indexes = _ref2.indexes,
          barHeight = _ref2.barHeight,
          strokeWidth = _ref2.strokeWidth,
          zeroW = _ref2.zeroW,
          x = _ref2.x,
          y = _ref2.y,
          yDivision = _ref2.yDivision,
          elSeries = _ref2.elSeries;
        var w = this.w;
        var i = indexes.i;
        var j = indexes.j;
        var barYPosition;
        if (w.globals.isXNumeric) {
          y = (w.globals.seriesX[i][j] - w.globals.minX) / this.invertedXRatio - barHeight;
          barYPosition = y + barHeight * this.visibleI;
        } else {
          if (w.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
            var _this$barHelpers$getZ = this.barHelpers.getZeroValueEncounters({
                i: i,
                j: j
              }),
              nonZeroColumns = _this$barHelpers$getZ.nonZeroColumns,
              zeroEncounters = _this$barHelpers$getZ.zeroEncounters;
            if (nonZeroColumns > 0) {
              barHeight = this.seriesLen * barHeight / nonZeroColumns;
            }
            barYPosition = y + barHeight * this.visibleI;
            barYPosition -= barHeight * zeroEncounters;
          } else {
            barYPosition = y + barHeight * this.visibleI;
          }
        }
        if (this.isFunnel) {
          zeroW = zeroW - (this.barHelpers.getXForValue(this.series[i][j], zeroW) - zeroW) / 2;
        }
        x = this.barHelpers.getXForValue(this.series[i][j], zeroW);
        var paths = this.barHelpers.getBarpaths({
          barYPosition: barYPosition,
          barHeight: barHeight,
          x1: zeroW,
          x2: x,
          strokeWidth: strokeWidth,
          isReversed: this.isReversed,
          series: this.series,
          realIndex: indexes.realIndex,
          i: i,
          j: j,
          w: w
        });
        if (!w.globals.isXNumeric) {
          y = y + yDivision;
        }
        this.barHelpers.barBackground({
          j: j,
          i: i,
          y1: barYPosition - barHeight * this.visibleI,
          y2: barHeight * this.seriesLen,
          elSeries: elSeries
        });
        return {
          pathTo: paths.pathTo,
          pathFrom: paths.pathFrom,
          x1: zeroW,
          x: x,
          y: y,
          goalX: this.barHelpers.getGoalValues('x', zeroW, null, i, j),
          barYPosition: barYPosition,
          barHeight: barHeight
        };
      }
    }, {
      key: "drawColumnPaths",
      value: function drawColumnPaths(_ref3) {
        var indexes = _ref3.indexes,
          x = _ref3.x,
          y = _ref3.y,
          xDivision = _ref3.xDivision,
          barWidth = _ref3.barWidth,
          zeroH = _ref3.zeroH,
          strokeWidth = _ref3.strokeWidth,
          elSeries = _ref3.elSeries;
        var w = this.w;
        var realIndex = indexes.realIndex;
        var translationsIndex = indexes.translationsIndex;
        var i = indexes.i;
        var j = indexes.j;
        var bc = indexes.bc;
        var barXPosition;
        if (w.globals.isXNumeric) {
          var xForNumericX = this.getBarXForNumericXAxis({
            x: x,
            j: j,
            realIndex: realIndex,
            barWidth: barWidth
          });
          x = xForNumericX.x;
          barXPosition = xForNumericX.barXPosition;
        } else {
          if (w.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
            var _this$barHelpers$getZ2 = this.barHelpers.getZeroValueEncounters({
                i: i,
                j: j
              }),
              nonZeroColumns = _this$barHelpers$getZ2.nonZeroColumns,
              zeroEncounters = _this$barHelpers$getZ2.zeroEncounters;
            if (nonZeroColumns > 0) {
              barWidth = this.seriesLen * barWidth / nonZeroColumns;
            }
            barXPosition = x + barWidth * this.visibleI;
            barXPosition -= barWidth * zeroEncounters;
          } else {
            barXPosition = x + barWidth * this.visibleI;
          }
        }
        y = this.barHelpers.getYForValue(this.series[i][j], zeroH, translationsIndex);
        var paths = this.barHelpers.getColumnPaths({
          barXPosition: barXPosition,
          barWidth: barWidth,
          y1: zeroH,
          y2: y,
          strokeWidth: strokeWidth,
          isReversed: this.isReversed,
          series: this.series,
          realIndex: realIndex,
          i: i,
          j: j,
          w: w
        });
        if (!w.globals.isXNumeric) {
          x = x + xDivision;
        }
        this.barHelpers.barBackground({
          bc: bc,
          j: j,
          i: i,
          x1: barXPosition - strokeWidth / 2 - barWidth * this.visibleI,
          x2: barWidth * this.seriesLen + strokeWidth / 2,
          elSeries: elSeries
        });
        return {
          pathTo: paths.pathTo,
          pathFrom: paths.pathFrom,
          x: x,
          y: y,
          goalY: this.barHelpers.getGoalValues('y', null, zeroH, i, j, translationsIndex),
          barXPosition: barXPosition,
          barWidth: barWidth
        };
      }
    }, {
      key: "getBarXForNumericXAxis",
      value: function getBarXForNumericXAxis(_ref4) {
        var x = _ref4.x,
          barWidth = _ref4.barWidth,
          realIndex = _ref4.realIndex,
          j = _ref4.j;
        var w = this.w;
        var sxI = realIndex;
        if (!w.globals.seriesX[realIndex].length) {
          sxI = w.globals.maxValsInArrayIndex;
        }
        if (Utils$1.isNumber(w.globals.seriesX[sxI][j])) {
          x = (w.globals.seriesX[sxI][j] - w.globals.minX) / this.xRatio - barWidth * this.seriesLen / 2;
        }
        return {
          barXPosition: x + barWidth * this.visibleI,
          x: x
        };
      }

      /** getPreviousPath is a common function for bars/columns which is used to get previous paths when data changes.
       * @memberof Bar
       * @param {int} realIndex - current iterating i
       * @param {int} j - current iterating series's j index
       * @return {string} pathFrom is the string which will be appended in animations
       **/
    }, {
      key: "getPreviousPath",
      value: function getPreviousPath(realIndex, j) {
        var w = this.w;
        var pathFrom = 'M 0 0';
        for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {
          var gpp = w.globals.previousPaths[pp];
          if (gpp.paths && gpp.paths.length > 0 && parseInt(gpp.realIndex, 10) === parseInt(realIndex, 10)) {
            if (typeof w.globals.previousPaths[pp].paths[j] !== 'undefined') {
              pathFrom = w.globals.previousPaths[pp].paths[j].d;
            }
          }
        }
        return pathFrom;
      }
    }]);
    return Bar;
  }();

  /**
   * ApexCharts BarStacked Class responsible for drawing both Stacked Columns and Bars.
   *
   * @module BarStacked
   * The whole calculation for stacked bar/column is different from normal bar/column,
   * hence it makes sense to derive a new class for it extending most of the props of Parent Bar
   **/
  var BarStacked = /*#__PURE__*/function (_Bar) {
    _inherits(BarStacked, _Bar);
    var _super = _createSuper(BarStacked);
    function BarStacked() {
      _classCallCheck(this, BarStacked);
      return _super.apply(this, arguments);
    }
    _createClass(BarStacked, [{
      key: "draw",
      value: function draw(series, seriesIndex) {
        var _this = this;
        var w = this.w;
        this.graphics = new Graphics(this.ctx);
        this.bar = new Bar(this.ctx, this.xyRatios);
        var coreUtils = new CoreUtils(this.ctx, w);
        series = coreUtils.getLogSeries(series);
        this.yRatio = coreUtils.getLogYRatios(this.yRatio);
        this.barHelpers.initVariables(series);
        if (w.config.chart.stackType === '100%') {
          series = w.globals.comboCharts ? seriesIndex.map(function (_) {
            return w.globals.seriesPercent[_];
          }) : w.globals.seriesPercent.slice();
        }
        this.series = series;
        this.barHelpers.initializeStackedPrevVars(this);
        var ret = this.graphics.group({
          class: 'apexcharts-bar-series apexcharts-plot-series'
        });
        var x = 0;
        var y = 0;
        var _loop = function _loop(i, bc) {
          var xDivision = void 0; // xDivision is the GRIDWIDTH divided by number of datapoints (columns)
          var yDivision = void 0; // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)
          var zeroH = void 0; // zeroH is the baseline where 0 meets y axis
          var zeroW = void 0; // zeroW is the baseline where 0 meets x axis

          var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;
          var _this$barHelpers$getG = _this.barHelpers.getGroupIndex(realIndex),
            groupIndex = _this$barHelpers$getG.groupIndex,
            columnGroupIndex = _this$barHelpers$getG.columnGroupIndex;
          _this.groupCtx = _this[w.globals.seriesGroups[groupIndex]];
          var xArrValues = [];
          var yArrValues = [];
          var translationsIndex = 0;
          if (_this.yRatio.length > 1) {
            _this.yaxisIndex = w.globals.seriesYAxisReverseMap[realIndex][0];
            translationsIndex = realIndex;
          }
          _this.isReversed = w.config.yaxis[_this.yaxisIndex] && w.config.yaxis[_this.yaxisIndex].reversed;

          // el to which series will be drawn
          var elSeries = _this.graphics.group({
            class: "apexcharts-series",
            seriesName: Utils$1.escapeString(w.globals.seriesNames[realIndex]),
            rel: i + 1,
            'data:realIndex': realIndex
          });
          _this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);

          // eldatalabels
          var elDataLabelsWrap = _this.graphics.group({
            class: 'apexcharts-datalabels',
            'data:realIndex': realIndex
          });
          var elGoalsMarkers = _this.graphics.group({
            class: 'apexcharts-bar-goals-markers'
          });
          var barHeight = 0;
          var barWidth = 0;
          var initPositions = _this.initialPositions(x, y, xDivision, yDivision, zeroH, zeroW, translationsIndex);
          y = initPositions.y;
          barHeight = initPositions.barHeight;
          yDivision = initPositions.yDivision;
          zeroW = initPositions.zeroW;
          x = initPositions.x;
          barWidth = initPositions.barWidth;
          xDivision = initPositions.xDivision;
          zeroH = initPositions.zeroH;
          w.globals.barHeight = barHeight;
          w.globals.barWidth = barWidth;
          _this.barHelpers.initializeStackedXYVars(_this);

          // where all stack bar disappear after collapsing the first series
          if (_this.groupCtx.prevY.length === 1 && _this.groupCtx.prevY[0].every(function (val) {
            return isNaN(val);
          })) {
            _this.groupCtx.prevY[0] = _this.groupCtx.prevY[0].map(function () {
              return zeroH;
            });
            _this.groupCtx.prevYF[0] = _this.groupCtx.prevYF[0].map(function () {
              return 0;
            });
          }
          for (var j = 0; j < w.globals.dataPoints; j++) {
            var strokeWidth = _this.barHelpers.getStrokeWidth(i, j, realIndex);
            var commonPathOpts = {
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                translationsIndex: translationsIndex,
                bc: bc
              },
              strokeWidth: strokeWidth,
              x: x,
              y: y,
              elSeries: elSeries,
              columnGroupIndex: columnGroupIndex,
              seriesGroup: w.globals.seriesGroups[groupIndex]
            };
            var paths = null;
            if (_this.isHorizontal) {
              paths = _this.drawStackedBarPaths(_objectSpread2(_objectSpread2({}, commonPathOpts), {}, {
                zeroW: zeroW,
                barHeight: barHeight,
                yDivision: yDivision
              }));
              barWidth = _this.series[i][j] / _this.invertedYRatio;
            } else {
              paths = _this.drawStackedColumnPaths(_objectSpread2(_objectSpread2({}, commonPathOpts), {}, {
                xDivision: xDivision,
                barWidth: barWidth,
                zeroH: zeroH
              }));
              barHeight = _this.series[i][j] / _this.yRatio[translationsIndex];
            }
            var barGoalLine = _this.barHelpers.drawGoalLine({
              barXPosition: paths.barXPosition,
              barYPosition: paths.barYPosition,
              goalX: paths.goalX,
              goalY: paths.goalY,
              barHeight: barHeight,
              barWidth: barWidth
            });
            if (barGoalLine) {
              elGoalsMarkers.add(barGoalLine);
            }
            y = paths.y;
            x = paths.x;
            xArrValues.push(x);
            yArrValues.push(y);
            var pathFill = _this.barHelpers.getPathFillColor(series, i, j, realIndex);
            var classes = '';
            var flipClass = w.globals.isBarHorizontal ? 'apexcharts-flip-x' : 'apexcharts-flip-y';
            if (_this.barHelpers.arrBorderRadius[realIndex][j] === 'bottom' && w.globals.series[realIndex][j] > 0 || _this.barHelpers.arrBorderRadius[realIndex][j] === 'top' && w.globals.series[realIndex][j] < 0) {
              classes = flipClass;
            }
            elSeries = _this.renderSeries(_objectSpread2(_objectSpread2({
              realIndex: realIndex,
              pathFill: pathFill.color
            }, pathFill.useRangeColor ? {
              lineFill: pathFill.color
            } : {}), {}, {
              j: j,
              i: i,
              columnGroupIndex: columnGroupIndex,
              pathFrom: paths.pathFrom,
              pathTo: paths.pathTo,
              strokeWidth: strokeWidth,
              elSeries: elSeries,
              x: x,
              y: y,
              series: series,
              barHeight: barHeight,
              barWidth: barWidth,
              elDataLabelsWrap: elDataLabelsWrap,
              elGoalsMarkers: elGoalsMarkers,
              type: 'bar',
              visibleSeries: columnGroupIndex,
              classes: classes
            }));
          }

          // push all x val arrays into main xArr
          w.globals.seriesXvalues[realIndex] = xArrValues;
          w.globals.seriesYvalues[realIndex] = yArrValues;

          // push all current y values array to main PrevY Array
          _this.groupCtx.prevY.push(_this.groupCtx.yArrj);
          _this.groupCtx.prevYF.push(_this.groupCtx.yArrjF);
          _this.groupCtx.prevYVal.push(_this.groupCtx.yArrjVal);
          _this.groupCtx.prevX.push(_this.groupCtx.xArrj);
          _this.groupCtx.prevXF.push(_this.groupCtx.xArrjF);
          _this.groupCtx.prevXVal.push(_this.groupCtx.xArrjVal);
          ret.add(elSeries);
        };
        for (var i = 0, bc = 0; i < series.length; i++, bc++) {
          _loop(i, bc);
        }
        return ret;
      }
    }, {
      key: "initialPositions",
      value: function initialPositions(x, y, xDivision, yDivision, zeroH, zeroW, translationsIndex) {
        var w = this.w;
        var barHeight, barWidth;
        if (this.isHorizontal) {
          // height divided into equal parts
          yDivision = w.globals.gridHeight / w.globals.dataPoints;
          var userBarHeight = w.config.plotOptions.bar.barHeight;
          if (String(userBarHeight).indexOf('%') === -1) {
            barHeight = parseInt(userBarHeight, 10);
          } else {
            barHeight = yDivision * parseInt(userBarHeight, 10) / 100;
          }
          zeroW = w.globals.padHorizontal + (this.isReversed ? w.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY);

          // initial y position is half of barHeight * half of number of Bars
          y = (yDivision - barHeight) / 2;
        } else {
          // width divided into equal parts
          xDivision = w.globals.gridWidth / w.globals.dataPoints;
          barWidth = xDivision;
          var userColumnWidth = w.config.plotOptions.bar.columnWidth;
          if (w.globals.isXNumeric && w.globals.dataPoints > 1) {
            xDivision = w.globals.minXDiff / this.xRatio;
            barWidth = xDivision * parseInt(this.barOptions.columnWidth, 10) / 100;
          } else if (String(userColumnWidth).indexOf('%') === -1) {
            barWidth = parseInt(userColumnWidth, 10);
          } else {
            barWidth *= parseInt(userColumnWidth, 10) / 100;
          }
          if (this.isReversed) {
            zeroH = this.baseLineY[translationsIndex];
          } else {
            zeroH = w.globals.gridHeight - this.baseLineY[translationsIndex];
          }

          // initial x position is the left-most edge of the first bar relative to
          // the left-most side of the grid area.
          x = w.globals.padHorizontal + (xDivision - barWidth) / 2;
        }

        // Up to this point, barWidth is the width that will accommodate all bars
        // at each datapoint or category.

        // The crude subdivision here assumes the series within each group are
        // stacked. If there is no stacking then the barWidth/barHeight is
        // further divided later by the number of series in the group. So, eg, two
        // groups of three series would become six bars side-by-side unstacked,
        // or two bars stacked.
        var subDivisions = w.globals.barGroups.length || 1;
        return {
          x: x,
          y: y,
          yDivision: yDivision,
          xDivision: xDivision,
          barHeight: barHeight / subDivisions,
          barWidth: barWidth / subDivisions,
          zeroH: zeroH,
          zeroW: zeroW
        };
      }
    }, {
      key: "drawStackedBarPaths",
      value: function drawStackedBarPaths(_ref) {
        var indexes = _ref.indexes,
          barHeight = _ref.barHeight,
          strokeWidth = _ref.strokeWidth,
          zeroW = _ref.zeroW,
          x = _ref.x,
          y = _ref.y,
          columnGroupIndex = _ref.columnGroupIndex,
          seriesGroup = _ref.seriesGroup,
          yDivision = _ref.yDivision,
          elSeries = _ref.elSeries;
        var w = this.w;
        var barYPosition = y + columnGroupIndex * barHeight;
        var barXPosition;
        var i = indexes.i;
        var j = indexes.j;
        var realIndex = indexes.realIndex;
        var translationsIndex = indexes.translationsIndex;
        var prevBarW = 0;
        for (var k = 0; k < this.groupCtx.prevXF.length; k++) {
          prevBarW = prevBarW + this.groupCtx.prevXF[k][j];
        }
        var gsi = i; // an index to keep track of the series inside a group
        if (w.config.series[realIndex].name) {
          gsi = seriesGroup.indexOf(w.config.series[realIndex].name);
        }
        if (gsi > 0) {
          var bXP = zeroW;
          if (this.groupCtx.prevXVal[gsi - 1][j] < 0) {
            bXP = this.series[i][j] >= 0 ? this.groupCtx.prevX[gsi - 1][j] + prevBarW - (this.isReversed ? prevBarW : 0) * 2 : this.groupCtx.prevX[gsi - 1][j];
          } else if (this.groupCtx.prevXVal[gsi - 1][j] >= 0) {
            bXP = this.series[i][j] >= 0 ? this.groupCtx.prevX[gsi - 1][j] : this.groupCtx.prevX[gsi - 1][j] - prevBarW + (this.isReversed ? prevBarW : 0) * 2;
          }
          barXPosition = bXP;
        } else {
          // the first series will not have prevX values
          barXPosition = zeroW;
        }
        if (this.series[i][j] === null) {
          x = barXPosition;
        } else {
          x = barXPosition + this.series[i][j] / this.invertedYRatio - (this.isReversed ? this.series[i][j] / this.invertedYRatio : 0) * 2;
        }
        var paths = this.barHelpers.getBarpaths({
          barYPosition: barYPosition,
          barHeight: barHeight,
          x1: barXPosition,
          x2: x,
          strokeWidth: strokeWidth,
          isReversed: this.isReversed,
          series: this.series,
          realIndex: indexes.realIndex,
          seriesGroup: seriesGroup,
          i: i,
          j: j,
          w: w
        });
        this.barHelpers.barBackground({
          j: j,
          i: i,
          y1: barYPosition,
          y2: barHeight,
          elSeries: elSeries
        });
        y = y + yDivision;
        return {
          pathTo: paths.pathTo,
          pathFrom: paths.pathFrom,
          goalX: this.barHelpers.getGoalValues('x', zeroW, null, i, j, translationsIndex),
          barXPosition: barXPosition,
          barYPosition: barYPosition,
          x: x,
          y: y
        };
      }
    }, {
      key: "drawStackedColumnPaths",
      value: function drawStackedColumnPaths(_ref2) {
        var indexes = _ref2.indexes,
          x = _ref2.x,
          y = _ref2.y,
          xDivision = _ref2.xDivision,
          barWidth = _ref2.barWidth,
          zeroH = _ref2.zeroH,
          columnGroupIndex = _ref2.columnGroupIndex,
          seriesGroup = _ref2.seriesGroup,
          elSeries = _ref2.elSeries;
        var w = this.w;
        var i = indexes.i;
        var j = indexes.j;
        var bc = indexes.bc;
        var realIndex = indexes.realIndex;
        var translationsIndex = indexes.translationsIndex;
        if (w.globals.isXNumeric) {
          var seriesVal = w.globals.seriesX[realIndex][j];
          if (!seriesVal) seriesVal = 0;
          // TODO: move the barWidth factor to barXPosition
          x = (seriesVal - w.globals.minX) / this.xRatio - barWidth / 2 * w.globals.barGroups.length;
        }
        var barXPosition = x + columnGroupIndex * barWidth;
        var barYPosition;
        var prevBarH = 0;
        for (var k = 0; k < this.groupCtx.prevYF.length; k++) {
          // fix issue #1215
          // in case where this.groupCtx.prevYF[k][j] is NaN, use 0 instead
          prevBarH = prevBarH + (!isNaN(this.groupCtx.prevYF[k][j]) ? this.groupCtx.prevYF[k][j] : 0);
        }
        var gsi = i; // an index to keep track of the series inside a group
        if (seriesGroup) {
          gsi = seriesGroup.indexOf(w.globals.seriesNames[realIndex]);
        }
        if (gsi > 0 && !w.globals.isXNumeric || gsi > 0 && w.globals.isXNumeric && w.globals.seriesX[realIndex - 1][j] === w.globals.seriesX[realIndex][j]) {
          var _this$groupCtx$prevYF;
          var bYP;
          var prevYValue;
          var p = Math.min(this.yRatio.length + 1, realIndex + 1);
          if (this.groupCtx.prevY[gsi - 1] !== undefined && this.groupCtx.prevY[gsi - 1].length) {
            for (var ii = 1; ii < p; ii++) {
              var _this$groupCtx$prevY;
              if (!isNaN((_this$groupCtx$prevY = this.groupCtx.prevY[gsi - ii]) === null || _this$groupCtx$prevY === void 0 ? void 0 : _this$groupCtx$prevY[j])) {
                // find the previous available value to give prevYValue
                prevYValue = this.groupCtx.prevY[gsi - ii][j];
                // if found it, break the loop
                break;
              }
            }
          }
          for (var _ii = 1; _ii < p; _ii++) {
            var _this$groupCtx$prevYV, _this$groupCtx$prevYV2;
            // find the previous available value(non-NaN) to give bYP
            if (((_this$groupCtx$prevYV = this.groupCtx.prevYVal[gsi - _ii]) === null || _this$groupCtx$prevYV === void 0 ? void 0 : _this$groupCtx$prevYV[j]) < 0) {
              bYP = this.series[i][j] >= 0 ? prevYValue - prevBarH + (this.isReversed ? prevBarH : 0) * 2 : prevYValue;
              // found it? break the loop
              break;
            } else if (((_this$groupCtx$prevYV2 = this.groupCtx.prevYVal[gsi - _ii]) === null || _this$groupCtx$prevYV2 === void 0 ? void 0 : _this$groupCtx$prevYV2[j]) >= 0) {
              bYP = this.series[i][j] >= 0 ? prevYValue : prevYValue + prevBarH - (this.isReversed ? prevBarH : 0) * 2;
              // found it? break the loop
              break;
            }
          }
          if (typeof bYP === 'undefined') bYP = w.globals.gridHeight;

          // if this.prevYF[0] is all 0 resulted from line #486
          // AND every arr starting from the second only contains NaN
          if ((_this$groupCtx$prevYF = this.groupCtx.prevYF[0]) !== null && _this$groupCtx$prevYF !== void 0 && _this$groupCtx$prevYF.every(function (val) {
            return val === 0;
          }) && this.groupCtx.prevYF.slice(1, gsi).every(function (arr) {
            return arr.every(function (val) {
              return isNaN(val);
            });
          })) {
            barYPosition = zeroH;
          } else {
            // Nothing special
            barYPosition = bYP;
          }
        } else {
          // the first series will not have prevY values, also if the prev index's
          // series X doesn't matches the current index's series X, then start from
          // zero
          barYPosition = zeroH;
        }
        if (this.series[i][j]) {
          y = barYPosition - this.series[i][j] / this.yRatio[translationsIndex] + (this.isReversed ? this.series[i][j] / this.yRatio[translationsIndex] : 0) * 2;
        } else {
          // fixes #3610
          y = barYPosition;
        }
        var paths = this.barHelpers.getColumnPaths({
          barXPosition: barXPosition,
          barWidth: barWidth,
          y1: barYPosition,
          y2: y,
          yRatio: this.yRatio[translationsIndex],
          strokeWidth: this.strokeWidth,
          isReversed: this.isReversed,
          series: this.series,
          seriesGroup: seriesGroup,
          realIndex: indexes.realIndex,
          i: i,
          j: j,
          w: w
        });
        this.barHelpers.barBackground({
          bc: bc,
          j: j,
          i: i,
          x1: barXPosition,
          x2: barWidth,
          elSeries: elSeries
        });
        return {
          pathTo: paths.pathTo,
          pathFrom: paths.pathFrom,
          goalY: this.barHelpers.getGoalValues('y', null, zeroH, i, j),
          barXPosition: barXPosition,
          x: w.globals.isXNumeric ? x : x + xDivision,
          y: y
        };
      }
    }]);
    return BarStacked;
  }(Bar);

  /**
   * ApexCharts BoxCandleStick Class responsible for drawing both Stacked Columns and Bars.
   *
   * @module BoxCandleStick
   **/
  var BoxCandleStick = /*#__PURE__*/function (_Bar) {
    _inherits(BoxCandleStick, _Bar);
    var _super = _createSuper(BoxCandleStick);
    function BoxCandleStick() {
      _classCallCheck(this, BoxCandleStick);
      return _super.apply(this, arguments);
    }
    _createClass(BoxCandleStick, [{
      key: "draw",
      value: function draw(series, ctype, seriesIndex) {
        var _this = this;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var type = w.globals.comboCharts ? ctype : w.config.chart.type;
        var fill = new Fill(this.ctx);
        this.candlestickOptions = this.w.config.plotOptions.candlestick;
        this.boxOptions = this.w.config.plotOptions.boxPlot;
        this.isHorizontal = w.config.plotOptions.bar.horizontal;
        // Add new property to check if we're using OHLC type
        this.isOHLC = this.candlestickOptions && this.candlestickOptions.type === 'ohlc';
        var coreUtils = new CoreUtils(this.ctx, w);
        series = coreUtils.getLogSeries(series);
        this.series = series;
        this.yRatio = coreUtils.getLogYRatios(this.yRatio);
        this.barHelpers.initVariables(series);
        var ret = graphics.group({
          class: "apexcharts-".concat(type, "-series apexcharts-plot-series")
        });
        var _loop = function _loop(i) {
          _this.isBoxPlot = w.config.chart.type === 'boxPlot' || w.config.series[i].type === 'boxPlot';
          var x = void 0,
            y = void 0,
            xDivision = void 0,
            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)
            yDivision = void 0,
            // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)
            zeroH = void 0,
            // zeroH is the baseline where 0 meets y axis
            zeroW = void 0; // zeroW is the baseline where 0 meets x axis

          var yArrj = []; // hold y values of current iterating series
          var xArrj = []; // hold x values of current iterating series

          var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;
          // As BoxCandleStick derives from Bar, we need this to render.
          var _this$barHelpers$getG = _this.barHelpers.getGroupIndex(realIndex),
            columnGroupIndex = _this$barHelpers$getG.columnGroupIndex;

          // el to which series will be drawn
          var elSeries = graphics.group({
            class: "apexcharts-series",
            seriesName: Utils$1.escapeString(w.globals.seriesNames[realIndex]),
            rel: i + 1,
            'data:realIndex': realIndex
          });
          _this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);
          if (series[i].length > 0) {
            _this.visibleI = _this.visibleI + 1;
          }
          var barHeight = 0;
          var barWidth = 0;
          var translationsIndex = 0;
          if (_this.yRatio.length > 1) {
            _this.yaxisIndex = w.globals.seriesYAxisReverseMap[realIndex][0];
            translationsIndex = realIndex;
          }
          var initPositions = _this.barHelpers.initialPositions(realIndex);
          y = initPositions.y;
          barHeight = initPositions.barHeight;
          yDivision = initPositions.yDivision;
          zeroW = initPositions.zeroW;
          x = initPositions.x;
          barWidth = initPositions.barWidth;
          xDivision = initPositions.xDivision;
          zeroH = initPositions.zeroH;
          xArrj.push(x + barWidth / 2);

          // eldatalabels
          var elDataLabelsWrap = graphics.group({
            class: 'apexcharts-datalabels',
            'data:realIndex': realIndex
          });
          var elGoalsMarkers = graphics.group({
            class: 'apexcharts-bar-goals-markers'
          });
          var _loop2 = function _loop2(j) {
            var strokeWidth = _this.barHelpers.getStrokeWidth(i, j, realIndex);
            var paths = null;
            var pathsParams = {
              indexes: {
                i: i,
                j: j,
                realIndex: realIndex,
                translationsIndex: translationsIndex
              },
              x: x,
              y: y,
              strokeWidth: strokeWidth,
              elSeries: elSeries
            };
            if (_this.isHorizontal) {
              paths = _this.drawHorizontalBoxPaths(_objectSpread2(_objectSpread2({}, pathsParams), {}, {
                yDivision: yDivision,
                barHeight: barHeight,
                zeroW: zeroW
              }));
            } else {
              paths = _this.drawVerticalBoxPaths(_objectSpread2(_objectSpread2({}, pathsParams), {}, {
                xDivision: xDivision,
                barWidth: barWidth,
                zeroH: zeroH
              }));
            }
            y = paths.y;
            x = paths.x;
            var barGoalLine = _this.barHelpers.drawGoalLine({
              barXPosition: paths.barXPosition,
              barYPosition: paths.barYPosition,
              goalX: paths.goalX,
              goalY: paths.goalY,
              barHeight: barHeight,
              barWidth: barWidth
            });
            if (barGoalLine) {
              elGoalsMarkers.add(barGoalLine);
            }

            // push current X
            if (j > 0) {
              xArrj.push(x + barWidth / 2);
            }
            yArrj.push(y);
            paths.pathTo.forEach(function (pathTo, pi) {
              var lineFill = !_this.isBoxPlot && _this.candlestickOptions.wick.useFillColor ? paths.color[pi] : w.globals.stroke.colors[i];
              var pathFill = fill.fillPath({
                seriesNumber: realIndex,
                dataPointIndex: j,
                color: paths.color[pi],
                value: series[i][j]
              });
              _this.renderSeries({
                realIndex: realIndex,
                pathFill: pathFill,
                lineFill: lineFill,
                j: j,
                i: i,
                pathFrom: paths.pathFrom,
                pathTo: pathTo,
                strokeWidth: strokeWidth,
                elSeries: elSeries,
                x: x,
                y: y,
                series: series,
                columnGroupIndex: columnGroupIndex,
                barHeight: barHeight,
                barWidth: barWidth,
                elDataLabelsWrap: elDataLabelsWrap,
                elGoalsMarkers: elGoalsMarkers,
                visibleSeries: _this.visibleI,
                type: w.config.chart.type
              });
            });
          };
          for (var j = 0; j < w.globals.dataPoints; j++) {
            _loop2(j);
          }

          // push all x val arrays into main xArr
          w.globals.seriesXvalues[realIndex] = xArrj;
          w.globals.seriesYvalues[realIndex] = yArrj;
          ret.add(elSeries);
        };
        for (var i = 0; i < series.length; i++) {
          _loop(i);
        }
        return ret;
      }
    }, {
      key: "drawVerticalBoxPaths",
      value: function drawVerticalBoxPaths(_ref) {
        var indexes = _ref.indexes,
          x = _ref.x;
          _ref.y;
          var xDivision = _ref.xDivision,
          barWidth = _ref.barWidth,
          zeroH = _ref.zeroH,
          strokeWidth = _ref.strokeWidth;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var i = indexes.i;
        var j = indexes.j;
        var candleColors = w.config.plotOptions.candlestick.colors;
        var boxColors = this.boxOptions.colors;
        var realIndex = indexes.realIndex;
        var getColor = function getColor(color) {
          return Array.isArray(color) ? color[realIndex] : color;
        };
        var colorPos = getColor(candleColors.upward);
        var colorNeg = getColor(candleColors.downward);
        var yRatio = this.yRatio[indexes.translationsIndex];
        var ohlc = this.getOHLCValue(realIndex, j);
        var l1 = zeroH;
        var l2 = zeroH;
        var color = ohlc.o < ohlc.c ? [colorPos] : [colorNeg];
        if (this.isBoxPlot) {
          color = [getColor(boxColors.lower), getColor(boxColors.upper)];
        }
        var y1 = Math.min(ohlc.o, ohlc.c);
        var y2 = Math.max(ohlc.o, ohlc.c);
        var m = ohlc.m;
        if (w.globals.isXNumeric) {
          x = (w.globals.seriesX[realIndex][j] - w.globals.minX) / this.xRatio - barWidth / 2;
        }
        var barXPosition = x + barWidth * this.visibleI;
        if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {
          y1 = zeroH;
          y2 = zeroH;
        } else {
          y1 = zeroH - y1 / yRatio;
          y2 = zeroH - y2 / yRatio;
          l1 = zeroH - ohlc.h / yRatio;
          l2 = zeroH - ohlc.l / yRatio;
          m = zeroH - ohlc.m / yRatio;
        }
        var pathTo = graphics.move(barXPosition, zeroH);
        var pathFrom = graphics.move(barXPosition + barWidth / 2, y1);
        if (w.globals.previousPaths.length > 0) {
          pathFrom = this.getPreviousPath(realIndex, j, true);
        }
        if (this.isOHLC) {
          var centerX = barXPosition + barWidth / 2;
          var openY = zeroH - ohlc.o / yRatio;
          var closeY = zeroH - ohlc.c / yRatio;
          pathTo = [graphics.move(centerX, l1) + graphics.line(centerX, l2) + graphics.move(centerX, openY) + graphics.line(barXPosition, openY) + graphics.move(centerX, closeY) + graphics.line(barXPosition + barWidth, closeY)];
        } else if (this.isBoxPlot) {
          pathTo = [graphics.move(barXPosition, y1) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition + barWidth / 2, l1) + graphics.line(barXPosition + barWidth / 4, l1) + graphics.line(barXPosition + barWidth - barWidth / 4, l1) + graphics.line(barXPosition + barWidth / 2, l1) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition + barWidth, m) + graphics.line(barXPosition, m) + graphics.line(barXPosition, y1 + strokeWidth / 2), graphics.move(barXPosition, m) + graphics.line(barXPosition + barWidth, m) + graphics.line(barXPosition + barWidth, y2) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth / 2, l2) + graphics.line(barXPosition + barWidth - barWidth / 4, l2) + graphics.line(barXPosition + barWidth / 4, l2) + graphics.line(barXPosition + barWidth / 2, l2) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition, y2) + graphics.line(barXPosition, m) + 'z'];
        } else {
          // Regular candlestick
          pathTo = [graphics.move(barXPosition, y2) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth / 2, l1) + graphics.line(barXPosition + barWidth / 2, y2) + graphics.line(barXPosition + barWidth, y2) + graphics.line(barXPosition + barWidth, y1) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition + barWidth / 2, l2) + graphics.line(barXPosition + barWidth / 2, y1) + graphics.line(barXPosition, y1) + graphics.line(barXPosition, y2 - strokeWidth / 2)];
        }
        pathFrom = pathFrom + graphics.move(barXPosition, y1);
        if (!w.globals.isXNumeric) {
          x = x + xDivision;
        }
        return {
          pathTo: pathTo,
          pathFrom: pathFrom,
          x: x,
          y: y2,
          goalY: this.barHelpers.getGoalValues('y', null, zeroH, i, j, indexes.translationsIndex),
          barXPosition: barXPosition,
          color: color
        };
      }
    }, {
      key: "drawHorizontalBoxPaths",
      value: function drawHorizontalBoxPaths(_ref2) {
        var indexes = _ref2.indexes;
          _ref2.x;
          var y = _ref2.y,
          yDivision = _ref2.yDivision,
          barHeight = _ref2.barHeight,
          zeroW = _ref2.zeroW,
          strokeWidth = _ref2.strokeWidth;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var i = indexes.i;
        var j = indexes.j;
        var color = this.boxOptions.colors.lower;
        if (this.isBoxPlot) {
          color = [this.boxOptions.colors.lower, this.boxOptions.colors.upper];
        }
        var yRatio = this.invertedYRatio;
        var realIndex = indexes.realIndex;
        var ohlc = this.getOHLCValue(realIndex, j);
        var l1 = zeroW;
        var l2 = zeroW;
        var x1 = Math.min(ohlc.o, ohlc.c);
        var x2 = Math.max(ohlc.o, ohlc.c);
        var m = ohlc.m;
        if (w.globals.isXNumeric) {
          y = (w.globals.seriesX[realIndex][j] - w.globals.minX) / this.invertedXRatio - barHeight / 2;
        }
        var barYPosition = y + barHeight * this.visibleI;
        if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {
          x1 = zeroW;
          x2 = zeroW;
        } else {
          x1 = zeroW + x1 / yRatio;
          x2 = zeroW + x2 / yRatio;
          l1 = zeroW + ohlc.h / yRatio;
          l2 = zeroW + ohlc.l / yRatio;
          m = zeroW + ohlc.m / yRatio;
        }
        var pathTo = graphics.move(zeroW, barYPosition);
        var pathFrom = graphics.move(x1, barYPosition + barHeight / 2);
        if (w.globals.previousPaths.length > 0) {
          pathFrom = this.getPreviousPath(realIndex, j, true);
        }
        pathTo = [graphics.move(x1, barYPosition) + graphics.line(x1, barYPosition + barHeight / 2) + graphics.line(l1, barYPosition + barHeight / 2) + graphics.line(l1, barYPosition + barHeight / 2 - barHeight / 4) + graphics.line(l1, barYPosition + barHeight / 2 + barHeight / 4) + graphics.line(l1, barYPosition + barHeight / 2) + graphics.line(x1, barYPosition + barHeight / 2) + graphics.line(x1, barYPosition + barHeight) + graphics.line(m, barYPosition + barHeight) + graphics.line(m, barYPosition) + graphics.line(x1 + strokeWidth / 2, barYPosition), graphics.move(m, barYPosition) + graphics.line(m, barYPosition + barHeight) + graphics.line(x2, barYPosition + barHeight) + graphics.line(x2, barYPosition + barHeight / 2) + graphics.line(l2, barYPosition + barHeight / 2) + graphics.line(l2, barYPosition + barHeight - barHeight / 4) + graphics.line(l2, barYPosition + barHeight / 4) + graphics.line(l2, barYPosition + barHeight / 2) + graphics.line(x2, barYPosition + barHeight / 2) + graphics.line(x2, barYPosition) + graphics.line(m, barYPosition) + 'z'];
        pathFrom = pathFrom + graphics.move(x1, barYPosition);
        if (!w.globals.isXNumeric) {
          y = y + yDivision;
        }
        return {
          pathTo: pathTo,
          pathFrom: pathFrom,
          x: x2,
          y: y,
          goalX: this.barHelpers.getGoalValues('x', zeroW, null, i, j),
          barYPosition: barYPosition,
          color: color
        };
      }
    }, {
      key: "getOHLCValue",
      value: function getOHLCValue(i, j) {
        var w = this.w;
        var coreUtils = new CoreUtils(this.ctx, w);
        var h = coreUtils.getLogValAtSeriesIndex(w.globals.seriesCandleH[i][j], i);
        var o = coreUtils.getLogValAtSeriesIndex(w.globals.seriesCandleO[i][j], i);
        var m = coreUtils.getLogValAtSeriesIndex(w.globals.seriesCandleM[i][j], i);
        var c = coreUtils.getLogValAtSeriesIndex(w.globals.seriesCandleC[i][j], i);
        var l = coreUtils.getLogValAtSeriesIndex(w.globals.seriesCandleL[i][j], i);
        return {
          o: this.isBoxPlot ? h : o,
          h: this.isBoxPlot ? o : h,
          m: m,
          l: this.isBoxPlot ? c : l,
          c: this.isBoxPlot ? l : c
        };
      }
    }]);
    return BoxCandleStick;
  }(Bar);

  var TreemapHelpers = /*#__PURE__*/function () {
    function TreemapHelpers(ctx) {
      _classCallCheck(this, TreemapHelpers);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(TreemapHelpers, [{
      key: "checkColorRange",
      value: function checkColorRange() {
        var w = this.w;
        var negRange = false;
        var chartOpts = w.config.plotOptions[w.config.chart.type];
        if (chartOpts.colorScale.ranges.length > 0) {
          chartOpts.colorScale.ranges.map(function (range, index) {
            if (range.from <= 0) {
              negRange = true;
            }
          });
        }
        return negRange;
      }
    }, {
      key: "getShadeColor",
      value: function getShadeColor(chartType, i, j, negRange) {
        var w = this.w;
        var colorShadePercent = 1;
        var shadeIntensity = w.config.plotOptions[chartType].shadeIntensity;
        var colorProps = this.determineColor(chartType, i, j);
        if (w.globals.hasNegs || negRange) {
          if (w.config.plotOptions[chartType].reverseNegativeShade) {
            if (colorProps.percent < 0) {
              colorShadePercent = colorProps.percent / 100 * (shadeIntensity * 1.25);
            } else {
              colorShadePercent = (1 - colorProps.percent / 100) * (shadeIntensity * 1.25);
            }
          } else {
            if (colorProps.percent <= 0) {
              colorShadePercent = 1 - (1 + colorProps.percent / 100) * shadeIntensity;
            } else {
              colorShadePercent = (1 - colorProps.percent / 100) * shadeIntensity;
            }
          }
        } else {
          colorShadePercent = 1 - colorProps.percent / 100;
          if (chartType === 'treemap') {
            colorShadePercent = (1 - colorProps.percent / 100) * (shadeIntensity * 1.25);
          }
        }
        var color = colorProps.color;
        var utils = new Utils$1();
        if (w.config.plotOptions[chartType].enableShades) {
          // The shadeColor function may return either an RGB or a hex color value
          // However, hexToRgba requires the input to be in hex format
          // The ternary operator checks if the color is in RGB format, and if so, converts it to hex
          if (this.w.config.theme.mode === 'dark') {
            var shadeColor = utils.shadeColor(colorShadePercent * -1, colorProps.color);
            color = Utils$1.hexToRgba(Utils$1.isColorHex(shadeColor) ? shadeColor : Utils$1.rgb2hex(shadeColor), w.config.fill.opacity);
          } else {
            var _shadeColor = utils.shadeColor(colorShadePercent, colorProps.color);
            color = Utils$1.hexToRgba(Utils$1.isColorHex(_shadeColor) ? _shadeColor : Utils$1.rgb2hex(_shadeColor), w.config.fill.opacity);
          }
        }
        return {
          color: color,
          colorProps: colorProps
        };
      }
    }, {
      key: "determineColor",
      value: function determineColor(chartType, i, j) {
        var w = this.w;
        var val = w.globals.series[i][j];
        var chartOpts = w.config.plotOptions[chartType];
        var seriesNumber = chartOpts.colorScale.inverse ? j : i;
        if (chartOpts.distributed && w.config.chart.type === 'treemap') {
          seriesNumber = j;
        }
        var color = w.globals.colors[seriesNumber];
        var foreColor = null;
        var min = Math.min.apply(Math, _toConsumableArray(w.globals.series[i]));
        var max = Math.max.apply(Math, _toConsumableArray(w.globals.series[i]));
        if (!chartOpts.distributed && chartType === 'heatmap') {
          min = w.globals.minY;
          max = w.globals.maxY;
        }
        if (typeof chartOpts.colorScale.min !== 'undefined') {
          min = chartOpts.colorScale.min < w.globals.minY ? chartOpts.colorScale.min : w.globals.minY;
          max = chartOpts.colorScale.max > w.globals.maxY ? chartOpts.colorScale.max : w.globals.maxY;
        }
        var total = Math.abs(max) + Math.abs(min);
        var percent = 100 * val / (total === 0 ? total - 0.000001 : total);
        if (chartOpts.colorScale.ranges.length > 0) {
          var colorRange = chartOpts.colorScale.ranges;
          colorRange.map(function (range, index) {
            if (val >= range.from && val <= range.to) {
              color = range.color;
              foreColor = range.foreColor ? range.foreColor : null;
              min = range.from;
              max = range.to;
              var rTotal = Math.abs(max) + Math.abs(min);
              percent = 100 * val / (rTotal === 0 ? rTotal - 0.000001 : rTotal);
            }
          });
        }
        return {
          color: color,
          foreColor: foreColor,
          percent: percent
        };
      }
    }, {
      key: "calculateDataLabels",
      value: function calculateDataLabels(_ref) {
        var text = _ref.text,
          x = _ref.x,
          y = _ref.y,
          i = _ref.i,
          j = _ref.j,
          colorProps = _ref.colorProps,
          fontSize = _ref.fontSize;
        var w = this.w;
        var dataLabelsConfig = w.config.dataLabels;
        var graphics = new Graphics(this.ctx);
        var dataLabels = new DataLabels(this.ctx);
        var elDataLabelsWrap = null;
        if (dataLabelsConfig.enabled) {
          elDataLabelsWrap = graphics.group({
            class: 'apexcharts-data-labels'
          });
          var offX = dataLabelsConfig.offsetX;
          var offY = dataLabelsConfig.offsetY;
          var dataLabelsX = x + offX;
          var dataLabelsY = y + parseFloat(dataLabelsConfig.style.fontSize) / 3 + offY;
          dataLabels.plotDataLabelsText({
            x: dataLabelsX,
            y: dataLabelsY,
            text: text,
            i: i,
            j: j,
            color: colorProps.foreColor,
            parent: elDataLabelsWrap,
            fontSize: fontSize,
            dataLabelsConfig: dataLabelsConfig
          });
        }
        return elDataLabelsWrap;
      }
    }, {
      key: "addListeners",
      value: function addListeners(elRect) {
        var graphics = new Graphics(this.ctx);
        elRect.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, elRect));
        elRect.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, elRect));
        elRect.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, elRect));
      }
    }]);
    return TreemapHelpers;
  }();

  /**
   * ApexCharts HeatMap Class.
   * @module HeatMap
   **/
  var HeatMap = /*#__PURE__*/function () {
    function HeatMap(ctx, xyRatios) {
      _classCallCheck(this, HeatMap);
      this.ctx = ctx;
      this.w = ctx.w;
      this.xRatio = xyRatios.xRatio;
      this.yRatio = xyRatios.yRatio;
      this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation;
      this.helpers = new TreemapHelpers(ctx);
      this.rectRadius = this.w.config.plotOptions.heatmap.radius;
      this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
    }
    _createClass(HeatMap, [{
      key: "draw",
      value: function draw(series) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var ret = graphics.group({
          class: 'apexcharts-heatmap'
        });
        ret.attr('clip-path', "url(#gridRectMask".concat(w.globals.cuid, ")"));

        // width divided into equal parts
        var xDivision = w.globals.gridWidth / w.globals.dataPoints;
        var yDivision = w.globals.gridHeight / w.globals.series.length;
        var y1 = 0;
        var rev = false;
        this.negRange = this.helpers.checkColorRange();
        var heatSeries = series.slice();
        if (w.config.yaxis[0].reversed) {
          rev = true;
          heatSeries.reverse();
        }
        for (var i = rev ? 0 : heatSeries.length - 1; rev ? i < heatSeries.length : i >= 0; rev ? i++ : i--) {
          // el to which series will be drawn
          var elSeries = graphics.group({
            class: "apexcharts-series apexcharts-heatmap-series",
            seriesName: Utils$1.escapeString(w.globals.seriesNames[i]),
            rel: i + 1,
            'data:realIndex': i
          });
          this.ctx.series.addCollapsedClassToSeries(elSeries, i);
          if (w.config.chart.dropShadow.enabled) {
            var shadow = w.config.chart.dropShadow;
            var filters = new Filters(this.ctx);
            filters.dropShadow(elSeries, shadow, i);
          }
          var x1 = 0;
          var shadeIntensity = w.config.plotOptions.heatmap.shadeIntensity;
          var j = 0;
          for (var dIndex = 0; dIndex < w.globals.dataPoints; dIndex++) {
            // Recognize gaps and align values based on x axis

            if (w.globals.seriesX.length && !w.globals.allSeriesHasEqualX) {
              if (w.globals.minX + w.globals.minXDiff * dIndex < w.globals.seriesX[i][j]) {
                x1 = x1 + xDivision;
                continue;
              }
            }

            // Stop loop if index is out of array length
            if (j >= heatSeries[i].length) break;
            var heatColor = this.helpers.getShadeColor(w.config.chart.type, i, j, this.negRange);
            var color = heatColor.color;
            var heatColorProps = heatColor.colorProps;
            if (w.config.fill.type === 'image') {
              var fill = new Fill(this.ctx);
              color = fill.fillPath({
                seriesNumber: i,
                dataPointIndex: j,
                opacity: w.globals.hasNegs ? heatColorProps.percent < 0 ? 1 - (1 + heatColorProps.percent / 100) : shadeIntensity + heatColorProps.percent / 100 : heatColorProps.percent / 100,
                patternID: Utils$1.randomId(),
                width: w.config.fill.image.width ? w.config.fill.image.width : xDivision,
                height: w.config.fill.image.height ? w.config.fill.image.height : yDivision
              });
            }
            var radius = this.rectRadius;
            var rect = graphics.drawRect(x1, y1, xDivision, yDivision, radius);
            rect.attr({
              cx: x1,
              cy: y1
            });
            rect.node.classList.add('apexcharts-heatmap-rect');
            elSeries.add(rect);
            rect.attr({
              fill: color,
              i: i,
              index: i,
              j: j,
              val: series[i][j],
              'stroke-width': this.strokeWidth,
              stroke: w.config.plotOptions.heatmap.useFillColorAsStroke ? color : w.globals.stroke.colors[0],
              color: color
            });
            this.helpers.addListeners(rect);
            if (w.config.chart.animations.enabled && !w.globals.dataChanged) {
              var speed = 1;
              if (!w.globals.resized) {
                speed = w.config.chart.animations.speed;
              }
              this.animateHeatMap(rect, x1, y1, xDivision, yDivision, speed);
            }
            if (w.globals.dataChanged) {
              var _speed = 1;
              if (this.dynamicAnim.enabled && w.globals.shouldAnimate) {
                _speed = this.dynamicAnim.speed;
                var colorFrom = w.globals.previousPaths[i] && w.globals.previousPaths[i][j] && w.globals.previousPaths[i][j].color;
                if (!colorFrom) colorFrom = 'rgba(255, 255, 255, 0)';
                this.animateHeatColor(rect, Utils$1.isColorHex(colorFrom) ? colorFrom : Utils$1.rgb2hex(colorFrom), Utils$1.isColorHex(color) ? color : Utils$1.rgb2hex(color), _speed);
              }
            }
            var formatter = w.config.dataLabels.formatter;
            var formattedText = formatter(w.globals.series[i][j], {
              value: w.globals.series[i][j],
              seriesIndex: i,
              dataPointIndex: j,
              w: w
            });
            var dataLabels = this.helpers.calculateDataLabels({
              text: formattedText,
              x: x1 + xDivision / 2,
              y: y1 + yDivision / 2,
              i: i,
              j: j,
              colorProps: heatColorProps,
              series: heatSeries
            });
            if (dataLabels !== null) {
              elSeries.add(dataLabels);
            }
            x1 = x1 + xDivision;
            j++;
          }
          y1 = y1 + yDivision;
          ret.add(elSeries);
        }

        // adjust yaxis labels for heatmap
        var yAxisScale = w.globals.yAxisScale[0].result.slice();
        if (w.config.yaxis[0].reversed) {
          yAxisScale.unshift('');
        } else {
          yAxisScale.push('');
        }
        w.globals.yAxisScale[0].result = yAxisScale;
        return ret;
      }
    }, {
      key: "animateHeatMap",
      value: function animateHeatMap(el, x, y, width, height, speed) {
        var animations = new Animations(this.ctx);
        animations.animateRect(el, {
          x: x + width / 2,
          y: y + height / 2,
          width: 0,
          height: 0
        }, {
          x: x,
          y: y,
          width: width,
          height: height
        }, speed, function () {
          animations.animationCompleted(el);
        });
      }
    }, {
      key: "animateHeatColor",
      value: function animateHeatColor(el, colorFrom, colorTo, speed) {
        el.attr({
          fill: colorFrom
        }).animate(speed).attr({
          fill: colorTo
        });
      }
    }]);
    return HeatMap;
  }();

  var CircularChartsHelpers = /*#__PURE__*/function () {
    function CircularChartsHelpers(ctx) {
      _classCallCheck(this, CircularChartsHelpers);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(CircularChartsHelpers, [{
      key: "drawYAxisTexts",
      value: function drawYAxisTexts(x, y, i, text) {
        var w = this.w;
        var yaxisConfig = w.config.yaxis[0];
        var formatter = w.globals.yLabelFormatters[0];
        var graphics = new Graphics(this.ctx);
        var yaxisLabel = graphics.drawText({
          x: x + yaxisConfig.labels.offsetX,
          y: y + yaxisConfig.labels.offsetY,
          text: formatter(text, i),
          textAnchor: 'middle',
          fontSize: yaxisConfig.labels.style.fontSize,
          fontFamily: yaxisConfig.labels.style.fontFamily,
          foreColor: Array.isArray(yaxisConfig.labels.style.colors) ? yaxisConfig.labels.style.colors[i] : yaxisConfig.labels.style.colors
        });
        return yaxisLabel;
      }
    }]);
    return CircularChartsHelpers;
  }();

  /**
   * ApexCharts Pie Class for drawing Pie / Donut Charts.
   * @module Pie
   **/
  var Pie = /*#__PURE__*/function () {
    function Pie(ctx) {
      _classCallCheck(this, Pie);
      this.ctx = ctx;
      this.w = ctx.w;
      var w = this.w;
      this.chartType = this.w.config.chart.type;
      this.initialAnim = this.w.config.chart.animations.enabled;
      this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
      this.animBeginArr = [0];
      this.animDur = 0;
      this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels;
      this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;
      this.defaultSize = Math.min(w.globals.gridWidth, w.globals.gridHeight);
      this.centerY = this.defaultSize / 2;
      this.centerX = w.globals.gridWidth / 2;
      if (w.config.chart.type === 'radialBar') {
        this.fullAngle = 360;
      } else {
        this.fullAngle = Math.abs(w.config.plotOptions.pie.endAngle - w.config.plotOptions.pie.startAngle);
      }
      this.initialAngle = w.config.plotOptions.pie.startAngle % this.fullAngle;
      w.globals.radialSize = this.defaultSize / 2.05 - w.config.stroke.width - (!w.config.chart.sparkline.enabled ? w.config.chart.dropShadow.blur : 0);
      this.donutSize = w.globals.radialSize * parseInt(w.config.plotOptions.pie.donut.size, 10) / 100;
      var scaleSize = w.config.plotOptions.pie.customScale;
      var halfW = w.globals.gridWidth / 2;
      var halfH = w.globals.gridHeight / 2;
      this.translateX = halfW - halfW * scaleSize;
      this.translateY = halfH - halfH * scaleSize;
      this.dataLabelsGroup = new Graphics(this.ctx).group({
        class: 'apexcharts-datalabels-group',
        transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(scaleSize, ")")
      });
      this.maxY = 0;
      this.sliceLabels = [];
      this.sliceSizes = [];
      this.prevSectorAngleArr = []; // for dynamic animations
    }
    _createClass(Pie, [{
      key: "draw",
      value: function draw(series) {
        var _this = this;
        var self = this;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var elPie = graphics.group({
          class: 'apexcharts-pie'
        });
        if (w.globals.noData) return elPie;
        var total = 0;
        for (var k = 0; k < series.length; k++) {
          // CALCULATE THE TOTAL
          total += Utils$1.negToZero(series[k]);
        }
        var sectorAngleArr = [];

        // el to which series will be drawn
        var elSeries = graphics.group();

        // prevent division by zero error if there is no data
        if (total === 0) {
          total = 0.00001;
        }
        series.forEach(function (m) {
          _this.maxY = Math.max(_this.maxY, m);
        });

        // override maxY if user provided in config
        if (w.config.yaxis[0].max) {
          this.maxY = w.config.yaxis[0].max;
        }
        if (w.config.grid.position === 'back' && this.chartType === 'polarArea') {
          this.drawPolarElements(elPie);
        }
        for (var i = 0; i < series.length; i++) {
          // CALCULATE THE ANGLES
          var angle = this.fullAngle * Utils$1.negToZero(series[i]) / total;
          sectorAngleArr.push(angle);
          if (this.chartType === 'polarArea') {
            sectorAngleArr[i] = this.fullAngle / series.length;
            this.sliceSizes.push(w.globals.radialSize * series[i] / this.maxY);
          } else {
            this.sliceSizes.push(w.globals.radialSize);
          }
        }
        if (w.globals.dataChanged) {
          var prevTotal = 0;
          for (var _k = 0; _k < w.globals.previousPaths.length; _k++) {
            // CALCULATE THE PREV TOTAL
            prevTotal += Utils$1.negToZero(w.globals.previousPaths[_k]);
          }
          var previousAngle;
          for (var _i = 0; _i < w.globals.previousPaths.length; _i++) {
            // CALCULATE THE PREVIOUS ANGLES
            previousAngle = this.fullAngle * Utils$1.negToZero(w.globals.previousPaths[_i]) / prevTotal;
            this.prevSectorAngleArr.push(previousAngle);
          }
        }

        // on small chart size after few count of resizes browser window donutSize can be negative
        if (this.donutSize < 0) {
          this.donutSize = 0;
        }
        if (this.chartType === 'donut') {
          // draw the inner circle and add some text to it
          var circle = graphics.drawCircle(this.donutSize);
          circle.attr({
            cx: this.centerX,
            cy: this.centerY,
            fill: w.config.plotOptions.pie.donut.background ? w.config.plotOptions.pie.donut.background : 'transparent'
          });
          elSeries.add(circle);
        }
        var elG = self.drawArcs(sectorAngleArr, series);

        // add slice dataLabels at the end
        this.sliceLabels.forEach(function (s) {
          elG.add(s);
        });
        elSeries.attr({
          transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(w.config.plotOptions.pie.customScale, ")")
        });
        elSeries.add(elG);
        elPie.add(elSeries);
        if (this.donutDataLabels.show) {
          var dataLabels = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, {
            hollowSize: this.donutSize,
            centerX: this.centerX,
            centerY: this.centerY,
            opacity: this.donutDataLabels.show
          });
          elPie.add(dataLabels);
        }
        if (w.config.grid.position === 'front' && this.chartType === 'polarArea') {
          this.drawPolarElements(elPie);
        }
        return elPie;
      }

      // core function for drawing pie arcs
    }, {
      key: "drawArcs",
      value: function drawArcs(sectorAngleArr, series) {
        var w = this.w;
        var filters = new Filters(this.ctx);
        var graphics = new Graphics(this.ctx);
        var fill = new Fill(this.ctx);
        var g = graphics.group({
          class: 'apexcharts-slices'
        });
        var startAngle = this.initialAngle;
        var prevStartAngle = this.initialAngle;
        var endAngle = this.initialAngle;
        var prevEndAngle = this.initialAngle;
        this.strokeWidth = w.config.stroke.show ? w.config.stroke.width : 0;
        for (var i = 0; i < sectorAngleArr.length; i++) {
          var elPieArc = graphics.group({
            class: "apexcharts-series apexcharts-pie-series",
            seriesName: Utils$1.escapeString(w.globals.seriesNames[i]),
            rel: i + 1,
            'data:realIndex': i
          });
          g.add(elPieArc);
          startAngle = endAngle;
          prevStartAngle = prevEndAngle;
          endAngle = startAngle + sectorAngleArr[i];
          prevEndAngle = prevStartAngle + this.prevSectorAngleArr[i];
          var angle = endAngle < startAngle ? this.fullAngle + endAngle - startAngle : endAngle - startAngle;
          var pathFill = fill.fillPath({
            seriesNumber: i,
            size: this.sliceSizes[i],
            value: series[i]
          }); // additionally, pass size for gradient drawing in the fillPath function

          var path = this.getChangedPath(prevStartAngle, prevEndAngle);
          var elPath = graphics.drawPath({
            d: path,
            stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[i] : this.lineColorArr,
            strokeWidth: 0,
            fill: pathFill,
            fillOpacity: w.config.fill.opacity,
            classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(i)
          });
          elPath.attr({
            index: 0,
            j: i
          });
          filters.setSelectionFilter(elPath, 0, i);
          if (w.config.chart.dropShadow.enabled) {
            var shadow = w.config.chart.dropShadow;
            filters.dropShadow(elPath, shadow, i);
          }
          this.addListeners(elPath, this.donutDataLabels);
          Graphics.setAttrs(elPath.node, {
            'data:angle': angle,
            'data:startAngle': startAngle,
            'data:strokeWidth': this.strokeWidth,
            'data:value': series[i]
          });
          var labelPosition = {
            x: 0,
            y: 0
          };
          if (this.chartType === 'pie' || this.chartType === 'polarArea') {
            labelPosition = Utils$1.polarToCartesian(this.centerX, this.centerY, w.globals.radialSize / 1.25 + w.config.plotOptions.pie.dataLabels.offset, (startAngle + angle / 2) % this.fullAngle);
          } else if (this.chartType === 'donut') {
            labelPosition = Utils$1.polarToCartesian(this.centerX, this.centerY, (w.globals.radialSize + this.donutSize) / 2 + w.config.plotOptions.pie.dataLabels.offset, (startAngle + angle / 2) % this.fullAngle);
          }
          elPieArc.add(elPath);

          // Animation code starts
          var dur = 0;
          if (this.initialAnim && !w.globals.resized && !w.globals.dataChanged) {
            dur = angle / this.fullAngle * w.config.chart.animations.speed;
            if (dur === 0) dur = 1;
            this.animDur = dur + this.animDur;
            this.animBeginArr.push(this.animDur);
          } else {
            this.animBeginArr.push(0);
          }
          if (this.dynamicAnim && w.globals.dataChanged) {
            this.animatePaths(elPath, {
              size: this.sliceSizes[i],
              endAngle: endAngle,
              startAngle: startAngle,
              prevStartAngle: prevStartAngle,
              prevEndAngle: prevEndAngle,
              animateStartingPos: true,
              i: i,
              animBeginArr: this.animBeginArr,
              shouldSetPrevPaths: true,
              dur: w.config.chart.animations.dynamicAnimation.speed
            });
          } else {
            this.animatePaths(elPath, {
              size: this.sliceSizes[i],
              endAngle: endAngle,
              startAngle: startAngle,
              i: i,
              totalItems: sectorAngleArr.length - 1,
              animBeginArr: this.animBeginArr,
              dur: dur
            });
          }
          // animation code ends

          if (w.config.plotOptions.pie.expandOnClick && this.chartType !== 'polarArea') {
            elPath.node.addEventListener('mouseup', this.pieClicked.bind(this, i));
          }
          if (typeof w.globals.selectedDataPoints[0] !== 'undefined' && w.globals.selectedDataPoints[0].indexOf(i) > -1) {
            this.pieClicked(i);
          }
          if (w.config.dataLabels.enabled) {
            var xPos = labelPosition.x;
            var yPos = labelPosition.y;
            var text = 100 * angle / this.fullAngle + '%';
            if (angle !== 0 && w.config.plotOptions.pie.dataLabels.minAngleToShowLabel < sectorAngleArr[i]) {
              var formatter = w.config.dataLabels.formatter;
              if (formatter !== undefined) {
                text = formatter(w.globals.seriesPercent[i][0], {
                  seriesIndex: i,
                  w: w
                });
              }
              var foreColor = w.globals.dataLabels.style.colors[i];
              var elPieLabelWrap = graphics.group({
                class: "apexcharts-datalabels"
              });
              var elPieLabel = graphics.drawText({
                x: xPos,
                y: yPos,
                text: text,
                textAnchor: 'middle',
                fontSize: w.config.dataLabels.style.fontSize,
                fontFamily: w.config.dataLabels.style.fontFamily,
                fontWeight: w.config.dataLabels.style.fontWeight,
                foreColor: foreColor
              });
              elPieLabelWrap.add(elPieLabel);
              if (w.config.dataLabels.dropShadow.enabled) {
                var textShadow = w.config.dataLabels.dropShadow;
                filters.dropShadow(elPieLabel, textShadow);
              }
              elPieLabel.node.classList.add('apexcharts-pie-label');
              if (w.config.chart.animations.animate && w.globals.resized === false) {
                elPieLabel.node.classList.add('apexcharts-pie-label-delay');
                elPieLabel.node.style.animationDelay = w.config.chart.animations.speed / 940 + 's';
              }
              this.sliceLabels.push(elPieLabelWrap);
            }
          }
        }
        return g;
      }
    }, {
      key: "addListeners",
      value: function addListeners(elPath, dataLabels) {
        var graphics = new Graphics(this.ctx);
        // append filters on mouseenter and mouseleave
        elPath.node.addEventListener('mouseenter', graphics.pathMouseEnter.bind(this, elPath));
        elPath.node.addEventListener('mouseleave', graphics.pathMouseLeave.bind(this, elPath));
        elPath.node.addEventListener('mouseleave', this.revertDataLabelsInner.bind(this, elPath.node, dataLabels));
        elPath.node.addEventListener('mousedown', graphics.pathMouseDown.bind(this, elPath));
        if (!this.donutDataLabels.total.showAlways) {
          elPath.node.addEventListener('mouseenter', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));
          elPath.node.addEventListener('mousedown', this.printDataLabelsInner.bind(this, elPath.node, dataLabels));
        }
      }

      // This function can be used for other circle charts too
    }, {
      key: "animatePaths",
      value: function animatePaths(el, opts) {
        var w = this.w;
        var me = this;
        var angle = opts.endAngle < opts.startAngle ? this.fullAngle + opts.endAngle - opts.startAngle : opts.endAngle - opts.startAngle;
        var prevAngle = angle;
        var fromStartAngle = opts.startAngle;
        var toStartAngle = opts.startAngle;
        if (opts.prevStartAngle !== undefined && opts.prevEndAngle !== undefined) {
          fromStartAngle = opts.prevEndAngle;
          prevAngle = opts.prevEndAngle < opts.prevStartAngle ? this.fullAngle + opts.prevEndAngle - opts.prevStartAngle : opts.prevEndAngle - opts.prevStartAngle;
        }
        if (opts.i === w.config.series.length - 1) {
          // some adjustments for the last overlapping paths
          if (angle + toStartAngle > this.fullAngle) {
            opts.endAngle = opts.endAngle - (angle + toStartAngle);
          } else if (angle + toStartAngle < this.fullAngle) {
            opts.endAngle = opts.endAngle + (this.fullAngle - (angle + toStartAngle));
          }
        }
        if (angle === this.fullAngle) angle = this.fullAngle - 0.01;
        me.animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts);
      }
    }, {
      key: "animateArc",
      value: function animateArc(el, fromStartAngle, toStartAngle, angle, prevAngle, opts) {
        var me = this;
        var w = this.w;
        var animations = new Animations(this.ctx);
        var size = opts.size;
        var path;
        if (isNaN(fromStartAngle) || isNaN(prevAngle)) {
          fromStartAngle = toStartAngle;
          prevAngle = angle;
          opts.dur = 0;
        }
        var currAngle = angle;
        var startAngle = toStartAngle;
        var fromAngle = fromStartAngle < toStartAngle ? this.fullAngle + fromStartAngle - toStartAngle : fromStartAngle - toStartAngle;
        if (w.globals.dataChanged && opts.shouldSetPrevPaths) {
          // to avoid flicker when updating, set prev path first and then animate from there
          if (opts.prevEndAngle) {
            path = me.getPiePath({
              me: me,
              startAngle: opts.prevStartAngle,
              angle: opts.prevEndAngle < opts.prevStartAngle ? this.fullAngle + opts.prevEndAngle - opts.prevStartAngle : opts.prevEndAngle - opts.prevStartAngle,
              size: size
            });
            el.attr({
              d: path
            });
          }
        }
        if (opts.dur !== 0) {
          el.animate(opts.dur, opts.animBeginArr[opts.i]).after(function () {
            if (me.chartType === 'pie' || me.chartType === 'donut' || me.chartType === 'polarArea') {
              this.animate(w.config.chart.animations.dynamicAnimation.speed).attr({
                'stroke-width': me.strokeWidth
              });
            }
            if (opts.i === w.config.series.length - 1) {
              animations.animationCompleted(el);
            }
          }).during(function (pos) {
            currAngle = fromAngle + (angle - fromAngle) * pos;
            if (opts.animateStartingPos) {
              currAngle = prevAngle + (angle - prevAngle) * pos;
              startAngle = fromStartAngle - prevAngle + (toStartAngle - (fromStartAngle - prevAngle)) * pos;
            }
            path = me.getPiePath({
              me: me,
              startAngle: startAngle,
              angle: currAngle,
              size: size
            });
            el.node.setAttribute('data:pathOrig', path);
            el.attr({
              d: path
            });
          });
        } else {
          path = me.getPiePath({
            me: me,
            startAngle: startAngle,
            angle: angle,
            size: size
          });
          if (!opts.isTrack) {
            w.globals.animationEnded = true;
          }
          el.node.setAttribute('data:pathOrig', path);
          el.attr({
            d: path,
            'stroke-width': me.strokeWidth
          });
        }
      }
    }, {
      key: "pieClicked",
      value: function pieClicked(i) {
        var w = this.w;
        var me = this;
        var path;
        var size = me.sliceSizes[i] + (w.config.plotOptions.pie.expandOnClick ? 4 : 0);
        var elPath = w.globals.dom.Paper.findOne(".apexcharts-".concat(me.chartType.toLowerCase(), "-slice-").concat(i));
        if (elPath.attr('data:pieClicked') === 'true') {
          elPath.attr({
            'data:pieClicked': 'false'
          });
          this.revertDataLabelsInner(elPath.node, this.donutDataLabels);
          var origPath = elPath.attr('data:pathOrig');
          elPath.attr({
            d: origPath
          });
          return;
        } else {
          // reset all elems
          var allEls = w.globals.dom.baseEl.getElementsByClassName('apexcharts-pie-area');
          Array.prototype.forEach.call(allEls, function (pieSlice) {
            pieSlice.setAttribute('data:pieClicked', 'false');
            var origPath = pieSlice.getAttribute('data:pathOrig');
            if (origPath) {
              pieSlice.setAttribute('d', origPath);
            }
          });
          w.globals.capturedDataPointIndex = i;
          elPath.attr('data:pieClicked', 'true');
        }
        var startAngle = parseInt(elPath.attr('data:startAngle'), 10);
        var angle = parseInt(elPath.attr('data:angle'), 10);
        path = me.getPiePath({
          me: me,
          startAngle: startAngle,
          angle: angle,
          size: size
        });
        if (angle === 360) return;
        elPath.plot(path);
      }
    }, {
      key: "getChangedPath",
      value: function getChangedPath(prevStartAngle, prevEndAngle) {
        var path = '';
        if (this.dynamicAnim && this.w.globals.dataChanged) {
          path = this.getPiePath({
            me: this,
            startAngle: prevStartAngle,
            angle: prevEndAngle - prevStartAngle,
            size: this.size
          });
        }
        return path;
      }
    }, {
      key: "getPiePath",
      value: function getPiePath(_ref) {
        var me = _ref.me,
          startAngle = _ref.startAngle,
          angle = _ref.angle,
          size = _ref.size;
        var path;
        var graphics = new Graphics(this.ctx);
        var startDeg = startAngle;
        var startRadians = Math.PI * (startDeg - 90) / 180;
        var endDeg = angle + startAngle;
        // prevent overlap
        if (Math.ceil(endDeg) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle) {
          endDeg = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01;
        }
        if (Math.ceil(endDeg) > this.fullAngle) endDeg -= this.fullAngle;
        var endRadians = Math.PI * (endDeg - 90) / 180;
        var x1 = me.centerX + size * Math.cos(startRadians);
        var y1 = me.centerY + size * Math.sin(startRadians);
        var x2 = me.centerX + size * Math.cos(endRadians);
        var y2 = me.centerY + size * Math.sin(endRadians);
        var startInner = Utils$1.polarToCartesian(me.centerX, me.centerY, me.donutSize, endDeg);
        var endInner = Utils$1.polarToCartesian(me.centerX, me.centerY, me.donutSize, startDeg);
        var largeArc = angle > 180 ? 1 : 0;
        var pathBeginning = ['M', x1, y1, 'A', size, size, 0, largeArc, 1, x2, y2];
        if (me.chartType === 'donut') {
          path = [].concat(pathBeginning, ['L', startInner.x, startInner.y, 'A', me.donutSize, me.donutSize, 0, largeArc, 0, endInner.x, endInner.y, 'L', x1, y1, 'z']).join(' ');
        } else if (me.chartType === 'pie' || me.chartType === 'polarArea') {
          path = [].concat(pathBeginning, ['L', me.centerX, me.centerY, 'L', x1, y1]).join(' ');
        } else {
          path = [].concat(pathBeginning).join(' ');
        }
        return graphics.roundPathCorners(path, this.strokeWidth * 2);
      }
    }, {
      key: "drawPolarElements",
      value: function drawPolarElements(parent) {
        var w = this.w;
        var scale = new Scales(this.ctx);
        var graphics = new Graphics(this.ctx);
        var helpers = new CircularChartsHelpers(this.ctx);
        var gCircles = graphics.group();
        var gYAxis = graphics.group();
        var yScale = scale.niceScale(0, Math.ceil(this.maxY), 0);
        var yTexts = yScale.result.reverse();
        var len = yScale.result.length;
        this.maxY = yScale.niceMax;
        var circleSize = w.globals.radialSize;
        var diff = circleSize / (len - 1);
        for (var i = 0; i < len - 1; i++) {
          var circle = graphics.drawCircle(circleSize);
          circle.attr({
            cx: this.centerX,
            cy: this.centerY,
            fill: 'none',
            'stroke-width': w.config.plotOptions.polarArea.rings.strokeWidth,
            stroke: w.config.plotOptions.polarArea.rings.strokeColor
          });
          if (w.config.yaxis[0].show) {
            var yLabel = helpers.drawYAxisTexts(this.centerX, this.centerY - circleSize + parseInt(w.config.yaxis[0].labels.style.fontSize, 10) / 2, i, yTexts[i]);
            gYAxis.add(yLabel);
          }
          gCircles.add(circle);
          circleSize = circleSize - diff;
        }
        this.drawSpokes(parent);
        parent.add(gCircles);
        parent.add(gYAxis);
      }
    }, {
      key: "renderInnerDataLabels",
      value: function renderInnerDataLabels(dataLabelsGroup, dataLabelsConfig, opts) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var showTotal = dataLabelsConfig.total.show;
        dataLabelsGroup.node.innerHTML = '';
        dataLabelsGroup.node.style.opacity = opts.opacity;
        var x = opts.centerX;
        var y = !this.donutDataLabels.total.label ? opts.centerY - opts.centerY / 6 : opts.centerY;
        var labelColor, valueColor;
        if (dataLabelsConfig.name.color === undefined) {
          labelColor = w.globals.colors[0];
        } else {
          labelColor = dataLabelsConfig.name.color;
        }
        var labelFontSize = dataLabelsConfig.name.fontSize;
        var labelFontFamily = dataLabelsConfig.name.fontFamily;
        var labelFontWeight = dataLabelsConfig.name.fontWeight;
        if (dataLabelsConfig.value.color === undefined) {
          valueColor = w.config.chart.foreColor;
        } else {
          valueColor = dataLabelsConfig.value.color;
        }
        var lbFormatter = dataLabelsConfig.value.formatter;
        var val = '';
        var name = '';
        if (showTotal) {
          labelColor = dataLabelsConfig.total.color;
          labelFontSize = dataLabelsConfig.total.fontSize;
          labelFontFamily = dataLabelsConfig.total.fontFamily;
          labelFontWeight = dataLabelsConfig.total.fontWeight;
          name = !this.donutDataLabels.total.label ? '' : dataLabelsConfig.total.label;
          val = dataLabelsConfig.total.formatter(w);
        } else {
          if (w.globals.series.length === 1) {
            val = lbFormatter(w.globals.series[0], w);
            name = w.globals.seriesNames[0];
          }
        }
        if (name) {
          name = dataLabelsConfig.name.formatter(name, dataLabelsConfig.total.show, w);
        }
        if (dataLabelsConfig.name.show) {
          var elLabel = graphics.drawText({
            x: x,
            y: y + parseFloat(dataLabelsConfig.name.offsetY),
            text: name,
            textAnchor: 'middle',
            foreColor: labelColor,
            fontSize: labelFontSize,
            fontWeight: labelFontWeight,
            fontFamily: labelFontFamily
          });
          elLabel.node.classList.add('apexcharts-datalabel-label');
          dataLabelsGroup.add(elLabel);
        }
        if (dataLabelsConfig.value.show) {
          var valOffset = dataLabelsConfig.name.show ? parseFloat(dataLabelsConfig.value.offsetY) + 16 : dataLabelsConfig.value.offsetY;
          var elValue = graphics.drawText({
            x: x,
            y: y + valOffset,
            text: val,
            textAnchor: 'middle',
            foreColor: valueColor,
            fontWeight: dataLabelsConfig.value.fontWeight,
            fontSize: dataLabelsConfig.value.fontSize,
            fontFamily: dataLabelsConfig.value.fontFamily
          });
          elValue.node.classList.add('apexcharts-datalabel-value');
          dataLabelsGroup.add(elValue);
        }

        // for a multi-series circle chart, we need to show total value instead of first series labels

        return dataLabelsGroup;
      }

      /**
       *
       * @param {string} name - The name of the series
       * @param {string} val - The value of that series
       * @param {object} el - Optional el (indicates which series was hovered/clicked). If this param is not present, means we need to show total
       */
    }, {
      key: "printInnerLabels",
      value: function printInnerLabels(labelsConfig, name, val, el) {
        var w = this.w;
        var labelColor;
        if (el) {
          if (labelsConfig.name.color === undefined) {
            labelColor = w.globals.colors[parseInt(el.parentNode.getAttribute('rel'), 10) - 1];
          } else {
            labelColor = labelsConfig.name.color;
          }
        } else {
          if (w.globals.series.length > 1 && labelsConfig.total.show) {
            labelColor = labelsConfig.total.color;
          }
        }
        var elLabel = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-label');
        var elValue = w.globals.dom.baseEl.querySelector('.apexcharts-datalabel-value');
        var lbFormatter = labelsConfig.value.formatter;
        val = lbFormatter(val, w);

        // we need to show Total Val - so get the formatter of it
        if (!el && typeof labelsConfig.total.formatter === 'function') {
          val = labelsConfig.total.formatter(w);
        }
        var isTotal = name === labelsConfig.total.label;
        name = !this.donutDataLabels.total.label ? '' : labelsConfig.name.formatter(name, isTotal, w);
        if (elLabel !== null) {
          elLabel.textContent = name;
        }
        if (elValue !== null) {
          elValue.textContent = val;
        }
        if (elLabel !== null) {
          elLabel.style.fill = labelColor;
        }
      }
    }, {
      key: "printDataLabelsInner",
      value: function printDataLabelsInner(el, dataLabelsConfig) {
        var w = this.w;
        var val = el.getAttribute('data:value');
        var name = w.globals.seriesNames[parseInt(el.parentNode.getAttribute('rel'), 10) - 1];
        if (w.globals.series.length > 1) {
          this.printInnerLabels(dataLabelsConfig, name, val, el);
        }
        var dataLabelsGroup = w.globals.dom.baseEl.querySelector('.apexcharts-datalabels-group');
        if (dataLabelsGroup !== null) {
          dataLabelsGroup.style.opacity = 1;
        }
      }
    }, {
      key: "drawSpokes",
      value: function drawSpokes(parent) {
        var _this2 = this;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var spokeConfig = w.config.plotOptions.polarArea.spokes;
        if (spokeConfig.strokeWidth === 0) return;
        var spokes = [];
        var angleDivision = 360 / w.globals.series.length;
        for (var i = 0; i < w.globals.series.length; i++) {
          spokes.push(Utils$1.polarToCartesian(this.centerX, this.centerY, w.globals.radialSize, w.config.plotOptions.pie.startAngle + angleDivision * i));
        }
        spokes.forEach(function (p, i) {
          var line = graphics.drawLine(p.x, p.y, _this2.centerX, _this2.centerY, Array.isArray(spokeConfig.connectorColors) ? spokeConfig.connectorColors[i] : spokeConfig.connectorColors);
          parent.add(line);
        });
      }
    }, {
      key: "revertDataLabelsInner",
      value: function revertDataLabelsInner() {
        var w = this.w;
        if (this.donutDataLabels.show) {
          var dataLabelsGroup = w.globals.dom.Paper.findOne(".apexcharts-datalabels-group");
          var dataLabels = this.renderInnerDataLabels(dataLabelsGroup, this.donutDataLabels, {
            hollowSize: this.donutSize,
            centerX: this.centerX,
            centerY: this.centerY,
            opacity: this.donutDataLabels.show
          });
          var elPie = w.globals.dom.Paper.findOne('.apexcharts-radialbar, .apexcharts-pie');
          elPie.add(dataLabels);
        }
      }
    }]);
    return Pie;
  }();

  /**
   * ApexCharts Radar Class for Spider/Radar Charts.
   * @module Radar
   **/
  var Radar = /*#__PURE__*/function () {
    function Radar(ctx) {
      _classCallCheck(this, Radar);
      this.ctx = ctx;
      this.w = ctx.w;
      this.chartType = this.w.config.chart.type;
      this.initialAnim = this.w.config.chart.animations.enabled;
      this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
      this.animDur = 0;
      var w = this.w;
      this.graphics = new Graphics(this.ctx);
      this.lineColorArr = w.globals.stroke.colors !== undefined ? w.globals.stroke.colors : w.globals.colors;
      this.defaultSize = w.globals.svgHeight < w.globals.svgWidth ? w.globals.gridHeight : w.globals.gridWidth;
      this.isLog = w.config.yaxis[0].logarithmic;
      this.logBase = w.config.yaxis[0].logBase;
      this.coreUtils = new CoreUtils(this.ctx);
      this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, w.globals.maxY, 0) : w.globals.maxY;
      this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : w.globals.minY;
      this.polygons = w.config.plotOptions.radar.polygons;
      this.strokeWidth = w.config.stroke.show ? w.config.stroke.width : 0;
      this.size = this.defaultSize / 2.1 - this.strokeWidth - w.config.chart.dropShadow.blur;
      if (w.config.xaxis.labels.show) {
        this.size = this.size - w.globals.xAxisLabelsWidth / 1.75;
      }
      if (w.config.plotOptions.radar.size !== undefined) {
        this.size = w.config.plotOptions.radar.size;
      }
      this.dataRadiusOfPercent = [];
      this.dataRadius = [];
      this.angleArr = [];
      this.yaxisLabelsTextsPos = [];
    }
    _createClass(Radar, [{
      key: "draw",
      value: function draw(series) {
        var _this = this;
        var w = this.w;
        var fill = new Fill(this.ctx);
        var allSeries = [];
        var dataLabels = new DataLabels(this.ctx);
        if (series.length) {
          this.dataPointsLen = series[w.globals.maxValsInArrayIndex].length;
        }
        this.disAngle = Math.PI * 2 / this.dataPointsLen;
        var halfW = w.globals.gridWidth / 2;
        var halfH = w.globals.gridHeight / 2;
        var translateX = halfW + w.config.plotOptions.radar.offsetX;
        var translateY = halfH + w.config.plotOptions.radar.offsetY;
        var ret = this.graphics.group({
          class: 'apexcharts-radar-series apexcharts-plot-series',
          transform: "translate(".concat(translateX || 0, ", ").concat(translateY || 0, ")")
        });
        var dataPointsPos = [];
        var elPointsMain = null;
        var elDataPointsMain = null;
        this.yaxisLabels = this.graphics.group({
          class: 'apexcharts-yaxis'
        });
        series.forEach(function (s, i) {
          var longestSeries = s.length === w.globals.dataPoints;

          // el to which series will be drawn
          var elSeries = _this.graphics.group().attr({
            class: "apexcharts-series",
            'data:longestSeries': longestSeries,
            seriesName: Utils$1.escapeString(w.globals.seriesNames[i]),
            rel: i + 1,
            'data:realIndex': i
          });
          _this.dataRadiusOfPercent[i] = [];
          _this.dataRadius[i] = [];
          _this.angleArr[i] = [];
          s.forEach(function (dv, j) {
            var range = Math.abs(_this.maxValue - _this.minValue);
            dv = dv - _this.minValue;
            if (_this.isLog) {
              dv = _this.coreUtils.getLogVal(_this.logBase, dv, 0);
            }
            _this.dataRadiusOfPercent[i][j] = dv / range;
            _this.dataRadius[i][j] = _this.dataRadiusOfPercent[i][j] * _this.size;
            _this.angleArr[i][j] = j * _this.disAngle;
          });
          dataPointsPos = _this.getDataPointsPos(_this.dataRadius[i], _this.angleArr[i]);
          var paths = _this.createPaths(dataPointsPos, {
            x: 0,
            y: 0
          });

          // points
          elPointsMain = _this.graphics.group({
            class: 'apexcharts-series-markers-wrap apexcharts-element-hidden'
          });

          // datapoints
          elDataPointsMain = _this.graphics.group({
            class: "apexcharts-datalabels",
            'data:realIndex': i
          });
          w.globals.delayedElements.push({
            el: elPointsMain.node,
            index: i
          });
          var defaultRenderedPathOptions = {
            i: i,
            realIndex: i,
            animationDelay: i,
            initialSpeed: w.config.chart.animations.speed,
            dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,
            className: "apexcharts-radar",
            shouldClipToGrid: false,
            bindEventsOnPaths: false,
            stroke: w.globals.stroke.colors[i],
            strokeLineCap: w.config.stroke.lineCap
          };
          var pathFrom = null;
          if (w.globals.previousPaths.length > 0) {
            pathFrom = _this.getPreviousPath(i);
          }
          for (var p = 0; p < paths.linePathsTo.length; p++) {
            var renderedLinePath = _this.graphics.renderPaths(_objectSpread2(_objectSpread2({}, defaultRenderedPathOptions), {}, {
              pathFrom: pathFrom === null ? paths.linePathsFrom[p] : pathFrom,
              pathTo: paths.linePathsTo[p],
              strokeWidth: Array.isArray(_this.strokeWidth) ? _this.strokeWidth[i] : _this.strokeWidth,
              fill: 'none',
              drawShadow: false
            }));
            elSeries.add(renderedLinePath);
            var pathFill = fill.fillPath({
              seriesNumber: i
            });
            var renderedAreaPath = _this.graphics.renderPaths(_objectSpread2(_objectSpread2({}, defaultRenderedPathOptions), {}, {
              pathFrom: pathFrom === null ? paths.areaPathsFrom[p] : pathFrom,
              pathTo: paths.areaPathsTo[p],
              strokeWidth: 0,
              fill: pathFill,
              drawShadow: false
            }));
            if (w.config.chart.dropShadow.enabled) {
              var filters = new Filters(_this.ctx);
              var shadow = w.config.chart.dropShadow;
              filters.dropShadow(renderedAreaPath, Object.assign({}, shadow, {
                noUserSpaceOnUse: true
              }), i);
            }
            elSeries.add(renderedAreaPath);
          }
          s.forEach(function (sj, j) {
            var markers = new Markers(_this.ctx);
            var opts = markers.getMarkerConfig({
              cssClass: 'apexcharts-marker',
              seriesIndex: i,
              dataPointIndex: j
            });
            var point = _this.graphics.drawMarker(dataPointsPos[j].x, dataPointsPos[j].y, opts);
            point.attr('rel', j);
            point.attr('j', j);
            point.attr('index', i);
            point.node.setAttribute('default-marker-size', opts.pSize);
            var elPointsWrap = _this.graphics.group({
              class: 'apexcharts-series-markers'
            });
            if (elPointsWrap) {
              elPointsWrap.add(point);
            }
            elPointsMain.add(elPointsWrap);
            elSeries.add(elPointsMain);
            var dataLabelsConfig = w.config.dataLabels;
            if (dataLabelsConfig.enabled) {
              var text = dataLabelsConfig.formatter(w.globals.series[i][j], {
                seriesIndex: i,
                dataPointIndex: j,
                w: w
              });
              dataLabels.plotDataLabelsText({
                x: dataPointsPos[j].x,
                y: dataPointsPos[j].y,
                text: text,
                textAnchor: 'middle',
                i: i,
                j: i,
                parent: elDataPointsMain,
                offsetCorrection: false,
                dataLabelsConfig: _objectSpread2({}, dataLabelsConfig)
              });
            }
            elSeries.add(elDataPointsMain);
          });
          allSeries.push(elSeries);
        });
        this.drawPolygons({
          parent: ret
        });
        if (w.config.xaxis.labels.show) {
          var xaxisTexts = this.drawXAxisTexts();
          ret.add(xaxisTexts);
        }
        allSeries.forEach(function (elS) {
          ret.add(elS);
        });
        ret.add(this.yaxisLabels);
        return ret;
      }
    }, {
      key: "drawPolygons",
      value: function drawPolygons(opts) {
        var _this2 = this;
        var w = this.w;
        var parent = opts.parent;
        var helpers = new CircularChartsHelpers(this.ctx);
        var yaxisTexts = w.globals.yAxisScale[0].result.reverse();
        var layers = yaxisTexts.length;
        var radiusSizes = [];
        var layerDis = this.size / (layers - 1);
        for (var i = 0; i < layers; i++) {
          radiusSizes[i] = layerDis * i;
        }
        radiusSizes.reverse();
        var polygonStrings = [];
        var lines = [];
        radiusSizes.forEach(function (radiusSize, r) {
          var polygon = Utils$1.getPolygonPos(radiusSize, _this2.dataPointsLen);
          var string = '';
          polygon.forEach(function (p, i) {
            if (r === 0) {
              var line = _this2.graphics.drawLine(p.x, p.y, 0, 0, Array.isArray(_this2.polygons.connectorColors) ? _this2.polygons.connectorColors[i] : _this2.polygons.connectorColors);
              lines.push(line);
            }
            if (i === 0) {
              _this2.yaxisLabelsTextsPos.push({
                x: p.x,
                y: p.y
              });
            }
            string += p.x + ',' + p.y + ' ';
          });
          polygonStrings.push(string);
        });
        polygonStrings.forEach(function (p, i) {
          var strokeColors = _this2.polygons.strokeColors;
          var strokeWidth = _this2.polygons.strokeWidth;
          var polygon = _this2.graphics.drawPolygon(p, Array.isArray(strokeColors) ? strokeColors[i] : strokeColors, Array.isArray(strokeWidth) ? strokeWidth[i] : strokeWidth, w.globals.radarPolygons.fill.colors[i]);
          parent.add(polygon);
        });
        lines.forEach(function (l) {
          parent.add(l);
        });
        if (w.config.yaxis[0].show) {
          this.yaxisLabelsTextsPos.forEach(function (p, i) {
            var yText = helpers.drawYAxisTexts(p.x, p.y, i, yaxisTexts[i]);
            _this2.yaxisLabels.add(yText);
          });
        }
      }
    }, {
      key: "drawXAxisTexts",
      value: function drawXAxisTexts() {
        var _this3 = this;
        var w = this.w;
        var xaxisLabelsConfig = w.config.xaxis.labels;
        var elXAxisWrap = this.graphics.group({
          class: 'apexcharts-xaxis'
        });
        var polygonPos = Utils$1.getPolygonPos(this.size, this.dataPointsLen);
        w.globals.labels.forEach(function (label, i) {
          var formatter = w.config.xaxis.labels.formatter;
          var dataLabels = new DataLabels(_this3.ctx);
          if (polygonPos[i]) {
            var textPos = _this3.getTextPos(polygonPos[i], _this3.size);
            var text = formatter(label, {
              seriesIndex: -1,
              dataPointIndex: i,
              w: w
            });
            var dataLabelText = dataLabels.plotDataLabelsText({
              x: textPos.newX,
              y: textPos.newY,
              text: text,
              textAnchor: textPos.textAnchor,
              i: i,
              j: i,
              parent: elXAxisWrap,
              className: 'apexcharts-xaxis-label',
              color: Array.isArray(xaxisLabelsConfig.style.colors) && xaxisLabelsConfig.style.colors[i] ? xaxisLabelsConfig.style.colors[i] : '#a8a8a8',
              dataLabelsConfig: _objectSpread2({
                textAnchor: textPos.textAnchor,
                dropShadow: {
                  enabled: false
                }
              }, xaxisLabelsConfig),
              offsetCorrection: false
            });
            dataLabelText.on('click', function (e) {
              if (typeof w.config.chart.events.xAxisLabelClick === 'function') {
                var opts = Object.assign({}, w, {
                  labelIndex: i
                });
                w.config.chart.events.xAxisLabelClick(e, _this3.ctx, opts);
              }
            });
          }
        });
        return elXAxisWrap;
      }
    }, {
      key: "createPaths",
      value: function createPaths(pos, origin) {
        var _this4 = this;
        var linePathsTo = [];
        var linePathsFrom = [];
        var areaPathsTo = [];
        var areaPathsFrom = [];
        if (pos.length) {
          linePathsFrom = [this.graphics.move(origin.x, origin.y)];
          areaPathsFrom = [this.graphics.move(origin.x, origin.y)];
          var linePathTo = this.graphics.move(pos[0].x, pos[0].y);
          var areaPathTo = this.graphics.move(pos[0].x, pos[0].y);
          pos.forEach(function (p, i) {
            linePathTo += _this4.graphics.line(p.x, p.y);
            areaPathTo += _this4.graphics.line(p.x, p.y);
            if (i === pos.length - 1) {
              linePathTo += 'Z';
              areaPathTo += 'Z';
            }
          });
          linePathsTo.push(linePathTo);
          areaPathsTo.push(areaPathTo);
        }
        return {
          linePathsFrom: linePathsFrom,
          linePathsTo: linePathsTo,
          areaPathsFrom: areaPathsFrom,
          areaPathsTo: areaPathsTo
        };
      }
    }, {
      key: "getTextPos",
      value: function getTextPos(pos, polygonSize) {
        var limit = 10;
        var textAnchor = 'middle';
        var newX = pos.x;
        var newY = pos.y;
        if (Math.abs(pos.x) >= limit) {
          if (pos.x > 0) {
            textAnchor = 'start';
            newX += 10;
          } else if (pos.x < 0) {
            textAnchor = 'end';
            newX -= 10;
          }
        } else {
          textAnchor = 'middle';
        }
        if (Math.abs(pos.y) >= polygonSize - limit) {
          if (pos.y < 0) {
            newY -= 10;
          } else if (pos.y > 0) {
            newY += 10;
          }
        }
        return {
          textAnchor: textAnchor,
          newX: newX,
          newY: newY
        };
      }
    }, {
      key: "getPreviousPath",
      value: function getPreviousPath(realIndex) {
        var w = this.w;
        var pathFrom = null;
        for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {
          var gpp = w.globals.previousPaths[pp];
          if (gpp.paths.length > 0 && parseInt(gpp.realIndex, 10) === parseInt(realIndex, 10)) {
            if (typeof w.globals.previousPaths[pp].paths[0] !== 'undefined') {
              pathFrom = w.globals.previousPaths[pp].paths[0].d;
            }
          }
        }
        return pathFrom;
      }
    }, {
      key: "getDataPointsPos",
      value: function getDataPointsPos(dataRadiusArr, angleArr) {
        var dataPointsLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dataPointsLen;
        dataRadiusArr = dataRadiusArr || [];
        angleArr = angleArr || [];
        var dataPointsPosArray = [];
        for (var j = 0; j < dataPointsLen; j++) {
          var curPointPos = {};
          curPointPos.x = dataRadiusArr[j] * Math.sin(angleArr[j]);
          curPointPos.y = -dataRadiusArr[j] * Math.cos(angleArr[j]);
          dataPointsPosArray.push(curPointPos);
        }
        return dataPointsPosArray;
      }
    }]);
    return Radar;
  }();

  /**
   * ApexCharts Radial Class for drawing Circle / Semi Circle Charts.
   * @module Radial
   **/
  var Radial = /*#__PURE__*/function (_Pie) {
    _inherits(Radial, _Pie);
    var _super = _createSuper(Radial);
    function Radial(ctx) {
      var _this;
      _classCallCheck(this, Radial);
      _this = _super.call(this, ctx);
      _this.ctx = ctx;
      _this.w = ctx.w;
      _this.animBeginArr = [0];
      _this.animDur = 0;
      var w = _this.w;
      _this.startAngle = w.config.plotOptions.radialBar.startAngle;
      _this.endAngle = w.config.plotOptions.radialBar.endAngle;
      _this.totalAngle = Math.abs(w.config.plotOptions.radialBar.endAngle - w.config.plotOptions.radialBar.startAngle);
      _this.trackStartAngle = w.config.plotOptions.radialBar.track.startAngle;
      _this.trackEndAngle = w.config.plotOptions.radialBar.track.endAngle;
      _this.barLabels = _this.w.config.plotOptions.radialBar.barLabels;
      _this.donutDataLabels = _this.w.config.plotOptions.radialBar.dataLabels;
      _this.radialDataLabels = _this.donutDataLabels; // make a copy for easy reference

      if (!_this.trackStartAngle) _this.trackStartAngle = _this.startAngle;
      if (!_this.trackEndAngle) _this.trackEndAngle = _this.endAngle;
      if (_this.endAngle === 360) _this.endAngle = 359.99;
      _this.margin = parseInt(w.config.plotOptions.radialBar.track.margin, 10);
      _this.onBarLabelClick = _this.onBarLabelClick.bind(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(Radial, [{
      key: "draw",
      value: function draw(series) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var ret = graphics.group({
          class: 'apexcharts-radialbar'
        });
        if (w.globals.noData) return ret;
        var elSeries = graphics.group();
        var centerY = this.defaultSize / 2;
        var centerX = w.globals.gridWidth / 2;
        var size = this.defaultSize / 2.05;
        if (!w.config.chart.sparkline.enabled) {
          size = size - w.config.stroke.width - w.config.chart.dropShadow.blur;
        }
        var colorArr = w.globals.fill.colors;
        if (w.config.plotOptions.radialBar.track.show) {
          var elTracks = this.drawTracks({
            size: size,
            centerX: centerX,
            centerY: centerY,
            colorArr: colorArr,
            series: series
          });
          elSeries.add(elTracks);
        }
        var elG = this.drawArcs({
          size: size,
          centerX: centerX,
          centerY: centerY,
          colorArr: colorArr,
          series: series
        });
        var totalAngle = 360;
        if (w.config.plotOptions.radialBar.startAngle < 0) {
          totalAngle = this.totalAngle;
        }
        var angleRatio = (360 - totalAngle) / 360;
        w.globals.radialSize = size - size * angleRatio;
        if (this.radialDataLabels.value.show) {
          var offset = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
          w.globals.radialSize += offset * angleRatio;
        }
        elSeries.add(elG.g);
        if (w.config.plotOptions.radialBar.hollow.position === 'front') {
          elG.g.add(elG.elHollow);
          if (elG.dataLabels) {
            elG.g.add(elG.dataLabels);
          }
        }
        ret.add(elSeries);
        return ret;
      }
    }, {
      key: "drawTracks",
      value: function drawTracks(opts) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var g = graphics.group({
          class: 'apexcharts-tracks'
        });
        var filters = new Filters(this.ctx);
        var fill = new Fill(this.ctx);
        var strokeWidth = this.getStrokeWidth(opts);
        opts.size = opts.size - strokeWidth / 2;
        for (var i = 0; i < opts.series.length; i++) {
          var elRadialBarTrack = graphics.group({
            class: 'apexcharts-radialbar-track apexcharts-track'
          });
          g.add(elRadialBarTrack);
          elRadialBarTrack.attr({
            rel: i + 1
          });
          opts.size = opts.size - strokeWidth - this.margin;
          var trackConfig = w.config.plotOptions.radialBar.track;
          var pathFill = fill.fillPath({
            seriesNumber: 0,
            size: opts.size,
            fillColors: Array.isArray(trackConfig.background) ? trackConfig.background[i] : trackConfig.background,
            solid: true
          });
          var startAngle = this.trackStartAngle;
          var endAngle = this.trackEndAngle;
          if (Math.abs(endAngle) + Math.abs(startAngle) >= 360) endAngle = 360 - Math.abs(this.startAngle) - 0.1;
          var elPath = graphics.drawPath({
            d: '',
            stroke: pathFill,
            strokeWidth: strokeWidth * parseInt(trackConfig.strokeWidth, 10) / 100,
            fill: 'none',
            strokeOpacity: trackConfig.opacity,
            classes: 'apexcharts-radialbar-area'
          });
          if (trackConfig.dropShadow.enabled) {
            var shadow = trackConfig.dropShadow;
            filters.dropShadow(elPath, shadow);
          }
          elRadialBarTrack.add(elPath);
          elPath.attr('id', 'apexcharts-radialbarTrack-' + i);
          this.animatePaths(elPath, {
            centerX: opts.centerX,
            centerY: opts.centerY,
            endAngle: endAngle,
            startAngle: startAngle,
            size: opts.size,
            i: i,
            totalItems: 2,
            animBeginArr: 0,
            dur: 0,
            isTrack: true
          });
        }
        return g;
      }
    }, {
      key: "drawArcs",
      value: function drawArcs(opts) {
        var w = this.w;
        // size, donutSize, centerX, centerY, colorArr, lineColorArr, sectorAngleArr, series

        var graphics = new Graphics(this.ctx);
        var fill = new Fill(this.ctx);
        var filters = new Filters(this.ctx);
        var g = graphics.group();
        var strokeWidth = this.getStrokeWidth(opts);
        opts.size = opts.size - strokeWidth / 2;
        var hollowFillID = w.config.plotOptions.radialBar.hollow.background;
        var hollowSize = opts.size - strokeWidth * opts.series.length - this.margin * opts.series.length - strokeWidth * parseInt(w.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2;
        var hollowRadius = hollowSize - w.config.plotOptions.radialBar.hollow.margin;
        if (w.config.plotOptions.radialBar.hollow.image !== undefined) {
          hollowFillID = this.drawHollowImage(opts, g, hollowSize, hollowFillID);
        }
        var elHollow = this.drawHollow({
          size: hollowRadius,
          centerX: opts.centerX,
          centerY: opts.centerY,
          fill: hollowFillID ? hollowFillID : 'transparent'
        });
        if (w.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
          var shadow = w.config.plotOptions.radialBar.hollow.dropShadow;
          filters.dropShadow(elHollow, shadow);
        }
        var shown = 1;
        if (!this.radialDataLabels.total.show && w.globals.series.length > 1) {
          shown = 0;
        }
        var dataLabels = null;
        if (this.radialDataLabels.show) {
          var dataLabelsGroup = w.globals.dom.Paper.findOne(".apexcharts-datalabels-group");
          dataLabels = this.renderInnerDataLabels(dataLabelsGroup, this.radialDataLabels, {
            hollowSize: hollowSize,
            centerX: opts.centerX,
            centerY: opts.centerY,
            opacity: shown
          });
        }
        if (w.config.plotOptions.radialBar.hollow.position === 'back') {
          g.add(elHollow);
          if (dataLabels) {
            g.add(dataLabels);
          }
        }
        var reverseLoop = false;
        if (w.config.plotOptions.radialBar.inverseOrder) {
          reverseLoop = true;
        }
        for (var i = reverseLoop ? opts.series.length - 1 : 0; reverseLoop ? i >= 0 : i < opts.series.length; reverseLoop ? i-- : i++) {
          var elRadialBarArc = graphics.group({
            class: "apexcharts-series apexcharts-radial-series",
            seriesName: Utils$1.escapeString(w.globals.seriesNames[i])
          });
          g.add(elRadialBarArc);
          elRadialBarArc.attr({
            rel: i + 1,
            'data:realIndex': i
          });
          this.ctx.series.addCollapsedClassToSeries(elRadialBarArc, i);
          opts.size = opts.size - strokeWidth - this.margin;
          var pathFill = fill.fillPath({
            seriesNumber: i,
            size: opts.size,
            value: opts.series[i]
          });
          var startAngle = this.startAngle;
          var prevStartAngle = void 0;

          // if data exceeds 100, make it 100
          var dataValue = Utils$1.negToZero(opts.series[i] > 100 ? 100 : opts.series[i]) / 100;
          var endAngle = Math.round(this.totalAngle * dataValue) + this.startAngle;
          var prevEndAngle = void 0;
          if (w.globals.dataChanged) {
            prevStartAngle = this.startAngle;
            prevEndAngle = Math.round(this.totalAngle * Utils$1.negToZero(w.globals.previousPaths[i]) / 100) + prevStartAngle;
          }
          var currFullAngle = Math.abs(endAngle) + Math.abs(startAngle);
          if (currFullAngle > 360) {
            endAngle = endAngle - 0.01;
          }
          var prevFullAngle = Math.abs(prevEndAngle) + Math.abs(prevStartAngle);
          if (prevFullAngle > 360) {
            prevEndAngle = prevEndAngle - 0.01;
          }
          var angle = endAngle - startAngle;
          var dashArray = Array.isArray(w.config.stroke.dashArray) ? w.config.stroke.dashArray[i] : w.config.stroke.dashArray;
          var elPath = graphics.drawPath({
            d: '',
            stroke: pathFill,
            strokeWidth: strokeWidth,
            fill: 'none',
            fillOpacity: w.config.fill.opacity,
            classes: 'apexcharts-radialbar-area apexcharts-radialbar-slice-' + i,
            strokeDashArray: dashArray
          });
          Graphics.setAttrs(elPath.node, {
            'data:angle': angle,
            'data:value': opts.series[i]
          });
          if (w.config.chart.dropShadow.enabled) {
            var _shadow = w.config.chart.dropShadow;
            filters.dropShadow(elPath, _shadow, i);
          }
          filters.setSelectionFilter(elPath, 0, i);
          this.addListeners(elPath, this.radialDataLabels);
          elRadialBarArc.add(elPath);
          elPath.attr({
            index: 0,
            j: i
          });
          if (this.barLabels.enabled) {
            var barStartCords = Utils$1.polarToCartesian(opts.centerX, opts.centerY, opts.size, startAngle);
            var text = this.barLabels.formatter(w.globals.seriesNames[i], {
              seriesIndex: i,
              w: w
            });
            var classes = ['apexcharts-radialbar-label'];
            if (!this.barLabels.onClick) {
              classes.push('apexcharts-no-click');
            }
            var textColor = this.barLabels.useSeriesColors ? w.globals.colors[i] : w.config.chart.foreColor;
            if (!textColor) {
              textColor = w.config.chart.foreColor;
            }
            var x = barStartCords.x + this.barLabels.offsetX;
            var y = barStartCords.y + this.barLabels.offsetY;
            var elText = graphics.drawText({
              x: x,
              y: y,
              text: text,
              textAnchor: 'end',
              dominantBaseline: 'middle',
              fontFamily: this.barLabels.fontFamily,
              fontWeight: this.barLabels.fontWeight,
              fontSize: this.barLabels.fontSize,
              foreColor: textColor,
              cssClass: classes.join(' ')
            });
            elText.on('click', this.onBarLabelClick);
            elText.attr({
              rel: i + 1
            });
            if (startAngle !== 0) {
              elText.attr({
                'transform-origin': "".concat(x, " ").concat(y),
                transform: "rotate(".concat(startAngle, " 0 0)")
              });
            }
            elRadialBarArc.add(elText);
          }
          var dur = 0;
          if (this.initialAnim && !w.globals.resized && !w.globals.dataChanged) {
            dur = w.config.chart.animations.speed;
          }
          if (w.globals.dataChanged) {
            dur = w.config.chart.animations.dynamicAnimation.speed;
          }
          this.animDur = dur / (opts.series.length * 1.2) + this.animDur;
          this.animBeginArr.push(this.animDur);
          this.animatePaths(elPath, {
            centerX: opts.centerX,
            centerY: opts.centerY,
            endAngle: endAngle,
            startAngle: startAngle,
            prevEndAngle: prevEndAngle,
            prevStartAngle: prevStartAngle,
            size: opts.size,
            i: i,
            totalItems: 2,
            animBeginArr: this.animBeginArr,
            dur: dur,
            shouldSetPrevPaths: true
          });
        }
        return {
          g: g,
          elHollow: elHollow,
          dataLabels: dataLabels
        };
      }
    }, {
      key: "drawHollow",
      value: function drawHollow(opts) {
        var graphics = new Graphics(this.ctx);
        var circle = graphics.drawCircle(opts.size * 2);
        circle.attr({
          class: 'apexcharts-radialbar-hollow',
          cx: opts.centerX,
          cy: opts.centerY,
          r: opts.size,
          fill: opts.fill
        });
        return circle;
      }
    }, {
      key: "drawHollowImage",
      value: function drawHollowImage(opts, g, hollowSize, hollowFillID) {
        var w = this.w;
        var fill = new Fill(this.ctx);
        var randID = Utils$1.randomId();
        var hollowFillImg = w.config.plotOptions.radialBar.hollow.image;
        if (w.config.plotOptions.radialBar.hollow.imageClipped) {
          fill.clippedImgArea({
            width: hollowSize,
            height: hollowSize,
            image: hollowFillImg,
            patternID: "pattern".concat(w.globals.cuid).concat(randID)
          });
          hollowFillID = "url(#pattern".concat(w.globals.cuid).concat(randID, ")");
        } else {
          var imgWidth = w.config.plotOptions.radialBar.hollow.imageWidth;
          var imgHeight = w.config.plotOptions.radialBar.hollow.imageHeight;
          if (imgWidth === undefined && imgHeight === undefined) {
            var image = w.globals.dom.Paper.image(hollowFillImg, function (loader) {
              this.move(opts.centerX - loader.width / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - loader.height / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);
            });
            g.add(image);
          } else {
            var _image = w.globals.dom.Paper.image(hollowFillImg, function (loader) {
              this.move(opts.centerX - imgWidth / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetX, opts.centerY - imgHeight / 2 + w.config.plotOptions.radialBar.hollow.imageOffsetY);
              this.size(imgWidth, imgHeight);
            });
            g.add(_image);
          }
        }
        return hollowFillID;
      }
    }, {
      key: "getStrokeWidth",
      value: function getStrokeWidth(opts) {
        var w = this.w;
        return opts.size * (100 - parseInt(w.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (opts.series.length + 1) - this.margin;
      }
    }, {
      key: "onBarLabelClick",
      value: function onBarLabelClick(e) {
        var seriesIndex = parseInt(e.target.getAttribute('rel'), 10) - 1;
        var legendClick = this.barLabels.onClick;
        var w = this.w;
        if (legendClick) {
          legendClick(w.globals.seriesNames[seriesIndex], {
            w: w,
            seriesIndex: seriesIndex
          });
        }
      }
    }]);
    return Radial;
  }(Pie);

  /**
   * ApexCharts RangeBar Class responsible for drawing Range/Timeline Bars.
   *
   * @module RangeBar
   **/
  var RangeBar = /*#__PURE__*/function (_Bar) {
    _inherits(RangeBar, _Bar);
    var _super = _createSuper(RangeBar);
    function RangeBar() {
      _classCallCheck(this, RangeBar);
      return _super.apply(this, arguments);
    }
    _createClass(RangeBar, [{
      key: "draw",
      value: function draw(series, seriesIndex) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        this.rangeBarOptions = this.w.config.plotOptions.rangeBar;
        this.series = series;
        this.seriesRangeStart = w.globals.seriesRangeStart;
        this.seriesRangeEnd = w.globals.seriesRangeEnd;
        this.barHelpers.initVariables(series);
        var ret = graphics.group({
          class: 'apexcharts-rangebar-series apexcharts-plot-series'
        });
        for (var i = 0; i < series.length; i++) {
          var x = void 0,
            y = void 0,
            xDivision = void 0,
            // xDivision is the GRIDWIDTH divided by number of datapoints (columns)
            yDivision = void 0,
            // yDivision is the GRIDHEIGHT divided by number of datapoints (bars)
            zeroH = void 0,
            // zeroH is the baseline where 0 meets y axis
            zeroW = void 0; // zeroW is the baseline where 0 meets x axis

          var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;
          var _this$barHelpers$getG = this.barHelpers.getGroupIndex(realIndex),
            columnGroupIndex = _this$barHelpers$getG.columnGroupIndex;

          // el to which series will be drawn
          var elSeries = graphics.group({
            class: "apexcharts-series",
            seriesName: Utils$1.escapeString(w.globals.seriesNames[realIndex]),
            rel: i + 1,
            'data:realIndex': realIndex
          });
          this.ctx.series.addCollapsedClassToSeries(elSeries, realIndex);
          if (series[i].length > 0) {
            this.visibleI = this.visibleI + 1;
          }
          var barHeight = 0;
          var barWidth = 0;
          var translationsIndex = 0;
          if (this.yRatio.length > 1) {
            this.yaxisIndex = w.globals.seriesYAxisReverseMap[realIndex][0];
            translationsIndex = realIndex;
          }
          var initPositions = this.barHelpers.initialPositions(realIndex);
          y = initPositions.y;
          zeroW = initPositions.zeroW;
          x = initPositions.x;
          barWidth = initPositions.barWidth;
          barHeight = initPositions.barHeight;
          xDivision = initPositions.xDivision;
          yDivision = initPositions.yDivision;
          zeroH = initPositions.zeroH;

          // eldatalabels
          var elDataLabelsWrap = graphics.group({
            class: 'apexcharts-datalabels',
            'data:realIndex': realIndex
          });
          var elGoalsMarkers = graphics.group({
            class: 'apexcharts-rangebar-goals-markers'
          });
          for (var j = 0; j < w.globals.dataPoints; j++) {
            var strokeWidth = this.barHelpers.getStrokeWidth(i, j, realIndex);
            var y1 = this.seriesRangeStart[i][j];
            var y2 = this.seriesRangeEnd[i][j];
            var paths = null;
            var barXPosition = null;
            var barYPosition = null;
            var params = {
              x: x,
              y: y,
              strokeWidth: strokeWidth,
              elSeries: elSeries
            };
            var seriesLen = this.seriesLen;
            if (w.config.plotOptions.bar.rangeBarGroupRows) {
              seriesLen = 1;
            }
            if (typeof w.config.series[i].data[j] === 'undefined') {
              // no data exists for further indexes, hence we need to get out the innr loop.
              // As we are iterating over total datapoints, there is a possiblity the series might not have data for j index
              break;
            }
            if (this.isHorizontal) {
              barYPosition = y + barHeight * this.visibleI;
              var srty = (yDivision - barHeight * seriesLen) / 2;
              if (w.config.series[i].data[j].x) {
                var positions = this.detectOverlappingBars({
                  i: i,
                  j: j,
                  barYPosition: barYPosition,
                  srty: srty,
                  barHeight: barHeight,
                  yDivision: yDivision,
                  initPositions: initPositions
                });
                barHeight = positions.barHeight;
                barYPosition = positions.barYPosition;
              }
              paths = this.drawRangeBarPaths(_objectSpread2({
                indexes: {
                  i: i,
                  j: j,
                  realIndex: realIndex
                },
                barHeight: barHeight,
                barYPosition: barYPosition,
                zeroW: zeroW,
                yDivision: yDivision,
                y1: y1,
                y2: y2
              }, params));
              barWidth = paths.barWidth;
            } else {
              if (w.globals.isXNumeric) {
                x = (w.globals.seriesX[i][j] - w.globals.minX) / this.xRatio - barWidth / 2;
              }
              barXPosition = x + barWidth * this.visibleI;
              var srtx = (xDivision - barWidth * seriesLen) / 2;
              if (w.config.series[i].data[j].x) {
                var _positions = this.detectOverlappingBars({
                  i: i,
                  j: j,
                  barXPosition: barXPosition,
                  srtx: srtx,
                  barWidth: barWidth,
                  xDivision: xDivision,
                  initPositions: initPositions
                });
                barWidth = _positions.barWidth;
                barXPosition = _positions.barXPosition;
              }
              paths = this.drawRangeColumnPaths(_objectSpread2({
                indexes: {
                  i: i,
                  j: j,
                  realIndex: realIndex,
                  translationsIndex: translationsIndex
                },
                barWidth: barWidth,
                barXPosition: barXPosition,
                zeroH: zeroH,
                xDivision: xDivision
              }, params));
              barHeight = paths.barHeight;
            }
            var barGoalLine = this.barHelpers.drawGoalLine({
              barXPosition: paths.barXPosition,
              barYPosition: barYPosition,
              goalX: paths.goalX,
              goalY: paths.goalY,
              barHeight: barHeight,
              barWidth: barWidth
            });
            if (barGoalLine) {
              elGoalsMarkers.add(barGoalLine);
            }
            y = paths.y;
            x = paths.x;
            var pathFill = this.barHelpers.getPathFillColor(series, i, j, realIndex);
            this.renderSeries({
              realIndex: realIndex,
              pathFill: pathFill.color,
              lineFill: pathFill.useRangeColor ? pathFill.color : w.globals.stroke.colors[realIndex],
              j: j,
              i: i,
              x: x,
              y: y,
              y1: y1,
              y2: y2,
              pathFrom: paths.pathFrom,
              pathTo: paths.pathTo,
              strokeWidth: strokeWidth,
              elSeries: elSeries,
              series: series,
              barHeight: barHeight,
              barWidth: barWidth,
              barXPosition: barXPosition,
              barYPosition: barYPosition,
              columnGroupIndex: columnGroupIndex,
              elDataLabelsWrap: elDataLabelsWrap,
              elGoalsMarkers: elGoalsMarkers,
              visibleSeries: this.visibleI,
              type: 'rangebar'
            });
          }
          ret.add(elSeries);
        }
        return ret;
      }
    }, {
      key: "detectOverlappingBars",
      value: function detectOverlappingBars(_ref) {
        var i = _ref.i,
          j = _ref.j,
          barYPosition = _ref.barYPosition,
          barXPosition = _ref.barXPosition,
          srty = _ref.srty,
          srtx = _ref.srtx,
          barHeight = _ref.barHeight,
          barWidth = _ref.barWidth,
          yDivision = _ref.yDivision,
          xDivision = _ref.xDivision,
          initPositions = _ref.initPositions;
        var w = this.w;
        var overlaps = [];
        var rangeName = w.config.series[i].data[j].rangeName;
        var x = w.config.series[i].data[j].x;
        var labelX = Array.isArray(x) ? x.join(' ') : x;
        var rowIndex = w.globals.labels.map(function (_) {
          return Array.isArray(_) ? _.join(' ') : _;
        }).indexOf(labelX);
        var overlappedIndex = w.globals.seriesRange[i].findIndex(function (tx) {
          return tx.x === labelX && tx.overlaps.length > 0;
        });
        if (this.isHorizontal) {
          if (w.config.plotOptions.bar.rangeBarGroupRows) {
            barYPosition = srty + yDivision * rowIndex;
          } else {
            barYPosition = srty + barHeight * this.visibleI + yDivision * rowIndex;
          }
          if (overlappedIndex > -1 && !w.config.plotOptions.bar.rangeBarOverlap) {
            overlaps = w.globals.seriesRange[i][overlappedIndex].overlaps;
            if (overlaps.indexOf(rangeName) > -1) {
              barHeight = initPositions.barHeight / overlaps.length;
              barYPosition = barHeight * this.visibleI + yDivision * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + barHeight * (this.visibleI + overlaps.indexOf(rangeName)) + yDivision * rowIndex;
            }
          }
        } else {
          if (rowIndex > -1 && !w.globals.timescaleLabels.length) {
            if (w.config.plotOptions.bar.rangeBarGroupRows) {
              barXPosition = srtx + xDivision * rowIndex;
            } else {
              barXPosition = srtx + barWidth * this.visibleI + xDivision * rowIndex;
            }
          }
          if (overlappedIndex > -1 && !w.config.plotOptions.bar.rangeBarOverlap) {
            overlaps = w.globals.seriesRange[i][overlappedIndex].overlaps;
            if (overlaps.indexOf(rangeName) > -1) {
              barWidth = initPositions.barWidth / overlaps.length;
              barXPosition = barWidth * this.visibleI + xDivision * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + barWidth * (this.visibleI + overlaps.indexOf(rangeName)) + xDivision * rowIndex;
            }
          }
        }
        return {
          barYPosition: barYPosition,
          barXPosition: barXPosition,
          barHeight: barHeight,
          barWidth: barWidth
        };
      }
    }, {
      key: "drawRangeColumnPaths",
      value: function drawRangeColumnPaths(_ref2) {
        var indexes = _ref2.indexes,
          x = _ref2.x,
          xDivision = _ref2.xDivision,
          barWidth = _ref2.barWidth,
          barXPosition = _ref2.barXPosition,
          zeroH = _ref2.zeroH;
        var w = this.w;
        var i = indexes.i,
          j = indexes.j,
          realIndex = indexes.realIndex,
          translationsIndex = indexes.translationsIndex;
        var yRatio = this.yRatio[translationsIndex];
        var range = this.getRangeValue(realIndex, j);
        var y1 = Math.min(range.start, range.end);
        var y2 = Math.max(range.start, range.end);
        if (typeof this.series[i][j] === 'undefined' || this.series[i][j] === null) {
          y1 = zeroH;
        } else {
          y1 = zeroH - y1 / yRatio;
          y2 = zeroH - y2 / yRatio;
        }
        var barHeight = Math.abs(y2 - y1);
        var paths = this.barHelpers.getColumnPaths({
          barXPosition: barXPosition,
          barWidth: barWidth,
          y1: y1,
          y2: y2,
          strokeWidth: this.strokeWidth,
          series: this.seriesRangeEnd,
          realIndex: realIndex,
          i: realIndex,
          j: j,
          w: w
        });
        if (!w.globals.isXNumeric) {
          x = x + xDivision;
        } else {
          var xForNumericXAxis = this.getBarXForNumericXAxis({
            x: x,
            j: j,
            realIndex: realIndex,
            barWidth: barWidth
          });
          x = xForNumericXAxis.x;
          barXPosition = xForNumericXAxis.barXPosition;
        }
        return {
          pathTo: paths.pathTo,
          pathFrom: paths.pathFrom,
          barHeight: barHeight,
          x: x,
          y: range.start < 0 && range.end < 0 ? y1 : y2,
          goalY: this.barHelpers.getGoalValues('y', null, zeroH, i, j, translationsIndex),
          barXPosition: barXPosition
        };
      }
    }, {
      key: "preventBarOverflow",
      value: function preventBarOverflow(val) {
        var w = this.w;
        if (val < 0) {
          val = 0;
        }
        if (val > w.globals.gridWidth) {
          val = w.globals.gridWidth;
        }
        return val;
      }
    }, {
      key: "drawRangeBarPaths",
      value: function drawRangeBarPaths(_ref3) {
        var indexes = _ref3.indexes,
          y = _ref3.y,
          y1 = _ref3.y1,
          y2 = _ref3.y2,
          yDivision = _ref3.yDivision,
          barHeight = _ref3.barHeight,
          barYPosition = _ref3.barYPosition,
          zeroW = _ref3.zeroW;
        var w = this.w;
        var realIndex = indexes.realIndex,
          j = indexes.j;
        var x1 = this.preventBarOverflow(zeroW + y1 / this.invertedYRatio);
        var x2 = this.preventBarOverflow(zeroW + y2 / this.invertedYRatio);
        var range = this.getRangeValue(realIndex, j);
        var barWidth = Math.abs(x2 - x1);
        var paths = this.barHelpers.getBarpaths({
          barYPosition: barYPosition,
          barHeight: barHeight,
          x1: x1,
          x2: x2,
          strokeWidth: this.strokeWidth,
          series: this.seriesRangeEnd,
          i: realIndex,
          realIndex: realIndex,
          j: j,
          w: w
        });
        if (!w.globals.isXNumeric) {
          y = y + yDivision;
        }
        return {
          pathTo: paths.pathTo,
          pathFrom: paths.pathFrom,
          barWidth: barWidth,
          x: range.start < 0 && range.end < 0 ? x1 : x2,
          goalX: this.barHelpers.getGoalValues('x', zeroW, null, realIndex, j),
          y: y
        };
      }
    }, {
      key: "getRangeValue",
      value: function getRangeValue(i, j) {
        var w = this.w;
        return {
          start: w.globals.seriesRangeStart[i][j],
          end: w.globals.seriesRangeEnd[i][j]
        };
      }
    }]);
    return RangeBar;
  }(Bar);

  var Helpers = /*#__PURE__*/function () {
    function Helpers(lineCtx) {
      _classCallCheck(this, Helpers);
      this.w = lineCtx.w;
      this.lineCtx = lineCtx;
    }
    _createClass(Helpers, [{
      key: "sameValueSeriesFix",
      value: function sameValueSeriesFix(i, series) {
        var w = this.w;
        if (w.config.fill.type === 'gradient' || w.config.fill.type[i] === 'gradient') {
          var coreUtils = new CoreUtils(this.lineCtx.ctx, w);

          // applied only to LINE chart
          // a small adjustment to allow gradient line to draw correctly for all same values
          /* #fix https://github.com/apexcharts/apexcharts.js/issues/358 */
          if (coreUtils.seriesHaveSameValues(i)) {
            var gSeries = series[i].slice();
            gSeries[gSeries.length - 1] = gSeries[gSeries.length - 1] + 0.000001;
            series[i] = gSeries;
          }
        }
        return series;
      }
    }, {
      key: "calculatePoints",
      value: function calculatePoints(_ref) {
        var series = _ref.series,
          realIndex = _ref.realIndex,
          x = _ref.x,
          y = _ref.y,
          i = _ref.i,
          j = _ref.j,
          prevY = _ref.prevY;
        var w = this.w;
        var ptX = [];
        var ptY = [];
        var xPT1st = this.lineCtx.categoryAxisCorrection + w.config.markers.offsetX;

        // the first point for line series
        // we need to check whether it's not a time series, because a time series may
        // start from the middle of the x axis
        if (w.globals.isXNumeric) {
          xPT1st = (w.globals.seriesX[realIndex][0] - w.globals.minX) / this.lineCtx.xRatio + w.config.markers.offsetX;
        }

        // push 2 points for the first data values
        if (j === 0) {
          ptX.push(xPT1st);
          ptY.push(Utils$1.isNumber(series[i][0]) ? prevY + w.config.markers.offsetY : null);
        }
        ptX.push(x + w.config.markers.offsetX);
        ptY.push(Utils$1.isNumber(series[i][j + 1]) ? y + w.config.markers.offsetY : null);
        return {
          x: ptX,
          y: ptY
        };
      }
    }, {
      key: "checkPreviousPaths",
      value: function checkPreviousPaths(_ref2) {
        var pathFromLine = _ref2.pathFromLine,
          pathFromArea = _ref2.pathFromArea,
          realIndex = _ref2.realIndex;
        var w = this.w;
        for (var pp = 0; pp < w.globals.previousPaths.length; pp++) {
          var gpp = w.globals.previousPaths[pp];
          if ((gpp.type === 'line' || gpp.type === 'area') && gpp.paths.length > 0 && parseInt(gpp.realIndex, 10) === parseInt(realIndex, 10)) {
            if (gpp.type === 'line') {
              this.lineCtx.appendPathFrom = false;
              pathFromLine = w.globals.previousPaths[pp].paths[0].d;
            } else if (gpp.type === 'area') {
              this.lineCtx.appendPathFrom = false;
              pathFromArea = w.globals.previousPaths[pp].paths[0].d;
              if (w.config.stroke.show && w.globals.previousPaths[pp].paths[1]) {
                pathFromLine = w.globals.previousPaths[pp].paths[1].d;
              }
            }
          }
        }
        return {
          pathFromLine: pathFromLine,
          pathFromArea: pathFromArea
        };
      }
    }, {
      key: "determineFirstPrevY",
      value: function determineFirstPrevY(_ref3) {
        var _this$w$config$series, _this$w$config$series2, _series$i;
        var i = _ref3.i,
          realIndex = _ref3.realIndex,
          series = _ref3.series,
          prevY = _ref3.prevY,
          lineYPosition = _ref3.lineYPosition,
          translationsIndex = _ref3.translationsIndex;
        var w = this.w;
        var stackSeries = w.config.chart.stacked && !w.globals.comboCharts || w.config.chart.stacked && w.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((_this$w$config$series = this.w.config.series[realIndex]) === null || _this$w$config$series === void 0 ? void 0 : _this$w$config$series.type) === 'bar' || ((_this$w$config$series2 = this.w.config.series[realIndex]) === null || _this$w$config$series2 === void 0 ? void 0 : _this$w$config$series2.type) === 'column');
        if (typeof ((_series$i = series[i]) === null || _series$i === void 0 ? void 0 : _series$i[0]) !== 'undefined') {
          if (stackSeries) {
            if (i > 0) {
              // 1st y value of previous series
              lineYPosition = this.lineCtx.prevSeriesY[i - 1][0];
            } else {
              // the first series will not have prevY values
              lineYPosition = this.lineCtx.zeroY;
            }
          } else {
            lineYPosition = this.lineCtx.zeroY;
          }
          prevY = lineYPosition - series[i][0] / this.lineCtx.yRatio[translationsIndex] + (this.lineCtx.isReversed ? series[i][0] / this.lineCtx.yRatio[translationsIndex] : 0) * 2;
        } else {
          // the first value in the current series is null
          if (stackSeries && i > 0 && typeof series[i][0] === 'undefined') {
            // check for undefined value (undefined value will occur when we clear the series while user clicks on legend to hide serieses)
            for (var s = i - 1; s >= 0; s--) {
              // for loop to get to 1st previous value until we get it
              if (series[s][0] !== null && typeof series[s][0] !== 'undefined') {
                lineYPosition = this.lineCtx.prevSeriesY[s][0];
                prevY = lineYPosition;
                break;
              }
            }
          }
        }
        return {
          prevY: prevY,
          lineYPosition: lineYPosition
        };
      }
    }]);
    return Helpers;
  }();

  /**
   * 
   * @yr/monotone-cubic-spline (https://github.com/YR/monotone-cubic-spline)
   * 
   * The MIT License (MIT)
   * 
   * Copyright (c) 2015 yr.no
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the "Software"), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   * the Software, and to permit persons to whom the Software is furnished to do so,
   * subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.

   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
  /**
   * Generate tangents for 'points'
   * @param {Array} points
   * @returns {Array}
   */
  var tangents = function tangents(points) {
    var m = finiteDifferences(points);
    var n = points.length - 1;
    var  = 1e-6;
    var tgts = [];
    var a, b, d, s;
    for (var i = 0; i < n; i++) {
      d = slope(points[i], points[i + 1]);
      if (Math.abs(d) < ) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    for (var _i = 0; _i <= n; _i++) {
      s = (points[Math.min(n, _i + 1)][0] - points[Math.max(0, _i - 1)][0]) / (6 * (1 + m[_i] * m[_i]));
      tgts.push([s || 0, m[_i] * s || 0]);
    }
    return tgts;
  };

  /**
   * Convert 'points' to svg path
   * @param {Array} points
   * @returns {String}
   */
  var svgPath = function svgPath(points) {
    var p = '';
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      var n = point.length;
      if (n > 4) {
        p += "C".concat(point[0], ", ").concat(point[1]);
        p += ", ".concat(point[2], ", ").concat(point[3]);
        p += ", ".concat(point[4], ", ").concat(point[5]);
      } else if (n > 2) {
        p += "S".concat(point[0], ", ").concat(point[1]);
        p += ", ".concat(point[2], ", ").concat(point[3]);
      }
    }
    return p;
  };
  var spline = {
    /**
     * Convert 'points' to bezier
     * @param {Array} points
     * @returns {Array}
     */
    points: function points(_points) {
      var tgts = tangents(_points);
      var p = _points[1];
      var p0 = _points[0];
      var pts = [];
      var t = tgts[1];
      var t0 = tgts[0];

      // Add starting 'M' and 'C' points
      pts.push(p0, [p0[0] + t0[0], p0[1] + t0[1], p[0] - t[0], p[1] - t[1], p[0], p[1]]);

      // Add 'S' points
      for (var i = 2, n = tgts.length; i < n; i++) {
        var _p = _points[i];
        var _t = tgts[i];
        pts.push([_p[0] - _t[0], _p[1] - _t[1], _p[0], _p[1]]);
      }
      return pts;
    },
    /**
     * Slice out a segment of 'points'
     * @param {Array} points
     * @param {Number} start
     * @param {Number} end
     * @returns {Array}
     */
    slice: function slice(points, start, end) {
      var pts = points.slice(start, end);
      if (start) {
        // Add additional 'C' points
        if (end - start > 1 && pts[1].length < 6) {
          var n = pts[0].length;
          pts[1] = [pts[0][n - 2] * 2 - pts[0][n - 4], pts[0][n - 1] * 2 - pts[0][n - 3]].concat(pts[1]);
        }
        // Remove control points for 'M'
        pts[0] = pts[0].slice(-2);
      }
      return pts;
    }
  };

  /**
   * Compute slope from point 'p0' to 'p1'
   * @param {Array} p0
   * @param {Array} p1
   * @returns {Number}
   */
  function slope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }

  /**
   * Compute three-point differences for 'points'
   * @param {Array} points
   * @returns {Array}
   */
  function finiteDifferences(points) {
    var m = [];
    var p0 = points[0];
    var p1 = points[1];
    var d = m[0] = slope(p0, p1);
    var i = 1;
    for (var n = points.length - 1; i < n; i++) {
      p0 = p1;
      p1 = points[i + 1];
      m[i] = (d + (d = slope(p0, p1))) * 0.5;
    }
    m[i] = d;
    return m;
  }

  /**
   * ApexCharts Line Class responsible for drawing Line / Area / RangeArea Charts.
   * This class is also responsible for generating values for Bubble/Scatter charts, so need to rename it to Axis Charts to avoid confusions
   * @module Line
   **/
  var Line = /*#__PURE__*/function () {
    function Line(ctx, xyRatios, isPointsChart) {
      _classCallCheck(this, Line);
      this.ctx = ctx;
      this.w = ctx.w;
      this.xyRatios = xyRatios;
      this.pointsChart = !(this.w.config.chart.type !== 'bubble' && this.w.config.chart.type !== 'scatter') || isPointsChart;
      this.scatter = new Scatter(this.ctx);
      this.noNegatives = this.w.globals.minX === Number.MAX_VALUE;
      this.lineHelpers = new Helpers(this);
      this.markers = new Markers(this.ctx);
      this.prevSeriesY = [];
      this.categoryAxisCorrection = 0;
      this.yaxisIndex = 0;
    }
    _createClass(Line, [{
      key: "draw",
      value: function draw(series, ctype, seriesIndex, seriesRangeEnd) {
        var _w$config$series$;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var type = w.globals.comboCharts ? ctype : w.config.chart.type;
        var ret = graphics.group({
          class: "apexcharts-".concat(type, "-series apexcharts-plot-series")
        });
        var coreUtils = new CoreUtils(this.ctx, w);
        this.yRatio = this.xyRatios.yRatio;
        this.zRatio = this.xyRatios.zRatio;
        this.xRatio = this.xyRatios.xRatio;
        this.baseLineY = this.xyRatios.baseLineY;
        series = coreUtils.getLogSeries(series);
        this.yRatio = coreUtils.getLogYRatios(this.yRatio);
        // We call draw() for each series group
        this.prevSeriesY = [];

        // push all series in an array, so we can draw in reverse order
        // (for stacked charts)
        var allSeries = [];
        for (var i = 0; i < series.length; i++) {
          series = this.lineHelpers.sameValueSeriesFix(i, series);
          var realIndex = w.globals.comboCharts ? seriesIndex[i] : i;
          var translationsIndex = this.yRatio.length > 1 ? realIndex : 0;
          this._initSerieVariables(series, i, realIndex);
          var yArrj = []; // hold y values of current iterating series
          var y2Arrj = []; // holds y2 values in range-area charts
          var xArrj = []; // hold x values of current iterating series

          var x = w.globals.padHorizontal + this.categoryAxisCorrection;
          var y = 1;
          var linePaths = [];
          var areaPaths = [];
          this.ctx.series.addCollapsedClassToSeries(this.elSeries, realIndex);
          if (w.globals.isXNumeric && w.globals.seriesX.length > 0) {
            x = (w.globals.seriesX[realIndex][0] - w.globals.minX) / this.xRatio;
          }
          xArrj.push(x);
          var pX = x;
          var pY = void 0;
          var pY2 = void 0;
          var prevX = pX;
          var prevY = this.zeroY;
          var prevY2 = this.zeroY;
          var lineYPosition = 0;

          // the first value in the current series is not null or undefined
          var firstPrevY = this.lineHelpers.determineFirstPrevY({
            i: i,
            realIndex: realIndex,
            series: series,
            prevY: prevY,
            lineYPosition: lineYPosition,
            translationsIndex: translationsIndex
          });
          prevY = firstPrevY.prevY;
          if (w.config.stroke.curve === 'monotoneCubic' && series[i][0] === null) {
            // we have to discard the y position if 1st dataPoint is null as it
            // causes issues with monotoneCubic path creation
            yArrj.push(null);
          } else {
            yArrj.push(prevY);
          }
          pY = prevY;

          // y2 are needed for range-area charts
          var firstPrevY2 = void 0;
          if (type === 'rangeArea') {
            firstPrevY2 = this.lineHelpers.determineFirstPrevY({
              i: i,
              realIndex: realIndex,
              series: seriesRangeEnd,
              prevY: prevY2,
              lineYPosition: lineYPosition,
              translationsIndex: translationsIndex
            });
            prevY2 = firstPrevY2.prevY;
            pY2 = prevY2;
            y2Arrj.push(yArrj[0] !== null ? prevY2 : null);
          }
          var pathsFrom = this._calculatePathsFrom({
            type: type,
            series: series,
            i: i,
            realIndex: realIndex,
            translationsIndex: translationsIndex,
            prevX: prevX,
            prevY: prevY,
            prevY2: prevY2
          });

          // RangeArea will resume with these for the upper path creation
          var rYArrj = [yArrj[0]];
          var rY2Arrj = [y2Arrj[0]];
          var iteratingOpts = {
            type: type,
            series: series,
            realIndex: realIndex,
            translationsIndex: translationsIndex,
            i: i,
            x: x,
            y: y,
            pX: pX,
            pY: pY,
            pathsFrom: pathsFrom,
            linePaths: linePaths,
            areaPaths: areaPaths,
            seriesIndex: seriesIndex,
            lineYPosition: lineYPosition,
            xArrj: xArrj,
            yArrj: yArrj,
            y2Arrj: y2Arrj,
            seriesRangeEnd: seriesRangeEnd
          };
          var paths = this._iterateOverDataPoints(_objectSpread2(_objectSpread2({}, iteratingOpts), {}, {
            iterations: type === 'rangeArea' ? series[i].length - 1 : undefined,
            isRangeStart: true
          }));
          if (type === 'rangeArea') {
            var pathsFrom2 = this._calculatePathsFrom({
              series: seriesRangeEnd,
              i: i,
              realIndex: realIndex,
              prevX: prevX,
              prevY: prevY2
            });
            var rangePaths = this._iterateOverDataPoints(_objectSpread2(_objectSpread2({}, iteratingOpts), {}, {
              series: seriesRangeEnd,
              xArrj: [x],
              yArrj: rYArrj,
              y2Arrj: rY2Arrj,
              pY: pY2,
              areaPaths: paths.areaPaths,
              pathsFrom: pathsFrom2,
              iterations: seriesRangeEnd[i].length - 1,
              isRangeStart: false
            }));

            // Path may be segmented by nulls in data.
            // paths.linePaths should hold (segments * 2) paths (upper and lower)
            // the first n segments belong to the lower and the last n segments
            // belong to the upper.
            // paths.linePaths and rangePaths.linepaths are actually equivalent
            // but we retain the distinction below for consistency with the
            // unsegmented paths conditional branch.
            var segments = paths.linePaths.length / 2;
            for (var s = 0; s < segments; s++) {
              paths.linePaths[s] = rangePaths.linePaths[s + segments] + paths.linePaths[s];
            }
            paths.linePaths.splice(segments);
            paths.pathFromLine = rangePaths.pathFromLine + paths.pathFromLine;
          } else {
            paths.pathFromArea += 'z';
          }
          this._handlePaths({
            type: type,
            realIndex: realIndex,
            i: i,
            paths: paths
          });
          this.elSeries.add(this.elPointsMain);
          this.elSeries.add(this.elDataLabelsWrap);
          allSeries.push(this.elSeries);
        }
        if (typeof ((_w$config$series$ = w.config.series[0]) === null || _w$config$series$ === void 0 ? void 0 : _w$config$series$.zIndex) !== 'undefined') {
          allSeries.sort(function (a, b) {
            return Number(a.node.getAttribute('zIndex')) - Number(b.node.getAttribute('zIndex'));
          });
        }
        if (w.config.chart.stacked) {
          for (var _s = allSeries.length - 1; _s >= 0; _s--) {
            ret.add(allSeries[_s]);
          }
        } else {
          for (var _s2 = 0; _s2 < allSeries.length; _s2++) {
            ret.add(allSeries[_s2]);
          }
        }
        return ret;
      }
    }, {
      key: "_initSerieVariables",
      value: function _initSerieVariables(series, i, realIndex) {
        var w = this.w;
        var graphics = new Graphics(this.ctx);

        // width divided into equal parts
        this.xDivision = w.globals.gridWidth / (w.globals.dataPoints - (w.config.xaxis.tickPlacement === 'on' ? 1 : 0));
        this.strokeWidth = Array.isArray(w.config.stroke.width) ? w.config.stroke.width[realIndex] : w.config.stroke.width;
        var translationsIndex = 0;
        if (this.yRatio.length > 1) {
          this.yaxisIndex = w.globals.seriesYAxisReverseMap[realIndex];
          translationsIndex = realIndex;
        }
        this.isReversed = w.config.yaxis[this.yaxisIndex] && w.config.yaxis[this.yaxisIndex].reversed;

        // zeroY is the 0 value in y series which can be used in negative charts
        this.zeroY = w.globals.gridHeight - this.baseLineY[translationsIndex] - (this.isReversed ? w.globals.gridHeight : 0) + (this.isReversed ? this.baseLineY[translationsIndex] * 2 : 0);
        this.areaBottomY = this.zeroY;
        if (this.zeroY > w.globals.gridHeight || w.config.plotOptions.area.fillTo === 'end') {
          this.areaBottomY = w.globals.gridHeight;
        }
        this.categoryAxisCorrection = this.xDivision / 2;

        // el to which series will be drawn
        this.elSeries = graphics.group({
          class: "apexcharts-series",
          zIndex: typeof w.config.series[realIndex].zIndex !== 'undefined' ? w.config.series[realIndex].zIndex : realIndex,
          seriesName: Utils$1.escapeString(w.globals.seriesNames[realIndex])
        });

        // points
        this.elPointsMain = graphics.group({
          class: 'apexcharts-series-markers-wrap',
          'data:realIndex': realIndex
        });
        if (w.globals.hasNullValues) {
          // fixes https://github.com/apexcharts/apexcharts.js/issues/3641
          var firstPoint = this.markers.plotChartMarkers({
            pointsPos: {
              x: [0],
              y: [w.globals.gridHeight + w.globals.markers.largestSize]
            },
            seriesIndex: i,
            j: 0,
            pSize: 0.1,
            alwaysDrawMarker: true,
            isVirtualPoint: true
          });
          if (firstPoint !== null) {
            // firstPoint is rendered for cases where there are null values and when dynamic markers are required
            this.elPointsMain.add(firstPoint);
          }
        }

        // eldatalabels
        this.elDataLabelsWrap = graphics.group({
          class: 'apexcharts-datalabels',
          'data:realIndex': realIndex
        });
        var longestSeries = series[i].length === w.globals.dataPoints;
        this.elSeries.attr({
          'data:longestSeries': longestSeries,
          rel: i + 1,
          'data:realIndex': realIndex
        });
        this.appendPathFrom = true;
      }
    }, {
      key: "_calculatePathsFrom",
      value: function _calculatePathsFrom(_ref) {
        var type = _ref.type,
          series = _ref.series,
          i = _ref.i,
          realIndex = _ref.realIndex,
          translationsIndex = _ref.translationsIndex,
          prevX = _ref.prevX,
          prevY = _ref.prevY,
          prevY2 = _ref.prevY2;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var linePath, areaPath, pathFromLine, pathFromArea;
        if (series[i][0] === null) {
          // when the first value itself is null, we need to move the pointer to a location where a null value is not found
          for (var s = 0; s < series[i].length; s++) {
            if (series[i][s] !== null) {
              prevX = this.xDivision * s;
              prevY = this.zeroY - series[i][s] / this.yRatio[translationsIndex];
              linePath = graphics.move(prevX, prevY);
              areaPath = graphics.move(prevX, this.areaBottomY);
              break;
            }
          }
        } else {
          linePath = graphics.move(prevX, prevY);
          if (type === 'rangeArea') {
            linePath = graphics.move(prevX, prevY2) + graphics.line(prevX, prevY);
          }
          areaPath = graphics.move(prevX, this.areaBottomY) + graphics.line(prevX, prevY);
        }
        pathFromLine = graphics.move(0, this.areaBottomY) + graphics.line(0, this.areaBottomY);
        pathFromArea = graphics.move(0, this.areaBottomY) + graphics.line(0, this.areaBottomY);
        if (w.globals.previousPaths.length > 0) {
          var pathFrom = this.lineHelpers.checkPreviousPaths({
            pathFromLine: pathFromLine,
            pathFromArea: pathFromArea,
            realIndex: realIndex
          });
          pathFromLine = pathFrom.pathFromLine;
          pathFromArea = pathFrom.pathFromArea;
        }
        return {
          prevX: prevX,
          prevY: prevY,
          linePath: linePath,
          areaPath: areaPath,
          pathFromLine: pathFromLine,
          pathFromArea: pathFromArea
        };
      }
    }, {
      key: "_handlePaths",
      value: function _handlePaths(_ref2) {
        var type = _ref2.type,
          realIndex = _ref2.realIndex,
          i = _ref2.i,
          paths = _ref2.paths;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var fill = new Fill(this.ctx);

        // push all current y values array to main PrevY Array
        this.prevSeriesY.push(paths.yArrj);

        // push all x val arrays into main xArr
        w.globals.seriesXvalues[realIndex] = paths.xArrj;
        w.globals.seriesYvalues[realIndex] = paths.yArrj;
        var forecast = w.config.forecastDataPoints;
        if (forecast.count > 0 && type !== 'rangeArea') {
          var forecastCutoff = w.globals.seriesXvalues[realIndex][w.globals.seriesXvalues[realIndex].length - forecast.count - 1];
          var elForecastMask = graphics.drawRect(forecastCutoff, 0, w.globals.gridWidth, w.globals.gridHeight, 0);
          w.globals.dom.elForecastMask.appendChild(elForecastMask.node);
          var elNonForecastMask = graphics.drawRect(0, 0, forecastCutoff, w.globals.gridHeight, 0);
          w.globals.dom.elNonForecastMask.appendChild(elNonForecastMask.node);
        }

        // these elements will be shown after area path animation completes
        if (!this.pointsChart) {
          w.globals.delayedElements.push({
            el: this.elPointsMain.node,
            index: realIndex
          });
        }
        var defaultRenderedPathOptions = {
          i: i,
          realIndex: realIndex,
          animationDelay: i,
          initialSpeed: w.config.chart.animations.speed,
          dataChangeSpeed: w.config.chart.animations.dynamicAnimation.speed,
          className: "apexcharts-".concat(type)
        };
        if (type === 'area') {
          var pathFill = fill.fillPath({
            seriesNumber: realIndex
          });
          for (var p = 0; p < paths.areaPaths.length; p++) {
            var renderedPath = graphics.renderPaths(_objectSpread2(_objectSpread2({}, defaultRenderedPathOptions), {}, {
              pathFrom: paths.pathFromArea,
              pathTo: paths.areaPaths[p],
              stroke: 'none',
              strokeWidth: 0,
              strokeLineCap: null,
              fill: pathFill
            }));
            this.elSeries.add(renderedPath);
          }
        }
        if (w.config.stroke.show && !this.pointsChart) {
          var lineFill = null;
          if (type === 'line') {
            lineFill = fill.fillPath({
              seriesNumber: realIndex,
              i: i
            });
          } else {
            if (w.config.stroke.fill.type === 'solid') {
              lineFill = w.globals.stroke.colors[realIndex];
            } else {
              var prevFill = w.config.fill;
              w.config.fill = w.config.stroke.fill;
              lineFill = fill.fillPath({
                seriesNumber: realIndex,
                i: i
              });
              w.config.fill = prevFill;
            }
          }

          // range-area paths are drawn using linePaths
          for (var _p = 0; _p < paths.linePaths.length; _p++) {
            var _pathFill = lineFill;
            if (type === 'rangeArea') {
              _pathFill = fill.fillPath({
                seriesNumber: realIndex
              });
            }
            var linePathCommonOpts = _objectSpread2(_objectSpread2({}, defaultRenderedPathOptions), {}, {
              pathFrom: paths.pathFromLine,
              pathTo: paths.linePaths[_p],
              stroke: lineFill,
              strokeWidth: this.strokeWidth,
              strokeLineCap: w.config.stroke.lineCap,
              fill: type === 'rangeArea' ? _pathFill : 'none'
            });
            var _renderedPath = graphics.renderPaths(linePathCommonOpts);
            this.elSeries.add(_renderedPath);
            _renderedPath.attr('fill-rule', "evenodd");
            if (forecast.count > 0 && type !== 'rangeArea') {
              var renderedForecastPath = graphics.renderPaths(linePathCommonOpts);
              renderedForecastPath.node.setAttribute('stroke-dasharray', forecast.dashArray);
              if (forecast.strokeWidth) {
                renderedForecastPath.node.setAttribute('stroke-width', forecast.strokeWidth);
              }
              this.elSeries.add(renderedForecastPath);
              renderedForecastPath.attr('clip-path', "url(#forecastMask".concat(w.globals.cuid, ")"));
              _renderedPath.attr('clip-path', "url(#nonForecastMask".concat(w.globals.cuid, ")"));
            }
          }
        }
      }
    }, {
      key: "_iterateOverDataPoints",
      value: function _iterateOverDataPoints(_ref3) {
        var _this = this,
          _this$w$config$series,
          _this$w$config$series2;
        var type = _ref3.type,
          series = _ref3.series,
          iterations = _ref3.iterations,
          realIndex = _ref3.realIndex,
          translationsIndex = _ref3.translationsIndex,
          i = _ref3.i,
          x = _ref3.x,
          y = _ref3.y,
          pX = _ref3.pX,
          pY = _ref3.pY,
          pathsFrom = _ref3.pathsFrom,
          linePaths = _ref3.linePaths,
          areaPaths = _ref3.areaPaths,
          seriesIndex = _ref3.seriesIndex,
          lineYPosition = _ref3.lineYPosition,
          xArrj = _ref3.xArrj,
          yArrj = _ref3.yArrj,
          y2Arrj = _ref3.y2Arrj,
          isRangeStart = _ref3.isRangeStart,
          seriesRangeEnd = _ref3.seriesRangeEnd;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var yRatio = this.yRatio;
        var prevY = pathsFrom.prevY,
          linePath = pathsFrom.linePath,
          areaPath = pathsFrom.areaPath,
          pathFromLine = pathsFrom.pathFromLine,
          pathFromArea = pathsFrom.pathFromArea;
        var minY = Utils$1.isNumber(w.globals.minYArr[realIndex]) ? w.globals.minYArr[realIndex] : w.globals.minY;
        if (!iterations) {
          iterations = w.globals.dataPoints > 1 ? w.globals.dataPoints - 1 : w.globals.dataPoints;
        }
        var getY = function getY(_y, lineYPos) {
          return lineYPos - _y / yRatio[translationsIndex] + (_this.isReversed ? _y / yRatio[translationsIndex] : 0) * 2;
        };
        var y2 = y;
        var stackSeries = w.config.chart.stacked && !w.globals.comboCharts || w.config.chart.stacked && w.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((_this$w$config$series = this.w.config.series[realIndex]) === null || _this$w$config$series === void 0 ? void 0 : _this$w$config$series.type) === 'bar' || ((_this$w$config$series2 = this.w.config.series[realIndex]) === null || _this$w$config$series2 === void 0 ? void 0 : _this$w$config$series2.type) === 'column');
        var curve = w.config.stroke.curve;
        if (Array.isArray(curve)) {
          if (Array.isArray(seriesIndex)) {
            curve = curve[seriesIndex[i]];
          } else {
            curve = curve[i];
          }
        }
        var pathState = 0;
        var segmentStartX;
        for (var j = 0; j < iterations; j++) {
          if (series[i].length === 0) break;
          var isNull = typeof series[i][j + 1] === 'undefined' || series[i][j + 1] === null;
          if (w.globals.isXNumeric) {
            var sX = w.globals.seriesX[realIndex][j + 1];
            if (typeof w.globals.seriesX[realIndex][j + 1] === 'undefined') {
              /* fix #374 */
              sX = w.globals.seriesX[realIndex][iterations - 1];
            }
            x = (sX - w.globals.minX) / this.xRatio;
          } else {
            x = x + this.xDivision;
          }
          if (stackSeries) {
            if (i > 0 && w.globals.collapsedSeries.length < w.config.series.length - 1) {
              // a collapsed series in a stacked chart may provide wrong result
              // for the next series, hence find the prevIndex of prev series
              // which is not collapsed - fixes apexcharts.js#1372
              var prevIndex = function prevIndex(pi) {
                for (var pii = pi; pii > 0; pii--) {
                  if (w.globals.collapsedSeriesIndices.indexOf((seriesIndex === null || seriesIndex === void 0 ? void 0 : seriesIndex[pii]) || pii) > -1) {
                    pii--;
                  } else {
                    return pii;
                  }
                }
                return 0;
              };
              lineYPosition = this.prevSeriesY[prevIndex(i - 1)][j + 1];
            } else {
              // the first series will not have prevY values
              lineYPosition = this.zeroY;
            }
          } else {
            lineYPosition = this.zeroY;
          }
          if (isNull) {
            y = getY(minY, lineYPosition);
          } else {
            y = getY(series[i][j + 1], lineYPosition);
            if (type === 'rangeArea') {
              y2 = getY(seriesRangeEnd[i][j + 1], lineYPosition);
            }
          }

          // push current X
          xArrj.push(series[i][j + 1] === null ? null : x);

          // push current Y that will be used as next series's bottom position
          if (isNull && (w.config.stroke.curve === 'smooth' || w.config.stroke.curve === 'monotoneCubic')) {
            yArrj.push(null);
            y2Arrj.push(null);
          } else {
            yArrj.push(y);
            y2Arrj.push(y2);
          }
          var pointsPos = this.lineHelpers.calculatePoints({
            series: series,
            x: x,
            y: y,
            realIndex: realIndex,
            i: i,
            j: j,
            prevY: prevY
          });
          var calculatedPaths = this._createPaths({
            type: type,
            series: series,
            i: i,
            realIndex: realIndex,
            j: j,
            x: x,
            y: y,
            y2: y2,
            xArrj: xArrj,
            yArrj: yArrj,
            y2Arrj: y2Arrj,
            pX: pX,
            pY: pY,
            pathState: pathState,
            segmentStartX: segmentStartX,
            linePath: linePath,
            areaPath: areaPath,
            linePaths: linePaths,
            areaPaths: areaPaths,
            curve: curve,
            isRangeStart: isRangeStart
          });
          areaPaths = calculatedPaths.areaPaths;
          linePaths = calculatedPaths.linePaths;
          pX = calculatedPaths.pX;
          pY = calculatedPaths.pY;
          pathState = calculatedPaths.pathState;
          segmentStartX = calculatedPaths.segmentStartX;
          areaPath = calculatedPaths.areaPath;
          linePath = calculatedPaths.linePath;
          if (this.appendPathFrom && !w.globals.hasNullValues && !(curve === 'monotoneCubic' && type === 'rangeArea')) {
            pathFromLine += graphics.line(x, this.areaBottomY);
            pathFromArea += graphics.line(x, this.areaBottomY);
          }
          this.handleNullDataPoints(series, pointsPos, i, j, realIndex);
          this._handleMarkersAndLabels({
            type: type,
            pointsPos: pointsPos,
            i: i,
            j: j,
            realIndex: realIndex,
            isRangeStart: isRangeStart
          });
        }
        return {
          yArrj: yArrj,
          xArrj: xArrj,
          pathFromArea: pathFromArea,
          areaPaths: areaPaths,
          pathFromLine: pathFromLine,
          linePaths: linePaths,
          linePath: linePath,
          areaPath: areaPath
        };
      }
    }, {
      key: "_handleMarkersAndLabels",
      value: function _handleMarkersAndLabels(_ref4) {
        var type = _ref4.type,
          pointsPos = _ref4.pointsPos,
          isRangeStart = _ref4.isRangeStart,
          i = _ref4.i,
          j = _ref4.j,
          realIndex = _ref4.realIndex;
        var w = this.w;
        var dataLabels = new DataLabels(this.ctx);
        if (!this.pointsChart) {
          if (w.globals.series[i].length > 1) {
            this.elPointsMain.node.classList.add('apexcharts-element-hidden');
          }
          var elPointsWrap = this.markers.plotChartMarkers({
            pointsPos: pointsPos,
            seriesIndex: realIndex,
            j: j + 1
          });
          if (elPointsWrap !== null) {
            this.elPointsMain.add(elPointsWrap);
          }
        } else {
          // scatter / bubble chart points creation
          this.scatter.draw(this.elSeries, j, {
            realIndex: realIndex,
            pointsPos: pointsPos,
            zRatio: this.zRatio,
            elParent: this.elPointsMain
          });
        }
        var drawnLabels = dataLabels.drawDataLabel({
          type: type,
          isRangeStart: isRangeStart,
          pos: pointsPos,
          i: realIndex,
          j: j + 1
        });
        if (drawnLabels !== null) {
          this.elDataLabelsWrap.add(drawnLabels);
        }
      }
    }, {
      key: "_createPaths",
      value: function _createPaths(_ref5) {
        var type = _ref5.type,
          series = _ref5.series,
          i = _ref5.i;
          _ref5.realIndex;
          var j = _ref5.j,
          x = _ref5.x,
          y = _ref5.y,
          xArrj = _ref5.xArrj,
          yArrj = _ref5.yArrj,
          y2 = _ref5.y2,
          y2Arrj = _ref5.y2Arrj,
          pX = _ref5.pX,
          pY = _ref5.pY,
          pathState = _ref5.pathState,
          segmentStartX = _ref5.segmentStartX,
          linePath = _ref5.linePath,
          areaPath = _ref5.areaPath,
          linePaths = _ref5.linePaths,
          areaPaths = _ref5.areaPaths,
          curve = _ref5.curve,
          isRangeStart = _ref5.isRangeStart;
        var graphics = new Graphics(this.ctx);
        var areaBottomY = this.areaBottomY;
        var rangeArea = type === 'rangeArea';
        var isLowerRangeAreaPath = type === 'rangeArea' && isRangeStart;
        switch (curve) {
          case 'monotoneCubic':
            var yAj = isRangeStart ? yArrj : y2Arrj;
            var getSmoothInputs = function getSmoothInputs(xArr, yArr) {
              return xArr.map(function (_, i) {
                return [_, yArr[i]];
              }).filter(function (_) {
                return _[1] !== null;
              });
            };
            var getSegmentLengths = function getSegmentLengths(yArr) {
              // Get the segment lengths so the segments can be extracted from
              // the null-filtered smoothInputs array
              var segLens = [];
              var count = 0;
              yArr.forEach(function (_) {
                if (_ !== null) {
                  count++;
                } else if (count > 0) {
                  segLens.push(count);
                  count = 0;
                }
              });
              if (count > 0) {
                segLens.push(count);
              }
              return segLens;
            };
            var getSegments = function getSegments(yArr, points) {
              var segLens = getSegmentLengths(yArr);
              var segments = [];
              for (var _i = 0, len = 0; _i < segLens.length; len += segLens[_i++]) {
                segments[_i] = spline.slice(points, len, len + segLens[_i]);
              }
              return segments;
            };
            switch (pathState) {
              case 0:
                // Find start of segment
                if (yAj[j + 1] === null) {
                  break;
                }
                pathState = 1;
              // continue through to pathState 1
              case 1:
                if (!(rangeArea ? xArrj.length === series[i].length : j === series[i].length - 2)) {
                  break;
                }
              // continue through to pathState 2
              case 2:
                // Interpolate the full series with nulls excluded then extract the
                // null delimited segments with interpolated points included.
                var _xAj = isRangeStart ? xArrj : xArrj.slice().reverse();
                var _yAj = isRangeStart ? yAj : yAj.slice().reverse();
                var smoothInputs = getSmoothInputs(_xAj, _yAj);
                var points = smoothInputs.length > 1 ? spline.points(smoothInputs) : smoothInputs;
                var smoothInputsLower = [];
                if (rangeArea) {
                  if (isLowerRangeAreaPath) {
                    // As we won't be needing it, borrow areaPaths to retain our
                    // rangeArea lower points.
                    areaPaths = smoothInputs;
                  } else {
                    // Retrieve the corresponding lower raw interpolated points so we
                    // can join onto its end points. Note: the upper Y2 segments will
                    // be in the reverse order relative to the lower segments.
                    smoothInputsLower = areaPaths.reverse();
                  }
                }
                var segmentCount = 0;
                var smoothInputsIndex = 0;
                getSegments(_yAj, points).forEach(function (_) {
                  segmentCount++;
                  var svgPoints = svgPath(_);
                  var _start = smoothInputsIndex;
                  smoothInputsIndex += _.length;
                  var _end = smoothInputsIndex - 1;
                  if (isLowerRangeAreaPath) {
                    linePath = graphics.move(smoothInputs[_start][0], smoothInputs[_start][1]) + svgPoints;
                  } else if (rangeArea) {
                    linePath = graphics.move(smoothInputsLower[_start][0], smoothInputsLower[_start][1]) + graphics.line(smoothInputs[_start][0], smoothInputs[_start][1]) + svgPoints + graphics.line(smoothInputsLower[_end][0], smoothInputsLower[_end][1]);
                  } else {
                    linePath = graphics.move(smoothInputs[_start][0], smoothInputs[_start][1]) + svgPoints;
                    areaPath = linePath + graphics.line(smoothInputs[_end][0], areaBottomY) + graphics.line(smoothInputs[_start][0], areaBottomY) + 'z';
                    areaPaths.push(areaPath);
                  }
                  linePaths.push(linePath);
                });
                if (rangeArea && segmentCount > 1 && !isLowerRangeAreaPath) {
                  // Reverse the order of the upper path segments
                  var upperLinePaths = linePaths.slice(segmentCount).reverse();
                  linePaths.splice(segmentCount);
                  upperLinePaths.forEach(function (u) {
                    return linePaths.push(u);
                  });
                }
                pathState = 0;
                break;
            }
            break;
          case 'smooth':
            var length = (x - pX) * 0.35;
            if (series[i][j] === null) {
              pathState = 0;
            } else {
              switch (pathState) {
                case 0:
                  // Beginning of segment
                  segmentStartX = pX;
                  if (isLowerRangeAreaPath) {
                    // Need to add path portion that will join to the upper path
                    linePath = graphics.move(pX, y2Arrj[j]) + graphics.line(pX, pY);
                  } else {
                    linePath = graphics.move(pX, pY);
                  }
                  areaPath = graphics.move(pX, pY);

                  // Check for single isolated point
                  if (series[i][j + 1] === null || typeof series[i][j + 1] === 'undefined') {
                    linePaths.push(linePath);
                    areaPaths.push(areaPath);
                    // Stay in pathState = 0;
                    break;
                  }
                  pathState = 1;
                  if (j < series[i].length - 2) {
                    var p = graphics.curve(pX + length, pY, x - length, y, x, y);
                    linePath += p;
                    areaPath += p;
                    break;
                  }
                // Continue on with pathState 1 to finish the path and exit
                case 1:
                  // Continuing with segment
                  if (series[i][j + 1] === null) {
                    // Segment ends here
                    if (isLowerRangeAreaPath) {
                      linePath += graphics.line(pX, y2);
                    } else {
                      linePath += graphics.move(pX, pY);
                    }
                    areaPath += graphics.line(pX, areaBottomY) + graphics.line(segmentStartX, areaBottomY) + 'z';
                    linePaths.push(linePath);
                    areaPaths.push(areaPath);
                    pathState = -1;
                  } else {
                    var _p2 = graphics.curve(pX + length, pY, x - length, y, x, y);
                    linePath += _p2;
                    areaPath += _p2;
                    if (j >= series[i].length - 2) {
                      if (isLowerRangeAreaPath) {
                        // Need to add path portion that will join to the upper path
                        linePath += graphics.curve(x, y, x, y, x, y2) + graphics.move(x, y2);
                      }
                      areaPath += graphics.curve(x, y, x, y, x, areaBottomY) + graphics.line(segmentStartX, areaBottomY) + 'z';
                      linePaths.push(linePath);
                      areaPaths.push(areaPath);
                      pathState = -1;
                    }
                  }
                  break;
              }
            }
            pX = x;
            pY = y;
            break;
          default:
            var pathToPoint = function pathToPoint(curve, x, y) {
              var path = [];
              switch (curve) {
                case 'stepline':
                  path = graphics.line(x, null, 'H') + graphics.line(null, y, 'V');
                  break;
                case 'linestep':
                  path = graphics.line(null, y, 'V') + graphics.line(x, null, 'H');
                  break;
                case 'straight':
                  path = graphics.line(x, y);
                  break;
              }
              return path;
            };
            if (series[i][j] === null) {
              pathState = 0;
            } else {
              switch (pathState) {
                case 0:
                  // Beginning of segment
                  segmentStartX = pX;
                  if (isLowerRangeAreaPath) {
                    // Need to add path portion that will join to the upper path
                    linePath = graphics.move(pX, y2Arrj[j]) + graphics.line(pX, pY);
                  } else {
                    linePath = graphics.move(pX, pY);
                  }
                  areaPath = graphics.move(pX, pY);

                  // Check for single isolated point
                  if (series[i][j + 1] === null || typeof series[i][j + 1] === 'undefined') {
                    linePaths.push(linePath);
                    areaPaths.push(areaPath);
                    // Stay in pathState = 0
                    break;
                  }
                  pathState = 1;
                  if (j < series[i].length - 2) {
                    var _p3 = pathToPoint(curve, x, y);
                    linePath += _p3;
                    areaPath += _p3;
                    break;
                  }
                // Continue on with pathState 1 to finish the path and exit
                case 1:
                  // Continuing with segment
                  if (series[i][j + 1] === null) {
                    // Segment ends here
                    if (isLowerRangeAreaPath) {
                      linePath += graphics.line(pX, y2);
                    } else {
                      linePath += graphics.move(pX, pY);
                    }
                    areaPath += graphics.line(pX, areaBottomY) + graphics.line(segmentStartX, areaBottomY) + 'z';
                    linePaths.push(linePath);
                    areaPaths.push(areaPath);
                    pathState = -1;
                  } else {
                    var _p4 = pathToPoint(curve, x, y);
                    linePath += _p4;
                    areaPath += _p4;
                    if (j >= series[i].length - 2) {
                      if (isLowerRangeAreaPath) {
                        // Need to add path portion that will join to the upper path
                        linePath += graphics.line(x, y2);
                      }
                      areaPath += graphics.line(x, areaBottomY) + graphics.line(segmentStartX, areaBottomY) + 'z';
                      linePaths.push(linePath);
                      areaPaths.push(areaPath);
                      pathState = -1;
                    }
                  }
                  break;
              }
            }
            pX = x;
            pY = y;
            break;
        }
        return {
          linePaths: linePaths,
          areaPaths: areaPaths,
          pX: pX,
          pY: pY,
          pathState: pathState,
          segmentStartX: segmentStartX,
          linePath: linePath,
          areaPath: areaPath
        };
      }
    }, {
      key: "handleNullDataPoints",
      value: function handleNullDataPoints(series, pointsPos, i, j, realIndex) {
        var w = this.w;
        if (series[i][j] === null && w.config.markers.showNullDataPoints || series[i].length === 1) {
          var pSize = this.strokeWidth - w.config.markers.strokeWidth / 2;
          if (!(pSize > 0)) {
            pSize = 0;
          }

          // fixes apexcharts.js#1282, #1252
          var elPointsWrap = this.markers.plotChartMarkers({
            pointsPos: pointsPos,
            seriesIndex: realIndex,
            j: j + 1,
            pSize: pSize,
            alwaysDrawMarker: true
          });
          if (elPointsWrap !== null) {
            this.elPointsMain.add(elPointsWrap);
          }
        }
      }
    }]);
    return Line;
  }();

  /*
   * treemap-squarify.js - open source implementation of squarified treemaps
   *
   * Treemap Squared 0.5 - Treemap Charting library
   *
   * https://github.com/imranghory/treemap-squared/
   *
   * Copyright (c) 2012 Imran Ghory (imranghory@gmail.com)
   * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
   *
   *
   * Implementation of the squarify treemap algorithm described in:
   *
   * Bruls, Mark; Huizing, Kees; van Wijk, Jarke J. (2000), "Squarified treemaps"
   * in de Leeuw, W.; van Liere, R., Data Visualization 2000:
   * Proc. Joint Eurographics and IEEE TCVG Symp. on Visualization, Springer-Verlag, pp. 3342.
   *
   * Paper is available online at: http://www.win.tue.nl/~vanwijk/stm.pdf
   *
   * The code in this file is completeley decoupled from the drawing code so it should be trivial
   * to port it to any other vector drawing library. Given an array of datapoints this library returns
   * an array of cartesian coordinates that represent the rectangles that make up the treemap.
   *
   * The library also supports multidimensional data (nested treemaps) and performs normalization on the data.
   *
   * See the README file for more details.
   */

  window.TreemapSquared = {};
  (function () {

    window.TreemapSquared.generate = function () {
      function Container(xoffset, yoffset, width, height) {
        this.xoffset = xoffset; // offset from the the top left hand corner
        this.yoffset = yoffset; // ditto
        this.height = height;
        this.width = width;
        this.shortestEdge = function () {
          return Math.min(this.height, this.width);
        };

        // getCoordinates - for a row of boxes which we've placed
        //                  return an array of their cartesian coordinates
        this.getCoordinates = function (row) {
          var coordinates = [];
          var subxoffset = this.xoffset,
            subyoffset = this.yoffset; //our offset within the container
          var areawidth = sumArray(row) / this.height;
          var areaheight = sumArray(row) / this.width;
          var i;
          if (this.width >= this.height) {
            for (i = 0; i < row.length; i++) {
              coordinates.push([subxoffset, subyoffset, subxoffset + areawidth, subyoffset + row[i] / areawidth]);
              subyoffset = subyoffset + row[i] / areawidth;
            }
          } else {
            for (i = 0; i < row.length; i++) {
              coordinates.push([subxoffset, subyoffset, subxoffset + row[i] / areaheight, subyoffset + areaheight]);
              subxoffset = subxoffset + row[i] / areaheight;
            }
          }
          return coordinates;
        };

        // cutArea - once we've placed some boxes into an row we then need to identify the remaining area,
        //           this function takes the area of the boxes we've placed and calculates the location and
        //           dimensions of the remaining space and returns a container box defined by the remaining area
        this.cutArea = function (area) {
          var newcontainer;
          if (this.width >= this.height) {
            var areawidth = area / this.height;
            var newwidth = this.width - areawidth;
            newcontainer = new Container(this.xoffset + areawidth, this.yoffset, newwidth, this.height);
          } else {
            var areaheight = area / this.width;
            var newheight = this.height - areaheight;
            newcontainer = new Container(this.xoffset, this.yoffset + areaheight, this.width, newheight);
          }
          return newcontainer;
        };
      }

      // normalize - the Bruls algorithm assumes we're passing in areas that nicely fit into our
      //             container box, this method takes our raw data and normalizes the data values into
      //             area values so that this assumption is valid.
      function normalize(data, area) {
        var normalizeddata = [];
        var sum = sumArray(data);
        var multiplier = area / sum;
        var i;
        for (i = 0; i < data.length; i++) {
          normalizeddata[i] = data[i] * multiplier;
        }
        return normalizeddata;
      }

      // treemapMultidimensional - takes multidimensional data (aka [[23,11],[11,32]] - nested array)
      //                           and recursively calls itself using treemapSingledimensional
      //                           to create a patchwork of treemaps and merge them
      function treemapMultidimensional(data, width, height, xoffset, yoffset) {
        xoffset = typeof xoffset === 'undefined' ? 0 : xoffset;
        yoffset = typeof yoffset === 'undefined' ? 0 : yoffset;
        var mergeddata = [];
        var mergedtreemap;
        var results = [];
        var i;
        if (isArray(data[0])) {
          // if we've got more dimensions of depth
          for (i = 0; i < data.length; i++) {
            mergeddata[i] = sumMultidimensionalArray(data[i]);
          }
          mergedtreemap = treemapSingledimensional(mergeddata, width, height, xoffset, yoffset);
          for (i = 0; i < data.length; i++) {
            results.push(treemapMultidimensional(data[i], mergedtreemap[i][2] - mergedtreemap[i][0], mergedtreemap[i][3] - mergedtreemap[i][1], mergedtreemap[i][0], mergedtreemap[i][1]));
          }
        } else {
          results = treemapSingledimensional(data, width, height, xoffset, yoffset);
        }
        return results;
      }

      // treemapSingledimensional - simple wrapper around squarify
      function treemapSingledimensional(data, width, height, xoffset, yoffset) {
        xoffset = typeof xoffset === 'undefined' ? 0 : xoffset;
        yoffset = typeof yoffset === 'undefined' ? 0 : yoffset;
        var rawtreemap = squarify(normalize(data, width * height), [], new Container(xoffset, yoffset, width, height), []);
        return flattenTreemap(rawtreemap);
      }

      // flattenTreemap - squarify implementation returns an array of arrays of coordinates
      //                  because we have a new array everytime we switch to building a new row
      //                  this converts it into an array of coordinates.
      function flattenTreemap(rawtreemap) {
        var flattreemap = [];
        var i, j;
        for (i = 0; i < rawtreemap.length; i++) {
          for (j = 0; j < rawtreemap[i].length; j++) {
            flattreemap.push(rawtreemap[i][j]);
          }
        }
        return flattreemap;
      }

      // squarify  - as per the Bruls paper
      //             plus coordinates stack and containers so we get
      //             usable data out of it
      function squarify(data, currentrow, container, stack) {
        var length;
        var nextdatapoint;
        var newcontainer;
        if (data.length === 0) {
          stack.push(container.getCoordinates(currentrow));
          return;
        }
        length = container.shortestEdge();
        nextdatapoint = data[0];
        if (improvesRatio(currentrow, nextdatapoint, length)) {
          currentrow.push(nextdatapoint);
          squarify(data.slice(1), currentrow, container, stack);
        } else {
          newcontainer = container.cutArea(sumArray(currentrow), stack);
          stack.push(container.getCoordinates(currentrow));
          squarify(data, [], newcontainer, stack);
        }
        return stack;
      }

      // improveRatio - implements the worse calculation and comparision as given in Bruls
      //                (note the error in the original paper; fixed here)
      function improvesRatio(currentrow, nextnode, length) {
        var newrow;
        if (currentrow.length === 0) {
          return true;
        }
        newrow = currentrow.slice();
        newrow.push(nextnode);
        var currentratio = calculateRatio(currentrow, length);
        var newratio = calculateRatio(newrow, length);

        // the pseudocode in the Bruls paper has the direction of the comparison
        // wrong, this is the correct one.
        return currentratio >= newratio;
      }

      // calculateRatio - calculates the maximum width to height ratio of the
      //                  boxes in this row
      function calculateRatio(row, length) {
        var min = Math.min.apply(Math, row);
        var max = Math.max.apply(Math, row);
        var sum = sumArray(row);
        return Math.max(Math.pow(length, 2) * max / Math.pow(sum, 2), Math.pow(sum, 2) / (Math.pow(length, 2) * min));
      }

      // isArray - checks if arr is an array
      function isArray(arr) {
        return arr && arr.constructor === Array;
      }

      // sumArray - sums a single dimensional array
      function sumArray(arr) {
        var sum = 0;
        var i;
        for (i = 0; i < arr.length; i++) {
          sum += arr[i];
        }
        return sum;
      }

      // sumMultidimensionalArray - sums the values in a nested array (aka [[0,1],[[2,3]]])
      function sumMultidimensionalArray(arr) {
        var i,
          total = 0;
        if (isArray(arr[0])) {
          for (i = 0; i < arr.length; i++) {
            total += sumMultidimensionalArray(arr[i]);
          }
        } else {
          total = sumArray(arr);
        }
        return total;
      }
      return treemapMultidimensional;
    }();
  })();

  /**
   * ApexCharts TreemapChart Class.
   * @module TreemapChart
   **/
  var TreemapChart = /*#__PURE__*/function () {
    function TreemapChart(ctx, xyRatios) {
      _classCallCheck(this, TreemapChart);
      this.ctx = ctx;
      this.w = ctx.w;
      this.strokeWidth = this.w.config.stroke.width;
      this.helpers = new TreemapHelpers(ctx);
      this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation;
      this.labels = [];
    }
    _createClass(TreemapChart, [{
      key: "draw",
      value: function draw(series) {
        var _this = this;
        var w = this.w;
        var graphics = new Graphics(this.ctx);
        var fill = new Fill(this.ctx);
        var ret = graphics.group({
          class: 'apexcharts-treemap'
        });
        if (w.globals.noData) return ret;
        var ser = [];
        series.forEach(function (s) {
          var d = s.map(function (v) {
            return Math.abs(v);
          });
          ser.push(d);
        });
        this.negRange = this.helpers.checkColorRange();
        w.config.series.forEach(function (s, i) {
          s.data.forEach(function (l) {
            if (!Array.isArray(_this.labels[i])) _this.labels[i] = [];
            _this.labels[i].push(l.x);
          });
        });
        var nodes = window.TreemapSquared.generate(ser, w.globals.gridWidth, w.globals.gridHeight);
        nodes.forEach(function (node, i) {
          var elSeries = graphics.group({
            class: "apexcharts-series apexcharts-treemap-series",
            seriesName: Utils$1.escapeString(w.globals.seriesNames[i]),
            rel: i + 1,
            'data:realIndex': i
          });
          if (w.config.chart.dropShadow.enabled) {
            var shadow = w.config.chart.dropShadow;
            var filters = new Filters(_this.ctx);
            filters.dropShadow(ret, shadow, i);
          }
          var elDataLabelWrap = graphics.group({
            class: 'apexcharts-data-labels'
          });
          var bounds = {
            xMin: Infinity,
            yMin: Infinity,
            xMax: -Infinity,
            yMax: -Infinity
          };
          node.forEach(function (r, j) {
            var x1 = r[0];
            var y1 = r[1];
            var x2 = r[2];
            var y2 = r[3];
            bounds.xMin = Math.min(bounds.xMin, x1);
            bounds.yMin = Math.min(bounds.yMin, y1);
            bounds.xMax = Math.max(bounds.xMax, x2);
            bounds.yMax = Math.max(bounds.yMax, y2);
            var colorProps = _this.helpers.getShadeColor(w.config.chart.type, i, j, _this.negRange);
            var color = colorProps.color;
            var pathFill = fill.fillPath({
              color: color,
              seriesNumber: i,
              dataPointIndex: j
            });
            var elRect = graphics.drawRect(x1, y1, x2 - x1, y2 - y1, w.config.plotOptions.treemap.borderRadius, '#fff', 1, _this.strokeWidth, w.config.plotOptions.treemap.useFillColorAsStroke ? color : w.globals.stroke.colors[i]);
            elRect.attr({
              cx: x1,
              cy: y1,
              index: i,
              i: i,
              j: j,
              width: x2 - x1,
              height: y2 - y1,
              fill: pathFill
            });
            elRect.node.classList.add('apexcharts-treemap-rect');
            _this.helpers.addListeners(elRect);
            var fromRect = {
              x: x1 + (x2 - x1) / 2,
              y: y1 + (y2 - y1) / 2,
              width: 0,
              height: 0
            };
            var toRect = {
              x: x1,
              y: y1,
              width: x2 - x1,
              height: y2 - y1
            };
            if (w.config.chart.animations.enabled && !w.globals.dataChanged) {
              var speed = 1;
              if (!w.globals.resized) {
                speed = w.config.chart.animations.speed;
              }
              _this.animateTreemap(elRect, fromRect, toRect, speed);
            }
            if (w.globals.dataChanged) {
              var _speed = 1;
              if (_this.dynamicAnim.enabled && w.globals.shouldAnimate) {
                _speed = _this.dynamicAnim.speed;
                if (w.globals.previousPaths[i] && w.globals.previousPaths[i][j] && w.globals.previousPaths[i][j].rect) {
                  fromRect = w.globals.previousPaths[i][j].rect;
                }
                _this.animateTreemap(elRect, fromRect, toRect, _speed);
              }
            }
            var fontSize = _this.getFontSize(r);
            var formattedText = w.config.dataLabels.formatter(_this.labels[i][j], {
              value: w.globals.series[i][j],
              seriesIndex: i,
              dataPointIndex: j,
              w: w
            });
            if (w.config.plotOptions.treemap.dataLabels.format === 'truncate') {
              fontSize = parseInt(w.config.dataLabels.style.fontSize, 10);
              formattedText = _this.truncateLabels(formattedText, fontSize, x1, y1, x2, y2);
            }
            var dataLabels = null;
            if (w.globals.series[i][j]) {
              dataLabels = _this.helpers.calculateDataLabels({
                text: formattedText,
                x: (x1 + x2) / 2,
                y: (y1 + y2) / 2 + _this.strokeWidth / 2 + fontSize / 3,
                i: i,
                j: j,
                colorProps: colorProps,
                fontSize: fontSize,
                series: series
              });
            }
            if (w.config.dataLabels.enabled && dataLabels) {
              _this.rotateToFitLabel(dataLabels, fontSize, formattedText, x1, y1, x2, y2);
            }
            elSeries.add(elRect);
            if (dataLabels !== null) {
              elSeries.add(dataLabels);
            }
          });
          var seriesTitle = w.config.plotOptions.treemap.seriesTitle;
          if (w.config.series.length > 1 && seriesTitle && seriesTitle.show) {
            var sName = w.config.series[i].name || '';
            if (sName && bounds.xMin < Infinity && bounds.yMin < Infinity) {
              var offsetX = seriesTitle.offsetX,
                offsetY = seriesTitle.offsetY,
                borderColor = seriesTitle.borderColor,
                borderWidth = seriesTitle.borderWidth,
                borderRadius = seriesTitle.borderRadius,
                style = seriesTitle.style;
              var textColor = style.color || w.config.chart.foreColor;
              var padding = {
                left: style.padding.left,
                right: style.padding.right,
                top: style.padding.top,
                bottom: style.padding.bottom
              };
              var textSize = graphics.getTextRects(sName, style.fontSize, style.fontFamily);
              var labelRectWidth = textSize.width + padding.left + padding.right;
              var labelRectHeight = textSize.height + padding.top + padding.bottom;

              // Position
              var labelX = bounds.xMin + (offsetX || 0);
              var labelY = bounds.yMin + (offsetY || 0);

              // Draw background rect
              var elLabelRect = graphics.drawRect(labelX, labelY, labelRectWidth, labelRectHeight, borderRadius, style.background, 1, borderWidth, borderColor);
              var elLabelText = graphics.drawText({
                x: labelX + padding.left,
                y: labelY + padding.top + textSize.height * 0.75,
                text: sName,
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                fontWeight: style.fontWeight,
                foreColor: textColor,
                cssClass: style.cssClass || ''
              });
              elSeries.add(elLabelRect);
              elSeries.add(elLabelText);
            }
          }
          elSeries.add(elDataLabelWrap);
          ret.add(elSeries);
        });
        return ret;
      }

      // This calculates a font-size based upon
      // average label length and the size of the box
    }, {
      key: "getFontSize",
      value: function getFontSize(coordinates) {
        var w = this.w;

        // total length of labels (i.e [["Italy"],["Spain", "Greece"]] -> 16)
        function totalLabelLength(arr) {
          var i,
            total = 0;
          if (Array.isArray(arr[0])) {
            for (i = 0; i < arr.length; i++) {
              total += totalLabelLength(arr[i]);
            }
          } else {
            for (i = 0; i < arr.length; i++) {
              total += arr[i].length;
            }
          }
          return total;
        }

        // count of labels (i.e [["Italy"],["Spain", "Greece"]] -> 3)
        function countLabels(arr) {
          var i,
            total = 0;
          if (Array.isArray(arr[0])) {
            for (i = 0; i < arr.length; i++) {
              total += countLabels(arr[i]);
            }
          } else {
            for (i = 0; i < arr.length; i++) {
              total += 1;
            }
          }
          return total;
        }
        var averagelabelsize = totalLabelLength(this.labels) / countLabels(this.labels);
        function fontSize(width, height) {
          var area = width * height;
          var arearoot = Math.pow(area, 0.5);
          return Math.min(arearoot / averagelabelsize, parseInt(w.config.dataLabels.style.fontSize, 10));
        }
        return fontSize(coordinates[2] - coordinates[0], coordinates[3] - coordinates[1]);
      }
    }, {
      key: "rotateToFitLabel",
      value: function rotateToFitLabel(elText, fontSize, text, x1, y1, x2, y2) {
        var graphics = new Graphics(this.ctx);
        var textRect = graphics.getTextRects(text, fontSize);

        // if the label fits better sideways then rotate it
        if (textRect.width + this.w.config.stroke.width + 5 > x2 - x1 && textRect.width <= y2 - y1) {
          var labelRotatingCenter = graphics.rotateAroundCenter(elText.node);
          elText.node.setAttribute('transform', "rotate(-90 ".concat(labelRotatingCenter.x, " ").concat(labelRotatingCenter.y, ") translate(").concat(textRect.height / 3, ")"));
        }
      }

      // This is an alternative label formatting method that uses a
      // consistent font size, and trims the edge of long labels
    }, {
      key: "truncateLabels",
      value: function truncateLabels(text, fontSize, x1, y1, x2, y2) {
        var graphics = new Graphics(this.ctx);
        var textRect = graphics.getTextRects(text, fontSize);

        // Determine max width based on ideal orientation of text
        var labelMaxWidth = textRect.width + this.w.config.stroke.width + 5 > x2 - x1 && y2 - y1 > x2 - x1 ? y2 - y1 : x2 - x1;
        var truncatedText = graphics.getTextBasedOnMaxWidth({
          text: text,
          maxWidth: labelMaxWidth,
          fontSize: fontSize
        });

        // Return empty label when text has been trimmed for very small rects
        if (text.length !== truncatedText.length && labelMaxWidth / fontSize < 5) {
          return '';
        } else {
          return truncatedText;
        }
      }
    }, {
      key: "animateTreemap",
      value: function animateTreemap(el, fromRect, toRect, speed) {
        var animations = new Animations(this.ctx);
        animations.animateRect(el, fromRect, toRect, speed, function () {
          animations.animationCompleted(el);
        });
      }
    }]);
    return TreemapChart;
  }();

  var MINUTES_IN_DAY = 24 * 60;
  var SECONDS_IN_DAY = MINUTES_IN_DAY * 60;
  var MIN_ZOOM_DAYS = 10 / SECONDS_IN_DAY;

  /**
   * ApexCharts TimeScale Class for generating time ticks for x-axis.
   *
   * @module TimeScale
   **/
  var TimeScale = /*#__PURE__*/function () {
    function TimeScale(ctx) {
      _classCallCheck(this, TimeScale);
      this.ctx = ctx;
      this.w = ctx.w;
      this.timeScaleArray = [];
      this.utc = this.w.config.xaxis.labels.datetimeUTC;
    }
    _createClass(TimeScale, [{
      key: "calculateTimeScaleTicks",
      value: function calculateTimeScaleTicks(minX, maxX) {
        var _this = this;
        var w = this.w;

        // null check when no series to show
        if (w.globals.allSeriesCollapsed) {
          w.globals.labels = [];
          w.globals.timescaleLabels = [];
          return [];
        }
        var dt = new DateTime(this.ctx);
        var daysDiff = (maxX - minX) / (1000 * SECONDS_IN_DAY);
        this.determineInterval(daysDiff);
        w.globals.disableZoomIn = false;
        w.globals.disableZoomOut = false;
        if (daysDiff < MIN_ZOOM_DAYS) {
          w.globals.disableZoomIn = true;
        } else if (daysDiff > 50000) {
          w.globals.disableZoomOut = true;
        }
        var timeIntervals = dt.getTimeUnitsfromTimestamp(minX, maxX, this.utc);
        var daysWidthOnXAxis = w.globals.gridWidth / daysDiff;
        var hoursWidthOnXAxis = daysWidthOnXAxis / 24;
        var minutesWidthOnXAxis = hoursWidthOnXAxis / 60;
        var secondsWidthOnXAxis = minutesWidthOnXAxis / 60;
        var numberOfHours = Math.floor(daysDiff * 24);
        var numberOfMinutes = Math.floor(daysDiff * MINUTES_IN_DAY);
        var numberOfSeconds = Math.floor(daysDiff * SECONDS_IN_DAY);
        var numberOfDays = Math.floor(daysDiff);
        var numberOfMonths = Math.floor(daysDiff / 30);
        var numberOfYears = Math.floor(daysDiff / 365);
        var firstVal = {
          minMillisecond: timeIntervals.minMillisecond,
          minSecond: timeIntervals.minSecond,
          minMinute: timeIntervals.minMinute,
          minHour: timeIntervals.minHour,
          minDate: timeIntervals.minDate,
          minMonth: timeIntervals.minMonth,
          minYear: timeIntervals.minYear
        };
        var currentMillisecond = firstVal.minMillisecond;
        var currentSecond = firstVal.minSecond;
        var currentMinute = firstVal.minMinute;
        var currentHour = firstVal.minHour;
        var currentMonthDate = firstVal.minDate;
        var currentDate = firstVal.minDate;
        var currentMonth = firstVal.minMonth;
        var currentYear = firstVal.minYear;
        var params = {
          firstVal: firstVal,
          currentMillisecond: currentMillisecond,
          currentSecond: currentSecond,
          currentMinute: currentMinute,
          currentHour: currentHour,
          currentMonthDate: currentMonthDate,
          currentDate: currentDate,
          currentMonth: currentMonth,
          currentYear: currentYear,
          daysWidthOnXAxis: daysWidthOnXAxis,
          hoursWidthOnXAxis: hoursWidthOnXAxis,
          minutesWidthOnXAxis: minutesWidthOnXAxis,
          secondsWidthOnXAxis: secondsWidthOnXAxis,
          numberOfSeconds: numberOfSeconds,
          numberOfMinutes: numberOfMinutes,
          numberOfHours: numberOfHours,
          numberOfDays: numberOfDays,
          numberOfMonths: numberOfMonths,
          numberOfYears: numberOfYears
        };
        switch (this.tickInterval) {
          case 'years':
            {
              this.generateYearScale(params);
              break;
            }
          case 'months':
          case 'half_year':
            {
              this.generateMonthScale(params);
              break;
            }
          case 'months_days':
          case 'months_fortnight':
          case 'days':
          case 'week_days':
            {
              this.generateDayScale(params);
              break;
            }
          case 'hours':
            {
              this.generateHourScale(params);
              break;
            }
          case 'minutes_fives':
          case 'minutes':
            this.generateMinuteScale(params);
            break;
          case 'seconds_tens':
          case 'seconds_fives':
          case 'seconds':
            this.generateSecondScale(params);
            break;
        }

        // first, we will adjust the month values index
        // as in the upper function, it is starting from 0
        // we will start them from 1
        var adjustedMonthInTimeScaleArray = this.timeScaleArray.map(function (ts) {
          var defaultReturn = {
            position: ts.position,
            unit: ts.unit,
            year: ts.year,
            day: ts.day ? ts.day : 1,
            hour: ts.hour ? ts.hour : 0,
            month: ts.month + 1
          };
          if (ts.unit === 'month') {
            return _objectSpread2(_objectSpread2({}, defaultReturn), {}, {
              day: 1,
              value: ts.value + 1
            });
          } else if (ts.unit === 'day' || ts.unit === 'hour') {
            return _objectSpread2(_objectSpread2({}, defaultReturn), {}, {
              value: ts.value
            });
          } else if (ts.unit === 'minute') {
            return _objectSpread2(_objectSpread2({}, defaultReturn), {}, {
              value: ts.value,
              minute: ts.value
            });
          } else if (ts.unit === 'second') {
            return _objectSpread2(_objectSpread2({}, defaultReturn), {}, {
              value: ts.value,
              minute: ts.minute,
              second: ts.second
            });
          }
          return ts;
        });
        var filteredTimeScale = adjustedMonthInTimeScaleArray.filter(function (ts) {
          var modulo = 1;
          var ticks = Math.ceil(w.globals.gridWidth / 120);
          var value = ts.value;
          if (w.config.xaxis.tickAmount !== undefined) {
            ticks = w.config.xaxis.tickAmount;
          }
          if (adjustedMonthInTimeScaleArray.length > ticks) {
            modulo = Math.floor(adjustedMonthInTimeScaleArray.length / ticks);
          }
          var shouldNotSkipUnit = false; // there is a big change in unit i.e days to months
          var shouldNotPrint = false; // should skip these values

          switch (_this.tickInterval) {
            case 'years':
              // make years label denser
              if (ts.unit === 'year') {
                shouldNotSkipUnit = true;
              }
              break;
            case 'half_year':
              modulo = 7;
              if (ts.unit === 'year') {
                shouldNotSkipUnit = true;
              }
              break;
            case 'months':
              modulo = 1;
              if (ts.unit === 'year') {
                shouldNotSkipUnit = true;
              }
              break;
            case 'months_fortnight':
              modulo = 15;
              if (ts.unit === 'year' || ts.unit === 'month') {
                shouldNotSkipUnit = true;
              }
              if (value === 30) {
                shouldNotPrint = true;
              }
              break;
            case 'months_days':
              modulo = 10;
              if (ts.unit === 'month') {
                shouldNotSkipUnit = true;
              }
              if (value === 30) {
                shouldNotPrint = true;
              }
              break;
            case 'week_days':
              modulo = 8;
              if (ts.unit === 'month') {
                shouldNotSkipUnit = true;
              }
              break;
            case 'days':
              modulo = 1;
              if (ts.unit === 'month') {
                shouldNotSkipUnit = true;
              }
              break;
            case 'hours':
              if (ts.unit === 'day') {
                shouldNotSkipUnit = true;
              }
              break;
            case 'minutes_fives':
              if (value % 5 !== 0) {
                shouldNotPrint = true;
              }
              break;
            case 'seconds_tens':
              if (value % 10 !== 0) {
                shouldNotPrint = true;
              }
              break;
            case 'seconds_fives':
              if (value % 5 !== 0) {
                shouldNotPrint = true;
              }
              break;
          }
          if (_this.tickInterval === 'hours' || _this.tickInterval === 'minutes_fives' || _this.tickInterval === 'seconds_tens' || _this.tickInterval === 'seconds_fives') {
            if (!shouldNotPrint) {
              return true;
            }
          } else {
            if ((value % modulo === 0 || shouldNotSkipUnit) && !shouldNotPrint) {
              return true;
            }
          }
        });
        return filteredTimeScale;
      }
    }, {
      key: "recalcDimensionsBasedOnFormat",
      value: function recalcDimensionsBasedOnFormat(filteredTimeScale, inverted) {
        var w = this.w;
        var reformattedTimescaleArray = this.formatDates(filteredTimeScale);
        var removedOverlappingTS = this.removeOverlappingTS(reformattedTimescaleArray);
        w.globals.timescaleLabels = removedOverlappingTS.slice();

        // at this stage, we need to re-calculate coords of the grid as timeline labels may have altered the xaxis labels coords
        // The reason we can't do this prior to this stage is because timeline labels depends on gridWidth, and as the ticks are calculated based on available gridWidth, there can be unknown number of ticks generated for different minX and maxX
        // Dependency on Dimensions(), need to refactor correctly
        // TODO - find an alternate way to avoid calling this Heavy method twice
        var dimensions = new Dimensions(this.ctx);
        dimensions.plotCoords();
      }
    }, {
      key: "determineInterval",
      value: function determineInterval(daysDiff) {
        var yearsDiff = daysDiff / 365;
        var hoursDiff = daysDiff * 24;
        var minutesDiff = hoursDiff * 60;
        var secondsDiff = minutesDiff * 60;
        switch (true) {
          case yearsDiff > 5:
            this.tickInterval = 'years';
            break;
          case daysDiff > 800:
            this.tickInterval = 'half_year';
            break;
          case daysDiff > 180:
            this.tickInterval = 'months';
            break;
          case daysDiff > 90:
            this.tickInterval = 'months_fortnight';
            break;
          case daysDiff > 60:
            this.tickInterval = 'months_days';
            break;
          case daysDiff > 30:
            this.tickInterval = 'week_days';
            break;
          case daysDiff > 2:
            this.tickInterval = 'days';
            break;
          case hoursDiff > 2.4:
            this.tickInterval = 'hours';
            break;
          case minutesDiff > 15:
            this.tickInterval = 'minutes_fives';
            break;
          case minutesDiff > 5:
            this.tickInterval = 'minutes';
            break;
          case minutesDiff > 1:
            this.tickInterval = 'seconds_tens';
            break;
          case secondsDiff > 20:
            this.tickInterval = 'seconds_fives';
            break;
          default:
            this.tickInterval = 'seconds';
            break;
        }
      }
    }, {
      key: "generateYearScale",
      value: function generateYearScale(_ref) {
        var firstVal = _ref.firstVal,
          currentMonth = _ref.currentMonth,
          currentYear = _ref.currentYear,
          daysWidthOnXAxis = _ref.daysWidthOnXAxis,
          numberOfYears = _ref.numberOfYears;
        var firstTickValue = firstVal.minYear;
        var firstTickPosition = 0;
        var dt = new DateTime(this.ctx);
        var unit = 'year';
        if (firstVal.minDate > 1 || firstVal.minMonth > 0) {
          var remainingDays = dt.determineRemainingDaysOfYear(firstVal.minYear, firstVal.minMonth, firstVal.minDate);

          // remainingDaysofFirstMonth is used to reacht the 2nd tick position
          var remainingDaysOfFirstYear = dt.determineDaysOfYear(firstVal.minYear) - remainingDays + 1;

          // calculate the first tick position
          firstTickPosition = remainingDaysOfFirstYear * daysWidthOnXAxis;
          firstTickValue = firstVal.minYear + 1;
          // push the first tick in the array
          this.timeScaleArray.push({
            position: firstTickPosition,
            value: firstTickValue,
            unit: unit,
            year: firstTickValue,
            month: Utils$1.monthMod(currentMonth + 1)
          });
        } else if (firstVal.minDate === 1 && firstVal.minMonth === 0) {
          // push the first tick in the array
          this.timeScaleArray.push({
            position: firstTickPosition,
            value: firstTickValue,
            unit: unit,
            year: currentYear,
            month: Utils$1.monthMod(currentMonth + 1)
          });
        }
        var year = firstTickValue;
        var pos = firstTickPosition;

        // keep drawing rest of the ticks
        for (var i = 0; i < numberOfYears; i++) {
          year++;
          pos = dt.determineDaysOfYear(year - 1) * daysWidthOnXAxis + pos;
          this.timeScaleArray.push({
            position: pos,
            value: year,
            unit: unit,
            year: year,
            month: 1
          });
        }
      }
    }, {
      key: "generateMonthScale",
      value: function generateMonthScale(_ref2) {
        var firstVal = _ref2.firstVal,
          currentMonthDate = _ref2.currentMonthDate,
          currentMonth = _ref2.currentMonth,
          currentYear = _ref2.currentYear,
          daysWidthOnXAxis = _ref2.daysWidthOnXAxis,
          numberOfMonths = _ref2.numberOfMonths;
        var firstTickValue = currentMonth;
        var firstTickPosition = 0;
        var dt = new DateTime(this.ctx);
        var unit = 'month';
        var yrCounter = 0;
        if (firstVal.minDate > 1) {
          // remainingDaysofFirstMonth is used to reacht the 2nd tick position
          var remainingDaysOfFirstMonth = dt.determineDaysOfMonths(currentMonth + 1, firstVal.minYear) - currentMonthDate + 1;

          // calculate the first tick position
          firstTickPosition = remainingDaysOfFirstMonth * daysWidthOnXAxis;
          firstTickValue = Utils$1.monthMod(currentMonth + 1);
          var year = currentYear + yrCounter;
          var _month = Utils$1.monthMod(firstTickValue);
          var value = firstTickValue;
          // it's Jan, so update the year
          if (firstTickValue === 0) {
            unit = 'year';
            value = year;
            _month = 1;
            yrCounter += 1;
            year = year + yrCounter;
          }

          // push the first tick in the array
          this.timeScaleArray.push({
            position: firstTickPosition,
            value: value,
            unit: unit,
            year: year,
            month: _month
          });
        } else {
          // push the first tick in the array
          this.timeScaleArray.push({
            position: firstTickPosition,
            value: firstTickValue,
            unit: unit,
            year: currentYear,
            month: Utils$1.monthMod(currentMonth)
          });
        }
        var month = firstTickValue + 1;
        var pos = firstTickPosition;

        // keep drawing rest of the ticks
        for (var i = 0, j = 1; i < numberOfMonths; i++, j++) {
          month = Utils$1.monthMod(month);
          if (month === 0) {
            unit = 'year';
            yrCounter += 1;
          } else {
            unit = 'month';
          }
          var _year = this._getYear(currentYear, month, yrCounter);
          pos = dt.determineDaysOfMonths(month, _year) * daysWidthOnXAxis + pos;
          var monthVal = month === 0 ? _year : month;
          this.timeScaleArray.push({
            position: pos,
            value: monthVal,
            unit: unit,
            year: _year,
            month: month === 0 ? 1 : month
          });
          month++;
        }
      }
    }, {
      key: "generateDayScale",
      value: function generateDayScale(_ref3) {
        var firstVal = _ref3.firstVal,
          currentMonth = _ref3.currentMonth,
          currentYear = _ref3.currentYear,
          hoursWidthOnXAxis = _ref3.hoursWidthOnXAxis,
          numberOfDays = _ref3.numberOfDays;
        var dt = new DateTime(this.ctx);
        var unit = 'day';
        var firstTickValue = firstVal.minDate + 1;
        var date = firstTickValue;
        var changeMonth = function changeMonth(dateVal, month, year) {
          var monthdays = dt.determineDaysOfMonths(month + 1, year);
          if (dateVal > monthdays) {
            month = month + 1;
            date = 1;
            unit = 'month';
            val = month;
            return month;
          }
          return month;
        };
        var remainingHours = 24 - firstVal.minHour;
        var yrCounter = 0;

        // calculate the first tick position
        var firstTickPosition = remainingHours * hoursWidthOnXAxis;
        var val = firstTickValue;
        var month = changeMonth(date, currentMonth, currentYear);
        if (firstVal.minHour === 0 && firstVal.minDate === 1) {
          // the first value is the first day of month
          firstTickPosition = 0;
          val = Utils$1.monthMod(firstVal.minMonth);
          unit = 'month';
          date = firstVal.minDate;
          // numberOfDays++
          // removed the above line to fix https://github.com/apexcharts/apexcharts.js/issues/305#issuecomment-1019520513
        } else if (firstVal.minDate !== 1 && firstVal.minHour === 0 && firstVal.minMinute === 0) {
          // fixes apexcharts/apexcharts.js/issues/1730
          firstTickPosition = 0;
          firstTickValue = firstVal.minDate;
          date = firstTickValue;
          val = firstTickValue;
          // in case it's the last date of month, we need to check it
          month = changeMonth(date, currentMonth, currentYear);
          if (val !== 1) {
            unit = 'day';
          }
        }

        // push the first tick in the array
        this.timeScaleArray.push({
          position: firstTickPosition,
          value: val,
          unit: unit,
          year: this._getYear(currentYear, month, yrCounter),
          month: Utils$1.monthMod(month),
          day: date
        });
        var pos = firstTickPosition;
        // keep drawing rest of the ticks
        for (var i = 0; i < numberOfDays; i++) {
          date += 1;
          unit = 'day';
          month = changeMonth(date, month, this._getYear(currentYear, month, yrCounter));
          var year = this._getYear(currentYear, month, yrCounter);
          pos = 24 * hoursWidthOnXAxis + pos;
          var value = date === 1 ? Utils$1.monthMod(month) : date;
          this.timeScaleArray.push({
            position: pos,
            value: value,
            unit: unit,
            year: year,
            month: Utils$1.monthMod(month),
            day: value
          });
        }
      }
    }, {
      key: "generateHourScale",
      value: function generateHourScale(_ref4) {
        var firstVal = _ref4.firstVal,
          currentDate = _ref4.currentDate,
          currentMonth = _ref4.currentMonth,
          currentYear = _ref4.currentYear,
          minutesWidthOnXAxis = _ref4.minutesWidthOnXAxis,
          numberOfHours = _ref4.numberOfHours;
        var dt = new DateTime(this.ctx);
        var yrCounter = 0;
        var unit = 'hour';
        var changeDate = function changeDate(dateVal, month) {
          var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);
          if (dateVal > monthdays) {
            date = 1;
            month = month + 1;
          }
          return {
            month: month,
            date: date
          };
        };
        var changeMonth = function changeMonth(dateVal, month) {
          var monthdays = dt.determineDaysOfMonths(month + 1, currentYear);
          if (dateVal > monthdays) {
            month = month + 1;
            return month;
          }
          return month;
        };

        // factor in minSeconds as well
        var remainingMins = 60 - (firstVal.minMinute + firstVal.minSecond / 60.0);
        var firstTickPosition = remainingMins * minutesWidthOnXAxis;
        var firstTickValue = firstVal.minHour + 1;
        var hour = firstTickValue;
        if (remainingMins === 60) {
          firstTickPosition = 0;
          firstTickValue = firstVal.minHour;
          hour = firstTickValue;
        }
        var date = currentDate;

        // we need to apply date switching logic here as well, to avoid duplicated labels
        if (hour >= 24) {
          hour = 0;
          date += 1;
          unit = 'day';
          // Unit changed to day , Value should align unit
          firstTickValue = date;
        }
        var checkNextMonth = changeDate(date, currentMonth);
        var month = checkNextMonth.month;
        month = changeMonth(date, month);

        // Check if date is greater than 31 and change month if it is
        if (firstTickValue > 31) {
          date = 1;
          firstTickValue = date;
        }

        // push the first tick in the array
        this.timeScaleArray.push({
          position: firstTickPosition,
          value: firstTickValue,
          unit: unit,
          day: date,
          hour: hour,
          year: currentYear,
          month: Utils$1.monthMod(month)
        });
        hour++;
        var pos = firstTickPosition;
        // keep drawing rest of the ticks
        for (var i = 0; i < numberOfHours; i++) {
          unit = 'hour';
          if (hour >= 24) {
            hour = 0;
            date += 1;
            unit = 'day';
            var _checkNextMonth = changeDate(date, month);
            month = _checkNextMonth.month;
            month = changeMonth(date, month);
          }
          var year = this._getYear(currentYear, month, yrCounter);
          pos = 60 * minutesWidthOnXAxis + pos;
          var val = hour === 0 ? date : hour;
          this.timeScaleArray.push({
            position: pos,
            value: val,
            unit: unit,
            hour: hour,
            day: date,
            year: year,
            month: Utils$1.monthMod(month)
          });
          hour++;
        }
      }
    }, {
      key: "generateMinuteScale",
      value: function generateMinuteScale(_ref5) {
        var currentMillisecond = _ref5.currentMillisecond,
          currentSecond = _ref5.currentSecond,
          currentMinute = _ref5.currentMinute,
          currentHour = _ref5.currentHour,
          currentDate = _ref5.currentDate,
          currentMonth = _ref5.currentMonth,
          currentYear = _ref5.currentYear,
          minutesWidthOnXAxis = _ref5.minutesWidthOnXAxis,
          secondsWidthOnXAxis = _ref5.secondsWidthOnXAxis,
          numberOfMinutes = _ref5.numberOfMinutes;
        var yrCounter = 0;
        var unit = 'minute';
        var remainingSecs = 60 - currentSecond;
        var firstTickPosition = (remainingSecs - currentMillisecond / 1000) * secondsWidthOnXAxis;
        var minute = currentMinute + 1;
        var date = currentDate;
        var month = currentMonth;
        var year = currentYear;
        var hour = currentHour;
        var pos = firstTickPosition;
        for (var i = 0; i < numberOfMinutes; i++) {
          if (minute >= 60) {
            minute = 0;
            hour += 1;
            if (hour === 24) {
              hour = 0;
            }
          }
          this.timeScaleArray.push({
            position: pos,
            value: minute,
            unit: unit,
            hour: hour,
            minute: minute,
            day: date,
            year: this._getYear(year, month, yrCounter),
            month: Utils$1.monthMod(month)
          });
          pos += minutesWidthOnXAxis;
          minute++;
        }
      }
    }, {
      key: "generateSecondScale",
      value: function generateSecondScale(_ref6) {
        var currentMillisecond = _ref6.currentMillisecond,
          currentSecond = _ref6.currentSecond,
          currentMinute = _ref6.currentMinute,
          currentHour = _ref6.currentHour,
          currentDate = _ref6.currentDate,
          currentMonth = _ref6.currentMonth,
          currentYear = _ref6.currentYear,
          secondsWidthOnXAxis = _ref6.secondsWidthOnXAxis,
          numberOfSeconds = _ref6.numberOfSeconds;
        var yrCounter = 0;
        var unit = 'second';
        var remainingMillisecs = 1000 - currentMillisecond;
        var firstTickPosition = remainingMillisecs / 1000 * secondsWidthOnXAxis;
        var second = currentSecond + 1;
        var minute = currentMinute;
        var date = currentDate;
        var month = currentMonth;
        var year = currentYear;
        var hour = currentHour;
        var pos = firstTickPosition;
        for (var i = 0; i < numberOfSeconds; i++) {
          if (second >= 60) {
            minute++;
            second = 0;
            if (minute >= 60) {
              hour++;
              minute = 0;
              if (hour === 24) {
                hour = 0;
              }
            }
          }
          this.timeScaleArray.push({
            position: pos,
            value: second,
            unit: unit,
            hour: hour,
            minute: minute,
            second: second,
            day: date,
            year: this._getYear(year, month, yrCounter),
            month: Utils$1.monthMod(month)
          });
          pos += secondsWidthOnXAxis;
          second++;
        }
      }
    }, {
      key: "createRawDateString",
      value: function createRawDateString(ts, value) {
        var raw = ts.year;
        if (ts.month === 0) {
          // invalid month, correct it
          ts.month = 1;
        }
        raw += '-' + ('0' + ts.month.toString()).slice(-2);

        // unit is day
        if (ts.unit === 'day') {
          raw += ts.unit === 'day' ? '-' + ('0' + value).slice(-2) : '-01';
        } else {
          raw += '-' + ('0' + (ts.day ? ts.day : '1')).slice(-2);
        }

        // unit is hour
        if (ts.unit === 'hour') {
          raw += ts.unit === 'hour' ? 'T' + ('0' + value).slice(-2) : 'T00';
        } else {
          raw += 'T' + ('0' + (ts.hour ? ts.hour : '0')).slice(-2);
        }
        if (ts.unit === 'minute') {
          raw += ':' + ('0' + value).slice(-2);
        } else {
          raw += ':' + (ts.minute ? ('0' + ts.minute).slice(-2) : '00');
        }
        if (ts.unit === 'second') {
          raw += ':' + ('0' + value).slice(-2);
        } else {
          raw += ':00';
        }
        if (this.utc) {
          raw += '.000Z';
        }
        return raw;
      }
    }, {
      key: "formatDates",
      value: function formatDates(filteredTimeScale) {
        var _this2 = this;
        var w = this.w;
        var reformattedTimescaleArray = filteredTimeScale.map(function (ts) {
          var value = ts.value.toString();
          var dt = new DateTime(_this2.ctx);
          var raw = _this2.createRawDateString(ts, value);
          var dateToFormat = dt.getDate(dt.parseDate(raw));
          if (!_this2.utc) {
            // Fixes #1726, #1544, #1485, #1255
            dateToFormat = dt.getDate(dt.parseDateWithTimezone(raw));
          }
          if (w.config.xaxis.labels.format === undefined) {
            var customFormat = 'dd MMM';
            var dtFormatter = w.config.xaxis.labels.datetimeFormatter;
            if (ts.unit === 'year') customFormat = dtFormatter.year;
            if (ts.unit === 'month') customFormat = dtFormatter.month;
            if (ts.unit === 'day') customFormat = dtFormatter.day;
            if (ts.unit === 'hour') customFormat = dtFormatter.hour;
            if (ts.unit === 'minute') customFormat = dtFormatter.minute;
            if (ts.unit === 'second') customFormat = dtFormatter.second;
            value = dt.formatDate(dateToFormat, customFormat);
          } else {
            value = dt.formatDate(dateToFormat, w.config.xaxis.labels.format);
          }
          return {
            dateString: raw,
            position: ts.position,
            value: value,
            unit: ts.unit,
            year: ts.year,
            month: ts.month
          };
        });
        return reformattedTimescaleArray;
      }
    }, {
      key: "removeOverlappingTS",
      value: function removeOverlappingTS(arr) {
        var _this3 = this;
        var graphics = new Graphics(this.ctx);
        var equalLabelLengthFlag = false; // These labels got same length?
        var constantLabelWidth; // If true, what is the constant length to use
        if (arr.length > 0 &&
        // check arr length
        arr[0].value &&
        // check arr[0] contains value
        arr.every(function (lb) {
          return lb.value.length === arr[0].value.length;
        }) // check every arr label value is the same as the first one
        ) {
          equalLabelLengthFlag = true; // These labels got same length
          constantLabelWidth = graphics.getTextRects(arr[0].value).width; // The constant label width to use
        }
        var lastDrawnIndex = 0;
        var filteredArray = arr.map(function (item, index) {
          if (index > 0 && _this3.w.config.xaxis.labels.hideOverlappingLabels) {
            var prevLabelWidth = !equalLabelLengthFlag // if vary in label length
            ? graphics.getTextRects(arr[lastDrawnIndex].value).width // get individual length
            : constantLabelWidth; // else: use constant length
            var prevPos = arr[lastDrawnIndex].position;
            var pos = item.position;
            if (pos > prevPos + prevLabelWidth + 10) {
              lastDrawnIndex = index;
              return item;
            } else {
              return null;
            }
          } else {
            return item;
          }
        });
        filteredArray = filteredArray.filter(function (f) {
          return f !== null;
        });
        return filteredArray;
      }
    }, {
      key: "_getYear",
      value: function _getYear(currentYear, month, yrCounter) {
        return currentYear + Math.floor(month / 12) + yrCounter;
      }
    }]);
    return TimeScale;
  }();

  /**
   * ApexCharts Core Class responsible for major calculations and creating elements.
   *
   * @module Core
   **/
  var Core = /*#__PURE__*/function () {
    function Core(el, ctx) {
      _classCallCheck(this, Core);
      this.ctx = ctx;
      this.w = ctx.w;
      this.el = el;
    }
    _createClass(Core, [{
      key: "setupElements",
      value: function setupElements() {
        var _this$w = this.w,
          gl = _this$w.globals,
          cnf = _this$w.config;
        var ct = cnf.chart.type;
        var axisChartsArrTypes = ['line', 'area', 'bar', 'rangeBar', 'rangeArea', 'candlestick', 'boxPlot', 'scatter', 'bubble', 'radar', 'heatmap', 'treemap'];
        var xyChartsArrTypes = ['line', 'area', 'bar', 'rangeBar', 'rangeArea', 'candlestick', 'boxPlot', 'scatter', 'bubble'];
        gl.axisCharts = axisChartsArrTypes.includes(ct);
        gl.xyCharts = xyChartsArrTypes.includes(ct);
        gl.isBarHorizontal = ['bar', 'rangeBar', 'boxPlot'].includes(ct) && cnf.plotOptions.bar.horizontal;
        gl.chartClass = ".apexcharts".concat(gl.chartID);
        gl.dom.baseEl = this.el;
        gl.dom.elWrap = document.createElement('div');
        Graphics.setAttrs(gl.dom.elWrap, {
          id: gl.chartClass.substring(1),
          class: "apexcharts-canvas ".concat(gl.chartClass.substring(1))
        });
        this.el.appendChild(gl.dom.elWrap);

        // gl.dom.Paper = new window.SVG.Doc(gl.dom.elWrap)
        gl.dom.Paper = window.SVG().addTo(gl.dom.elWrap);
        gl.dom.Paper.attr({
          class: 'apexcharts-svg',
          'xmlns:data': 'ApexChartsNS',
          transform: "translate(".concat(cnf.chart.offsetX, ", ").concat(cnf.chart.offsetY, ")")
        });
        gl.dom.Paper.node.style.background = cnf.theme.mode === 'dark' && !cnf.chart.background ? '#343A3F' : cnf.theme.mode === 'light' && !cnf.chart.background ? '#fff' : cnf.chart.background;
        this.setSVGDimensions();
        gl.dom.elLegendForeign = document.createElementNS(gl.SVGNS, 'foreignObject');
        Graphics.setAttrs(gl.dom.elLegendForeign, {
          x: 0,
          y: 0,
          width: gl.svgWidth,
          height: gl.svgHeight
        });
        gl.dom.elLegendWrap = document.createElement('div');
        gl.dom.elLegendWrap.classList.add('apexcharts-legend');
        gl.dom.elWrap.appendChild(gl.dom.elLegendWrap);
        gl.dom.Paper.node.appendChild(gl.dom.elLegendForeign);
        gl.dom.elGraphical = gl.dom.Paper.group().attr({
          class: 'apexcharts-inner apexcharts-graphical'
        });
        gl.dom.elDefs = gl.dom.Paper.defs();
        gl.dom.Paper.add(gl.dom.elGraphical);
        gl.dom.elGraphical.add(gl.dom.elDefs);
      }
    }, {
      key: "plotChartType",
      value: function plotChartType(ser, xyRatios) {
        var w = this.w,
          ctx = this.ctx;
        var cnf = w.config,
          gl = w.globals;
        var seriesTypes = {
          line: {
            series: [],
            i: []
          },
          area: {
            series: [],
            i: []
          },
          scatter: {
            series: [],
            i: []
          },
          bubble: {
            series: [],
            i: []
          },
          bar: {
            series: [],
            i: []
          },
          candlestick: {
            series: [],
            i: []
          },
          boxPlot: {
            series: [],
            i: []
          },
          rangeBar: {
            series: [],
            i: []
          },
          rangeArea: {
            series: [],
            seriesRangeEnd: [],
            i: []
          }
        };
        var chartType = cnf.chart.type || 'line';
        var nonComboType = null;
        var comboCount = 0;
        gl.series.forEach(function (serie, st) {
          var _ser$st, _ser$st2;
          var seriesType = ((_ser$st = ser[st]) === null || _ser$st === void 0 ? void 0 : _ser$st.type) === 'column' ? 'bar' : ((_ser$st2 = ser[st]) === null || _ser$st2 === void 0 ? void 0 : _ser$st2.type) || (chartType === 'column' ? 'bar' : chartType);
          if (seriesTypes[seriesType]) {
            if (seriesType === 'rangeArea') {
              seriesTypes[seriesType].series.push(gl.seriesRangeStart[st]);
              seriesTypes[seriesType].seriesRangeEnd.push(gl.seriesRangeEnd[st]);
            } else {
              seriesTypes[seriesType].series.push(serie);
            }
            seriesTypes[seriesType].i.push(st);
            if (seriesType === 'bar') w.globals.columnSeries = seriesTypes.bar;
          } else if (['heatmap', 'treemap', 'pie', 'donut', 'polarArea', 'radialBar', 'radar'].includes(seriesType)) {
            nonComboType = seriesType;
          } else {
            console.warn("You have specified an unrecognized series type (".concat(seriesType, ")."));
          }
          if (chartType !== seriesType && seriesType !== 'scatter') comboCount++;
        });
        if (comboCount > 0) {
          if (nonComboType) {
            console.warn("Chart or series type ".concat(nonComboType, " cannot appear with other chart or series types."));
          }
          if (seriesTypes.bar.series.length > 0 && cnf.plotOptions.bar.horizontal) {
            comboCount -= seriesTypes.bar.series.length;
            seriesTypes.bar = {
              series: [],
              i: []
            };
            w.globals.columnSeries = {
              series: [],
              i: []
            };
            console.warn('Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`');
          }
        }
        gl.comboCharts || (gl.comboCharts = comboCount > 0);
        var line = new Line(ctx, xyRatios);
        var boxCandlestick = new BoxCandleStick(ctx, xyRatios);
        ctx.pie = new Pie(ctx);
        var radialBar = new Radial(ctx);
        ctx.rangeBar = new RangeBar(ctx, xyRatios);
        var radar = new Radar(ctx);
        var elGraph = [];
        if (gl.comboCharts) {
          var coreUtils = new CoreUtils(ctx);
          if (seriesTypes.area.series.length > 0) {
            var _elGraph;
            (_elGraph = elGraph).push.apply(_elGraph, _toConsumableArray(coreUtils.drawSeriesByGroup(seriesTypes.area, gl.areaGroups, 'area', line)));
          }
          if (seriesTypes.bar.series.length > 0) {
            if (cnf.chart.stacked) {
              var barStacked = new BarStacked(ctx, xyRatios);
              elGraph.push(barStacked.draw(seriesTypes.bar.series, seriesTypes.bar.i));
            } else {
              ctx.bar = new Bar(ctx, xyRatios);
              elGraph.push(ctx.bar.draw(seriesTypes.bar.series, seriesTypes.bar.i));
            }
          }
          if (seriesTypes.rangeArea.series.length > 0) {
            elGraph.push(line.draw(seriesTypes.rangeArea.series, 'rangeArea', seriesTypes.rangeArea.i, seriesTypes.rangeArea.seriesRangeEnd));
          }
          if (seriesTypes.line.series.length > 0) {
            var _elGraph2;
            (_elGraph2 = elGraph).push.apply(_elGraph2, _toConsumableArray(coreUtils.drawSeriesByGroup(seriesTypes.line, gl.lineGroups, 'line', line)));
          }
          if (seriesTypes.candlestick.series.length > 0) {
            elGraph.push(boxCandlestick.draw(seriesTypes.candlestick.series, 'candlestick', seriesTypes.candlestick.i));
          }
          if (seriesTypes.boxPlot.series.length > 0) {
            elGraph.push(boxCandlestick.draw(seriesTypes.boxPlot.series, 'boxPlot', seriesTypes.boxPlot.i));
          }
          if (seriesTypes.rangeBar.series.length > 0) {
            elGraph.push(ctx.rangeBar.draw(seriesTypes.rangeBar.series, seriesTypes.rangeBar.i));
          }
          if (seriesTypes.scatter.series.length > 0) {
            var scatterLine = new Line(ctx, xyRatios, true);
            elGraph.push(scatterLine.draw(seriesTypes.scatter.series, 'scatter', seriesTypes.scatter.i));
          }
          if (seriesTypes.bubble.series.length > 0) {
            var bubbleLine = new Line(ctx, xyRatios, true);
            elGraph.push(bubbleLine.draw(seriesTypes.bubble.series, 'bubble', seriesTypes.bubble.i));
          }
        } else {
          switch (cnf.chart.type) {
            case 'line':
              elGraph = line.draw(gl.series, 'line');
              break;
            case 'area':
              elGraph = line.draw(gl.series, 'area');
              break;
            case 'bar':
              if (cnf.chart.stacked) {
                var _barStacked = new BarStacked(ctx, xyRatios);
                elGraph = _barStacked.draw(gl.series);
              } else {
                ctx.bar = new Bar(ctx, xyRatios);
                elGraph = ctx.bar.draw(gl.series);
              }
              break;
            case 'candlestick':
              var candleStick = new BoxCandleStick(ctx, xyRatios);
              elGraph = candleStick.draw(gl.series, 'candlestick');
              break;
            case 'boxPlot':
              var boxPlot = new BoxCandleStick(ctx, xyRatios);
              elGraph = boxPlot.draw(gl.series, cnf.chart.type);
              break;
            case 'rangeBar':
              elGraph = ctx.rangeBar.draw(gl.series);
              break;
            case 'rangeArea':
              elGraph = line.draw(gl.seriesRangeStart, 'rangeArea', undefined, gl.seriesRangeEnd);
              break;
            case 'heatmap':
              var heatmap = new HeatMap(ctx, xyRatios);
              elGraph = heatmap.draw(gl.series);
              break;
            case 'treemap':
              var treemap = new TreemapChart(ctx, xyRatios);
              elGraph = treemap.draw(gl.series);
              break;
            case 'pie':
            case 'donut':
            case 'polarArea':
              elGraph = ctx.pie.draw(gl.series);
              break;
            case 'radialBar':
              elGraph = radialBar.draw(gl.series);
              break;
            case 'radar':
              elGraph = radar.draw(gl.series);
              break;
            default:
              elGraph = line.draw(gl.series);
          }
        }
        return elGraph;
      }
    }, {
      key: "setSVGDimensions",
      value: function setSVGDimensions() {
        var _this$w2 = this.w,
          gl = _this$w2.globals,
          cnf = _this$w2.config;
        cnf.chart.width = cnf.chart.width || '100%';
        cnf.chart.height = cnf.chart.height || 'auto';
        gl.svgWidth = cnf.chart.width;
        gl.svgHeight = cnf.chart.height;
        var elDim = Utils$1.getDimensions(this.el);
        var widthUnit = cnf.chart.width.toString().split(/[0-9]+/g).pop();
        if (widthUnit === '%') {
          if (Utils$1.isNumber(elDim[0])) {
            if (elDim[0].width === 0) {
              elDim = Utils$1.getDimensions(this.el.parentNode);
            }
            gl.svgWidth = elDim[0] * parseInt(cnf.chart.width, 10) / 100;
          }
        } else if (widthUnit === 'px' || widthUnit === '') {
          gl.svgWidth = parseInt(cnf.chart.width, 10);
        }
        var heightUnit = String(cnf.chart.height).toString().split(/[0-9]+/g).pop();
        if (gl.svgHeight !== 'auto' && gl.svgHeight !== '') {
          if (heightUnit === '%') {
            var elParentDim = Utils$1.getDimensions(this.el.parentNode);
            gl.svgHeight = elParentDim[1] * parseInt(cnf.chart.height, 10) / 100;
          } else {
            gl.svgHeight = parseInt(cnf.chart.height, 10);
          }
        } else {
          gl.svgHeight = gl.axisCharts ? gl.svgWidth / 1.61 : gl.svgWidth / 1.2;
        }
        gl.svgWidth = Math.max(gl.svgWidth, 0);
        gl.svgHeight = Math.max(gl.svgHeight, 0);
        Graphics.setAttrs(gl.dom.Paper.node, {
          width: gl.svgWidth,
          height: gl.svgHeight
        });
        if (heightUnit !== '%') {
          var offsetY = cnf.chart.sparkline.enabled ? 0 : gl.axisCharts ? cnf.chart.parentHeightOffset : 0;
          gl.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(gl.svgHeight + offsetY, "px");
        }
        gl.dom.elWrap.style.width = "".concat(gl.svgWidth, "px");
        gl.dom.elWrap.style.height = "".concat(gl.svgHeight, "px");
      }
    }, {
      key: "shiftGraphPosition",
      value: function shiftGraphPosition() {
        var gl = this.w.globals;
        var tY = gl.translateY,
          tX = gl.translateX;
        Graphics.setAttrs(gl.dom.elGraphical.node, {
          transform: "translate(".concat(tX, ", ").concat(tY, ")")
        });
      }
    }, {
      key: "resizeNonAxisCharts",
      value: function resizeNonAxisCharts() {
        var w = this.w;
        var gl = w.globals;
        var legendHeight = 0;
        var offY = w.config.chart.sparkline.enabled ? 1 : 15;
        offY += w.config.grid.padding.bottom;
        if (['top', 'bottom'].includes(w.config.legend.position) && w.config.legend.show && !w.config.legend.floating) {
          legendHeight = new Legend(this.ctx).legendHelpers.getLegendDimensions().clwh + 7;
        }
        var el = w.globals.dom.baseEl.querySelector('.apexcharts-radialbar, .apexcharts-pie');
        var chartInnerDimensions = w.globals.radialSize * 2.05;
        if (el && !w.config.chart.sparkline.enabled && w.config.plotOptions.radialBar.startAngle !== 0) {
          var elRadialRect = Utils$1.getBoundingClientRect(el);
          chartInnerDimensions = elRadialRect.bottom;
          var maxHeight = elRadialRect.bottom - elRadialRect.top;
          chartInnerDimensions = Math.max(w.globals.radialSize * 2.05, maxHeight);
        }
        var newHeight = Math.ceil(chartInnerDimensions + gl.translateY + legendHeight + offY);
        if (gl.dom.elLegendForeign) {
          gl.dom.elLegendForeign.setAttribute('height', newHeight);
        }
        if (w.config.chart.height && String(w.config.chart.height).includes('%')) return;
        gl.dom.elWrap.style.height = "".concat(newHeight, "px");
        Graphics.setAttrs(gl.dom.Paper.node, {
          height: newHeight
        });
        gl.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(newHeight, "px");
      }
    }, {
      key: "coreCalculations",
      value: function coreCalculations() {
        new Range(this.ctx).init();
      }
    }, {
      key: "resetGlobals",
      value: function resetGlobals() {
        var _this = this;
        var resetxyValues = function resetxyValues() {
          return _this.w.config.series.map(function () {
            return [];
          });
        };
        var globalObj = new Globals();
        var gl = this.w.globals;
        var parsingFlags = {
          dataWasParsed: gl.dataWasParsed,
          originalSeries: gl.originalSeries
        };
        globalObj.initGlobalVars(gl);
        gl.seriesXvalues = resetxyValues();
        gl.seriesYvalues = resetxyValues();
        if (parsingFlags.dataWasParsed) {
          gl.dataWasParsed = parsingFlags.dataWasParsed;
          gl.originalSeries = parsingFlags.originalSeries;
        }
      }
    }, {
      key: "isMultipleY",
      value: function isMultipleY() {
        if (Array.isArray(this.w.config.yaxis) && this.w.config.yaxis.length > 1) {
          this.w.globals.isMultipleYAxis = true;
          return true;
        }
        return false;
      }
    }, {
      key: "xySettings",
      value: function xySettings() {
        var w = this.w;
        var xyRatios = null;
        if (w.globals.axisCharts) {
          if (w.config.xaxis.crosshairs.position === 'back') {
            new Crosshairs(this.ctx).drawXCrosshairs();
          }
          if (w.config.yaxis[0].crosshairs.position === 'back') {
            new Crosshairs(this.ctx).drawYCrosshairs();
          }
          if (w.config.xaxis.type === 'datetime' && w.config.xaxis.labels.formatter === undefined) {
            this.ctx.timeScale = new TimeScale(this.ctx);
            var formattedTimeScale = [];
            if (isFinite(w.globals.minX) && isFinite(w.globals.maxX) && !w.globals.isBarHorizontal) {
              formattedTimeScale = this.ctx.timeScale.calculateTimeScaleTicks(w.globals.minX, w.globals.maxX);
            } else if (w.globals.isBarHorizontal) {
              formattedTimeScale = this.ctx.timeScale.calculateTimeScaleTicks(w.globals.minY, w.globals.maxY);
            }
            this.ctx.timeScale.recalcDimensionsBasedOnFormat(formattedTimeScale);
          }
          var coreUtils = new CoreUtils(this.ctx);
          xyRatios = coreUtils.getCalculatedRatios();
        }
        return xyRatios;
      }
    }, {
      key: "updateSourceChart",
      value: function updateSourceChart(targetChart) {
        this.ctx.w.globals.selection = undefined;
        this.ctx.updateHelpers._updateOptions({
          chart: {
            selection: {
              xaxis: {
                min: targetChart.w.globals.minX,
                max: targetChart.w.globals.maxX
              }
            }
          }
        }, false, false);
      }
    }, {
      key: "setupBrushHandler",
      value: function setupBrushHandler() {
        var _this2 = this;
        var ctx = this.ctx,
          w = this.w;
        if (!w.config.chart.brush.enabled) return;
        if (typeof w.config.chart.events.selection !== 'function') {
          var targets = Array.isArray(w.config.chart.brush.targets) ? w.config.chart.brush.targets : [w.config.chart.brush.target];
          targets.forEach(function (target) {
            var targetChart = ctx.constructor.getChartByID(target);
            targetChart.w.globals.brushSource = _this2.ctx;
            if (typeof targetChart.w.config.chart.events.zoomed !== 'function') {
              targetChart.w.config.chart.events.zoomed = function () {
                return _this2.updateSourceChart(targetChart);
              };
            }
            if (typeof targetChart.w.config.chart.events.scrolled !== 'function') {
              targetChart.w.config.chart.events.scrolled = function () {
                return _this2.updateSourceChart(targetChart);
              };
            }
          });
          w.config.chart.events.selection = function (chart, e) {
            targets.forEach(function (target) {
              var targetChart = ctx.constructor.getChartByID(target);
              targetChart.ctx.updateHelpers._updateOptions({
                xaxis: {
                  min: e.xaxis.min,
                  max: e.xaxis.max
                }
              }, false, false, false, false);
            });
          };
        }
      }
    }]);
    return Core;
  }();

  var UpdateHelpers = /*#__PURE__*/function () {
    function UpdateHelpers(ctx) {
      _classCallCheck(this, UpdateHelpers);
      this.ctx = ctx;
      this.w = ctx.w;
    }

    /**
     * private method to update Options.
     *
     * @param {object} options - A new config object can be passed which will be merged with the existing config object
     * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there
     * @param {boolean} animate - should animate or not on updating Options
     * @param {boolean} overwriteInitialConfig - should update the initial config or not
     */
    _createClass(UpdateHelpers, [{
      key: "_updateOptions",
      value: function _updateOptions(options) {
        var _this = this;
        var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var updateSyncedCharts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var overwriteInitialConfig = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        return new Promise(function (resolve) {
          var charts = [_this.ctx];
          if (updateSyncedCharts) {
            charts = _this.ctx.getSyncedCharts();
          }
          if (_this.ctx.w.globals.isExecCalled) {
            // If the user called exec method, we don't want to get grouped charts as user specifically provided a chartID to update
            charts = [_this.ctx];
            _this.ctx.w.globals.isExecCalled = false;
          }
          charts.forEach(function (ch, chartIndex) {
            var w = ch.w;
            w.globals.shouldAnimate = animate;
            if (!redraw) {
              w.globals.resized = true;
              w.globals.dataChanged = true;
              if (animate) {
                ch.series.getPreviousPaths();
              }
            }
            if (options && _typeof(options) === 'object') {
              ch.config = new Config(options);
              options = CoreUtils.extendArrayProps(ch.config, options, w);

              // fixes #914, #623
              if (ch.w.globals.chartID !== _this.ctx.w.globals.chartID) {
                // don't overwrite series of synchronized charts
                delete options.series;
              }
              w.config = Utils$1.extend(w.config, options);
              if (overwriteInitialConfig) {
                // we need to forget the lastXAxis and lastYAxis as user forcefully overwriteInitialConfig. If we do not do this, and next time when user zooms the chart after setting yaxis.min/max or xaxis.min/max - the stored lastXAxis will never allow the chart to use the updated min/max by user.
                w.globals.lastXAxis = options.xaxis ? Utils$1.clone(options.xaxis) : [];
                w.globals.lastYAxis = options.yaxis ? Utils$1.clone(options.yaxis) : [];

                // After forgetting lastAxes, we need to restore the new config in initialConfig/initialSeries
                w.globals.initialConfig = Utils$1.extend({}, w.config);
                w.globals.initialSeries = Utils$1.clone(w.config.series);
                if (options.series) {
                  // Replace the collapsed series data
                  for (var i = 0; i < w.globals.collapsedSeriesIndices.length; i++) {
                    var series = w.config.series[w.globals.collapsedSeriesIndices[i]];
                    w.globals.collapsedSeries[i].data = w.globals.axisCharts ? series.data.slice() : series;
                  }
                  for (var _i = 0; _i < w.globals.ancillaryCollapsedSeriesIndices.length; _i++) {
                    var _series = w.config.series[w.globals.ancillaryCollapsedSeriesIndices[_i]];
                    w.globals.ancillaryCollapsedSeries[_i].data = w.globals.axisCharts ? _series.data.slice() : _series;
                  }

                  // Ensure that auto-generated axes are scaled to the visible data
                  ch.series.emptyCollapsedSeries(w.config.series);
                }
              }
            }
            return ch.update(options).then(function () {
              if (chartIndex === charts.length - 1) {
                resolve(ch);
              }
            });
          });
        });
      }

      /**
       * Private method to update Series.
       *
       * @param {array} series - New series which will override the existing
       */
    }, {
      key: "_updateSeries",
      value: function _updateSeries(newSeries, animate) {
        var _this2 = this;
        var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        return new Promise(function (resolve) {
          var w = _this2.w;
          w.globals.shouldAnimate = animate;
          w.globals.dataChanged = true;
          if (animate) {
            _this2.ctx.series.getPreviousPaths();
          }
          _this2.ctx.data.resetParsingFlags();
          _this2.ctx.data.parseData(newSeries);
          if (overwriteInitialSeries) {
            w.globals.initialConfig.series = Utils$1.clone(w.config.series);
            w.globals.initialSeries = Utils$1.clone(w.config.series);
          }
          return _this2.ctx.update().then(function () {
            resolve(_this2.ctx);
          });
        });
      }
    }, {
      key: "_extendSeries",
      value: function _extendSeries(s, i) {
        var w = this.w;
        var ser = w.config.series[i];
        return _objectSpread2(_objectSpread2({}, w.config.series[i]), {}, {
          name: s.name ? s.name : ser === null || ser === void 0 ? void 0 : ser.name,
          color: s.color ? s.color : ser === null || ser === void 0 ? void 0 : ser.color,
          type: s.type ? s.type : ser === null || ser === void 0 ? void 0 : ser.type,
          group: s.group ? s.group : ser === null || ser === void 0 ? void 0 : ser.group,
          hidden: typeof s.hidden !== 'undefined' ? s.hidden : ser === null || ser === void 0 ? void 0 : ser.hidden,
          data: s.data ? s.data : ser === null || ser === void 0 ? void 0 : ser.data,
          zIndex: typeof s.zIndex !== 'undefined' ? s.zIndex : i
        });
      }
    }, {
      key: "toggleDataPointSelection",
      value: function toggleDataPointSelection(seriesIndex, dataPointIndex) {
        var w = this.w;
        var elPath = null;
        var parent = ".apexcharts-series[data\\:realIndex='".concat(seriesIndex, "']");
        if (w.globals.axisCharts) {
          elPath = w.globals.dom.Paper.findOne("".concat(parent, " path[j='").concat(dataPointIndex, "'], ").concat(parent, " circle[j='").concat(dataPointIndex, "'], ").concat(parent, " rect[j='").concat(dataPointIndex, "']"));
        } else {
          // dataPointIndex will be undefined here, hence using seriesIndex
          if (typeof dataPointIndex === 'undefined') {
            elPath = w.globals.dom.Paper.findOne("".concat(parent, " path[j='").concat(seriesIndex, "']"));
            if (w.config.chart.type === 'pie' || w.config.chart.type === 'polarArea' || w.config.chart.type === 'donut') {
              this.ctx.pie.pieClicked(seriesIndex);
            }
          }
        }
        if (elPath) {
          var graphics = new Graphics(this.ctx);
          graphics.pathMouseDown(elPath, null);
        } else {
          console.warn('toggleDataPointSelection: Element not found');
          return null;
        }
        return elPath.node ? elPath.node : null;
      }
    }, {
      key: "forceXAxisUpdate",
      value: function forceXAxisUpdate(options) {
        var w = this.w;
        var minmax = ['min', 'max'];
        minmax.forEach(function (a) {
          if (typeof options.xaxis[a] !== 'undefined') {
            w.config.xaxis[a] = options.xaxis[a];
            w.globals.lastXAxis[a] = options.xaxis[a];
          }
        });
        if (options.xaxis.categories && options.xaxis.categories.length) {
          w.config.xaxis.categories = options.xaxis.categories;
        }
        if (w.config.xaxis.convertedCatToNumeric) {
          var defaults = new Defaults(options);
          options = defaults.convertCatToNumericXaxis(options, this.ctx);
        }
        return options;
      }
    }, {
      key: "forceYAxisUpdate",
      value: function forceYAxisUpdate(options) {
        if (options.chart && options.chart.stacked && options.chart.stackType === '100%') {
          if (Array.isArray(options.yaxis)) {
            options.yaxis.forEach(function (yaxe, index) {
              options.yaxis[index].min = 0;
              options.yaxis[index].max = 100;
            });
          } else {
            options.yaxis.min = 0;
            options.yaxis.max = 100;
          }
        }
        return options;
      }

      /**
       * This function reverts the yaxis and xaxis min/max values to what it was when the chart was defined.
       * This function fixes an important bug where a user might load a new series after zooming in/out of previous series which resulted in wrong min/max
       * Also, this should never be called internally on zoom/pan - the reset should only happen when user calls the updateSeries() function externally
       * The function also accepts an object {xaxis, yaxis} which when present is set as the new xaxis/yaxis
       */
    }, {
      key: "revertDefaultAxisMinMax",
      value: function revertDefaultAxisMinMax(opts) {
        var _this3 = this;
        var w = this.w;
        var xaxis = w.globals.lastXAxis;
        var yaxis = w.globals.lastYAxis;
        if (opts && opts.xaxis) {
          xaxis = opts.xaxis;
        }
        if (opts && opts.yaxis) {
          yaxis = opts.yaxis;
        }
        w.config.xaxis.min = xaxis.min;
        w.config.xaxis.max = xaxis.max;
        var getLastYAxis = function getLastYAxis(index) {
          if (typeof yaxis[index] !== 'undefined') {
            w.config.yaxis[index].min = yaxis[index].min;
            w.config.yaxis[index].max = yaxis[index].max;
          }
        };
        w.config.yaxis.map(function (yaxe, index) {
          if (w.globals.zoomed) {
            // user has zoomed, check the last yaxis
            getLastYAxis(index);
          } else {
            // user hasn't zoomed, check the last yaxis first
            if (typeof yaxis[index] !== 'undefined') {
              getLastYAxis(index);
            } else {
              // if last y-axis don't exist, check the original yaxis
              if (typeof _this3.ctx.opts.yaxis[index] !== 'undefined') {
                yaxe.min = _this3.ctx.opts.yaxis[index].min;
                yaxe.max = _this3.ctx.opts.yaxis[index].max;
              }
            }
          }
        });
      }
    }]);
    return UpdateHelpers;
  }();

  (function () {

    extend(PathArray, {
      morph: function morph(fromArray, toArray, pos, stepper, context) {
        var startArr = this.parse(fromArray),
          destArr = this.parse(toArray);
        var startOffsetM = 0,
          destOffsetM = 0;
        var startOffsetNextM = false,
          destOffsetNextM = false;
        while (true) {
          // stop if there is no M anymore
          if (startOffsetM === false && destOffsetM === false) break;

          // find the next M in path array
          startOffsetNextM = findNextM(startArr, startOffsetM === false ? false : startOffsetM + 1);
          destOffsetNextM = findNextM(destArr, destOffsetM === false ? false : destOffsetM + 1);

          // We have to add one M to the startArray
          if (startOffsetM === false) {
            var bbox = new PathArray(result.start).bbox();

            // when the last block had no bounding box we simply take the first M we got
            if (bbox.height == 0 || bbox.width == 0) {
              startOffsetM = startArr.push(startArr[0]) - 1;
            } else {
              // we take the middle of the bbox instead when we got one
              startOffsetM = startArr.push(['M', bbox.x + bbox.width / 2, bbox.y + bbox.height / 2]) - 1;
            }
          }

          // We have to add one M to the destArray
          if (destOffsetM === false) {
            var bbox = new PathArray(result.dest).bbox();
            if (bbox.height == 0 || bbox.width == 0) {
              destOffsetM = destArr.push(destArr[0]) - 1;
            } else {
              destOffsetM = destArr.push(['M', bbox.x + bbox.width / 2, bbox.y + bbox.height / 2]) - 1;
            }
          }

          // handle block from M to next M
          var result = handleBlock(startArr, startOffsetM, startOffsetNextM, destArr, destOffsetM, destOffsetNextM);

          // update the arrays to their new values
          startArr = startArr.slice(0, startOffsetM).concat(result.start, startOffsetNextM === false ? [] : startArr.slice(startOffsetNextM));
          destArr = destArr.slice(0, destOffsetM).concat(result.dest, destOffsetNextM === false ? [] : destArr.slice(destOffsetNextM));

          // update offsets
          startOffsetM = startOffsetNextM === false ? false : startOffsetM + result.start.length;
          destOffsetM = destOffsetNextM === false ? false : destOffsetM + result.dest.length;
        }

        // copy back arrays
        this._array = startArr;
        this.destination = new PathArray();
        this.destination._array = destArr;
        var finalArr = this.fromArray(startArr.map(function (from, fromIndex) {
          var step = destArr[fromIndex].map(function (to, toIndex) {
            if (toIndex === 0) return to;
            return stepper.step(from[toIndex], destArr[fromIndex][toIndex], pos, context[fromIndex], context);
          });
          return step;
        }));
        return finalArr;
      }
    });

    // sorry for the long declaration
    // slices out one block (from M to M) and syncronize it so the types and length match
    function handleBlock() {
      var startArr = arguments.length > 0 && arguments[0] !== undefined$1 ? arguments[0] : [];
      var startOffsetM = arguments.length > 1 ? arguments[1] : undefined$1;
      var startOffsetNextM = arguments.length > 2 ? arguments[2] : undefined$1;
      var destArr = arguments.length > 3 ? arguments[3] : undefined$1;
      var destOffsetM = arguments.length > 4 ? arguments[4] : undefined$1;
      var destOffsetNextM = arguments.length > 5 ? arguments[5] : undefined$1;
      var undefined$1 = arguments.length > 6 ? arguments[6] : undefined$1;
      // slice out the block we need
      var startArrTemp = startArr.slice(startOffsetM, startOffsetNextM || undefined$1),
        destArrTemp = destArr.slice(destOffsetM, destOffsetNextM || undefined$1);
      var i = 0,
        posStart = {
          pos: [0, 0],
          start: [0, 0]
        },
        posDest = {
          pos: [0, 0],
          start: [0, 0]
        };
      do {
        // convert shorthand types to long form
        startArrTemp[i] = simplyfy.call(posStart, startArrTemp[i]);
        destArrTemp[i] = simplyfy.call(posDest, destArrTemp[i]);

        // check if both shape types match
        // 2 elliptical arc curve commands ('A'), are considered different if the
        // flags (large-arc-flag, sweep-flag) don't match
        if (startArrTemp[i][0] != destArrTemp[i][0] || startArrTemp[i][0] == 'M' || startArrTemp[i][0] == 'A' && (startArrTemp[i][4] != destArrTemp[i][4] || startArrTemp[i][5] != destArrTemp[i][5])) {
          // if not, convert shapes to beziere
          Array.prototype.splice.apply(startArrTemp, [i, 1].concat(toBeziere.call(posStart, startArrTemp[i])));
          Array.prototype.splice.apply(destArrTemp, [i, 1].concat(toBeziere.call(posDest, destArrTemp[i])));
        } else {
          // only update positions otherwise
          startArrTemp[i] = setPosAndReflection.call(posStart, startArrTemp[i]);
          destArrTemp[i] = setPosAndReflection.call(posDest, destArrTemp[i]);
        }

        // we are at the end at both arrays. stop here
        if (++i == startArrTemp.length && i == destArrTemp.length) break;

        // destArray is longer. Add one element
        if (i == startArrTemp.length) {
          startArrTemp.push(['C', posStart.pos[0], posStart.pos[1], posStart.pos[0], posStart.pos[1], posStart.pos[0], posStart.pos[1]]);
        }

        // startArr is longer. Add one element
        if (i == destArrTemp.length) {
          destArrTemp.push(['C', posDest.pos[0], posDest.pos[1], posDest.pos[0], posDest.pos[1], posDest.pos[0], posDest.pos[1]]);
        }
      } while (true);

      // return the updated block
      return {
        start: startArrTemp,
        dest: destArrTemp
      };
    }

    // converts shorthand types to long form
    function simplyfy(val) {
      switch (val[0]) {
        case 'z': // shorthand line to start
        case 'Z':
          val[0] = 'L';
          val[1] = this.start[0];
          val[2] = this.start[1];
          break;
        case 'H':
          // shorthand horizontal line
          val[0] = 'L';
          val[2] = this.pos[1];
          break;
        case 'V':
          // shorthand vertical line
          val[0] = 'L';
          val[2] = val[1];
          val[1] = this.pos[0];
          break;
        case 'T':
          // shorthand quadratic beziere
          val[0] = 'Q';
          val[3] = val[1];
          val[4] = val[2];
          val[1] = this.reflection[1];
          val[2] = this.reflection[0];
          break;
        case 'S':
          // shorthand cubic beziere
          val[0] = 'C';
          val[6] = val[4];
          val[5] = val[3];
          val[4] = val[2];
          val[3] = val[1];
          val[2] = this.reflection[1];
          val[1] = this.reflection[0];
          break;
      }
      return val;
    }

    // updates reflection point and current position
    function setPosAndReflection(val) {
      var len = val.length;
      this.pos = [val[len - 2], val[len - 1]];
      if ('SCQT'.indexOf(val[0]) != -1) this.reflection = [2 * this.pos[0] - val[len - 4], 2 * this.pos[1] - val[len - 3]];
      return val;
    }

    // converts all types to cubic beziere
    function toBeziere(val) {
      var retVal = [val];
      switch (val[0]) {
        case 'M':
          // special handling for M
          this.pos = this.start = [val[1], val[2]];
          return retVal;
        case 'L':
          val[5] = val[3] = val[1];
          val[6] = val[4] = val[2];
          val[1] = this.pos[0];
          val[2] = this.pos[1];
          break;
        case 'Q':
          val[6] = val[4];
          val[5] = val[3];
          val[4] = val[4] * 1 / 3 + val[2] * 2 / 3;
          val[3] = val[3] * 1 / 3 + val[1] * 2 / 3;
          val[2] = this.pos[1] * 1 / 3 + val[2] * 2 / 3;
          val[1] = this.pos[0] * 1 / 3 + val[1] * 2 / 3;
          break;
        case 'A':
          retVal = arcToBeziere(this.pos, val);
          val = retVal[0];
          break;
      }
      val[0] = 'C';
      this.pos = [val[5], val[6]];
      this.reflection = [2 * val[5] - val[3], 2 * val[6] - val[4]];
      return retVal;
    }

    // finds the next position of type M
    function findNextM() {
      var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 ? arguments[1] : undefined;
      if (offset === false) return false;
      for (var i = offset, len = arr.length; i < len; ++i) {
        if (arr[i][0] == 'M') return i;
      }
      return false;
    }

    // Convert an arc segment into equivalent cubic Bezier curves
    // Depending on the arc, up to 4 curves might be used to represent it since a
    // curve gives a good approximation for only a quarter of an ellipse
    // The curves are returned as an array of SVG curve commands:
    // [ ['C', x1, y1, x2, y2, x, y] ... ]
    function arcToBeziere(pos, val) {
      // Parameters extraction, handle out-of-range parameters as specified in the SVG spec
      // See: https://www.w3.org/TR/SVG11/implnote.html#ArcOutOfRangeParameters
      var rx = Math.abs(val[1]),
        ry = Math.abs(val[2]),
        xAxisRotation = val[3] % 360,
        largeArcFlag = val[4],
        sweepFlag = val[5],
        x = val[6],
        y = val[7],
        A = new Point(pos),
        B = new Point(x, y),
        primedCoord,
        lambda,
        mat,
        k,
        c,
        cSquare,
        t,
        O,
        OA,
        OB,
        tetaStart,
        tetaEnd,
        deltaTeta,
        nbSectors,
        f,
        arcSegPoints,
        angle,
        sinAngle,
        cosAngle,
        pt,
        i,
        il,
        retVal = [],
        x1,
        y1,
        x2,
        y2;

      // Ensure radii are non-zero
      if (rx === 0 || ry === 0 || A.x === B.x && A.y === B.y) {
        // treat this arc as a straight line segment
        return [['C', A.x, A.y, B.x, B.y, B.x, B.y]];
      }

      // Ensure radii are large enough using the algorithm provided in the SVG spec
      // See: https://www.w3.org/TR/SVG11/implnote.html#ArcCorrectionOutOfRangeRadii
      primedCoord = new Point((A.x - B.x) / 2, (A.y - B.y) / 2).transform(new Matrix().rotate(xAxisRotation));
      lambda = primedCoord.x * primedCoord.x / (rx * rx) + primedCoord.y * primedCoord.y / (ry * ry);
      if (lambda > 1) {
        lambda = Math.sqrt(lambda);
        rx = lambda * rx;
        ry = lambda * ry;
      }

      // To simplify calculations, we make the arc part of a unit circle (rayon is 1) instead of an ellipse
      mat = new Matrix().rotate(xAxisRotation).scale(1 / rx, 1 / ry).rotate(-xAxisRotation);
      A = A.transform(mat);
      B = B.transform(mat);

      // Calculate the horizontal and vertical distance between the initial and final point of the arc
      k = [B.x - A.x, B.y - A.y];

      // Find the length of the chord formed by A and B
      cSquare = k[0] * k[0] + k[1] * k[1];
      c = Math.sqrt(cSquare);

      // Calculate the ratios of the horizontal and vertical distance on the length of the chord
      k[0] /= c;
      k[1] /= c;

      // Calculate the distance between the circle center and the chord midpoint
      // using this formula: t = sqrt(r^2 - c^2 / 4)
      // where t is the distance between the cirle center and the chord midpoint,
      //       r is the rayon of the circle and c is the chord length
      // From: http://www.ajdesigner.com/phpcircle/circle_segment_chord_t.php
      // Because of the imprecision of floating point numbers, cSquare might end
      // up being slightly above 4 which would result in a negative radicand
      // To prevent that, a test is made before computing the square root
      t = cSquare < 4 ? Math.sqrt(1 - cSquare / 4) : 0;

      // For most situations, there are actually two different ellipses that
      // satisfy the constraints imposed by the points A and B, the radii rx and ry,
      // and the xAxisRotation
      // When the flags largeArcFlag and sweepFlag are equal, it means that the
      // second ellipse is used as a solution
      // See: https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
      if (largeArcFlag === sweepFlag) {
        t *= -1;
      }

      // Calculate the coordinates of the center of the circle from the midpoint of the chord
      // This is done by multiplying the ratios calculated previously by the distance between
      // the circle center and the chord midpoint and using these values to go from the midpoint
      // to the center of the circle
      // The negative of the vertical distance ratio is used to modify the x coordinate while
      // the horizontal distance ratio is used to modify the y coordinate
      // That is because the center of the circle is perpendicular to the chord and perpendicular
      // lines are negative reciprocals
      O = new Point((B.x + A.x) / 2 + t * -k[1], (B.y + A.y) / 2 + t * k[0]);
      // Move the center of the circle at the origin
      OA = new Point(A.x - O.x, A.y - O.y);
      OB = new Point(B.x - O.x, B.y - O.y);

      // Calculate the start and end angle
      tetaStart = Math.acos(OA.x / Math.sqrt(OA.x * OA.x + OA.y * OA.y));
      if (OA.y < 0) {
        tetaStart *= -1;
      }
      tetaEnd = Math.acos(OB.x / Math.sqrt(OB.x * OB.x + OB.y * OB.y));
      if (OB.y < 0) {
        tetaEnd *= -1;
      }

      // If sweep-flag is '1', then the arc will be drawn in a "positive-angle" direction,
      // make sure that the end angle is above the start angle
      if (sweepFlag && tetaStart > tetaEnd) {
        tetaEnd += 2 * Math.PI;
      }
      // If sweep-flag is '0', then the arc will be drawn in a "negative-angle" direction,
      // make sure that the end angle is below the start angle
      if (!sweepFlag && tetaStart < tetaEnd) {
        tetaEnd -= 2 * Math.PI;
      }

      // Find the number of Bezier curves that are required to represent the arc
      // A cubic Bezier curve gives a good enough approximation when representing at most a quarter of a circle
      nbSectors = Math.ceil(Math.abs(tetaStart - tetaEnd) * 2 / Math.PI);

      // Calculate the coordinates of the points of all the Bezier curves required to represent the arc
      // For an in-depth explanation of this part see: http://pomax.github.io/bezierinfo/#circles_cubic
      arcSegPoints = [];
      angle = tetaStart;
      deltaTeta = (tetaEnd - tetaStart) / nbSectors;
      f = 4 * Math.tan(deltaTeta / 4) / 3;
      for (i = 0; i <= nbSectors; i++) {
        // The <= is because a Bezier curve have a start and a endpoint
        cosAngle = Math.cos(angle);
        sinAngle = Math.sin(angle);
        pt = new Point(O.x + cosAngle, O.y + sinAngle);
        arcSegPoints[i] = [new Point(pt.x + f * sinAngle, pt.y - f * cosAngle), pt, new Point(pt.x - f * sinAngle, pt.y + f * cosAngle)];
        angle += deltaTeta;
      }

      // Remove the first control point of the first segment point and remove the second control point of the last segment point
      // These two control points are not used in the approximation of the arc, that is why they are removed
      arcSegPoints[0][0] = arcSegPoints[0][1].clone();
      arcSegPoints[arcSegPoints.length - 1][2] = arcSegPoints[arcSegPoints.length - 1][1].clone();

      // Revert the transformation that was applied to make the arc part of a unit circle instead of an ellipse
      mat = new Matrix().rotate(xAxisRotation).scale(rx, ry).rotate(-xAxisRotation);
      for (i = 0, il = arcSegPoints.length; i < il; i++) {
        arcSegPoints[i][0] = arcSegPoints[i][0].transform(mat);
        arcSegPoints[i][1] = arcSegPoints[i][1].transform(mat);
        arcSegPoints[i][2] = arcSegPoints[i][2].transform(mat);
      }

      // Convert the segments points to SVG curve commands
      for (i = 1, il = arcSegPoints.length; i < il; i++) {
        pt = arcSegPoints[i - 1][2];
        x1 = pt.x;
        y1 = pt.y;
        pt = arcSegPoints[i][0];
        x2 = pt.x;
        y2 = pt.y;
        pt = arcSegPoints[i][1];
        x = pt.x;
        y = pt.y;
        retVal.push(['C', x1, y1, x2, y2, x, y]);
      }
      return retVal;
    }
  })();

  const getCoordsFromEvent$1 = (ev) => {
    if (ev.changedTouches) {
      ev = ev.changedTouches[0];
    }
    return { x: ev.clientX, y: ev.clientY }
  };

  // Creates handler, saves it
  class DragHandler {
    constructor(el) {
      el.remember('_draggable', this);
      this.el = el;

      this.drag = this.drag.bind(this);
      this.startDrag = this.startDrag.bind(this);
      this.endDrag = this.endDrag.bind(this);
    }

    // Enables or disabled drag based on input
    init(enabled) {
      if (enabled) {
        this.el.on('mousedown.drag', this.startDrag);
        this.el.on('touchstart.drag', this.startDrag, { passive: false });
      } else {
        this.el.off('mousedown.drag');
        this.el.off('touchstart.drag');
      }
    }

    // Start dragging
    startDrag(ev) {
      const isMouse = !ev.type.indexOf('mouse');

      // Check for left button
      if (isMouse && ev.which !== 1 && ev.buttons !== 0) {
        return
      }

      // Fire beforedrag event
      if (
        this.el.dispatch('beforedrag', { event: ev, handler: this })
          .defaultPrevented
      ) {
        return
      }

      // Prevent browser drag behavior as soon as possible
      ev.preventDefault();

      // Prevent propagation to a parent that might also have dragging enabled
      ev.stopPropagation();

      // Make sure that start events are unbound so that one element
      // is only dragged by one input only
      this.init(false);

      this.box = this.el.bbox();
      this.lastClick = this.el.point(getCoordsFromEvent$1(ev));

      const eventMove = (isMouse ? 'mousemove' : 'touchmove') + '.drag';
      const eventEnd = (isMouse ? 'mouseup' : 'touchend') + '.drag';

      // Bind drag and end events to window
      on(window, eventMove, this.drag, this, { passive: false });
      on(window, eventEnd, this.endDrag, this, { passive: false });

      // Fire dragstart event
      this.el.fire('dragstart', { event: ev, handler: this, box: this.box });
    }

    // While dragging
    drag(ev) {
      const { box, lastClick } = this;

      const currentClick = this.el.point(getCoordsFromEvent$1(ev));
      const dx = currentClick.x - lastClick.x;
      const dy = currentClick.y - lastClick.y;

      if (!dx && !dy) return box

      const x = box.x + dx;
      const y = box.y + dy;
      this.box = new Box(x, y, box.w, box.h);
      this.lastClick = currentClick;

      if (
        this.el.dispatch('dragmove', {
          event: ev,
          handler: this,
          box: this.box,
        }).defaultPrevented
      ) {
        return
      }

      this.move(x, y);
    }

    move(x, y) {
      // Svg elements bbox depends on their content even though they have
      // x, y, width and height - strange!
      // Thats why we handle them the same as groups
      if (this.el.type === 'svg') {
        G.prototype.move.call(this.el, x, y);
      } else {
        this.el.move(x, y);
      }
    }

    endDrag(ev) {
      // final drag
      this.drag(ev);

      // fire dragend event
      this.el.fire('dragend', { event: ev, handler: this, box: this.box });

      // unbind events
      off(window, 'mousemove.drag');
      off(window, 'touchmove.drag');
      off(window, 'mouseup.drag');
      off(window, 'touchend.drag');

      // Rebind initial Events
      this.init(true);
    }
  }

  extend(Element$1, {
    draggable(enable = true) {
      const dragHandler = this.remember('_draggable') || new DragHandler(this);
      dragHandler.init(enable);
      return this
    },
  });

  /*!
  * @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
  * @version 4.0.1
  * https://github.com/svgdotjs/svg.select.js
  *
  * @copyright Ulrich-Matthias Schfer
  * @license MIT
  *
  * BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
  */
  function getMoseDownFunc$1(eventName, el, points, index = null) {
    return function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      var x = ev.pageX || ev.touches[0].pageX;
      var y = ev.pageY || ev.touches[0].pageY;
      el.fire(eventName, { x, y, event: ev, index, points });
    };
  }
  function transformPoint$1([x, y], { a, b, c, d, e, f }) {
    return [x * a + y * c + e, x * b + y * d + f];
  }
  let SelectHandler$1 = class SelectHandler {
    constructor(el) {
      this.el = el;
      el.remember("_selectHandler", this);
      this.selection = new G();
      this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"];
      this.mutationHandler = this.mutationHandler.bind(this);
      const win = getWindow();
      this.observer = new win.MutationObserver(this.mutationHandler);
    }
    init(options) {
      this.createHandle = options.createHandle || this.createHandleFn;
      this.createRot = options.createRot || this.createRotFn;
      this.updateHandle = options.updateHandle || this.updateHandleFn;
      this.updateRot = options.updateRot || this.updateRotFn;
      this.el.root().put(this.selection);
      this.updatePoints();
      this.createSelection();
      this.createResizeHandles();
      this.updateResizeHandles();
      this.createRotationHandle();
      this.updateRotationHandle();
      this.observer.observe(this.el.node, { attributes: true });
    }
    active(val, options) {
      if (!val) {
        this.selection.clear().remove();
        this.observer.disconnect();
        return;
      }
      this.init(options);
    }
    createSelection() {
      this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
    }
    updateSelection() {
      this.selection.get(0).plot(this.handlePoints);
    }
    createResizeHandles() {
      this.handlePoints.forEach((p, index, arr) => {
        const name = this.order[index];
        this.createHandle.call(this, this.selection, p, index, arr, name);
        this.selection.get(index + 1).addClass("svg_select_handle svg_select_handle_" + name).on("mousedown.selection touchstart.selection", getMoseDownFunc$1(name, this.el, this.handlePoints, index));
      });
    }
    createHandleFn(group) {
      group.polyline();
    }
    updateHandleFn(shape, point, index, arr) {
      const before = arr.at(index - 1);
      const next = arr[(index + 1) % arr.length];
      const p = point;
      const diff1 = [p[0] - before[0], p[1] - before[1]];
      const diff2 = [p[0] - next[0], p[1] - next[1]];
      const len1 = Math.sqrt(diff1[0] * diff1[0] + diff1[1] * diff1[1]);
      const len2 = Math.sqrt(diff2[0] * diff2[0] + diff2[1] * diff2[1]);
      const normalized1 = [diff1[0] / len1, diff1[1] / len1];
      const normalized2 = [diff2[0] / len2, diff2[1] / len2];
      const beforeNew = [p[0] - normalized1[0] * 10, p[1] - normalized1[1] * 10];
      const nextNew = [p[0] - normalized2[0] * 10, p[1] - normalized2[1] * 10];
      shape.plot([beforeNew, p, nextNew]);
    }
    updateResizeHandles() {
      this.handlePoints.forEach((p, index, arr) => {
        const name = this.order[index];
        this.updateHandle.call(this, this.selection.get(index + 1), p, index, arr, name);
      });
    }
    createRotFn(group) {
      group.line();
      group.circle(5);
    }
    getPoint(name) {
      return this.handlePoints[this.order.indexOf(name)];
    }
    getPointHandle(name) {
      return this.selection.get(this.order.indexOf(name) + 1);
    }
    updateRotFn(group, rotPoint) {
      const topPoint = this.getPoint("t");
      group.get(0).plot(topPoint[0], topPoint[1], rotPoint[0], rotPoint[1]);
      group.get(1).center(rotPoint[0], rotPoint[1]);
    }
    createRotationHandle() {
      const handle = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", getMoseDownFunc$1("rot", this.el, this.handlePoints));
      this.createRot.call(this, handle);
    }
    updateRotationHandle() {
      const group = this.selection.findOne("g.svg_select_handle_rot");
      this.updateRot(group, this.rotationPoint, this.handlePoints);
    }
    // gets new bounding box points and transform them into the elements space
    updatePoints() {
      const bbox = this.el.bbox();
      const fromShapeToUiMatrix = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
      this.handlePoints = this.getHandlePoints(bbox).map((p) => transformPoint$1(p, fromShapeToUiMatrix));
      this.rotationPoint = transformPoint$1(this.getRotationPoint(bbox), fromShapeToUiMatrix);
    }
    // A collection of all the points we need to draw our ui
    getHandlePoints({ x, x2, y, y2, cx, cy } = this.el.bbox()) {
      return [
        [x, y],
        [cx, y],
        [x2, y],
        [x2, cy],
        [x2, y2],
        [cx, y2],
        [x, y2],
        [x, cy]
      ];
    }
    // A collection of all the points we need to draw our ui
    getRotationPoint({ y, cx } = this.el.bbox()) {
      return [cx, y - 20];
    }
    mutationHandler() {
      this.updatePoints();
      this.updateSelection();
      this.updateResizeHandles();
      this.updateRotationHandle();
    }
  };
  let PointSelectHandler$1 = class PointSelectHandler {
    constructor(el) {
      this.el = el;
      el.remember("_pointSelectHandler", this);
      this.selection = new G();
      this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"];
      this.mutationHandler = this.mutationHandler.bind(this);
      const win = getWindow();
      this.observer = new win.MutationObserver(this.mutationHandler);
    }
    init(options) {
      this.createHandle = options.createHandle || this.createHandleFn;
      this.updateHandle = options.updateHandle || this.updateHandleFn;
      this.el.root().put(this.selection);
      this.updatePoints();
      this.createSelection();
      this.createPointHandles();
      this.updatePointHandles();
      this.observer.observe(this.el.node, { attributes: true });
    }
    active(val, options) {
      if (!val) {
        this.selection.clear().remove();
        this.observer.disconnect();
        return;
      }
      this.init(options);
    }
    createSelection() {
      this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
    }
    updateSelection() {
      this.selection.get(0).plot(this.points);
    }
    createPointHandles() {
      this.points.forEach((p, index, arr) => {
        this.createHandle.call(this, this.selection, p, index, arr);
        this.selection.get(index + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", getMoseDownFunc$1("point", this.el, this.points, index));
      });
    }
    createHandleFn(group) {
      group.circle(5);
    }
    updateHandleFn(shape, point) {
      shape.center(point[0], point[1]);
    }
    updatePointHandles() {
      this.points.forEach((p, index, arr) => {
        this.updateHandle.call(this, this.selection.get(index + 1), p, index, arr);
      });
    }
    // gets new bounding box points and transform them into the elements space
    updatePoints() {
      const fromShapeToUiMatrix = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
      this.points = this.el.array().map((p) => transformPoint$1(p, fromShapeToUiMatrix));
    }
    mutationHandler() {
      this.updatePoints();
      this.updateSelection();
      this.updatePointHandles();
    }
  };
  const getSelectFn$1 = (handleClass) => {
    return function(enabled = true, options = {}) {
      if (typeof enabled === "object") {
        options = enabled;
        enabled = true;
      }
      let selectHandler = this.remember("_" + handleClass.name);
      if (!selectHandler) {
        if (enabled.prototype instanceof SelectHandler$1) {
          selectHandler = new enabled(this);
          enabled = true;
        } else {
          selectHandler = new handleClass(this);
        }
        this.remember("_" + handleClass.name, selectHandler);
      }
      selectHandler.active(enabled, options);
      return this;
    };
  };
  extend(Element$1, {
    select: getSelectFn$1(SelectHandler$1)
  });
  extend([Polygon, Polyline, Line$1], {
    pointSelect: getSelectFn$1(PointSelectHandler$1)
  });

  /*!
  * @svgdotjs/svg.resize.js - An extension for svg.js which allows to resize elements which are selected
  * @version 2.0.2
  * https://github.com/svgdotjs/svg.resize.js
  *
  * @copyright [object Object]
  * @license MIT
  *
  * BUILT: Mon Jul 01 2024 15:05:58 GMT+0200 (Central European Summer Time)
  */
  /*!
  * @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
  * @version 4.0.1
  * https://github.com/svgdotjs/svg.select.js
  *
  * @copyright Ulrich-Matthias Schfer
  * @license MIT
  *
  * BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
  */
  function getMoseDownFunc(eventName, el, points, index = null) {
    return function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      var x = ev.pageX || ev.touches[0].pageX;
      var y = ev.pageY || ev.touches[0].pageY;
      el.fire(eventName, { x, y, event: ev, index, points });
    };
  }
  function transformPoint([x, y], { a, b, c, d, e, f }) {
    return [x * a + y * c + e, x * b + y * d + f];
  }
  class SelectHandler {
    constructor(el) {
      this.el = el;
      el.remember("_selectHandler", this);
      this.selection = new G();
      this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"];
      this.mutationHandler = this.mutationHandler.bind(this);
      const win = getWindow();
      this.observer = new win.MutationObserver(this.mutationHandler);
    }
    init(options) {
      this.createHandle = options.createHandle || this.createHandleFn;
      this.createRot = options.createRot || this.createRotFn;
      this.updateHandle = options.updateHandle || this.updateHandleFn;
      this.updateRot = options.updateRot || this.updateRotFn;
      this.el.root().put(this.selection);
      this.updatePoints();
      this.createSelection();
      this.createResizeHandles();
      this.updateResizeHandles();
      this.createRotationHandle();
      this.updateRotationHandle();
      this.observer.observe(this.el.node, { attributes: true });
    }
    active(val, options) {
      if (!val) {
        this.selection.clear().remove();
        this.observer.disconnect();
        return;
      }
      this.init(options);
    }
    createSelection() {
      this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
    }
    updateSelection() {
      this.selection.get(0).plot(this.handlePoints);
    }
    createResizeHandles() {
      this.handlePoints.forEach((p, index, arr) => {
        const name = this.order[index];
        this.createHandle.call(this, this.selection, p, index, arr, name);
        this.selection.get(index + 1).addClass("svg_select_handle svg_select_handle_" + name).on("mousedown.selection touchstart.selection", getMoseDownFunc(name, this.el, this.handlePoints, index));
      });
    }
    createHandleFn(group) {
      group.polyline();
    }
    updateHandleFn(shape, point, index, arr) {
      const before = arr.at(index - 1);
      const next = arr[(index + 1) % arr.length];
      const p = point;
      const diff1 = [p[0] - before[0], p[1] - before[1]];
      const diff2 = [p[0] - next[0], p[1] - next[1]];
      const len1 = Math.sqrt(diff1[0] * diff1[0] + diff1[1] * diff1[1]);
      const len2 = Math.sqrt(diff2[0] * diff2[0] + diff2[1] * diff2[1]);
      const normalized1 = [diff1[0] / len1, diff1[1] / len1];
      const normalized2 = [diff2[0] / len2, diff2[1] / len2];
      const beforeNew = [p[0] - normalized1[0] * 10, p[1] - normalized1[1] * 10];
      const nextNew = [p[0] - normalized2[0] * 10, p[1] - normalized2[1] * 10];
      shape.plot([beforeNew, p, nextNew]);
    }
    updateResizeHandles() {
      this.handlePoints.forEach((p, index, arr) => {
        const name = this.order[index];
        this.updateHandle.call(this, this.selection.get(index + 1), p, index, arr, name);
      });
    }
    createRotFn(group) {
      group.line();
      group.circle(5);
    }
    getPoint(name) {
      return this.handlePoints[this.order.indexOf(name)];
    }
    getPointHandle(name) {
      return this.selection.get(this.order.indexOf(name) + 1);
    }
    updateRotFn(group, rotPoint) {
      const topPoint = this.getPoint("t");
      group.get(0).plot(topPoint[0], topPoint[1], rotPoint[0], rotPoint[1]);
      group.get(1).center(rotPoint[0], rotPoint[1]);
    }
    createRotationHandle() {
      const handle = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", getMoseDownFunc("rot", this.el, this.handlePoints));
      this.createRot.call(this, handle);
    }
    updateRotationHandle() {
      const group = this.selection.findOne("g.svg_select_handle_rot");
      this.updateRot(group, this.rotationPoint, this.handlePoints);
    }
    // gets new bounding box points and transform them into the elements space
    updatePoints() {
      const bbox = this.el.bbox();
      const fromShapeToUiMatrix = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
      this.handlePoints = this.getHandlePoints(bbox).map((p) => transformPoint(p, fromShapeToUiMatrix));
      this.rotationPoint = transformPoint(this.getRotationPoint(bbox), fromShapeToUiMatrix);
    }
    // A collection of all the points we need to draw our ui
    getHandlePoints({ x, x2, y, y2, cx, cy } = this.el.bbox()) {
      return [
        [x, y],
        [cx, y],
        [x2, y],
        [x2, cy],
        [x2, y2],
        [cx, y2],
        [x, y2],
        [x, cy]
      ];
    }
    // A collection of all the points we need to draw our ui
    getRotationPoint({ y, cx } = this.el.bbox()) {
      return [cx, y - 20];
    }
    mutationHandler() {
      this.updatePoints();
      this.updateSelection();
      this.updateResizeHandles();
      this.updateRotationHandle();
    }
  }
  class PointSelectHandler {
    constructor(el) {
      this.el = el;
      el.remember("_pointSelectHandler", this);
      this.selection = new G();
      this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"];
      this.mutationHandler = this.mutationHandler.bind(this);
      const win = getWindow();
      this.observer = new win.MutationObserver(this.mutationHandler);
    }
    init(options) {
      this.createHandle = options.createHandle || this.createHandleFn;
      this.updateHandle = options.updateHandle || this.updateHandleFn;
      this.el.root().put(this.selection);
      this.updatePoints();
      this.createSelection();
      this.createPointHandles();
      this.updatePointHandles();
      this.observer.observe(this.el.node, { attributes: true });
    }
    active(val, options) {
      if (!val) {
        this.selection.clear().remove();
        this.observer.disconnect();
        return;
      }
      this.init(options);
    }
    createSelection() {
      this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
    }
    updateSelection() {
      this.selection.get(0).plot(this.points);
    }
    createPointHandles() {
      this.points.forEach((p, index, arr) => {
        this.createHandle.call(this, this.selection, p, index, arr);
        this.selection.get(index + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", getMoseDownFunc("point", this.el, this.points, index));
      });
    }
    createHandleFn(group) {
      group.circle(5);
    }
    updateHandleFn(shape, point) {
      shape.center(point[0], point[1]);
    }
    updatePointHandles() {
      this.points.forEach((p, index, arr) => {
        this.updateHandle.call(this, this.selection.get(index + 1), p, index, arr);
      });
    }
    // gets new bounding box points and transform them into the elements space
    updatePoints() {
      const fromShapeToUiMatrix = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
      this.points = this.el.array().map((p) => transformPoint(p, fromShapeToUiMatrix));
    }
    mutationHandler() {
      this.updatePoints();
      this.updateSelection();
      this.updatePointHandles();
    }
  }
  const getSelectFn = (handleClass) => {
    return function(enabled = true, options = {}) {
      if (typeof enabled === "object") {
        options = enabled;
        enabled = true;
      }
      let selectHandler = this.remember("_" + handleClass.name);
      if (!selectHandler) {
        if (enabled.prototype instanceof SelectHandler) {
          selectHandler = new enabled(this);
          enabled = true;
        } else {
          selectHandler = new handleClass(this);
        }
        this.remember("_" + handleClass.name, selectHandler);
      }
      selectHandler.active(enabled, options);
      return this;
    };
  };
  extend(Element$1, {
    select: getSelectFn(SelectHandler)
  });
  extend([Polygon, Polyline, Line$1], {
    pointSelect: getSelectFn(PointSelectHandler)
  });
  const getCoordsFromEvent = (ev) => {
    if (ev.changedTouches) {
      ev = ev.changedTouches[0];
    }
    return { x: ev.clientX, y: ev.clientY };
  };
  const maxBoxFromPoints = (points) => {
    let x = Infinity;
    let y = Infinity;
    let x2 = -Infinity;
    let y2 = -Infinity;
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      x = Math.min(x, p[0]);
      y = Math.min(y, p[1]);
      x2 = Math.max(x2, p[0]);
      y2 = Math.max(y2, p[1]);
    }
    return new Box(x, y, x2 - x, y2 - y);
  };
  function scaleBox(box, origin, scale) {
    const points = [
      [box.x, box.y],
      [box.x + box.width, box.y],
      [box.x + box.width, box.y + box.height],
      [box.x, box.y + box.height]
    ];
    const newPoints = points.map(([x, y]) => {
      const translatedX = x - origin[0];
      const translatedY = y - origin[1];
      const scaledX = translatedX * scale;
      const scaledY = translatedY * scale;
      return [scaledX + origin[0], scaledY + origin[1]];
    });
    return maxBoxFromPoints(newPoints);
  }
  class ResizeHandler {
    constructor(el) {
      this.el = el;
      el.remember("_ResizeHandler", this);
      this.lastCoordinates = null;
      this.eventType = "";
      this.lastEvent = null;
      this.angle = 0;
      this.handleResize = this.handleResize.bind(this);
      this.resize = this.resize.bind(this);
      this.endResize = this.endResize.bind(this);
      this.rotate = this.rotate.bind(this);
      this.movePoint = this.movePoint.bind(this);
    }
    active(value, options) {
      this.preserveAspectRatio = options.preserveAspectRatio ?? false;
      this.aroundCenter = options.aroundCenter ?? false;
      this.grid = options.grid ?? 0;
      this.degree = options.degree ?? 0;
      this.el.off(".resize");
      if (!value) return;
      this.el.on(
        [
          "lt.resize",
          "rt.resize",
          "rb.resize",
          "lb.resize",
          "t.resize",
          "r.resize",
          "b.resize",
          "l.resize",
          "rot.resize",
          "point.resize"
        ],
        this.handleResize
      );
      if (this.lastEvent) {
        if (this.eventType === "rot") {
          this.rotate(this.lastEvent);
        } else if (this.eventType === "point") {
          this.movePoint(this.lastEvent);
        } else {
          this.resize(this.lastEvent);
        }
      }
    }
    // This is called when a user clicks on one of the resize points
    handleResize(e) {
      this.eventType = e.type;
      const { event, index, points } = e.detail;
      const isMouse = !event.type.indexOf("mouse");
      if (isMouse && (event.which || event.buttons) !== 1) {
        return;
      }
      if (this.el.dispatch("beforeresize", { event: e, handler: this }).defaultPrevented) {
        return;
      }
      this.box = this.el.bbox();
      this.startPoint = this.el.point(getCoordsFromEvent(event));
      this.index = index;
      this.points = points.slice();
      const eventMove = (isMouse ? "mousemove" : "touchmove") + ".resize";
      const eventEnd = (isMouse ? "mouseup" : "touchcancel.resize touchend") + ".resize";
      if (e.type === "point") {
        on(window, eventMove, this.movePoint);
      } else if (e.type === "rot") {
        on(window, eventMove, this.rotate);
      } else {
        on(window, eventMove, this.resize);
      }
      on(window, eventEnd, this.endResize);
    }
    resize(e) {
      this.lastEvent = e;
      const endPoint = this.snapToGrid(this.el.point(getCoordsFromEvent(e)));
      let dx = endPoint.x - this.startPoint.x;
      let dy = endPoint.y - this.startPoint.y;
      console.log("endPoint", endPoint, "startPoint", this.startPoint, dx, dy);
      if (this.preserveAspectRatio && this.aroundCenter) {
        dx *= 2;
        dy *= 2;
      }
      const x = this.box.x + dx;
      const y = this.box.y + dy;
      const x2 = this.box.x2 + dx;
      const y2 = this.box.y2 + dy;
      let box = new Box(this.box);
      if (this.eventType.includes("l")) {
        box.x = Math.min(x, this.box.x2);
        box.x2 = Math.max(x, this.box.x2);
      }
      if (this.eventType.includes("r")) {
        box.x = Math.min(x2, this.box.x);
        box.x2 = Math.max(x2, this.box.x);
      }
      if (this.eventType.includes("t")) {
        box.y = Math.min(y, this.box.y2);
        box.y2 = Math.max(y, this.box.y2);
      }
      if (this.eventType.includes("b")) {
        box.y = Math.min(y2, this.box.y);
        box.y2 = Math.max(y2, this.box.y);
      }
      box.width = box.x2 - box.x;
      box.height = box.y2 - box.y;
      if (this.preserveAspectRatio) {
        const scaleX = box.width / this.box.width;
        const scaleY = box.height / this.box.height;
        const order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l"];
        const origin = (order.indexOf(this.eventType) + 4) % order.length;
        const constantPoint = this.aroundCenter ? [this.box.cx, this.box.cy] : this.points[origin];
        let scale = this.eventType.includes("t") || this.eventType.includes("b") ? scaleY : scaleX;
        scale = this.eventType.length === 2 ? Math.max(scaleX, scaleY) : scale;
        box = scaleBox(this.box, constantPoint, scale);
      }
      if (this.el.dispatch("resize", {
        box: new Box(box),
        angle: 0,
        eventType: this.eventType,
        event: e,
        handler: this
      }).defaultPrevented) {
        return;
      }
      this.el.move(box.x, box.y).size(box.width, box.height);
    }
    movePoint(e) {
      this.lastEvent = e;
      const { x, y } = this.snapToGrid(this.el.point(getCoordsFromEvent(e)));
      const pointArr = this.el.array().slice();
      pointArr[this.index] = [x, y];
      if (this.el.dispatch("resize", {
        box: maxBoxFromPoints(pointArr),
        angle: 0,
        eventType: this.eventType,
        event: e,
        handler: this
      }).defaultPrevented) {
        return;
      }
      this.el.plot(pointArr);
    }
    rotate(e) {
      this.lastEvent = e;
      const endPoint = this.el.point(getCoordsFromEvent(e));
      const cx = this.box.cx;
      const cy = this.box.cy;
      const dx1 = this.startPoint.x - cx;
      const dy1 = this.startPoint.y - cy;
      const dx2 = endPoint.x - cx;
      const dy2 = endPoint.y - cy;
      const c = Math.sqrt(dx1 * dx1 + dy1 * dy1) * Math.sqrt(dx2 * dx2 + dy2 * dy2);
      if (c === 0) {
        return;
      }
      let angle = Math.acos((dx1 * dx2 + dy1 * dy2) / c) / Math.PI * 180;
      if (endPoint.x < this.startPoint.x) {
        angle = -angle;
      }
      this.angle = this.snapToAngle(this.angle + angle);
      if (this.el.dispatch("resize", {
        box: this.startBox,
        angle: this.angle,
        eventType: this.eventType,
        event: e,
        handler: this
      }).defaultPrevented) {
        return;
      }
      this.el.transform({ rotate: this.angle });
    }
    endResize(ev) {
      if (this.eventType !== "rot" && this.eventType !== "point") {
        this.resize(ev);
      }
      this.lastEvent = null;
      this.eventType = "";
      off(window, "mousemove.resize touchmove.resize");
      off(window, "mouseup.resize touchend.resize");
    }
    snapToGrid(point) {
      if (this.grid) {
        point.x = Math.round(point.x / this.grid) * this.grid;
        point.y = Math.round(point.y / this.grid) * this.grid;
      }
      return point;
    }
    snapToAngle(angle) {
      if (this.degree) {
        angle = Math.round(angle / this.degree) * this.degree;
      }
      return angle;
    }
  }
  extend(Element$1, {
    // Resize element with mouse
    resize: function(enabled = true, options = {}) {
      if (typeof enabled === "object") {
        options = enabled;
        enabled = true;
      }
      let resizeHandler = this.remember("_ResizeHandler");
      if (!resizeHandler) {
        if (enabled.prototype instanceof ResizeHandler) {
          resizeHandler = new enabled(this);
          enabled = true;
        } else {
          resizeHandler = new ResizeHandler(this);
        }
        this.remember("_resizeHandler", resizeHandler);
      }
      resizeHandler.active(enabled, options);
      return this;
    }
  });

  if (typeof window.SVG === 'undefined') {
    window.SVG = SVG;
  }

  // global Apex object which user can use to override chart's defaults globally
  if (typeof window.Apex === 'undefined') {
    window.Apex = {};
  }
  var InitCtxVariables = /*#__PURE__*/function () {
    function InitCtxVariables(ctx) {
      _classCallCheck(this, InitCtxVariables);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(InitCtxVariables, [{
      key: "initModules",
      value: function initModules() {
        this.ctx.publicMethods = ['updateOptions', 'updateSeries', 'appendData', 'appendSeries', 'isSeriesHidden', 'highlightSeries', 'toggleSeries', 'showSeries', 'hideSeries', 'setLocale', 'resetSeries', 'zoomX', 'toggleDataPointSelection', 'dataURI', 'exportToCSV', 'addXaxisAnnotation', 'addYaxisAnnotation', 'addPointAnnotation', 'clearAnnotations', 'removeAnnotation', 'paper', 'destroy'];
        this.ctx.eventList = ['click', 'mousedown', 'mousemove', 'mouseleave', 'touchstart', 'touchmove', 'touchleave', 'mouseup', 'touchend'];
        this.ctx.animations = new Animations(this.ctx);
        this.ctx.axes = new Axes(this.ctx);
        this.ctx.core = new Core(this.ctx.el, this.ctx);
        this.ctx.config = new Config({});
        this.ctx.data = new Data(this.ctx);
        this.ctx.grid = new Grid(this.ctx);
        this.ctx.graphics = new Graphics(this.ctx);
        this.ctx.coreUtils = new CoreUtils(this.ctx);
        this.ctx.crosshairs = new Crosshairs(this.ctx);
        this.ctx.events = new Events(this.ctx);
        this.ctx.exports = new Exports(this.ctx);
        this.ctx.fill = new Fill(this.ctx);
        this.ctx.localization = new Localization(this.ctx);
        this.ctx.options = new Options();
        this.ctx.responsive = new Responsive(this.ctx);
        this.ctx.series = new Series(this.ctx);
        this.ctx.theme = new Theme(this.ctx);
        this.ctx.formatters = new Formatters(this.ctx);
        this.ctx.titleSubtitle = new TitleSubtitle(this.ctx);
        this.ctx.legend = new Legend(this.ctx);
        this.ctx.toolbar = new Toolbar(this.ctx);
        this.ctx.tooltip = new Tooltip(this.ctx);
        this.ctx.dimensions = new Dimensions(this.ctx);
        this.ctx.updateHelpers = new UpdateHelpers(this.ctx);
        this.ctx.zoomPanSelection = new ZoomPanSelection(this.ctx);
        this.ctx.w.globals.tooltip = new Tooltip(this.ctx);
      }
    }]);
    return InitCtxVariables;
  }();

  var Destroy = /*#__PURE__*/function () {
    function Destroy(ctx) {
      _classCallCheck(this, Destroy);
      this.ctx = ctx;
      this.w = ctx.w;
    }
    _createClass(Destroy, [{
      key: "clear",
      value: function clear(_ref) {
        var isUpdating = _ref.isUpdating;
        if (this.ctx.zoomPanSelection) {
          this.ctx.zoomPanSelection.destroy();
        }
        if (this.ctx.toolbar) {
          this.ctx.toolbar.destroy();
        }
        this.ctx.animations = null;
        this.ctx.axes = null;
        this.ctx.annotations = null;
        this.ctx.core = null;
        this.ctx.data = null;
        this.ctx.grid = null;
        this.ctx.series = null;
        this.ctx.responsive = null;
        this.ctx.theme = null;
        this.ctx.formatters = null;
        this.ctx.titleSubtitle = null;
        this.ctx.legend = null;
        this.ctx.dimensions = null;
        this.ctx.options = null;
        this.ctx.crosshairs = null;
        this.ctx.zoomPanSelection = null;
        this.ctx.updateHelpers = null;
        this.ctx.toolbar = null;
        this.ctx.localization = null;
        this.ctx.w.globals.tooltip = null;
        this.clearDomElements({
          isUpdating: isUpdating
        });
      }
    }, {
      key: "killSVG",
      value: function killSVG(draw) {
        draw.each(function () {
          this.removeClass('*');
          this.off();
          // this.stop()
        }, true);
        // draw.ungroup()
        draw.clear();
      }
    }, {
      key: "clearDomElements",
      value: function clearDomElements(_ref2) {
        var _this = this;
        var isUpdating = _ref2.isUpdating;
        var elSVG = this.w.globals.dom.Paper.node;
        // fixes apexcharts.js#1654 & vue-apexcharts#256
        if (elSVG.parentNode && elSVG.parentNode.parentNode && !isUpdating) {
          elSVG.parentNode.parentNode.style.minHeight = 'unset';
        }

        // detach root event
        var baseEl = this.w.globals.dom.baseEl;
        if (baseEl) {
          // see https://github.com/apexcharts/vue-apexcharts/issues/275
          this.ctx.eventList.forEach(function (event) {
            baseEl.removeEventListener(event, _this.ctx.events.documentEvent);
          });
        }
        var domEls = this.w.globals.dom;
        if (this.ctx.el !== null) {
          // remove all child elements - resetting the whole chart
          while (this.ctx.el.firstChild) {
            this.ctx.el.removeChild(this.ctx.el.firstChild);
          }
        }
        this.killSVG(domEls.Paper);
        domEls.Paper.remove();
        domEls.elWrap = null;
        domEls.elGraphical = null;
        domEls.elLegendWrap = null;
        domEls.elLegendForeign = null;
        domEls.baseEl = null;
        domEls.elGridRect = null;
        domEls.elGridRectMask = null;
        domEls.elGridRectBarMask = null;
        domEls.elGridRectMarkerMask = null;
        domEls.elForecastMask = null;
        domEls.elNonForecastMask = null;
        domEls.elDefs = null;
      }
    }]);
    return Destroy;
  }();

  // Helpers to react to element resizes, regardless of what caused them
  // TODO Currently this creates a new ResizeObserver every time we want to observe an element for resizes
  // Ideally, we should be able to use a single observer for all elements
  var ros = new WeakMap(); // Map callbacks to ResizeObserver instances for easy removal

  function addResizeListener(el, fn) {
    var called = false;
    if (el.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
      var elRect = el.getBoundingClientRect();
      if (el.style.display === 'none' || elRect.width === 0) {
        // if elRect.width=0, the chart is not rendered at all
        // (it has either display none or hidden in a different tab)
        // fixes https://github.com/apexcharts/apexcharts.js/issues/2825
        // fixes https://github.com/apexcharts/apexcharts.js/issues/2991
        // fixes https://github.com/apexcharts/apexcharts.js/issues/2992
        called = true;
      }
    }
    var ro = new ResizeObserver(function (r) {
      // ROs fire immediately after being created,
      // per spec: https://drafts.csswg.org/resize-observer/#ref-for-element%E2%91%A3
      // we don't want that so we just discard the first run
      if (called) {
        fn.call(el, r);
      }
      called = true;
    });
    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      // Document fragment, observe children instead (needed for Shadow DOM, see #1332)
      Array.from(el.children).forEach(function (c) {
        return ro.observe(c);
      });
    } else {
      ro.observe(el);
    }
    ros.set(fn, ro);
  }
  function removeResizeListener(el, fn) {
    var ro = ros.get(fn);
    if (ro) {
      ro.disconnect();
      ros.delete(fn);
    }
  }

  var css_248z = "@keyframes opaque {\n  0% {\n    opacity: 0\n  }\n\n  to {\n    opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n\n  0%,\n  to {\n    opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  direction: ltr !important;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\nrect.legend-mouseover-inactive,\n.legend-mouseover-inactive rect,\n.legend-mouseover-inactive path,\n.legend-mouseover-inactive circle,\n.legend-mouseover-inactive line,\n.legend-mouseover-inactive text.apexcharts-yaxis-title-text,\n.legend-mouseover-inactive text.apexcharts-yaxis-label {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, .96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, .8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, .7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-z-value:empty,\n.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  display: inline-block;\n  position: relative;\n  width: 16px;\n  height: 16px;\n  font-size: 16px;\n  line-height: 16px;\n  margin-right: 4px;\n  text-align: center;\n  vertical-align: middle;\n  color: inherit;\n}\n\n.apexcharts-tooltip-marker::before {\n  content: \"\";\n  display: inline-block;\n  width: 100%;\n  text-align: center;\n  color: currentcolor;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  font-size: 26px;\n  font-family: Arial, Helvetica, sans-serif;\n  line-height: 14px;\n  font-weight: 900;\n}\n\n.apexcharts-tooltip-marker[shape=\"circle\"]::before {\n  content: \"\\25CF\";\n}\n\n.apexcharts-tooltip-marker[shape=\"square\"]::before,\n.apexcharts-tooltip-marker[shape=\"rect\"]::before {\n  content: \"\\25A0\";\n  transform: translate(-1px, -2px);\n}\n\n.apexcharts-tooltip-marker[shape=\"line\"]::before {\n  content: \"\\2500\";\n}\n\n.apexcharts-tooltip-marker[shape=\"diamond\"]::before {\n  content: \"\\25C6\";\n  font-size: 28px;\n}\n\n.apexcharts-tooltip-marker[shape=\"triangle\"]::before {\n  content: \"\\25B2\";\n  font-size: 22px;\n}\n\n.apexcharts-tooltip-marker[shape=\"cross\"]::before {\n  content: \"\\2715\";\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape=\"plus\"]::before {\n  content: \"\\2715\";\n  transform: rotate(45deg) translate(-1px, -1px);\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape=\"star\"]::before {\n  content: \"\\2605\";\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape=\"sparkle\"]::before {\n  content: \"\\2726\";\n  font-size: 20px;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,\n.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_shape {\n  stroke-width: 1;\n  stroke-dasharray: 10 10;\n  stroke: black;\n  stroke-opacity: 0.1;\n  pointer-events: none;\n  fill: none;\n}\n\n.svg_select_handle {\n  stroke-width: 3;\n  stroke: black;\n  fill: none;\n}\n\n.svg_select_handle_r {\n  cursor: e-resize;\n}\n\n.svg_select_handle_l {\n  cursor: w-resize;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,\n.apexcharts-pan-icon,\n.apexcharts-reset-icon,\n.apexcharts-selection-icon,\n.apexcharts-toolbar-custom-icon,\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,\n.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,\n.apexcharts-reset-icon,\n.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, .7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,\n.apexcharts-datalabel.apexcharts-element-hidden,\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value,\n.apexcharts-datalabels,\n.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-gridline,\n.apexcharts-line,\n.apexcharts-point-annotation-label,\n.apexcharts-radar-series path:not(.apexcharts-marker),\n.apexcharts-radar-series polygon,\n.apexcharts-toolbar svg,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-zoom-rect,\n.no-pointer-events {\n  pointer-events: none\n}\n\n.apexcharts-tooltip-active .apexcharts-marker {\n  transition: .15s ease all\n}\n\n.apexcharts-radar-series .apexcharts-yaxis {\n  pointer-events: none;\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,\n.resize-triggers,\n.resize-triggers>div {\n  content: \" \";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows {\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-disable-transitions * {\n  transition: none !important;\n}";

  /**
   *
   * @module ApexCharts
   **/
  var ApexCharts = /*#__PURE__*/function () {
    function ApexCharts(el, opts) {
      _classCallCheck(this, ApexCharts);
      this.opts = opts;
      this.ctx = this;

      // Pass the user supplied options to the Base Class where these options will be extended with defaults. The returned object from Base Class will become the config object in the entire codebase.
      this.w = new Base(opts).init();
      this.el = el;
      this.w.globals.cuid = Utils$1.randomId();
      this.w.globals.chartID = this.w.config.chart.id ? Utils$1.escapeString(this.w.config.chart.id) : this.w.globals.cuid;
      var initCtx = new InitCtxVariables(this);
      initCtx.initModules();
      this.lastUpdateOptions = null;
      this.create = Utils$1.bind(this.create, this);
      this.windowResizeHandler = this._windowResizeHandler.bind(this);
      this.parentResizeHandler = this._parentResizeCallback.bind(this);
    }

    /**
     * The primary method user will call to render the chart.
     */
    _createClass(ApexCharts, [{
      key: "render",
      value: function render() {
        var _this = this;
        // main method
        return new Promise(function (resolve, reject) {
          // only draw chart, if element found
          if (Utils$1.elementExists(_this.el)) {
            if (typeof Apex._chartInstances === 'undefined') {
              Apex._chartInstances = [];
            }
            if (_this.w.config.chart.id) {
              Apex._chartInstances.push({
                id: _this.w.globals.chartID,
                group: _this.w.config.chart.group,
                chart: _this
              });
            }

            // set the locale here
            _this.setLocale(_this.w.config.chart.defaultLocale);
            var beforeMount = _this.w.config.chart.events.beforeMount;
            if (typeof beforeMount === 'function') {
              beforeMount(_this, _this.w);
            }
            _this.events.fireEvent('beforeMount', [_this, _this.w]);
            window.addEventListener('resize', _this.windowResizeHandler);
            addResizeListener(_this.el.parentNode, _this.parentResizeHandler);
            var rootNode = _this.el.getRootNode && _this.el.getRootNode();
            var inShadowRoot = Utils$1.is('ShadowRoot', rootNode);
            var doc = _this.el.ownerDocument;
            var css = inShadowRoot ? rootNode.getElementById('apexcharts-css') : doc.getElementById('apexcharts-css');
            if (!css) {
              var _this$opts$chart;
              css = document.createElement('style');
              css.id = 'apexcharts-css';
              css.textContent = css_248z;
              var nonce = ((_this$opts$chart = _this.opts.chart) === null || _this$opts$chart === void 0 ? void 0 : _this$opts$chart.nonce) || _this.w.config.chart.nonce;
              if (nonce) {
                css.setAttribute('nonce', nonce);
              }
              if (inShadowRoot) {
                // We are in Shadow DOM, add to shadow root
                rootNode.prepend(css);
              } else if (_this.w.config.chart.injectStyleSheet !== false) {
                // Add to <head> of element's document
                doc.head.appendChild(css);
              }
            }
            var graphData = _this.create(_this.w.config.series, {});
            if (!graphData) return resolve(_this);
            _this.mount(graphData).then(function () {
              if (typeof _this.w.config.chart.events.mounted === 'function') {
                _this.w.config.chart.events.mounted(_this, _this.w);
              }
              _this.events.fireEvent('mounted', [_this, _this.w]);
              resolve(graphData);
            }).catch(function (e) {
              reject(e);
              // handle error in case no data or element not found
            });
          } else {
            reject(new Error('Element not found'));
          }
        });
      }
    }, {
      key: "create",
      value: function create(ser, opts) {
        var _this2 = this;
        var w = this.w;
        var initCtx = new InitCtxVariables(this);
        initCtx.initModules();
        var gl = this.w.globals;
        gl.noData = false;
        gl.animationEnded = false;
        if (!Utils$1.elementExists(this.el)) {
          gl.animationEnded = true;
          return null;
        }
        this.responsive.checkResponsiveConfig(opts);
        if (w.config.xaxis.convertedCatToNumeric) {
          var defaults = new Defaults(w.config);
          defaults.convertCatToNumericXaxis(w.config, this.ctx);
        }
        this.core.setupElements();
        if (w.config.chart.type === 'treemap') {
          w.config.grid.show = false;
          w.config.yaxis[0].show = false;
        }
        if (gl.svgWidth === 0) {
          // if the element is hidden, skip drawing
          gl.animationEnded = true;
          return null;
        }
        var series = ser;
        ser.forEach(function (s, realIndex) {
          if (s.hidden) {
            series = _this2.legend.legendHelpers.getSeriesAfterCollapsing({
              realIndex: realIndex
            });
          }
        });
        var combo = CoreUtils.checkComboSeries(series, w.config.chart.type);
        gl.comboCharts = combo.comboCharts;
        gl.comboBarCount = combo.comboBarCount;
        var allSeriesAreEmpty = series.every(function (s) {
          return s.data && s.data.length === 0;
        });
        if (series.length === 0 || allSeriesAreEmpty && gl.collapsedSeries.length < 1) {
          this.series.handleNoData();
        }
        this.events.setupEventHandlers();

        // Handle the data inputted by user and set some of the global variables (for eg, if data is datetime / numeric / category). Don't calculate the range / min / max at this time
        this.data.parseData(series);

        // this is a good time to set theme colors first
        this.theme.init();

        // as markers accepts array, we need to setup global markers for easier access
        var markers = new Markers(this);
        markers.setGlobalMarkerSize();

        // labelFormatters should be called before dimensions as in dimensions we need text labels width
        this.formatters.setLabelFormatters();
        this.titleSubtitle.draw();

        // legend is calculated here before coreCalculations because it affects the plottable area
        // if there is some data to show or user collapsed all series, then proceed drawing legend
        if (!gl.noData || gl.collapsedSeries.length === gl.series.length || w.config.legend.showForSingleSeries) {
          this.legend.init();
        }

        // check whether in multiple series, all series share the same X
        this.series.hasAllSeriesEqualX();

        // coreCalculations will give the min/max range and yaxis/axis values. It should be called here to set series variable from config to globals
        if (gl.axisCharts) {
          this.core.coreCalculations();
          if (w.config.xaxis.type !== 'category') {
            // as we have minX and maxX values, determine the default DateTimeFormat for time series
            this.formatters.setLabelFormatters();
          }
          this.ctx.toolbar.minX = w.globals.minX;
          this.ctx.toolbar.maxX = w.globals.maxX;
        }

        // we need to generate yaxis for heatmap separately as we are not showing numerics there, but seriesNames. There are some tweaks which are required for heatmap to align labels correctly which are done in below function
        // Also we need to do this before calculating Dimensions plotCoords() method of Dimensions
        this.formatters.heatmapLabelFormatters();

        // get the largest marker size which will be needed in dimensions calc
        var coreUtils = new CoreUtils(this);
        coreUtils.getLargestMarkerSize();

        // We got plottable area here, next task would be to calculate axis areas
        this.dimensions.plotCoords();
        var xyRatios = this.core.xySettings();
        this.grid.createGridMask();
        var elGraph = this.core.plotChartType(series, xyRatios);
        var dataLabels = new DataLabels(this);
        dataLabels.bringForward();
        if (w.config.dataLabels.background.enabled) {
          dataLabels.dataLabelsBackground();
        }

        // after all the drawing calculations, shift the graphical area (actual charts/bars) excluding legends
        this.core.shiftGraphPosition();
        if (w.globals.dataPoints > 50) {
          w.globals.dom.elWrap.classList.add('apexcharts-disable-transitions');
        }
        var dim = {
          plot: {
            left: w.globals.translateX,
            top: w.globals.translateY,
            width: w.globals.gridWidth,
            height: w.globals.gridHeight
          }
        };
        return {
          elGraph: elGraph,
          xyRatios: xyRatios,
          dimensions: dim
        };
      }
    }, {
      key: "mount",
      value: function mount() {
        var _this3 = this;
        var graphData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var me = this;
        var w = me.w;
        return new Promise(function (resolve, reject) {
          // no data to display
          if (me.el === null) {
            return reject(new Error('Not enough data to display or target element not found'));
          } else if (graphData === null || w.globals.allSeriesCollapsed) {
            me.series.handleNoData();
          }
          me.grid = new Grid(me);
          var elgrid = me.grid.drawGrid();
          me.annotations = new Annotations(me);
          me.annotations.drawImageAnnos();
          me.annotations.drawTextAnnos();
          if (w.config.grid.position === 'back') {
            var _elgrid$elGridBorders;
            if (elgrid) {
              w.globals.dom.elGraphical.add(elgrid.el);
            }
            if (elgrid !== null && elgrid !== void 0 && (_elgrid$elGridBorders = elgrid.elGridBorders) !== null && _elgrid$elGridBorders !== void 0 && _elgrid$elGridBorders.node) {
              w.globals.dom.elGraphical.add(elgrid.elGridBorders);
            }
          }
          if (Array.isArray(graphData.elGraph)) {
            for (var g = 0; g < graphData.elGraph.length; g++) {
              w.globals.dom.elGraphical.add(graphData.elGraph[g]);
            }
          } else {
            w.globals.dom.elGraphical.add(graphData.elGraph);
          }
          if (w.config.grid.position === 'front') {
            var _elgrid$elGridBorders2;
            if (elgrid) {
              w.globals.dom.elGraphical.add(elgrid.el);
            }
            if (elgrid !== null && elgrid !== void 0 && (_elgrid$elGridBorders2 = elgrid.elGridBorders) !== null && _elgrid$elGridBorders2 !== void 0 && _elgrid$elGridBorders2.node) {
              w.globals.dom.elGraphical.add(elgrid.elGridBorders);
            }
          }
          if (w.config.xaxis.crosshairs.position === 'front') {
            me.crosshairs.drawXCrosshairs();
          }
          if (w.config.yaxis[0].crosshairs.position === 'front') {
            me.crosshairs.drawYCrosshairs();
          }
          if (w.config.chart.type !== 'treemap') {
            me.axes.drawAxis(w.config.chart.type, elgrid);
          }
          var xAxis = new XAxis(_this3.ctx, elgrid);
          var yaxis = new YAxis(_this3.ctx, elgrid);
          if (elgrid !== null) {
            xAxis.xAxisLabelCorrections(elgrid.xAxisTickWidth);
            yaxis.setYAxisTextAlignments();
            w.config.yaxis.map(function (yaxe, index) {
              if (w.globals.ignoreYAxisIndexes.indexOf(index) === -1) {
                yaxis.yAxisTitleRotate(index, yaxe.opposite);
              }
            });
          }
          me.annotations.drawAxesAnnotations();
          if (!w.globals.noData) {
            // draw tooltips at the end
            if (w.config.tooltip.enabled && !w.globals.noData) {
              me.w.globals.tooltip.drawTooltip(graphData.xyRatios);
            }
            if (w.globals.axisCharts && (w.globals.isXNumeric || w.config.xaxis.convertedCatToNumeric || w.globals.isRangeBar)) {
              if (w.config.chart.zoom.enabled || w.config.chart.selection && w.config.chart.selection.enabled || w.config.chart.pan && w.config.chart.pan.enabled) {
                me.zoomPanSelection.init({
                  xyRatios: graphData.xyRatios
                });
              }
            } else {
              var tools = w.config.chart.toolbar.tools;
              var toolsArr = ['zoom', 'zoomin', 'zoomout', 'selection', 'pan', 'reset'];
              toolsArr.forEach(function (t) {
                tools[t] = false;
              });
            }
            if (w.config.chart.toolbar.show && !w.globals.allSeriesCollapsed) {
              me.toolbar.createToolbar();
            }
          }
          if (w.globals.memory.methodsToExec.length > 0) {
            w.globals.memory.methodsToExec.forEach(function (fn) {
              fn.method(fn.params, false, fn.context);
            });
          }
          if (!w.globals.axisCharts && !w.globals.noData) {
            me.core.resizeNonAxisCharts();
          }
          resolve(me);
        });
      }

      /**
       * Destroy the chart instance by removing all elements which also clean up event listeners on those elements.
       */
    }, {
      key: "destroy",
      value: function destroy() {
        window.removeEventListener('resize', this.windowResizeHandler);
        removeResizeListener(this.el.parentNode, this.parentResizeHandler);
        // remove the chart's instance from the global Apex._chartInstances
        var chartID = this.w.config.chart.id;
        if (chartID) {
          Apex._chartInstances.forEach(function (c, i) {
            if (c.id === Utils$1.escapeString(chartID)) {
              Apex._chartInstances.splice(i, 1);
            }
          });
        }
        new Destroy(this.ctx).clear({
          isUpdating: false
        });
      }

      /**
       * Allows users to update Options after the chart has rendered.
       *
       * @param {object} options - A new config object can be passed which will be merged with the existing config object
       * @param {boolean} redraw - should redraw from beginning or should use existing paths and redraw from there
       * @param {boolean} animate - should animate or not on updating Options
       */
    }, {
      key: "updateOptions",
      value: function updateOptions(options) {
        var _this4 = this;
        var redraw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var updateSyncedCharts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var overwriteInitialConfig = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        var w = this.w;

        // when called externally, clear some global variables
        // fixes apexcharts.js#1488
        w.globals.selection = undefined;
        if (this.lastUpdateOptions && JSON.stringify(this.lastUpdateOptions) === JSON.stringify(options)) {
          // Options are identical, skip the update
          return this;
        }
        if (options.series) {
          this.data.resetParsingFlags();
          this.series.resetSeries(false, true, false);
          if (options.series.length && options.series[0].data) {
            options.series = options.series.map(function (s, i) {
              return _this4.updateHelpers._extendSeries(s, i);
            });
          }

          // user updated the series via updateOptions() function.
          // Hence, we need to reset axis min/max to avoid zooming issues
          this.updateHelpers.revertDefaultAxisMinMax();
        }
        // user has set x-axis min/max externally - hence we need to forcefully set the xaxis min/max
        if (options.xaxis) {
          options = this.updateHelpers.forceXAxisUpdate(options);
        }
        if (options.yaxis) {
          options = this.updateHelpers.forceYAxisUpdate(options);
        }
        if (w.globals.collapsedSeriesIndices.length > 0) {
          this.series.clearPreviousPaths();
        }
        /* update theme mode#459 */
        if (options.theme) {
          options = this.theme.updateThemeOptions(options);
        }
        return this.updateHelpers._updateOptions(options, redraw, animate, updateSyncedCharts, overwriteInitialConfig);
      }

      /**
       * Allows users to update Series after the chart has rendered.
       *
       * @param {array} series - New series which will override the existing
       */
    }, {
      key: "updateSeries",
      value: function updateSeries() {
        var newSeries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        this.data.resetParsingFlags();
        this.series.resetSeries(false);
        this.updateHelpers.revertDefaultAxisMinMax();
        return this.updateHelpers._updateSeries(newSeries, animate, overwriteInitialSeries);
      }

      /**
       * Allows users to append a new series after the chart has rendered.
       *
       * @param {array} newSerie - New serie which will be appended to the existing series
       */
    }, {
      key: "appendSeries",
      value: function appendSeries(newSerie) {
        var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var overwriteInitialSeries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        this.data.resetParsingFlags();
        var newSeries = this.w.config.series.slice();
        newSeries.push(newSerie);
        this.series.resetSeries(false);
        this.updateHelpers.revertDefaultAxisMinMax();
        return this.updateHelpers._updateSeries(newSeries, animate, overwriteInitialSeries);
      }

      /**
       * Allows users to append Data to series.
       *
       * @param {array} newData - New data in the same format as series
       */
    }, {
      key: "appendData",
      value: function appendData(newData) {
        var overwriteInitialSeries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var me = this;
        me.data.resetParsingFlags();
        me.w.globals.dataChanged = true;
        me.series.getPreviousPaths();
        var newSeries = me.w.config.series.slice();
        for (var i = 0; i < newSeries.length; i++) {
          if (newData[i] !== null && typeof newData[i] !== 'undefined') {
            for (var j = 0; j < newData[i].data.length; j++) {
              newSeries[i].data.push(newData[i].data[j]);
            }
          }
        }
        me.w.config.series = newSeries;
        if (overwriteInitialSeries) {
          me.w.globals.initialSeries = Utils$1.clone(me.w.config.series);
        }
        return this.update();
      }
    }, {
      key: "update",
      value: function update(options) {
        var _this5 = this;
        return new Promise(function (resolve, reject) {
          if (_this5.lastUpdateOptions && JSON.stringify(_this5.lastUpdateOptions) === JSON.stringify(options)) {
            // Options are identical, skip the update
            return resolve(_this5);
          }
          _this5.lastUpdateOptions = Utils$1.clone(options);
          new Destroy(_this5.ctx).clear({
            isUpdating: true
          });
          var graphData = _this5.create(_this5.w.config.series, options);
          if (!graphData) return resolve(_this5);
          _this5.mount(graphData).then(function () {
            if (typeof _this5.w.config.chart.events.updated === 'function') {
              _this5.w.config.chart.events.updated(_this5, _this5.w);
            }
            _this5.events.fireEvent('updated', [_this5, _this5.w]);
            _this5.w.globals.isDirty = true;
            resolve(_this5);
          }).catch(function (e) {
            reject(e);
          });
        });
      }

      /**
       * Get all charts in the same "group" (including the instance which is called upon) to sync them when user zooms in/out or pan.
       */
    }, {
      key: "getSyncedCharts",
      value: function getSyncedCharts() {
        var chartGroups = this.getGroupedCharts();
        var allCharts = [this];
        if (chartGroups.length) {
          allCharts = [];
          chartGroups.forEach(function (ch) {
            allCharts.push(ch);
          });
        }
        return allCharts;
      }

      /**
       * Get charts in the same "group" (excluding the instance which is called upon) to perform operations on the other charts of the same group (eg., tooltip hovering)
       */
    }, {
      key: "getGroupedCharts",
      value: function getGroupedCharts() {
        var _this6 = this;
        return Apex._chartInstances.filter(function (ch) {
          if (ch.group) {
            return true;
          }
        }).map(function (ch) {
          return _this6.w.config.chart.group === ch.group ? ch.chart : _this6;
        });
      }
    }, {
      key: "toggleSeries",
      value: function toggleSeries(seriesName) {
        return this.series.toggleSeries(seriesName);
      }
    }, {
      key: "highlightSeriesOnLegendHover",
      value: function highlightSeriesOnLegendHover(e, targetElement) {
        return this.series.toggleSeriesOnHover(e, targetElement);
      }
    }, {
      key: "showSeries",
      value: function showSeries(seriesName) {
        this.series.showSeries(seriesName);
      }
    }, {
      key: "hideSeries",
      value: function hideSeries(seriesName) {
        this.series.hideSeries(seriesName);
      }
    }, {
      key: "highlightSeries",
      value: function highlightSeries(seriesName) {
        this.series.highlightSeries(seriesName);
      }
    }, {
      key: "isSeriesHidden",
      value: function isSeriesHidden(seriesName) {
        this.series.isSeriesHidden(seriesName);
      }
    }, {
      key: "resetSeries",
      value: function resetSeries() {
        var shouldUpdateChart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var shouldResetZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        this.series.resetSeries(shouldUpdateChart, shouldResetZoom);
      }

      // Public method to add event listener on chart context
    }, {
      key: "addEventListener",
      value: function addEventListener(name, handler) {
        this.events.addEventListener(name, handler);
      }

      // Public method to remove event listener on chart context
    }, {
      key: "removeEventListener",
      value: function removeEventListener(name, handler) {
        this.events.removeEventListener(name, handler);
      }
    }, {
      key: "addXaxisAnnotation",
      value: function addXaxisAnnotation(opts) {
        var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
        var me = this;
        if (context) {
          me = context;
        }
        me.annotations.addXaxisAnnotationExternal(opts, pushToMemory, me);
      }
    }, {
      key: "addYaxisAnnotation",
      value: function addYaxisAnnotation(opts) {
        var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
        var me = this;
        if (context) {
          me = context;
        }
        me.annotations.addYaxisAnnotationExternal(opts, pushToMemory, me);
      }
    }, {
      key: "addPointAnnotation",
      value: function addPointAnnotation(opts) {
        var pushToMemory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
        var me = this;
        if (context) {
          me = context;
        }
        me.annotations.addPointAnnotationExternal(opts, pushToMemory, me);
      }
    }, {
      key: "clearAnnotations",
      value: function clearAnnotations() {
        var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
        var me = this;
        if (context) {
          me = context;
        }
        me.annotations.clearAnnotations(me);
      }
    }, {
      key: "removeAnnotation",
      value: function removeAnnotation(id) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        var me = this;
        if (context) {
          me = context;
        }
        me.annotations.removeAnnotation(me, id);
      }
    }, {
      key: "getChartArea",
      value: function getChartArea() {
        var el = this.w.globals.dom.baseEl.querySelector('.apexcharts-inner');
        return el;
      }
    }, {
      key: "getSeriesTotalXRange",
      value: function getSeriesTotalXRange(minX, maxX) {
        return this.coreUtils.getSeriesTotalsXRange(minX, maxX);
      }
    }, {
      key: "getHighestValueInSeries",
      value: function getHighestValueInSeries() {
        var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var range = new Range(this.ctx);
        return range.getMinYMaxY(seriesIndex).highestY;
      }
    }, {
      key: "getLowestValueInSeries",
      value: function getLowestValueInSeries() {
        var seriesIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var range = new Range(this.ctx);
        return range.getMinYMaxY(seriesIndex).lowestY;
      }
    }, {
      key: "getSeriesTotal",
      value: function getSeriesTotal() {
        return this.w.globals.seriesTotals;
      }
    }, {
      key: "toggleDataPointSelection",
      value: function toggleDataPointSelection(seriesIndex, dataPointIndex) {
        return this.updateHelpers.toggleDataPointSelection(seriesIndex, dataPointIndex);
      }
    }, {
      key: "zoomX",
      value: function zoomX(min, max) {
        this.ctx.toolbar.zoomUpdateOptions(min, max);
      }
    }, {
      key: "setLocale",
      value: function setLocale(localeName) {
        this.localization.setCurrentLocaleValues(localeName);
      }
    }, {
      key: "dataURI",
      value: function dataURI(options) {
        var exp = new Exports(this.ctx);
        return exp.dataURI(options);
      }
    }, {
      key: "getSvgString",
      value: function getSvgString(scale) {
        return new Exports(this.ctx).getSvgString(scale);
      }
    }, {
      key: "exportToCSV",
      value: function exportToCSV() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var exp = new Exports(this.ctx);
        return exp.exportToCSV(options);
      }
    }, {
      key: "paper",
      value: function paper() {
        return this.w.globals.dom.Paper;
      }
    }, {
      key: "_parentResizeCallback",
      value: function _parentResizeCallback() {
        if (this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize) {
          this._windowResize();
        }
      }

      /**
       * Handle window resize and re-draw the whole chart.
       */
    }, {
      key: "_windowResize",
      value: function _windowResize() {
        var _this7 = this;
        clearTimeout(this.w.globals.resizeTimer);
        this.w.globals.resizeTimer = window.setTimeout(function () {
          _this7.w.globals.resized = true;
          _this7.w.globals.dataChanged = false;

          // we need to redraw the whole chart on window resize (with a small delay).
          _this7.ctx.update();
        }, 150);
      }
    }, {
      key: "_windowResizeHandler",
      value: function _windowResizeHandler() {
        var redraw = this.w.config.chart.redrawOnWindowResize;
        if (typeof redraw === 'function') {
          redraw = redraw();
        }
        redraw && this._windowResize();
      }
    }], [{
      key: "getChartByID",
      value: function getChartByID(id) {
        var chartId = Utils$1.escapeString(id);
        if (!Apex._chartInstances) return undefined;
        var c = Apex._chartInstances.filter(function (ch) {
          return ch.id === chartId;
        })[0];
        return c && c.chart;
      }

      /**
       * Allows the user to provide data attrs in the element and the chart will render automatically when this method is called by searching for the elements containing 'data-apexcharts' attribute
       */
    }, {
      key: "initOnLoad",
      value: function initOnLoad() {
        var els = document.querySelectorAll('[data-apexcharts]');
        for (var i = 0; i < els.length; i++) {
          var el = els[i];
          var options = JSON.parse(els[i].getAttribute('data-options'));
          var apexChart = new ApexCharts(el, options);
          apexChart.render();
        }
      }

      /**
       * This static method allows users to call chart methods without necessarily from the
       * instance of the chart in case user has assigned chartID to the targeted chart.
       * The chartID is used for mapping the instance stored in Apex._chartInstances global variable
       *
       * This is helpful in cases when you don't have reference of the chart instance
       * easily and need to call the method from anywhere.
       * For eg, in React/Vue applications when you have many parent/child components,
       * and need easy reference to other charts for performing dynamic operations
       *
       * @param {string} chartID - The unique identifier which will be used to call methods
       * on that chart instance
       * @param {function} fn - The method name to call
       * @param {object} opts - The parameters which are accepted in the original method will be passed here in the same order.
       */
    }, {
      key: "exec",
      value: function exec(chartID, fn) {
        var chart = this.getChartByID(chartID);
        if (!chart) return;

        // turn on the global exec flag to indicate this method was called
        chart.w.globals.isExecCalled = true;
        var ret = null;
        if (chart.publicMethods.indexOf(fn) !== -1) {
          for (var _len = arguments.length, opts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            opts[_key - 2] = arguments[_key];
          }
          ret = chart[fn].apply(chart, opts);
        }
        return ret;
      }
    }, {
      key: "merge",
      value: function merge(target, source) {
        return Utils$1.extend(target, source);
      }
    }, {
      key: "getThemePalettes",
      value: function getThemePalettes() {
        return {
          palette1: ['#008FFB', '#00E396', '#FEB019', '#FF4560', '#775DD0'],
          palette2: ['#3F51B5', '#03A9F4', '#4CAF50', '#F9CE1D', '#FF9800'],
          palette3: ['#33B2DF', '#546E7A', '#D4526E', '#13D8AA', '#A5978B'],
          palette4: ['#4ECDC4', '#C7F464', '#81D4FA', '#FD6A6A', '#546E7A'],
          palette5: ['#2B908F', '#F9A3A4', '#90EE7E', '#FA4443', '#69D2E7'],
          palette6: ['#449DD1', '#F86624', '#EA3546', '#662E9B', '#C5D86D'],
          palette7: ['#D7263D', '#1B998B', '#2E294E', '#F46036', '#E2C044'],
          palette8: ['#662E9B', '#F86624', '#F9C80E', '#EA3546', '#43BCCD'],
          palette9: ['#5C4742', '#A5978B', '#8D5B4C', '#5A2A27', '#C4BBAF'],
          palette10: ['#A300D6', '#7D02EB', '#5653FE', '#2983FF', '#00B1F2']
        };
      }
    }]);
    return ApexCharts;
  }();

  return ApexCharts;

}));

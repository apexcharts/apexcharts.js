{"version":3,"sources":["container/HashContainer/HashMap.js","../../src/container/HashContainer/HashMap.ts"],"names":["Object","defineProperty","exports","value","default","_Base","require","_checkObject","_interopRequireDefault","_throwError","obj","__esModule","HashMapIterator","HashContainerIterator","constructor","node","header","container","iteratorType","super","this","pointer","_node","_header","throwIteratorAccessError","self","Proxy","get","target","prop","_key","_value","set","_","newValue","TypeError","copy","HashMap","HashContainer","forEach","el","setElement","begin","_head","end","rBegin","_tail","rEnd","front","_length","back","key","isObject","_set","getElementByKey","undefined","checkObject","index","HASH_TAG","_objMap","_originMap","getElementByPos","pos","RangeError","_next","find","_findElementNode","callback","Symbol","iterator","_default"],"mappings":"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","file":"HashMap.js","sourcesContent":["import { HashContainer, HashContainerIterator } from \"./Base\";\nimport checkObject from \"../../utils/checkObject\";\nimport $checkWithinAccessParams from \"../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../utils/throwError\";\nclass HashMapIterator extends HashContainerIterator {\n    constructor(node, header, container, iteratorType) {\n        super(node, header, iteratorType);\n        this.container = container;\n    }\n    get pointer() {\n        if (this._node === this._header) {\n            throwIteratorAccessError();\n        }\n        const self = this;\n        return new Proxy([], {\n            get(target, prop) {\n                if (prop === '0')\n                    return self._node._key;\n                else if (prop === '1')\n                    return self._node._value;\n                target[0] = self._node._key;\n                target[1] = self._node._value;\n                return target[prop];\n            },\n            set(_, prop, newValue) {\n                if (prop !== '1') {\n                    throw new TypeError('prop must be 1');\n                }\n                self._node._value = newValue;\n                return true;\n            }\n        });\n    }\n    copy() {\n        return new HashMapIterator(this._node, this._header, this.container, this.iteratorType);\n    }\n}\nclass HashMap extends HashContainer {\n    constructor(container = []) {\n        super();\n        const self = this;\n        container.forEach(function (el) {\n            self.setElement(el[0], el[1]);\n        });\n    }\n    begin() {\n        return new HashMapIterator(this._head, this._header, this);\n    }\n    end() {\n        return new HashMapIterator(this._header, this._header, this);\n    }\n    rBegin() {\n        return new HashMapIterator(this._tail, this._header, this, 1 /* IteratorType.REVERSE */);\n    }\n    rEnd() {\n        return new HashMapIterator(this._header, this._header, this, 1 /* IteratorType.REVERSE */);\n    }\n    front() {\n        if (this._length === 0)\n            return;\n        return [this._head._key, this._head._value];\n    }\n    back() {\n        if (this._length === 0)\n            return;\n        return [this._tail._key, this._tail._value];\n    }\n    /**\n     * @description Insert a key-value pair or set value by the given key.\n     * @param key - The key want to insert.\n     * @param value - The value want to set.\n     * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n     *                   If a `undefined` value is passed in, the type will be automatically judged.\n     * @returns The size of container after setting.\n     */\n    setElement(key, value, isObject) {\n        return this._set(key, value, isObject);\n    }\n    /**\n     * @description Get the value of the element of the specified key.\n     * @param key - The key want to search.\n     * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n     *                   If a `undefined` value is passed in, the type will be automatically judged.\n     * @example\n     * const val = container.getElementByKey(1);\n     */\n    getElementByKey(key, isObject) {\n        if (isObject === undefined)\n            isObject = checkObject(key);\n        if (isObject) {\n            const index = key[this.HASH_TAG];\n            return index !== undefined ? this._objMap[index]._value : undefined;\n        }\n        const node = this._originMap[key];\n        return node ? node._value : undefined;\n    }\n    getElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        let node = this._head;\n        while (pos--) {\n            node = node._next;\n        }\n        return [node._key, node._value];\n    }\n    /**\n     * @description Check key if exist in container.\n     * @param key - The element you want to search.\n     * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n     *                   If a `undefined` value is passed in, the type will be automatically judged.\n     * @returns An iterator pointing to the element if found, or super end if not found.\n     */\n    find(key, isObject) {\n        const node = this._findElementNode(key, isObject);\n        return new HashMapIterator(node, this._header, this);\n    }\n    forEach(callback) {\n        let index = 0;\n        let node = this._head;\n        while (node !== this._header) {\n            callback([node._key, node._value], index++, this);\n            node = node._next;\n        }\n    }\n    *[Symbol.iterator]() {\n        let node = this._head;\n        while (node !== this._header) {\n            yield [node._key, node._value];\n            node = node._next;\n        }\n    }\n}\nexport default HashMap;\n","import { initContainer, IteratorType } from '@/container/ContainerBase';\nimport { HashContainer, HashContainerIterator, HashLinkNode } from '@/container/HashContainer/Base';\nimport checkObject from '@/utils/checkObject';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nclass HashMapIterator<K, V> extends HashContainerIterator<K, V> {\n  readonly container: HashMap<K, V>;\n  constructor(\n    node: HashLinkNode<K, V>,\n    header: HashLinkNode<K, V>,\n    container: HashMap<K, V>,\n    iteratorType?: IteratorType\n  ) {\n    super(node, header, iteratorType);\n    this.container = container;\n  }\n  get pointer() {\n    if (this._node === this._header) {\n      throwIteratorAccessError();\n    }\n    const self = this;\n    return new Proxy(<[K, V]><unknown>[], {\n      get(target, prop: '0' | '1') {\n        if (prop === '0') return self._node._key;\n        else if (prop === '1') return self._node._value;\n        target[0] = self._node._key;\n        target[1] = self._node._value;\n        return target[prop];\n      },\n      set(_, prop: '1', newValue: V) {\n        if (prop !== '1') {\n          throw new TypeError('prop must be 1');\n        }\n        self._node._value = newValue;\n        return true;\n      }\n    });\n  }\n  copy() {\n    return new HashMapIterator<K, V>(this._node, this._header, this.container, this.iteratorType);\n  }\n  // @ts-ignore\n  equals(iter: HashMapIterator<K, V>): boolean;\n}\n\nexport type { HashMapIterator };\n\nclass HashMap<K, V> extends HashContainer<K, V> {\n  constructor(container: initContainer<[K, V]> = []) {\n    super();\n    const self = this;\n    container.forEach(function (el) {\n      self.setElement(el[0], el[1]);\n    });\n  }\n  begin() {\n    return new HashMapIterator<K, V>(this._head, this._header, this);\n  }\n  end() {\n    return new HashMapIterator<K, V>(this._header, this._header, this);\n  }\n  rBegin() {\n    return new HashMapIterator<K, V>(this._tail, this._header, this, IteratorType.REVERSE);\n  }\n  rEnd() {\n    return new HashMapIterator<K, V>(this._header, this._header, this, IteratorType.REVERSE);\n  }\n  front() {\n    if (this._length === 0) return;\n    return <[K, V]>[this._head._key, this._head._value];\n  }\n  back() {\n    if (this._length === 0) return;\n    return <[K, V]>[this._tail._key, this._tail._value];\n  }\n  /**\n   * @description Insert a key-value pair or set value by the given key.\n   * @param key - The key want to insert.\n   * @param value - The value want to set.\n   * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n   *                   If a `undefined` value is passed in, the type will be automatically judged.\n   * @returns The size of container after setting.\n   */\n  setElement(key: K, value: V, isObject?: boolean) {\n    return this._set(key, value, isObject);\n  }\n  /**\n   * @description Get the value of the element of the specified key.\n   * @param key - The key want to search.\n   * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n   *                   If a `undefined` value is passed in, the type will be automatically judged.\n   * @example\n   * const val = container.getElementByKey(1);\n   */\n  getElementByKey(key: K, isObject?: boolean) {\n    if (isObject === undefined) isObject = checkObject(key);\n    if (isObject) {\n      const index = (<Record<symbol, number>><unknown>key)[this.HASH_TAG];\n      return index !== undefined ? this._objMap[index]._value : undefined;\n    }\n    const node = this._originMap[<string><unknown>key];\n    return node ? node._value : undefined;\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let node = this._head;\n    while (pos--) {\n      node = node._next;\n    }\n    return <[K, V]>[node._key, node._value];\n  }\n  /**\n   * @description Check key if exist in container.\n   * @param key - The element you want to search.\n   * @param isObject - Tell us if the type of inserted key is `object` to improve efficiency.<br/>\n   *                   If a `undefined` value is passed in, the type will be automatically judged.\n   * @returns An iterator pointing to the element if found, or super end if not found.\n   */\n  find(key: K, isObject?: boolean) {\n    const node = this._findElementNode(key, isObject);\n    return new HashMapIterator<K, V>(node, this._header, this);\n  }\n  forEach(callback: (element: [K, V], index: number, hashMap: HashMap<K, V>) => void) {\n    let index = 0;\n    let node = this._head;\n    while (node !== this._header) {\n      callback(<[K, V]>[node._key, node._value], index++, this);\n      node = node._next;\n    }\n  }\n  * [Symbol.iterator]() {\n    let node = this._head;\n    while (node !== this._header) {\n      yield <[K, V]>[node._key, node._value];\n      node = node._next;\n    }\n  }\n}\n\nexport default HashMap;\n"]}
{"version":3,"sources":["container/TreeContainer/Base/index.js","../../src/container/TreeContainer/Base/index.ts"],"names":["Object","defineProperty","exports","value","default","_TreeNode","require","_ContainerBase","_throwError","TreeContainer","Container","constructor","cmp","x","y","enableIndex","super","this","_root","undefined","_cmp","_TreeNodeClass","TreeNodeEnableIndex","TreeNode","_header","_lowerBound","curNode","key","resNode","cmpResult","_key","_right","_left","_upperBound","_reverseLowerBound","_reverseUpperBound","_eraseNodeSelfBalance","parentNode","_parent","_color","brother","_rotateLeft","_rotateRight","_eraseNode","_length","clear","swapNode","_value","_subTreeSize","_inOrderTraversal","param","pos","callback","nodeList","index","stack","length","push","pop","_insertNodeSelfBalance","grandParent","uncle","GP","_recount","_set","hint","minNode","compareToMin","maxNode","compareToMax","iterNode","_node","iterCmpRes","preNode","_pre","preCmpRes","parent","_getTreeNodeByKey","updateKeyByIterator","iter","node","throwIteratorAccessError","nextKey","_next","preKey","eraseElementByPos","RangeError","eraseElementByKey","eraseElementByIterator","hasNoRight","isNormal","iteratorType","next","getHeight","traversal","Math","max","_default"],"mappings":"AAAA;;AAEAA,OAAOC,eAAeC,SAAS,KAAc;IAC3CC,OAAO;;;AAETD,QAAQE,eAAe;;ACJvB,IAAAC,YAAAC,QAAA;;AACA,IAAAC,iBAAAD,QAAA;;AAEA,IAAAE,cAAAF,QAAA;;AAEA,MAAeG,sBAA4BC,eAAAA;IAqBzCC,WAAAA,CACEC,IACA,SAAUC,GAAMC;QACd,IAAID,IAAIC,GAAG,QAAQ;QACnB,IAAID,IAAIC,GAAG,OAAO;QAClB,OAAO;ADlBT,OCoBAC,IAAc;QAEdC;QArBQC,KAAAC,IAAoCC;QAsB5CF,KAAKG,IAAOR;QACZK,KAAKF,cAAcA;QACnBE,KAAKI,KAAiBN,IAAcO,UAAAA,sBAAsBC,UAAAA;QAC1DN,KAAKO,IAAU,IAAIP,KAAKI;ADhBxB;ICqBQI,CAAAA,CAAYC,GAAqCC;QACzD,IAAIC,IAAUX,KAAKO;QACnB,OAAOE,GAAS;YACd,MAAMG,IAAYZ,KAAKG,EAAKM,EAAQI,GAAOH;YAC3C,IAAIE,IAAY,GAAG;gBACjBH,IAAUA,EAAQK;ADhBd,mBCiBC,IAAIF,IAAY,GAAG;gBACxBD,IAAUF;gBACVA,IAAUA,EAAQM;ADfd,mBCgBC,OAAON;ADbZ;QCeJ,OAAOE;ADbP;ICkBQK,CAAAA,CAAYP,GAAqCC;QACzD,IAAIC,IAAUX,KAAKO;QACnB,OAAOE,GAAS;YACd,MAAMG,IAAYZ,KAAKG,EAAKM,EAAQI,GAAOH;YAC3C,IAAIE,KAAa,GAAG;gBAClBH,IAAUA,EAAQK;ADbd,mBCcC;gBACLH,IAAUF;gBACVA,IAAUA,EAAQM;ADZd;AACJ;QCcJ,OAAOJ;ADZP;ICiBQM,CAAAA,CAAmBR,GAAqCC;QAChE,IAAIC,IAAUX,KAAKO;QACnB,OAAOE,GAAS;YACd,MAAMG,IAAYZ,KAAKG,EAAKM,EAAQI,GAAOH;YAC3C,IAAIE,IAAY,GAAG;gBACjBD,IAAUF;gBACVA,IAAUA,EAAQK;ADZd,mBCaC,IAAIF,IAAY,GAAG;gBACxBH,IAAUA,EAAQM;ADXd,mBCYC,OAAON;ADTZ;QCWJ,OAAOE;ADTP;ICcQO,CAAAA,CAAmBT,GAAqCC;QAChE,IAAIC,IAAUX,KAAKO;QACnB,OAAOE,GAAS;YACd,MAAMG,IAAYZ,KAAKG,EAAKM,EAAQI,GAAOH;YAC3C,IAAIE,IAAY,GAAG;gBACjBD,IAAUF;gBACVA,IAAUA,EAAQK;ADTd,mBCUC;gBACLL,IAAUA,EAAQM;ADRd;AACJ;QCUJ,OAAOJ;ADRP;ICaQQ,EAAAA,CAAsBV;QAC9B,OAAO,MAAM;YACX,MAAMW,IAAaX,EAAQY;YAC3B,IAAID,MAAepB,KAAKO,GAAS;YACjC,IAAIE,EAAQa,OAAM,GAAwB;gBACxCb,EAAQa,KAAM;gBACd;ADPI;YCSN,IAAIb,MAAYW,EAAWL,GAAO;gBAChC,MAAMQ,IAAUH,EAAWN;gBAC3B,IAAIS,EAAQD,OAAM,GAAwB;oBACxCC,EAAQD,KAAM;oBACdF,EAAWE,KAAM;oBACjB,IAAIF,MAAepB,KAAKC,GAAO;wBAC7BD,KAAKC,IAAQmB,EAAWI;ADPhB,2BCQHJ,EAAWI;ADLZ,uBCMD;oBACL,IAAID,EAAQT,KAAUS,EAAQT,EAAOQ,OAAM,GAAwB;wBACjEC,EAAQD,KAASF,EAAWE;wBAC5BF,EAAWE,KAAM;wBACjBC,EAAQT,EAAOQ,KAAM;wBACrB,IAAIF,MAAepB,KAAKC,GAAO;4BAC7BD,KAAKC,IAAQmB,EAAWI;ADJd,+BCKLJ,EAAWI;wBAClB;ADFQ,2BCGH,IAAID,EAAQR,KAASQ,EAAQR,EAAMO,OAAM,GAAwB;wBACtEC,EAAQD,KAAM;wBACdC,EAAQR,EAAMO,KAAM;wBACpBC,EAAQE;ADDA,2BCEH;wBACLF,EAAQD,KAAM;wBACdb,IAAUW;ADAF;AACJ;AACJ,mBCCC;gBACL,MAAMG,IAAUH,EAAWL;gBAC3B,IAAIQ,EAAQD,OAAM,GAAwB;oBACxCC,EAAQD,KAAM;oBACdF,EAAWE,KAAM;oBACjB,IAAIF,MAAepB,KAAKC,GAAO;wBAC7BD,KAAKC,IAAQmB,EAAWK;ADChB,2BCAHL,EAAWK;ADGZ,uBCFD;oBACL,IAAIF,EAAQR,KAASQ,EAAQR,EAAMO,OAAM,GAAwB;wBAC/DC,EAAQD,KAASF,EAAWE;wBAC5BF,EAAWE,KAAM;wBACjBC,EAAQR,EAAMO,KAAM;wBACpB,IAAIF,MAAepB,KAAKC,GAAO;4BAC7BD,KAAKC,IAAQmB,EAAWK;ADId,+BCHLL,EAAWK;wBAClB;ADMQ,2BCLH,IAAIF,EAAQT,KAAUS,EAAQT,EAAOQ,OAAM,GAAwB;wBACxEC,EAAQD,KAAM;wBACdC,EAAQT,EAAOQ,KAAM;wBACrBC,EAAQC;ADOA,2BCNH;wBACLD,EAAQD,KAAM;wBACdb,IAAUW;ADQF;AACJ;AACJ;AACJ;AACJ;ICHQM,CAAAA,CAAWjB;QACnB,IAAIT,KAAK2B,MAAY,GAAG;YACtB3B,KAAK4B;YACL;ADQE;QCNJ,IAAIC,IAAWpB;QACf,OAAOoB,EAASd,KAASc,EAASf,GAAQ;YACxC,IAAIe,EAASf,GAAQ;gBACnBe,IAAWA,EAASf;gBACpB,OAAOe,EAASd,GAAOc,IAAWA,EAASd;ADSvC,mBCRC;gBACLc,IAAWA,EAASd;ADUhB;YCRN,MAAML,IAAMD,EAAQI;YACpBJ,EAAQI,IAAOgB,EAAShB;YACxBgB,EAAShB,IAAOH;YAChB,MAAMxB,IAAQuB,EAAQqB;YACtBrB,EAAQqB,IAASD,EAASC;YAC1BD,EAASC,IAAS5C;YAClBuB,IAAUoB;ADUR;QCRJ,IAAI7B,KAAKO,EAAQQ,MAAUc,GAAU;YACnC7B,KAAKO,EAAQQ,IAAQc,EAASR;ADU5B,eCTG,IAAIrB,KAAKO,EAAQO,MAAWe,GAAU;YAC3C7B,KAAKO,EAAQO,IAASe,EAASR;ADW7B;QCTJrB,KAAKmB,GAAsBU;QAC3B,IAAIR,IAAUQ,EAASR;QACvB,IAAIQ,MAAaR,EAAQN,GAAO;YAC9BM,EAAQN,IAAQb;ADWd,eCVGmB,EAAQP,IAASZ;QACxBF,KAAK2B,KAAW;QAChB3B,KAAKC,EAAOqB,KAAM;QAClB,IAAItB,KAAKF,aAAa;YACpB,OAAOuB,MAAYrB,KAAKO,GAAS;gBAC/Bc,EAAQU,MAAgB;gBACxBV,IAAUA,EAAQA;ADad;AACJ;AACJ;ICHQW,EAAAA,CACRC;QAEA,MAAMC,WAAaD,MAAU,WAAWA,IAAQ/B;QAChD,MAAMiC,WAAkBF,MAAU,aAAaA,IAAQ/B;QACvD,MAAMkC,WAAkBH,MAAU,cAAgC,KAAK/B;QACvE,IAAImC,IAAQ;QACZ,IAAI5B,IAAUT,KAAKC;QACnB,MAAMqC,IAA0B;QAChC,OAAOA,EAAMC,UAAU9B,GAAS;YAC9B,IAAIA,GAAS;gBACX6B,EAAME,KAAK/B;gBACXA,IAAUA,EAAQM;ADMd,mBCLC;gBACLN,IAAU6B,EAAMG;gBAChB,IAAIJ,MAAUH,GAAK,OAAOzB;gBAC1B2B,KAAYA,EAASI,KAAK/B;gBAC1B0B,KAAYA,EAAS1B,GAAS4B,GAAOrC;gBACrCqC,KAAS;gBACT5B,IAAUA,EAAQK;ADQd;AACJ;QCNJ,OAAOsB;ADQP;ICHQM,EAAAA,CAAuBjC;QAC/B,OAAO,MAAM;YACX,MAAMW,IAAaX,EAAQY;YAC3B,IAAID,EAAWE,OAAM,GAA0B;YAC/C,MAAMqB,IAAcvB,EAAWC;YAC/B,IAAID,MAAeuB,EAAY5B,GAAO;gBACpC,MAAM6B,IAAQD,EAAY7B;gBAC1B,IAAI8B,KAASA,EAAMtB,OAAM,GAAwB;oBAC/CsB,EAAMtB,KAASF,EAAWE,KAAM;oBAChC,IAAIqB,MAAgB3C,KAAKC,GAAO;oBAChC0C,EAAYrB,KAAM;oBAClBb,IAAUkC;oBACV;ADUM,uBCTD,IAAIlC,MAAYW,EAAWN,GAAQ;oBACxCL,EAAQa,KAAM;oBACd,IAAIb,EAAQM,GAAO;wBACjBN,EAAQM,EAAMM,KAAUD;ADWhB;oBCTV,IAAIX,EAAQK,GAAQ;wBAClBL,EAAQK,EAAOO,KAAUsB;ADWjB;oBCTVvB,EAAWN,IAASL,EAAQM;oBAC5B4B,EAAY5B,IAAQN,EAAQK;oBAC5BL,EAAQM,IAAQK;oBAChBX,EAAQK,IAAS6B;oBACjB,IAAIA,MAAgB3C,KAAKC,GAAO;wBAC9BD,KAAKC,IAAQQ;wBACbT,KAAKO,EAAQc,KAAUZ;ADWf,2BCVH;wBACL,MAAMoC,IAAKF,EAAYtB;wBACvB,IAAIwB,EAAG9B,MAAU4B,GAAa;4BAC5BE,EAAG9B,IAAQN;ADYD,+BCXLoC,EAAG/B,IAASL;ADcX;oBCZVA,EAAQY,KAAUsB,EAAYtB;oBAC9BD,EAAWC,KAAUZ;oBACrBkC,EAAYtB,KAAUZ;oBACtBkC,EAAYrB,KAAM;ADcZ,uBCbD;oBACLF,EAAWE,KAAM;oBACjB,IAAIqB,MAAgB3C,KAAKC,GAAO;wBAC9BD,KAAKC,IAAQ0C,EAAYlB;ADejB,2BCdHkB,EAAYlB;oBACnBkB,EAAYrB,KAAM;oBAClB;ADiBM;AACJ,mBChBC;gBACL,MAAMsB,IAAQD,EAAY5B;gBAC1B,IAAI6B,KAASA,EAAMtB,OAAM,GAAwB;oBAC/CsB,EAAMtB,KAASF,EAAWE,KAAM;oBAChC,IAAIqB,MAAgB3C,KAAKC,GAAO;oBAChC0C,EAAYrB,KAAM;oBAClBb,IAAUkC;oBACV;ADmBM,uBClBD,IAAIlC,MAAYW,EAAWL,GAAO;oBACvCN,EAAQa,KAAM;oBACd,IAAIb,EAAQM,GAAO;wBACjBN,EAAQM,EAAMM,KAAUsB;ADoBhB;oBClBV,IAAIlC,EAAQK,GAAQ;wBAClBL,EAAQK,EAAOO,KAAUD;ADoBjB;oBClBVuB,EAAY7B,IAASL,EAAQM;oBAC7BK,EAAWL,IAAQN,EAAQK;oBAC3BL,EAAQM,IAAQ4B;oBAChBlC,EAAQK,IAASM;oBACjB,IAAIuB,MAAgB3C,KAAKC,GAAO;wBAC9BD,KAAKC,IAAQQ;wBACbT,KAAKO,EAAQc,KAAUZ;ADoBf,2BCnBH;wBACL,MAAMoC,IAAKF,EAAYtB;wBACvB,IAAIwB,EAAG9B,MAAU4B,GAAa;4BAC5BE,EAAG9B,IAAQN;ADqBD,+BCpBLoC,EAAG/B,IAASL;ADuBX;oBCrBVA,EAAQY,KAAUsB,EAAYtB;oBAC9BD,EAAWC,KAAUZ;oBACrBkC,EAAYtB,KAAUZ;oBACtBkC,EAAYrB,KAAM;ADuBZ,uBCtBD;oBACLF,EAAWE,KAAM;oBACjB,IAAIqB,MAAgB3C,KAAKC,GAAO;wBAC9BD,KAAKC,IAAQ0C,EAAYnB;ADwBjB,2BCvBHmB,EAAYnB;oBACnBmB,EAAYrB,KAAM;oBAClB;AD0BM;AACJ;YCxBN,IAAItB,KAAKF,aAAa;gBACQsB,EAAY0B;gBACZH,EAAaG;gBACbrC,EAASqC;AD0BjC;YCxBN;AD0BE;AACJ;ICrBQC,CAAAA,CAAKrC,GAAQxB,GAAW8D;QAChC,IAAIhD,KAAKC,MAAUC,WAAW;YAC5BF,KAAK2B,KAAW;YAChB3B,KAAKC,IAAQ,IAAID,KAAKI,GAAeM,GAAKxB,GAAK;YAC/Cc,KAAKC,EAAMoB,KAAUrB,KAAKO;YAC1BP,KAAKO,EAAQc,KAAUrB,KAAKO,EAAQQ,IAAQf,KAAKO,EAAQO,IAASd,KAAKC;YACvE,OAAOD,KAAK2B;AD0BV;QCxBJ,IAAIlB;QACJ,MAAMwC,IAAUjD,KAAKO,EAAQQ;QAC7B,MAAMmC,IAAelD,KAAKG,EAAK8C,EAAQpC,GAAOH;QAC9C,IAAIwC,MAAiB,GAAG;YACtBD,EAAQnB,IAAS5C;YACjB,OAAOc,KAAK2B;AD0BV,eCzBG,IAAIuB,IAAe,GAAG;YAC3BD,EAAQlC,IAAQ,IAAIf,KAAKI,GAAeM,GAAKxB;YAC7C+D,EAAQlC,EAAMM,KAAU4B;YACxBxC,IAAUwC,EAAQlC;YAClBf,KAAKO,EAAQQ,IAAQN;AD2BnB,eC1BG;YACL,MAAM0C,IAAUnD,KAAKO,EAAQO;YAC7B,MAAMsC,IAAepD,KAAKG,EAAKgD,EAAQtC,GAAOH;YAC9C,IAAI0C,MAAiB,GAAG;gBACtBD,EAAQrB,IAAS5C;gBACjB,OAAOc,KAAK2B;AD4BR,mBC3BC,IAAIyB,IAAe,GAAG;gBAC3BD,EAAQrC,IAAS,IAAId,KAAKI,GAAeM,GAAKxB;gBAC9CiE,EAAQrC,EAAOO,KAAU8B;gBACzB1C,IAAU0C,EAAQrC;gBAClBd,KAAKO,EAAQO,IAASL;AD6BlB,mBC5BC;gBACL,IAAIuC,MAAS9C,WAAW;oBACtB,MAAMmD,IAAWL,EAAKM;oBACtB,IAAID,MAAarD,KAAKO,GAAS;wBAC7B,MAAMgD,IAAavD,KAAKG,EAAKkD,EAASxC,GAAOH;wBAC7C,IAAI6C,MAAe,GAAG;4BACpBF,EAASvB,IAAS5C;4BAClB,OAAOc,KAAK2B;AD8BF,+BC7BsB,IAAI4B,IAAa,GAAG;4BACpD,MAAMC,IAAUH,EAASI;4BACzB,MAAMC,IAAY1D,KAAKG,EAAKqD,EAAQ3C,GAAOH;4BAC3C,IAAIgD,MAAc,GAAG;gCACnBF,EAAQ1B,IAAS5C;gCACjB,OAAOc,KAAK2B;AD+BA,mCC9BP,IAAI+B,IAAY,GAAG;gCACxBjD,IAAU,IAAIT,KAAKI,GAAeM,GAAKxB;gCACvC,IAAIsE,EAAQ1C,MAAWZ,WAAW;oCAChCsD,EAAQ1C,IAASL;oCACjBA,EAAQY,KAAUmC;ADgCJ,uCC/BT;oCACLH,EAAStC,IAAQN;oCACjBA,EAAQY,KAAUgC;ADiCJ;AACJ;AACJ;AACJ;AACJ;gBC/BR,IAAI5C,MAAYP,WAAW;oBACzBO,IAAUT,KAAKC;oBACf,OAAO,MAAM;wBACX,MAAMW,IAAYZ,KAAKG,EAAKM,EAAQI,GAAOH;wBAC3C,IAAIE,IAAY,GAAG;4BACjB,IAAIH,EAAQM,MAAUb,WAAW;gCAC/BO,EAAQM,IAAQ,IAAIf,KAAKI,GAAeM,GAAKxB;gCAC7CuB,EAAQM,EAAMM,KAAUZ;gCACxBA,IAAUA,EAAQM;gCAClB;ADiCY;4BC/BdN,IAAUA,EAAQM;ADiCR,+BChCL,IAAIH,IAAY,GAAG;4BACxB,IAAIH,EAAQK,MAAWZ,WAAW;gCAChCO,EAAQK,IAAS,IAAId,KAAKI,GAAeM,GAAKxB;gCAC9CuB,EAAQK,EAAOO,KAAUZ;gCACzBA,IAAUA,EAAQK;gCAClB;ADkCY;4BChCdL,IAAUA,EAAQK;ADkCR,+BCjCL;4BACLL,EAAQqB,IAAS5C;4BACjB,OAAOc,KAAK2B;ADmCF;AACJ;AACJ;AACJ;AACJ;QCjCJ,IAAI3B,KAAKF,aAAa;YACpB,IAAI6D,IAASlD,EAAQY;YACrB,OAAOsC,MAAW3D,KAAKO,GAAS;gBAC9BoD,EAAO5B,MAAgB;gBACvB4B,IAASA,EAAOtC;ADmCZ;AACJ;QCjCJrB,KAAK0C,GAAuBjC;QAC5BT,KAAK2B,KAAW;QAChB,OAAO3B,KAAK2B;ADmCZ;IC9BQiC,EAAAA,CAAkBnD,GAAqCC;QAC/D,OAAOD,GAAS;YACd,MAAMG,IAAYZ,KAAKG,EAAKM,EAAQI,GAAOH;YAC3C,IAAIE,IAAY,GAAG;gBACjBH,IAAUA,EAAQK;ADmCd,mBClCC,IAAIF,IAAY,GAAG;gBACxBH,IAAUA,EAAQM;ADoCd,mBCnCC,OAAON;ADsCZ;QCpCJ,OAAOA,KAAWT,KAAKO;ADsCvB;ICpCFqB,KAAAA;QACE5B,KAAK2B,IAAU;QACf3B,KAAKC,IAAQC;QACbF,KAAKO,EAAQc,KAAUnB;QACvBF,KAAKO,EAAQQ,IAAQf,KAAKO,EAAQO,IAASZ;ADsC3C;IC1BF2D,mBAAAA,CAAoBC,GAA0BpD;QAC5C,MAAMqD,IAAOD,EAAKR;QAClB,IAAIS,MAAS/D,KAAKO,GAAS;aACzB,GAAAyD,YAAAA;ADsCE;QCpCJ,IAAIhE,KAAK2B,MAAY,GAAG;YACtBoC,EAAKlD,IAAOH;YACZ,OAAO;ADsCL;QCpCJ,MAAMuD,IAAUF,EAAKG,IAAQrD;QAC7B,IAAIkD,MAAS/D,KAAKO,EAAQQ,GAAO;YAC/B,IAAIf,KAAKG,EAAK8D,GAASvD,KAAO,GAAG;gBAC/BqD,EAAKlD,IAAOH;gBACZ,OAAO;ADsCH;YCpCN,OAAO;ADsCL;QCpCJ,MAAMyD,IAASJ,EAAKN,IAAO5C;QAC3B,IAAIkD,MAAS/D,KAAKO,EAAQO,GAAQ;YAChC,IAAId,KAAKG,EAAKgE,GAAQzD,KAAO,GAAG;gBAC9BqD,EAAKlD,IAAOH;gBACZ,OAAO;ADsCH;YCpCN,OAAO;ADsCL;QCpCJ,IACEV,KAAKG,EAAKgE,GAAQzD,MAAQ,KAC1BV,KAAKG,EAAK8D,GAASvD,MAAQ,GAC3B,OAAO;QACTqD,EAAKlD,IAAOH;QACZ,OAAO;ADqCP;ICnCF0D,iBAAAA,CAAkBlC;QDqCZ,ICpCsBA,IAAG,KAAHA,IAAQlC,KAAK2B,IAAO,GAtfd;YAAE,MAAU,IAAI0C;AD4hB5C;QCrCJ,MAAMN,IAAO/D,KAAKgC,GAAkBE;QACpClC,KAAK0B,EAAWqC;QAChB,OAAO/D,KAAK2B;ADuCZ;IChCF2C,iBAAAA,CAAkB5D;QAChB,IAAIV,KAAK2B,MAAY,GAAG,OAAO;QAC/B,MAAMlB,IAAUT,KAAK4D,GAAkB5D,KAAKC,GAAOS;QACnD,IAAID,MAAYT,KAAKO,GAAS,OAAO;QACrCP,KAAK0B,EAAWjB;QAChB,OAAO;ADyCP;ICvCF8D,sBAAAA,CAAuBT;QACrB,MAAMC,IAAOD,EAAKR;QAClB,IAAIS,MAAS/D,KAAKO,GAAS;aACzB,GAAAyD,YAAAA;ADyCE;QCvCJ,MAAMQ,IAAaT,EAAKjD,MAAWZ;QACnC,MAAMuE,IAAWX,EAAKY,iBAAY;QAElC,IAAID,GAAU;YAEZ,IAAID,GAAYV,EAAKa;AD0CnB,eCzCG;YAGL,KAAKH,KAAcT,EAAKhD,MAAUb,WAAW4D,EAAKa;AD4ChD;QC1CJ3E,KAAK0B,EAAWqC;QAChB,OAAOD;AD4CP;ICtCFc,SAAAA;QACE,IAAI5E,KAAK2B,MAAY,GAAG,OAAO;QAC/B,SAASkD,UAAUpE;YACjB,KAAKA,GAAS,OAAO;YACrB,OAAOqE,KAAKC,IAAIF,UAAUpE,EAAQM,IAAQ8D,UAAUpE,EAAQK,MAAW;AD8CrE;QC5CJ,OAAO+D,UAAU7E,KAAKC;AD8CtB;;;AClBH,IAAA+E,WAEcxF;;AAAaP,QAAAE,UAAA6F","file":"index.js","sourcesContent":["import { TreeNode, TreeNodeEnableIndex } from './TreeNode';\nimport { Container } from \"../../ContainerBase\";\nimport $checkWithinAccessParams from \"../../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../../utils/throwError\";\nclass TreeContainer extends Container {\n    /**\n     * @internal\n     */\n    constructor(cmp = function (x, y) {\n        if (x < y)\n            return -1;\n        if (x > y)\n            return 1;\n        return 0;\n    }, enableIndex = false) {\n        super();\n        /**\n         * @internal\n         */\n        this._root = undefined;\n        this._cmp = cmp;\n        this.enableIndex = enableIndex;\n        this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n        this._header = new this._TreeNodeClass();\n    }\n    /**\n     * @internal\n     */\n    _lowerBound(curNode, key) {\n        let resNode = this._header;\n        while (curNode) {\n            const cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    }\n    /**\n     * @internal\n     */\n    _upperBound(curNode, key) {\n        let resNode = this._header;\n        while (curNode) {\n            const cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult <= 0) {\n                curNode = curNode._right;\n            }\n            else {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    }\n    /**\n     * @internal\n     */\n    _reverseLowerBound(curNode, key) {\n        let resNode = this._header;\n        while (curNode) {\n            const cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    }\n    /**\n     * @internal\n     */\n    _reverseUpperBound(curNode, key) {\n        let resNode = this._header;\n        while (curNode) {\n            const cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else {\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    }\n    /**\n     * @internal\n     */\n    _eraseNodeSelfBalance(curNode) {\n        while (true) {\n            const parentNode = curNode._parent;\n            if (parentNode === this._header)\n                return;\n            if (curNode._color === 1 /* TreeNodeColor.RED */) {\n                curNode._color = 0 /* TreeNodeColor.BLACK */;\n                return;\n            }\n            if (curNode === parentNode._left) {\n                const brother = parentNode._right;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateLeft();\n                    }\n                    else\n                        parentNode._rotateLeft();\n                }\n                else {\n                    if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateLeft();\n                        }\n                        else\n                            parentNode._rotateLeft();\n                        return;\n                    }\n                    else if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateRight();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n            else {\n                const brother = parentNode._left;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateRight();\n                    }\n                    else\n                        parentNode._rotateRight();\n                }\n                else {\n                    if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateRight();\n                        }\n                        else\n                            parentNode._rotateRight();\n                        return;\n                    }\n                    else if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateLeft();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _eraseNode(curNode) {\n        if (this._length === 1) {\n            this.clear();\n            return;\n        }\n        let swapNode = curNode;\n        while (swapNode._left || swapNode._right) {\n            if (swapNode._right) {\n                swapNode = swapNode._right;\n                while (swapNode._left)\n                    swapNode = swapNode._left;\n            }\n            else {\n                swapNode = swapNode._left;\n            }\n            const key = curNode._key;\n            curNode._key = swapNode._key;\n            swapNode._key = key;\n            const value = curNode._value;\n            curNode._value = swapNode._value;\n            swapNode._value = value;\n            curNode = swapNode;\n        }\n        if (this._header._left === swapNode) {\n            this._header._left = swapNode._parent;\n        }\n        else if (this._header._right === swapNode) {\n            this._header._right = swapNode._parent;\n        }\n        this._eraseNodeSelfBalance(swapNode);\n        let _parent = swapNode._parent;\n        if (swapNode === _parent._left) {\n            _parent._left = undefined;\n        }\n        else\n            _parent._right = undefined;\n        this._length -= 1;\n        this._root._color = 0 /* TreeNodeColor.BLACK */;\n        if (this.enableIndex) {\n            while (_parent !== this._header) {\n                _parent._subTreeSize -= 1;\n                _parent = _parent._parent;\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _inOrderTraversal(param) {\n        const pos = typeof param === 'number' ? param : undefined;\n        const callback = typeof param === 'function' ? param : undefined;\n        const nodeList = typeof param === 'undefined' ? [] : undefined;\n        let index = 0;\n        let curNode = this._root;\n        const stack = [];\n        while (stack.length || curNode) {\n            if (curNode) {\n                stack.push(curNode);\n                curNode = curNode._left;\n            }\n            else {\n                curNode = stack.pop();\n                if (index === pos)\n                    return curNode;\n                nodeList && nodeList.push(curNode);\n                callback && callback(curNode, index, this);\n                index += 1;\n                curNode = curNode._right;\n            }\n        }\n        return nodeList;\n    }\n    /**\n     * @internal\n     */\n    _insertNodeSelfBalance(curNode) {\n        while (true) {\n            const parentNode = curNode._parent;\n            if (parentNode._color === 0 /* TreeNodeColor.BLACK */)\n                return;\n            const grandParent = parentNode._parent;\n            if (parentNode === grandParent._left) {\n                const uncle = grandParent._right;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._right) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left) {\n                        curNode._left._parent = parentNode;\n                    }\n                    if (curNode._right) {\n                        curNode._right._parent = grandParent;\n                    }\n                    parentNode._right = curNode._left;\n                    grandParent._left = curNode._right;\n                    curNode._left = parentNode;\n                    curNode._right = grandParent;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        const GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateRight();\n                    }\n                    else\n                        grandParent._rotateRight();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return;\n                }\n            }\n            else {\n                const uncle = grandParent._left;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._left) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left) {\n                        curNode._left._parent = grandParent;\n                    }\n                    if (curNode._right) {\n                        curNode._right._parent = parentNode;\n                    }\n                    grandParent._right = curNode._left;\n                    parentNode._left = curNode._right;\n                    curNode._left = grandParent;\n                    curNode._right = parentNode;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        const GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateLeft();\n                    }\n                    else\n                        grandParent._rotateLeft();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return;\n                }\n            }\n            if (this.enableIndex) {\n                parentNode._recount();\n                grandParent._recount();\n                curNode._recount();\n            }\n            return;\n        }\n    }\n    /**\n     * @internal\n     */\n    _set(key, value, hint) {\n        if (this._root === undefined) {\n            this._length += 1;\n            this._root = new this._TreeNodeClass(key, value, 0 /* TreeNodeColor.BLACK */);\n            this._root._parent = this._header;\n            this._header._parent = this._header._left = this._header._right = this._root;\n            return this._length;\n        }\n        let curNode;\n        const minNode = this._header._left;\n        const compareToMin = this._cmp(minNode._key, key);\n        if (compareToMin === 0) {\n            minNode._value = value;\n            return this._length;\n        }\n        else if (compareToMin > 0) {\n            minNode._left = new this._TreeNodeClass(key, value);\n            minNode._left._parent = minNode;\n            curNode = minNode._left;\n            this._header._left = curNode;\n        }\n        else {\n            const maxNode = this._header._right;\n            const compareToMax = this._cmp(maxNode._key, key);\n            if (compareToMax === 0) {\n                maxNode._value = value;\n                return this._length;\n            }\n            else if (compareToMax < 0) {\n                maxNode._right = new this._TreeNodeClass(key, value);\n                maxNode._right._parent = maxNode;\n                curNode = maxNode._right;\n                this._header._right = curNode;\n            }\n            else {\n                if (hint !== undefined) {\n                    const iterNode = hint._node;\n                    if (iterNode !== this._header) {\n                        const iterCmpRes = this._cmp(iterNode._key, key);\n                        if (iterCmpRes === 0) {\n                            iterNode._value = value;\n                            return this._length;\n                        }\n                        else /* istanbul ignore else */ if (iterCmpRes > 0) {\n                            const preNode = iterNode._pre();\n                            const preCmpRes = this._cmp(preNode._key, key);\n                            if (preCmpRes === 0) {\n                                preNode._value = value;\n                                return this._length;\n                            }\n                            else if (preCmpRes < 0) {\n                                curNode = new this._TreeNodeClass(key, value);\n                                if (preNode._right === undefined) {\n                                    preNode._right = curNode;\n                                    curNode._parent = preNode;\n                                }\n                                else {\n                                    iterNode._left = curNode;\n                                    curNode._parent = iterNode;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (curNode === undefined) {\n                    curNode = this._root;\n                    while (true) {\n                        const cmpResult = this._cmp(curNode._key, key);\n                        if (cmpResult > 0) {\n                            if (curNode._left === undefined) {\n                                curNode._left = new this._TreeNodeClass(key, value);\n                                curNode._left._parent = curNode;\n                                curNode = curNode._left;\n                                break;\n                            }\n                            curNode = curNode._left;\n                        }\n                        else if (cmpResult < 0) {\n                            if (curNode._right === undefined) {\n                                curNode._right = new this._TreeNodeClass(key, value);\n                                curNode._right._parent = curNode;\n                                curNode = curNode._right;\n                                break;\n                            }\n                            curNode = curNode._right;\n                        }\n                        else {\n                            curNode._value = value;\n                            return this._length;\n                        }\n                    }\n                }\n            }\n        }\n        if (this.enableIndex) {\n            let parent = curNode._parent;\n            while (parent !== this._header) {\n                parent._subTreeSize += 1;\n                parent = parent._parent;\n            }\n        }\n        this._insertNodeSelfBalance(curNode);\n        this._length += 1;\n        return this._length;\n    }\n    /**\n     * @internal\n     */\n    _getTreeNodeByKey(curNode, key) {\n        while (curNode) {\n            const cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return curNode || this._header;\n    }\n    clear() {\n        this._length = 0;\n        this._root = undefined;\n        this._header._parent = undefined;\n        this._header._left = this._header._right = undefined;\n    }\n    /**\n     * @description Update node's key by iterator.\n     * @param iter - The iterator you want to change.\n     * @param key - The key you want to update.\n     * @returns Whether the modification is successful.\n     * @example\n     * const st = new orderedSet([1, 2, 5]);\n     * const iter = st.find(2);\n     * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n     */\n    updateKeyByIterator(iter, key) {\n        const node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        if (this._length === 1) {\n            node._key = key;\n            return true;\n        }\n        const nextKey = node._next()._key;\n        if (node === this._header._left) {\n            if (this._cmp(nextKey, key) > 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        const preKey = node._pre()._key;\n        if (node === this._header._right) {\n            if (this._cmp(preKey, key) < 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        if (this._cmp(preKey, key) >= 0 ||\n            this._cmp(nextKey, key) <= 0)\n            return false;\n        node._key = key;\n        return true;\n    }\n    eraseElementByPos(pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        const node = this._inOrderTraversal(pos);\n        this._eraseNode(node);\n        return this._length;\n    }\n    /**\n     * @description Remove the element of the specified key.\n     * @param key - The key you want to remove.\n     * @returns Whether erase successfully.\n     */\n    eraseElementByKey(key) {\n        if (this._length === 0)\n            return false;\n        const curNode = this._getTreeNodeByKey(this._root, key);\n        if (curNode === this._header)\n            return false;\n        this._eraseNode(curNode);\n        return true;\n    }\n    eraseElementByIterator(iter) {\n        const node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        const hasNoRight = node._right === undefined;\n        const isNormal = iter.iteratorType === 0 /* IteratorType.NORMAL */;\n        // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n        if (isNormal) {\n            // So we should move it to next when it's right is null.\n            if (hasNoRight)\n                iter.next();\n        }\n        else {\n            // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n            // So when it has right, or it is a leaf node we should move it to `next`.\n            if (!hasNoRight || node._left === undefined)\n                iter.next();\n        }\n        this._eraseNode(node);\n        return iter;\n    }\n    /**\n     * @description Get the height of the tree.\n     * @returns Number about the height of the RB-tree.\n     */\n    getHeight() {\n        if (this._length === 0)\n            return 0;\n        function traversal(curNode) {\n            if (!curNode)\n                return 0;\n            return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n        }\n        return traversal(this._root);\n    }\n}\nexport default TreeContainer;\n","import type TreeIterator from './TreeIterator';\nimport { TreeNode, TreeNodeColor, TreeNodeEnableIndex } from './TreeNode';\nimport { Container, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeContainer<K, V> extends Container<K | [K, V]> {\n  enableIndex: boolean;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _root: TreeNode<K, V> | undefined = undefined;\n  /**\n   * @internal\n   */\n  protected readonly _cmp: (x: K, y: K) => number;\n  /**\n   * @internal\n   */\n  protected readonly _TreeNodeClass: typeof TreeNode | typeof TreeNodeEnableIndex;\n  /**\n   * @internal\n   */\n  protected constructor(\n    cmp: (x: K, y: K) => number =\n    function (x: K, y: K) {\n      if (x < y) return -1;\n      if (x > y) return 1;\n      return 0;\n    },\n    enableIndex = false\n  ) {\n    super();\n    this._cmp = cmp;\n    this.enableIndex = enableIndex;\n    this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n    this._header = new this._TreeNodeClass();\n  }\n  /**\n   * @internal\n   */\n  protected _lowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _upperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseLowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseUpperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode === this._header) return;\n      if (curNode._color === TreeNodeColor.RED) {\n        curNode._color = TreeNodeColor.BLACK;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        const brother = parentNode._right!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._right._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._left._color = TreeNodeColor.BLACK;\n            brother._rotateRight();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        const brother = parentNode._left!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._left._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._right._color = TreeNodeColor.BLACK;\n            brother._rotateLeft();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNode(curNode: TreeNode<K, V>) {\n    if (this._length === 1) {\n      this.clear();\n      return;\n    }\n    let swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left!;\n      }\n      const key = curNode._key;\n      curNode._key = swapNode._key;\n      swapNode._key = key;\n      const value = curNode._value;\n      curNode._value = swapNode._value;\n      swapNode._value = value;\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    let _parent = swapNode._parent as TreeNodeEnableIndex<K, V>;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root!._color = TreeNodeColor.BLACK;\n    if (this.enableIndex) {\n      while (_parent !== this._header) {\n        _parent._subTreeSize -= 1;\n        _parent = _parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n  }\n  protected _inOrderTraversal(): TreeNode<K, V>[];\n  protected _inOrderTraversal(pos: number): TreeNode<K, V>;\n  protected _inOrderTraversal(\n    callback: (node: TreeNode<K, V>, index: number, map: this) => void\n  ): TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _inOrderTraversal(\n    param?: number | ((node: TreeNode<K, V>, index: number, map: this) => void)\n  ) {\n    const pos = typeof param === 'number' ? param : undefined;\n    const callback = typeof param === 'function' ? param : undefined;\n    const nodeList = typeof param === 'undefined' ? <TreeNode<K, V>[]>[] : undefined;\n    let index = 0;\n    let curNode = this._root;\n    const stack: TreeNode<K, V>[] = [];\n    while (stack.length || curNode) {\n      if (curNode) {\n        stack.push(curNode);\n        curNode = curNode._left;\n      } else {\n        curNode = stack.pop()!;\n        if (index === pos) return curNode;\n        nodeList && nodeList.push(curNode);\n        callback && callback(curNode, index, this);\n        index += 1;\n        curNode = curNode._right;\n      }\n    }\n    return nodeList;\n  }\n  /**\n   * @internal\n   */\n  protected _insertNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode._color === TreeNodeColor.BLACK) return;\n      const grandParent = parentNode._parent!;\n      if (parentNode === grandParent._left) {\n        const uncle = grandParent._right;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = parentNode;\n          }\n          if (curNode._right) {\n            curNode._right._parent = grandParent;\n          }\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      } else {\n        const uncle = grandParent._left;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = grandParent;\n          }\n          if (curNode._right) {\n            curNode._right._parent = parentNode;\n          }\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      }\n      if (this.enableIndex) {\n        (<TreeNodeEnableIndex<K, V>>parentNode)._recount();\n        (<TreeNodeEnableIndex<K, V>>grandParent)._recount();\n        (<TreeNodeEnableIndex<K, V>>curNode)._recount();\n      }\n      return;\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _set(key: K, value?: V, hint?: TreeIterator<K, V>) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value, TreeNodeColor.BLACK);\n      this._root._parent = this._header;\n      this._header._parent = this._header._left = this._header._right = this._root;\n      return this._length;\n    }\n    let curNode;\n    const minNode = this._header._left!;\n    const compareToMin = this._cmp(minNode._key!, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return this._length;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      const maxNode = this._header._right!;\n      const compareToMax = this._cmp(maxNode._key!, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return this._length;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          const iterNode = hint._node;\n          if (iterNode !== this._header) {\n            const iterCmpRes = this._cmp(iterNode._key!, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return this._length;\n            } else /* istanbul ignore else */ if (iterCmpRes > 0) {\n              const preNode = iterNode._pre();\n              const preCmpRes = this._cmp(preNode._key!, key);\n              if (preCmpRes === 0) {\n                preNode._value = value;\n                return this._length;\n              } else if (preCmpRes < 0) {\n                curNode = new this._TreeNodeClass(key, value);\n                if (preNode._right === undefined) {\n                  preNode._right = curNode;\n                  curNode._parent = preNode;\n                } else {\n                  iterNode._left = curNode;\n                  curNode._parent = iterNode;\n                }\n              }\n            }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            const cmpResult = this._cmp(curNode._key!, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return this._length;\n            }\n          }\n        }\n      }\n    }\n    if (this.enableIndex) {\n      let parent = curNode._parent as TreeNodeEnableIndex<K, V>;\n      while (parent !== this._header) {\n        parent._subTreeSize += 1;\n        parent = parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n    this._insertNodeSelfBalance(curNode);\n    this._length += 1;\n    return this._length;\n  }\n  /**\n   * @internal\n   */\n  protected _getTreeNodeByKey(curNode: TreeNode<K, V> | undefined, key: K) {\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  }\n  clear() {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  }\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  updateKeyByIterator(iter: TreeIterator<K, V>, key: K): boolean {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    const nextKey = node._next()._key!;\n    if (node === this._header._left) {\n      if (this._cmp(nextKey, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    const preKey = node._pre()._key!;\n    if (node === this._header._right) {\n      if (this._cmp(preKey, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (\n      this._cmp(preKey, key) >= 0 ||\n      this._cmp(nextKey, key) <= 0\n    ) return false;\n    node._key = key;\n    return true;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    this._eraseNode(node);\n    return this._length;\n  }\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  eraseElementByKey(key: K) {\n    if (this._length === 0) return false;\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  }\n  eraseElementByIterator(iter: TreeIterator<K, V>) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    const hasNoRight = node._right === undefined;\n    const isNormal = iter.iteratorType === IteratorType.NORMAL;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  }\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  getHeight() {\n    if (this._length === 0) return 0;\n    function traversal(curNode: TreeNode<K, V> | undefined): number {\n      if (!curNode) return 0;\n      return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n    }\n    return traversal(this._root);\n  }\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element less than the given key.\n   */\n  abstract reverseUpperBound(key: K): TreeIterator<K, V>;\n  /**\n   * @description Union the other tree to self.\n   * @param other - The other tree container you want to merge.\n   * @returns The size of the tree after union.\n   */\n  abstract union(other: TreeContainer<K, V>): number;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not greater than the given key.\n   */\n  abstract reverseLowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not less than the given key.\n   */\n  abstract lowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element greater than the given key.\n   */\n  abstract upperBound(key: K): TreeIterator<K, V>;\n}\n\nexport default TreeContainer;\n"]}